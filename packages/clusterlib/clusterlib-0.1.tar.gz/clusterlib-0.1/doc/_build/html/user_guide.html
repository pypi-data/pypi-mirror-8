
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>User guide &mdash; clusterlib 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootswatch-3.1.0/lumen/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="clusterlib 0.1.0 documentation" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          Clusterlib</a>
        <span class="navbar-text navbar-version pull-left"><b>0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="#">User guide</a></li>
                <li><a href="references.html">References</a></li>
                <li><a href="whats_new.html">What's new?</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container content-container">
  
  <div class="section" id="user-guide">
<h1>User guide<a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h1>
<p>This documentation aims at showing how to use python and <tt class="xref py py-mod docutils literal"><span class="pre">clusterlib</span></tt> to
launch and manage jobs on super-computers with schedulers such as
<a class="reference external" href="https://computing.llnl.gov/linux/slurm/">SLURM</a> or
<a class="reference external" href="http://en.wikipedia.org/wiki/Oracle_Grid_Engine">SGE</a>.</p>
<p>Typically working on a super-computer requires to maintain and to write
three programs:</p>
<ol class="arabic simple">
<li>A <em>main program</em> who performs some useful computations and accept some
parameters.</li>
<li>A <em>submission script</em>, e.g. a bash script, where you define the resources
needed by the jobs such as the maximal duration and the maximal required
memory.</li>
<li>A <em>launching script</em> which will coordinate your submission scripts and
and the <em>main program</em> to perform all the required computations.</li>
</ol>
<p>In the following, we will see how to use Python to manage a large number of
jobs without actually needing any submission script and avoiding to re-launch
queued, running or already completed jobs.</p>
<div class="section" id="how-to-submit-jobs-easily">
<span id="submit-jobs"></span><h2>How to submit jobs easily?<a class="headerlink" href="#how-to-submit-jobs-easily" title="Permalink to this headline">¶</a></h2>
<p>Submitting a job on a cluster requires to write a shell script to specify the
resources required for the job. For instance, here you have an example of
a submission script using the
<a class="reference external" href="https://computing.llnl.gov/linux/slurm/sbatch.html">SLURM sbatch command</a>
which scheduled a job requiring at most 10 minutes of computation and 1000 mega
bytes of ram.</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c">#!/bin/bash</span>
<span class="c">#</span>
<span class="c">#SBATCH --job-name=job-name</span>
<span class="c">#SBATCH --time=10:00</span>
<span class="c">#SBATCH --mem=1000</span>

srun hostname
</pre></div>
</div>
<p>Managing such scripts has several drawbacks: (i) a separate file has to be
maintained, (ii) parameters and resources are fixed in the script, e.g. memory
asked can not be adapted automatically given some parameter of the main program
and (iii) those scripts are scheduler specific.</p>
<p>With the <a class="reference internal" href="generated/clusterlib.scheduler.submit.html#clusterlib.scheduler.submit" title="clusterlib.scheduler.submit"><tt class="xref py py-func docutils literal"><span class="pre">clusterlib.scheduler.submit()</span></tt></a> function, you can simply do
everything in Python without any of the previous drawbacks:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusterlib.scheduler</span> <span class="kn">import</span> <span class="n">submit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">script</span> <span class="o">=</span> <span class="n">submit</span><span class="p">(</span><span class="s">&quot;srun hostname&quot;</span><span class="p">,</span> <span class="n">job_name</span><span class="o">=</span><span class="s">&quot;job-name&quot;</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">time</span><span class="o">=</span><span class="s">&quot;10:00&quot;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s">&quot;slurm&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="go">echo &#39;#!/bin/bash</span>
<span class="go">srun hostname&#39; | sbatch --job-name=job-name --time=10:00 --mem=1000</span>
</pre></div>
</div>
<p>Launching the job with the generated submission <tt class="docutils literal"><span class="pre">script</span></tt> can be done
directly by using <tt class="docutils literal"><span class="pre">os.system(script)</span></tt> or with the Python <tt class="docutils literal"><span class="pre">subprocess</span></tt>
submodule.</p>
<p>More options to the submission script could be appended to the generated
string. Here for instance, we add the quiet sbatch option:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">script</span> <span class="o">+=</span> <span class="s">&#39; --quiet&#39;</span>  <span class="c"># Note the space in front of --</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="go">echo &#39;#!/bin/bash</span>
<span class="go">srun hostname&#39; | sbatch --job-name=job-name --time=10:00 --mem=1000 --quiet</span>
</pre></div>
</div>
<p>In the case your task required multiple line, you can separate each command
by making a line break in the job command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">script</span> <span class="o">=</span> <span class="n">submit</span><span class="p">(</span><span class="s">&quot;srun hostname</span><span class="se">\n</span><span class="s">sleep 60&quot;</span><span class="p">,</span> <span class="n">job_name</span><span class="o">=</span><span class="s">&quot;job-name&quot;</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">time</span><span class="o">=</span><span class="s">&quot;10:00&quot;</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s">&quot;slurm&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="go">echo &#39;#!/bin/bash</span>
<span class="go">srun hostname</span>
<span class="go">sleep 60&#39; | sbatch --job-name=job-name --time=10:00 --mem=1000</span>
</pre></div>
</div>
</div>
<div class="section" id="how-to-avoid-re-launching-queued-or-running-jobs">
<h2>How to avoid re-launching queued or running jobs?<a class="headerlink" href="#how-to-avoid-re-launching-queued-or-running-jobs" title="Permalink to this headline">¶</a></h2>
<p>In the previous section, we have seen how to write and generate submission
queries. This allows to schedule thousands of jobs with a simple logic. In order
to spare computing resources, we are going to add some mechanisms to avoid
launching jobs that are already queued or running.</p>
<p>The function <a class="reference internal" href="generated/clusterlib.scheduler.queued_or_running_jobs.html#clusterlib.scheduler.queued_or_running_jobs" title="clusterlib.scheduler.queued_or_running_jobs"><tt class="xref py py-func docutils literal"><span class="pre">clusterlib.scheduler.queued_or_running_jobs()</span></tt></a> allows to get
the list of all running or queued jobs. This will allow us to derive a first
launching manager. As a small usage example, here we want to launch the program
<tt class="docutils literal"><span class="pre">main</span></tt> for a variety of parameters, but avoid re-relaunching jobs that are
already queued or running.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">clusterlib.scheduler</span> <span class="kn">import</span> <span class="n">queued_or_running_jobs</span>
<span class="kn">from</span> <span class="nn">clusterlib.scheduler</span> <span class="kn">import</span> <span class="n">submit</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">scheduled_jobs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">queued_or_running_jobs</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">job_name</span> <span class="o">=</span> <span class="s">&quot;job-param=</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">param</span>
        <span class="k">if</span> <span class="n">job_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scheduled_jobs</span><span class="p">:</span>
            <span class="n">script</span> <span class="o">=</span> <span class="n">submit</span><span class="p">(</span><span class="s">&quot;./main --param </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">param</span><span class="p">,</span>
                            <span class="n">job_name</span><span class="o">=</span><span class="n">job_name</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s">&quot;slurm&quot;</span><span class="p">)</span>

            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we have constructed unique job names with a string formatting. As an
alternative, one can generate hash of the job parameters to have automatically
unique identifiers using either the Python built-in <tt class="docutils literal"><span class="pre">hash</span></tt> or
<a class="reference external" href="https://pythonhosted.org/joblib/generated/joblib.hash.html">joblib.hash</a>.</p>
</div>
<div class="section" id="how-to-avoid-re-launching-already-done-jobs">
<h2>How to avoid re-launching already done jobs?<a class="headerlink" href="#how-to-avoid-re-launching-already-done-jobs" title="Permalink to this headline">¶</a></h2>
<p>Checking if a job is queued or running must be done through the scheduler.
However, knowing if a job is already done must be accomplished through the file
system. Clusterlib offers a simple NO-SQL database based on sqlite3 to achieve
this. With the transactions of the database, jobs could register their
completion.</p>
<p>Let&#8217;s take a practical example, we want to launch the script <tt class="docutils literal"><span class="pre">main.py</span></tt> with a
large number of different parameter combinations. Due to the heavy
computational burden, we want to parallelize the script evaluation on a
super-computer.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># main.py</span>

<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A function with heavy computation&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">argv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span>  <span class="c"># For ease, function parameters are sys.argv</span>

    <span class="c"># do heavy computation (usually based on argument)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

    <span class="c"># Save script evaluation on the hard disk</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>In order to do this, we first modify or add to the original script some call to
the NO-SQL database which will indicate the parameter combinations that have
been evaluated.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># clusterlib_main.py</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">clusterlib.storage</span> <span class="kn">import</span> <span class="n">sqlite3_dumps</span>
<span class="kn">from</span> <span class="nn">main</span> <span class="kn">import</span> <span class="n">main</span>

<span class="n">NOSQL_PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&quot;HOME&quot;</span><span class="p">],</span> <span class="s">&quot;job.sqlite3&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
    <span class="n">sqlite3_dumps</span><span class="p">({</span><span class="s">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">):</span> <span class="s">&quot;JOB DONE&quot;</span><span class="p">},</span> <span class="n">NOSQL_PATH</span><span class="p">)</span>
</pre></div>
</div>
<p>Secondly, we write a launcher script (<tt class="docutils literal"><span class="pre">clusterlib_launcher.py</span></tt>) to
use this information and re-launch only jobs that have not been done so far
or that are not running or queued.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># clusterlib_launcher.py</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">clusterlib.scheduler</span> <span class="kn">import</span> <span class="n">queued_or_running_jobs</span>
<span class="kn">from</span> <span class="nn">clusterlib.scheduler</span> <span class="kn">import</span> <span class="n">submit</span>
<span class="kn">from</span> <span class="nn">clusterlib.storage</span> <span class="kn">import</span> <span class="n">sqlite3_loads</span>
<span class="kn">from</span> <span class="nn">clusterlib_main</span> <span class="kn">import</span> <span class="n">NOSQL_PATH</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">scheduled_jobs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">queued_or_running_jobs</span><span class="p">())</span>
    <span class="n">done_jobs</span> <span class="o">=</span> <span class="n">sqlite3_loads</span><span class="p">(</span><span class="n">NOSQL_PATH</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">job_name</span> <span class="o">=</span> <span class="s">&quot;job-param=</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">param</span>
        <span class="n">job_command</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> clusterlib.py --param </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span>
                                                       <span class="n">param</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">job_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scheduled_jobs</span> <span class="ow">and</span> <span class="n">job_command</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">done_jobs</span><span class="p">:</span>
            <span class="n">script</span> <span class="o">=</span> <span class="n">submit</span><span class="p">(</span><span class="n">job_command</span><span class="p">,</span> <span class="n">job_name</span><span class="o">=</span><span class="n">job_name</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>

            <span class="c"># Uncomment those lines to launch the jobs</span>
            <span class="c"># import os</span>
            <span class="c"># os.system(script)</span>
</pre></div>
</div>
<p>This simple launcher allows to manage thousands of jobs while avoiding
to repeat jobs that are processed or in process.</p>
</div>
<div class="section" id="more-tips-when-working-on-a-super-computer">
<h2>More tips when working on a super-computer<a class="headerlink" href="#more-tips-when-working-on-a-super-computer" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Forbid the temptation to guess: work with absolute path.</li>
<li>With multiple python interpreters, use absolute path to the desired python
interpreter. <tt class="docutils literal"><span class="pre">sys.executable</span></tt> will give you the path of the python
interpreter.</li>
<li>If objects are hashed, hash them sooner rather than later.</li>
<li>Check your program logic with a fast and dummy setting.</li>
<li>Use a version file system such as git.</li>
</ul>
</div>
</div>


</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014, Arnaud Joly.<br/>
    </p>
  </div>
</footer>
  </body>
</html>