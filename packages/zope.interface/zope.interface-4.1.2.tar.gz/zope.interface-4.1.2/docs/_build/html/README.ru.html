<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Интерфейсы &mdash; zope.interface 4.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '4.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="zope.interface 4.0.1 documentation" href="index.html" />
    <link rel="next" title="Реестр адаптеров" href="adapter.ru.html" />
    <link rel="prev" title="Hacking on zope.interface" href="hacking.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="adapter.ru.html" title="Реестр адаптеров"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="hacking.html" title="Hacking on zope.interface"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">zope.interface 4.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id18">Интерфейсы</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id18">Интерфейсы</a><ul>
<li><a class="reference internal" href="#id2" id="id19">Определение интерфейсов</a></li>
<li><a class="reference internal" href="#id4" id="id20">Объявление интерфейсов</a><ul>
<li><a class="reference internal" href="#id6" id="id21">Объявление реализуемых интерфейсов</a></li>
<li><a class="reference internal" href="#id7" id="id22">Объявление предоставляемых интерфейсов</a></li>
<li><a class="reference internal" href="#id8" id="id23">Наследуемые объявления</a></li>
<li><a class="reference internal" href="#id9" id="id24">Внешние объявления</a></li>
<li><a class="reference internal" href="#id10" id="id25">Объекты объявлений</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11" id="id26">Наследование интерфейсов</a><ul>
<li><a class="reference internal" href="#id13" id="id27">Наследование в случае определения атрибутов</a></li>
<li><a class="reference internal" href="#id14" id="id28">Спецификации</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id15" id="id29">Помеченные значения</a></li>
<li><a class="reference internal" href="#id16" id="id30">Инварианты</a></li>
<li><a class="reference internal" href="#id17" id="id31">Адаптация</a><ul>
<li><a class="reference internal" href="#adapt" id="id32">__adapt__</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>Интерфейсы - это объекты специфицирующие (документирующие) внешнее поведение
объектов которые их &#8220;предоставляют&#8221;. Интерфейсы определяют поведение через
следующие составляющие:</p>
<ul class="simple">
<li>Неформальную документацию в строках документации</li>
<li>Определения атрибутов</li>
<li>Инварианты - условия, которые должны соблюдаться для объектов предоставляющих
интерфейс</li>
</ul>
<p>Определения атрибутов описывают конкретные атрибуты. Они определяют
имя атрибута и предоставляют документацию и ограничения для значений
атрибута. Определения атрибутов могут быть заданы несколькими путями
как мы увидим ниже.</p>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id19">Определение интерфейсов</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Интерфейсы определяются с использованием ключевого слова class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">zope.interface</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IFoo</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>
<span class="gp">... </span>   <span class="sd">&quot;&quot;&quot;Foo blah blah&quot;&quot;&quot;</span>
<span class="gp">...</span>
<span class="gp">... </span>   <span class="n">x</span> <span class="o">=</span> <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;&quot;&quot;X blah blah&quot;&quot;&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>       <span class="sd">&quot;&quot;&quot;bar blah blah&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>В примере выше мы создали интерфейс <cite>IFoo</cite>. Мы наследуем его от
класса <cite>zope.interface.Interface</cite>, который является родительским интерфейсом
для всех интерфейсов, как <cite>object</cite> - это родительский класс для всех новых
классов <a class="footnote-reference" href="#create" id="id3">[1]</a>. Данный интерфейс не является классом, а является
Интерфейсом, экземпляром <cite>InterfaceClass</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)</span>
<span class="go">&lt;class &#39;zope.interface.interface.InterfaceClass&#39;&gt;</span>
</pre></div>
</div>
<p>Мы можем запросить у интерфейса его документацию:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">__doc__</span>
<span class="go">&#39;Foo blah blah&#39;</span>
</pre></div>
</div>
<p>и его имя:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">__name__</span>
<span class="go">&#39;IFoo&#39;</span>
</pre></div>
</div>
<p>и даже модуль в котором он определен:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">__module__</span>
<span class="go">&#39;__main__&#39;</span>
</pre></div>
</div>
<p>Наш интерфейс определяет два атрибута:</p>
<dl class="docutils">
<dt><cite>x</cite></dt>
<dd>Это простейшая форма определения атрибутов. Определяются имя
и строка документации. Формально здесь не определяется ничего более.</dd>
<dt><cite>bar</cite></dt>
<dd><p class="first">Это метод. Методы определяются как обычные функции. Метод - это просто
атрибут который должен быть вызываемым с указанием сигнатуры,
предоставляемой определением функции.</p>
<p class="last">Надо отметить, что аргумент <cite>self</cite> не указывается для <cite>bar</cite>. Интерфейс
документирует как объект <em>используется</em>. Когда методы экземпляров классов
вызываются мы не передаем аргумент <cite>self</cite>, таким образом аргумент <cite>self</cite>
не включается и в сигнатуру интерфейса. Аргумент <cite>self</cite> в методах
экземпляров классов на самом деле деталь реализации экземпляров классов
в Python. Другие объекты кроме экземпляров классов могут предоставлять
интерфейсы и их методы могут не быть методами экземпляров классов. Для
примера модули могут предоставлять интерфейсы и их методы обычно просто
функции. Даже экземпляры могут иметь методы не являющиеся методами
экземпляров класса.</p>
</dd>
</dl>
<p>Мы можем получить доступ к атрибутам определенным интерфейсом используя
синтаксис доступа к элементам массива:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">IFoo</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&lt;class &#39;zope.interface.interface.Attribute&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">__name__</span>
<span class="go">&#39;x&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">__doc__</span>
<span class="go">&#39;X blah blah&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span>
<span class="go">&#39;x&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Можно использовать <cite>in</cite> для определения содержит ли интерфейс
определенное имя:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">IFoo</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Мы можем использовать итератор для интерфейсов что бы получить все имена
которые интерфейсы определяют:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">names</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">names</span>
<span class="go">[&#39;bar&#39;, &#39;x&#39;]</span>
</pre></div>
</div>
<p>Надо помнить, что интерфейсы не являются классами. Мы не можем получить
доступ к определениям атрибутов через доступ к атрибутам интерфейсов:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">x</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;InterfaceClass&#39; object has no attribute &#39;x&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;InterfaceClass&#39; object has no attribute &#39;x&#39;</span>
</pre></div>
</div>
<p>Методы также предоставляют доступ к сигнатуре метода:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">IFoo</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">getSignatureString</span><span class="p">()</span>
<span class="go">&#39;(q, r=None)&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id20">Объявление интерфейсов</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>Определив интерфейс мы можем теперь <em>объявить</em>, что объекты предоставляют их.
Перед описанием деталей определим некоторые термины:</p>
<dl class="docutils">
<dt><em>предоставлять</em></dt>
<dd>Мы говорим, что объекты <em>предоставляют</em> интерфейсы. Если объект
предоставляет интерфейс, тогда интерфейс специфицирует поведение объекта.
Другими словами, интерфейсы специфицируют поведение объектов которые
предоставляют их.</dd>
<dt><em>реализовать</em></dt>
<dd><p class="first">Мы обычно говорим что классы <em>реализуют</em> интерфейсы. Если класс
реализует интерфейс, тогда экземпляры этого класса предоставляют
данный интерфейс. Объекты предоставляют интерфейсы которые их классы
реализуют <a class="footnote-reference" href="#factory" id="id5">[2]</a>. (Объекты также могут предоставлять интерфейсы напрямую
плюс к тем которые реализуют их классы.)</p>
<p>Важно помнить, что классы обычно не предоставляют интерфейсы которые
они реализуют.</p>
<p class="last">Мы можем обобщить это до фабрик. Для любого вызываемого объекта мы можем
объявить что он производит объекты которые предоставляют какие-либо
интерфейсы сказав, что фабрика реализует данные интерфейсы.</p>
</dd>
</dl>
<p>Теперь после того как мы определили эти термины мы можем поговорить об
API для объявления интерфейсов.</p>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id21">Объявление реализуемых интерфейсов</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>Наиболее часто используемый путь для объявления интерфейсов - это использование
функции implements в определении класса:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implements</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s">&quot;Foo(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>В этом примере мы объявили, что <cite>Foo</cite> реализует <cite>IFoo</cite>. Это значит, что
экземпляры <cite>Foo</cite> предоставляют <cite>IFoo</cite>. После данного объявления есть
несколько путей для анализа объявлений. Во-первых мы можем спросить
что интерфейс реализован классом:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Также мы можем спросить если интерфейс предоставляется объектами класса:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Конечно <cite>Foo</cite> не предоставляет <cite>IFoo</cite>, он реализует его:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Мы можем также узнать какие интерфейсы реализуются объектами:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">Foo</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.IFoo&gt;]</span>
</pre></div>
</div>
<p>Это ошибка спрашивать про интерфейсы реализуемые не вызываемым объектом:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">(&#39;ImplementedBy called for non-factory&#39;, Foo(None))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">(&#39;ImplementedBy called for non-factory&#39;, Foo(None))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">(&#39;ImplementedBy called for non-factory&#39;, Foo(None))</span>
</pre></div>
</div>
<p>Также можно узнать какие интерфейсы предоставляются объектами:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.IFoo&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">Foo</span><span class="p">))</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Мы можем объявить интерфейсы реализуемые другими фабриками (кроме классов).
Это можно сделать используя декоратор <cite>implementer</cite> (в стиле Python 2.4).
Для версий Python ниже 2.4 это будет выглядеть следующим образом:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">yfoo</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">foo</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">foo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yfoo</span> <span class="o">=</span> <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementer</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)(</span><span class="n">yfoo</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">yfoo</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.IFoo&gt;]</span>
</pre></div>
</div>
<p>Надо заметить, что декоратор implementer может модифицировать свои аргументы.
Вызывающая сторона не должна предполагать, что всегда будет создаваться
новый объект.</p>
<p>XXX: Double check and update these version numbers, and translate to russian:</p>
<p>In zope.interface 3.5.1 and lower, the implementer decorator can not
be used for classes, but in 3.5.2 and higher it can:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Foo</span> <span class="o">=</span> <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementer</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)(</span><span class="n">Foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">Foo</span><span class="p">()))</span>
<span class="go">[&lt;InterfaceClass __main__.IFoo&gt;]</span>
</pre></div>
</div>
<p>Note that class decorators using the &#64;implementer(IFoo) syntax are only
supported in Python 2.6 and later.</p>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id22">Объявление предоставляемых интерфейсов</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Мы можем объявлять интерфейсы напрямую предоставляемые объектами. Предположим
что мы хотим документировать что делает метод <cite>__init__</cite> класса <cite>Foo</cite>. Это
<em>точно</em> не часть <cite>IFoo</cite>. Обычно мы не должны напрямую вызывать метод <cite>__init__</cite>
для экземпляров Foo. Скорее метод <cite>__init__</cite> является частью метода <cite>__call__</cite>
класса <cite>Foo</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IFooFactory</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Create foos&quot;&quot;&quot;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>        <span class="sd">&quot;&quot;&quot;Create a foo</span>
<span class="gp">...</span><span class="sd"></span>
<span class="gp">... </span><span class="sd">        The argument provides the initial value for x ...</span>
<span class="gp">... </span><span class="sd">        &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>У нас есть класс предоставляющий данный интерфейс, таким образом мы можем
объявить интерфейс класса:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">directlyProvides</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">IFooFactory</span><span class="p">)</span>
</pre></div>
</div>
<p>Теперь мы видим, что Foo уже предоставляет интерфейсы:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">Foo</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.IFooFactory&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IFooFactory</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Объявление интерфейсов класса достаточно частая операция и для нее есть
специальная функция объявления <cite>classProvides</cite>, которая позволяет объявлять
интерфейсы при определении класса:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo2</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implements</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">classProvides</span><span class="p">(</span><span class="n">IFooFactory</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s">&quot;Foo(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">Foo2</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.IFooFactory&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IFooFactory</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">Foo2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Похожая функция <cite>moduleProvides</cite> поддерживает объявление интерфейсов при
определении модуля. Для примера смотрите использование вызова
<cite>moduleProvides</cite> в <cite>zope.interface.__init__</cite>, который объявляет, что
пакет <cite>zope.interface</cite> предоставляет <cite>IInterfaceDeclaration</cite>.</p>
<p>Иногда мы хотим объявить интерфейсы экземпляров, даже если эти экземпляры
уже берут интерфейсы от своих классов. Предположим, что мы создаем новый
интерфейс <cite>ISpecial</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ISpecial</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">reason</span> <span class="o">=</span> <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;Reason why we&#39;re special&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">brag</span><span class="p">():</span>
<span class="gp">... </span>        <span class="s">&quot;Brag about being special&quot;</span>
</pre></div>
</div>
<p>Мы можем сделать созданный экземпляр foo специальным предоставив атрибуты
<cite>reason</cite> и <cite>brag</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="o">.</span><span class="n">reason</span> <span class="o">=</span> <span class="s">&#39;I just am&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">brag</span><span class="p">():</span>
<span class="gp">... </span>     <span class="k">return</span> <span class="s">&quot;I&#39;m special!&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="o">.</span><span class="n">brag</span> <span class="o">=</span> <span class="n">brag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="o">.</span><span class="n">reason</span>
<span class="go">&#39;I just am&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="o">.</span><span class="n">brag</span><span class="p">()</span>
<span class="go">&quot;I&#39;m special!&quot;</span>
</pre></div>
</div>
<p>и объявив интерфейс:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">directlyProvides</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">ISpecial</span><span class="p">)</span>
</pre></div>
</div>
<p>таким образом новый интерфейс включается в список предоставляемых интерфейсов:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ISpecial</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.ISpecial&gt;, &lt;InterfaceClass __main__.IFoo&gt;]</span>
</pre></div>
</div>
<p>Мы также можем определить, что интерфейсы напрямую предоставляются
объектами:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">directlyProvidedBy</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.ISpecial&gt;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">newfoo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">directlyProvidedBy</span><span class="p">(</span><span class="n">newfoo</span><span class="p">))</span>
<span class="go">[]</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id23">Наследуемые объявления</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>Обычно объявления наследуются:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">SpecialFoo</span><span class="p">(</span><span class="n">Foo</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implements</span><span class="p">(</span><span class="n">ISpecial</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">reason</span> <span class="o">=</span> <span class="s">&#39;I just am&#39;</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">brag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s">&quot;I&#39;m special because </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">reason</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">SpecialFoo</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.ISpecial&gt;, &lt;InterfaceClass __main__.IFoo&gt;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">SpecialFoo</span><span class="p">()))</span>
<span class="go">[&lt;InterfaceClass __main__.ISpecial&gt;, &lt;InterfaceClass __main__.IFoo&gt;]</span>
</pre></div>
</div>
<p>Иногда мы не хотим наследовать объявления. В этом случае мы можем
использовать <cite>implementsOnly</cite> вместо <cite>implements</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Special</span><span class="p">(</span><span class="n">Foo</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementsOnly</span><span class="p">(</span><span class="n">ISpecial</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">reason</span> <span class="o">=</span> <span class="s">&#39;I just am&#39;</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">brag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s">&quot;I&#39;m special because </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">reason</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">Special</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.ISpecial&gt;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">providedBy</span><span class="p">(</span><span class="n">Special</span><span class="p">()))</span>
<span class="go">[&lt;InterfaceClass __main__.ISpecial&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id24">Внешние объявления</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>Обычно мы создаем объявления реализации как часть объявления класса. Иногда
мы можем захотеть создать объявления вне объявления класса. Для примера,
мы можем хотеть объявить интерфейсы для классов которые писали не мы.
Для этого может использоваться функция <cite>classImplements</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">classImplements</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">IFoo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.IFoo&gt;]</span>
</pre></div>
</div>
<p>Мы можем использовать <cite>classImplementsOnly</cite> для исключения наследуемых
интерфейсов:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Foo</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">classImplementsOnly</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">ISpecial</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.ISpecial&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id25">Объекты объявлений</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>Когда мы объявляем интерфейсы мы создаем объект <em>объявления</em>. Когда мы
запрашиваем объявления возвращается объект объявления:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">Special</span><span class="p">))</span>
<span class="go">&lt;class &#39;zope.interface.declarations.Implements&#39;&gt;</span>
</pre></div>
</div>
<p>Объекты объявления и объекты интерфейсов во многом похожи друг на друга.
На самом деле они даже имеют общий базовый класс. Важно понять, что они могут
использоваться там где в объявлениях ожидаются интерфейсы. Вот простой
пример:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Special2</span><span class="p">(</span><span class="n">Foo</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementsOnly</span><span class="p">(</span>
<span class="gp">... </span>         <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">Foo</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">ISpecial</span><span class="p">,</span>
<span class="gp">... </span>         <span class="p">)</span>
<span class="gp">... </span>    <span class="n">reason</span> <span class="o">=</span> <span class="s">&#39;I just am&#39;</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">brag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s">&quot;I&#39;m special because </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">reason</span>
</pre></div>
</div>
<p>Объявление здесь практически такое же как
<code class="docutils literal"><span class="pre">zope.interface.implements(ISpecial)</span></code>, отличие только в порядке
интерфейсов в итоговом объявления:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">Special2</span><span class="p">))</span>
<span class="go">[&lt;InterfaceClass __main__.IFoo&gt;, &lt;InterfaceClass __main__.ISpecial&gt;]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id26">Наследование интерфейсов</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>Интерфейсы могут расширять другие интерфейсы. Они делают это просто
показывая эти интерфейсы как базовые:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IBlat</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Blat blah blah&quot;&quot;&quot;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">y</span> <span class="o">=</span> <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;y blah blah&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">eek</span><span class="p">():</span>
<span class="gp">... </span>        <span class="sd">&quot;&quot;&quot;eek blah blah&quot;&quot;&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">IBlat</span><span class="o">.</span><span class="n">__bases__</span>
<span class="go">(&lt;InterfaceClass zope.interface.Interface&gt;,)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IBaz</span><span class="p">(</span><span class="n">IFoo</span><span class="p">,</span> <span class="n">IBlat</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Baz blah&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">eek</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>        <span class="sd">&quot;&quot;&quot;eek in baz blah&quot;&quot;&quot;</span>
<span class="gp">...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">IBaz</span><span class="o">.</span><span class="n">__bases__</span>
<span class="go">(&lt;InterfaceClass __main__.IFoo&gt;, &lt;InterfaceClass __main__.IBlat&gt;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">IBaz</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">names</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">names</span>
<span class="go">[&#39;bar&#39;, &#39;eek&#39;, &#39;x&#39;, &#39;y&#39;]</span>
</pre></div>
</div>
<p>Заметим, что <cite>IBaz</cite> переопределяет eek:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IBlat</span><span class="p">[</span><span class="s">&#39;eek&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">__doc__</span>
<span class="go">&#39;eek blah blah&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IBaz</span><span class="p">[</span><span class="s">&#39;eek&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">__doc__</span>
<span class="go">&#39;eek in baz blah&#39;</span>
</pre></div>
</div>
<p>Мы были осторожны переопределяя eek совместимым путем. Когда интерфейс
расширяется, расширенный интерфейс должен быть совместимым <a class="footnote-reference" href="#compat" id="id12">[3]</a> с
расширяемыми интерфейсами.</p>
<p>Мы можем запросить расширяет ли один из интерфейсов другой:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IBaz</span><span class="o">.</span><span class="n">extends</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IBlat</span><span class="o">.</span><span class="n">extends</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Заметим, что интерфейсы не расширяют сами себя:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IBaz</span><span class="o">.</span><span class="n">extends</span><span class="p">(</span><span class="n">IBaz</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Иногда мы можем хотеть что бы они расширяли сами себя, но вместо этого
мы можем использовать <cite>isOrExtends</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IBaz</span><span class="o">.</span><span class="n">isOrExtends</span><span class="p">(</span><span class="n">IBaz</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IBaz</span><span class="o">.</span><span class="n">isOrExtends</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">isOrExtends</span><span class="p">(</span><span class="n">IBaz</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Когда мы применяем итерацию к интерфейсу мы получаем все имена которые он
определяет включая имена определенные для базовых интерфейсов. Иногда
мы хотим получить <em>только</em> имена определенные интерфейсом напрямую.
Для этого мы используем метод <cite>names</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">IBaz</span><span class="o">.</span><span class="n">names</span><span class="p">())</span>
<span class="go">[&#39;eek&#39;]</span>
</pre></div>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id27">Наследование в случае определения атрибутов</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>Интерфейс может переопределять определения атрибутов из базовых интерфейсов.
Если два базовых интерфейса определяют один и тот же атрибут атрибут
наследуется от более специфичного интерфейса. Для примера:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IBase</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>        <span class="s">&quot;base foo doc&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IBase1</span><span class="p">(</span><span class="n">IBase</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IBase2</span><span class="p">(</span><span class="n">IBase</span><span class="p">):</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>        <span class="s">&quot;base2 foo doc&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ISub</span><span class="p">(</span><span class="n">IBase1</span><span class="p">,</span> <span class="n">IBase2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
</pre></div>
</div>
<p>Определение ISub для foo будет из IBase2 т.к. IBase2 более специфичен для
IBase:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ISub</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">__doc__</span>
<span class="go">&#39;base2 foo doc&#39;</span>
</pre></div>
</div>
<p>Заметим, что это отличается от поиска в глубину.</p>
<p>Иногда полезно узнать, что интерфейс определяет атрибут напрямую. Мы можем
использовать метод direct для получения напрямую определенных атрибутов:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IBase</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">__doc__</span>
<span class="go">&#39;base foo doc&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ISub</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id28">Спецификации</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>Интерфейсы и объявления - это специальные случаи спецификаций. Описание
выше для наследования интерфейсов можно применить и к объявлениям и
к спецификациям. Объявления фактически расширяют интерфейсы которые они
объявляют:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Baz</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implements</span><span class="p">(</span><span class="n">IBaz</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">baz_implements</span> <span class="o">=</span> <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implementedBy</span><span class="p">(</span><span class="n">Baz</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">baz_implements</span><span class="o">.</span><span class="n">__bases__</span>
<span class="go">(&lt;InterfaceClass __main__.IBaz&gt;, &lt;implementedBy ...object&gt;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">baz_implements</span><span class="o">.</span><span class="n">extends</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">baz_implements</span><span class="o">.</span><span class="n">isOrExtends</span><span class="p">(</span><span class="n">IFoo</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">baz_implements</span><span class="o">.</span><span class="n">isOrExtends</span><span class="p">(</span><span class="n">baz_implements</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Спецификации (интерфейсы и объявления) предоставляют атрибут <cite>__sro__</cite>
который описывает спецификацию и всех ее предков:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">baz_implements</span><span class="o">.</span><span class="n">__sro__</span>
<span class="go">(&lt;implementedBy __main__.Baz&gt;,</span>
<span class="go"> &lt;InterfaceClass __main__.IBaz&gt;,</span>
<span class="go"> &lt;InterfaceClass __main__.IFoo&gt;,</span>
<span class="go"> &lt;InterfaceClass __main__.IBlat&gt;,</span>
<span class="go"> &lt;InterfaceClass zope.interface.Interface&gt;,</span>
<span class="go"> &lt;implementedBy ...object&gt;)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id15">
<h2><a class="toc-backref" href="#id29">Помеченные значения</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<p>Интерфейсы и описания атрибутов поддерживают механизм расширения
заимствованный из UML и называемый &#8220;помеченные значения&#8221; который позволяет
сохранять дополнительные данные:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">setTaggedValue</span><span class="p">(</span><span class="s">&#39;date-modified&#39;</span><span class="p">,</span> <span class="s">&#39;2004-04-01&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">setTaggedValue</span><span class="p">(</span><span class="s">&#39;author&#39;</span><span class="p">,</span> <span class="s">&#39;Jim Fulton&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">getTaggedValue</span><span class="p">(</span><span class="s">&#39;date-modified&#39;</span><span class="p">)</span>
<span class="go">&#39;2004-04-01&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">queryTaggedValue</span><span class="p">(</span><span class="s">&#39;date-modified&#39;</span><span class="p">)</span>
<span class="go">&#39;2004-04-01&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IFoo</span><span class="o">.</span><span class="n">queryTaggedValue</span><span class="p">(</span><span class="s">&#39;datemodified&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">IFoo</span><span class="o">.</span><span class="n">getTaggedValueTags</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tags</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tags</span>
<span class="go">[&#39;author&#39;, &#39;date-modified&#39;]</span>
</pre></div>
</div>
<p>Атрибуты функций конвертируются в помеченные значения когда создаются
определения атрибутов метода:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IBazFactory</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">():</span>
<span class="gp">... </span>        <span class="s">&quot;create one&quot;</span>
<span class="gp">... </span>    <span class="n">__call__</span><span class="o">.</span><span class="n">return_type</span> <span class="o">=</span> <span class="n">IBaz</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">IBazFactory</span><span class="p">[</span><span class="s">&#39;__call__&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getTaggedValue</span><span class="p">(</span><span class="s">&#39;return_type&#39;</span><span class="p">)</span>
<span class="go">&lt;InterfaceClass __main__.IBaz&gt;</span>
</pre></div>
</div>
<p>Помеченные значения также могут быть определены внутри определения
интерфейса:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IWithTaggedValues</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">taggedValue</span><span class="p">(</span><span class="s">&#39;squish&#39;</span><span class="p">,</span> <span class="s">&#39;squash&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IWithTaggedValues</span><span class="o">.</span><span class="n">getTaggedValue</span><span class="p">(</span><span class="s">&#39;squish&#39;</span><span class="p">)</span>
<span class="go">&#39;squash&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2><a class="toc-backref" href="#id30">Инварианты</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<p>Интерфейсы могут описывать условия которые должны быть соблюдены для объектов
которые их предоставляют. Эти условия описываются используя один или более
инвариантов. Инварианты - это вызываемые объекты которые будут вызваны
с объектом предоставляющим интерфейс в качестве параметра. Инвариант
должен выкинуть исключение <cite>Invalid</cite> если условие не соблюдено. Например:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RangeError</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Invalid</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;A range has invalid limits&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s">&quot;RangeError(</span><span class="si">%r</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">range_invariant</span><span class="p">(</span><span class="n">ob</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">ob</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">RangeError</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
</pre></div>
</div>
<p>Определив этот инвариант мы можем использовать его в определении интерфейсов:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IRange</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">min</span> <span class="o">=</span> <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;Lower bound&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">max</span> <span class="o">=</span> <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Attribute</span><span class="p">(</span><span class="s">&quot;Upper bound&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">invariant</span><span class="p">(</span><span class="n">range_invariant</span><span class="p">)</span>
</pre></div>
</div>
<p>Интерфейсы имеют метод для проверки своих инвариантов:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Range</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implements</span><span class="p">(</span><span class="n">IRange</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s">&quot;Range(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">IRange</span><span class="o">.</span><span class="n">validateInvariants</span><span class="p">(</span><span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IRange</span><span class="o">.</span><span class="n">validateInvariants</span><span class="p">(</span><span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">IRange</span><span class="o">.</span><span class="n">validateInvariants</span><span class="p">(</span><span class="n">Range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RangeError</span>: <span class="n">Range(2, 1)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RangeError</span>: <span class="n">Range(2, 1)</span>
</pre></div>
</div>
<p>В случае нескольких инвариантов мы можем захотеть остановить проверку после
первой ошибки. Если мы передадим в <cite>validateInvariants</cite> пустой список тогда
будет выкинуто единственное исключение <cite>Invalid</cite> со списком исключений
как аргументом:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">zope.interface.exceptions</span> <span class="kn">import</span> <span class="n">Invalid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">IRange</span><span class="o">.</span><span class="n">validateInvariants</span><span class="p">(</span><span class="n">Range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">errors</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="n">Invalid</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">&#39;[RangeError(Range(2, 1))]&#39;</span>
</pre></div>
</div>
<p>И список будет заполнен индивидуальными исключениями:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">errors</span>
<span class="go">[RangeError(Range(2, 1))]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">errors</span><span class="p">[:]</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2><a class="toc-backref" href="#id31">Адаптация</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p>Интерфейсы могут быть вызваны для осуществления адаптации. Эта семантика
основана на функции adapt из PEP 246. Если объект не может быть адаптирован
будет выкинут TypeError:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">I</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">(&#39;Could not adapt&#39;, 0, &lt;InterfaceClass __main__.I&gt;)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">(&#39;Could not adapt&#39;, 0, &lt;InterfaceClass __main__.I&gt;)</span>
</pre></div>
</div>
<p>только если альтернативное значение не передано как второй аргумент:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;bob&#39;</span><span class="p">)</span>
<span class="go">&#39;bob&#39;</span>
</pre></div>
</div>
<p>Если объект уже реализует нужный интерфейс он будет возвращен:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implements</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="n">obj</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Если объект реализует __conform__, тогда она будет использована:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implements</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__conform__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proto</span><span class="p">):</span>
<span class="gp">... </span>         <span class="k">return</span> <span class="mi">0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Также если присутствуют функции для вызова адаптации (см. __adapt__) они будут
использованы:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">zope.interface.interface</span> <span class="kn">import</span> <span class="n">adapter_hooks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">adapt_0_to_42</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">42</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">adapter_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adapt_0_to_42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">42</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">adapter_hooks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">adapt_0_to_42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">(&#39;Could not adapt&#39;, 0, &lt;InterfaceClass __main__.I&gt;)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">(&#39;Could not adapt&#39;, 0, &lt;InterfaceClass __main__.I&gt;)</span>
</pre></div>
</div>
<div class="section" id="adapt">
<h3><a class="toc-backref" href="#id32">__adapt__</a><a class="headerlink" href="#adapt" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">I</span><span class="p">(</span><span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">Interface</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
</pre></div>
</div>
<p>Интерфейсы реализуют метод __adapt__ из PEP 246. Этот метод обычно не
вызывается напрямую. Он вызывается архитектурой адаптации из PEP 246 и методом
__call__ интерфейсов. Метод адаптации отвечает за адаптацию объекта к
получателю. Версия по умолчанию возвращает None:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">__adapt__</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>если только переданный объект не предоставляет нужный интерфейс:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zope</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">implements</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">__adapt__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="n">obj</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Функции для вызова адаптации могут быть добавлены (или удалены) для
предоставления адаптации &#8220;на заказ&#8221;. Мы установим глупую функцию которая
адаптирует 0 к 42. Мы устанавливаем функцию просто добавляя ее к списку
adapter_hooks:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">zope.interface.interface</span> <span class="kn">import</span> <span class="n">adapter_hooks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">adapt_0_to_42</span><span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">42</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">adapter_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adapt_0_to_42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">__adapt__</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">42</span>
</pre></div>
</div>
<p>Функции должны возвращать либо адаптер, либо None если адаптер не найден.
Функции могут быть удалены удалением их из списка:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">adapter_hooks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">adapt_0_to_42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="o">.</span><span class="n">__adapt__</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="create" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><p class="first">Основная причина по которой мы наследуемся от <cite>Interface</cite> - это
что бы быть уверенными в том, что ключевое слово class будет
создавать интерфейс, а не класс.</p>
<p class="last">Есть возможность создать интерфейсы вызвав специальный
класс интерфейса напрямую. Делая это, возможно (и в редких
случаях полезно) создать интерфейсы которые не наследуются
от <cite>Interface</cite>. Однако использование этой техники выходит
за рамки данного документа.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="factory" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>Классы - это фабрики. Они могут быть вызваны для создания
своих экземпляров. Мы ожидаем что в итоге мы расширим
концепцию реализации на другие типы фабрик, таким образом
мы сможем объявлять интерфейсы предоставляемые созданными
фабриками объектами.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="compat" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[3]</a></td><td><p class="first">Цель - заменяемость. Объект который предоставляет расширенный
интерфейс должен быть заменяем в качестве объектов которые
предоставляют расширяемый интерфейс. В нашем примере объект
который предоставляет IBaz должен быть используемым и
в случае если ожидается объект который предоставляет IBlat.</p>
<p class="last">Реализация интерфейса не требует этого. Но возможно в дальнейшем
она должна будет делать какие-либо проверки.</p>
</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Интерфейсы</a><ul>
<li><a class="reference internal" href="#id2">Определение интерфейсов</a></li>
<li><a class="reference internal" href="#id4">Объявление интерфейсов</a><ul>
<li><a class="reference internal" href="#id6">Объявление реализуемых интерфейсов</a></li>
<li><a class="reference internal" href="#id7">Объявление предоставляемых интерфейсов</a></li>
<li><a class="reference internal" href="#id8">Наследуемые объявления</a></li>
<li><a class="reference internal" href="#id9">Внешние объявления</a></li>
<li><a class="reference internal" href="#id10">Объекты объявлений</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">Наследование интерфейсов</a><ul>
<li><a class="reference internal" href="#id13">Наследование в случае определения атрибутов</a></li>
<li><a class="reference internal" href="#id14">Спецификации</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id15">Помеченные значения</a></li>
<li><a class="reference internal" href="#id16">Инварианты</a></li>
<li><a class="reference internal" href="#id17">Адаптация</a><ul>
<li><a class="reference internal" href="#adapt">__adapt__</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="hacking.html"
                        title="previous chapter">Hacking on <code class="docutils literal"><span class="pre">zope.interface</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="adapter.ru.html"
                        title="next chapter">Реестр адаптеров</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/README.ru.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="adapter.ru.html" title="Реестр адаптеров"
             >next</a> |</li>
        <li class="right" >
          <a href="hacking.html" title="Hacking on zope.interface"
             >previous</a> |</li>
        <li><a href="index.html">zope.interface 4.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, Zope Foundation contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3b2.
    </div>
  </body>
</html>