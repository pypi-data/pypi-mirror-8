<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>fnss.topologies.randmodels &mdash; FNSS 0.6.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="FNSS 0.6.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">FNSS 0.6.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for fnss.topologies.randmodels</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Provides functions to generate random topologies according to a number of </span>
<span class="sd">models.</span>

<span class="sd">The generated topologies are either Topology or DIrectedTopology objects.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>

<span class="kn">from</span> <span class="nn">fnss.util</span> <span class="kn">import</span> <span class="n">random_from_pdf</span>
<span class="kn">from</span> <span class="nn">fnss.topologies.topology</span> <span class="kn">import</span> <span class="n">Topology</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;erdos_renyi_topology&#39;</span><span class="p">,</span>
    <span class="s">&#39;waxman_1_topology&#39;</span><span class="p">,</span>
    <span class="s">&#39;waxman_2_topology&#39;</span><span class="p">,</span>
    <span class="s">&#39;barabasi_albert_topology&#39;</span><span class="p">,</span>
    <span class="s">&#39;extended_barabasi_albert_topology&#39;</span><span class="p">,</span>
    <span class="s">&#39;glp_topology&#39;</span>
          <span class="p">]</span>

<div class="viewcode-block" id="erdos_renyi_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.randmodels.erdos_renyi_topology.html#fnss.topologies.randmodels.erdos_renyi_topology">[docs]</a><span class="k">def</span> <span class="nf">erdos_renyi_topology</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Return a random graph :math:`G_{n,p}` (Erdos-Renyi graph, binomial </span>
<span class="sd">    graph).</span>

<span class="sd">    Chooses each of the possible edges with probability p.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of nodes.</span>
<span class="sd">    p : float</span>
<span class="sd">        Probability for edge creation.</span>
<span class="sd">    seed : int, optional</span>
<span class="sd">        Seed for random number generator (default=None). </span>
<span class="sd">    fast : boolean, optional</span>
<span class="sd">        Uses the algorithm proposed by [3]_, which is faster for small p </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] P. Erdos and A. Renyi, On Random Graphs, Publ. Math. 6, 290 (1959).</span>
<span class="sd">    .. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959).</span>
<span class="sd">    .. [3] Vladimir Batagelj and Ulrik Brandes, </span>
<span class="sd">       &quot;Efficient generation of large random networks&quot;,</span>
<span class="sd">       Phys. Rev. E, 71, 036113, 2005.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># validate input parameters</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;n must be a positive integer&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;p must be a value in (0,1)&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fast</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">gnp_random_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">))</span>
    <span class="n">G</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;erdos_renyi_topology(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;er&#39;</span>
    <span class="k">return</span> <span class="n">G</span>

</div>
<div class="viewcode-block" id="waxman_1_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.randmodels.waxman_1_topology.html#fnss.topologies.randmodels.waxman_1_topology">[docs]</a><span class="k">def</span> <span class="nf">waxman_1_topology</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                      <span class="n">distance_unit</span><span class="o">=</span><span class="s">&#39;Km&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return a Waxman-1 random topology.</span>

<span class="sd">    The Waxman-1 random topology models assigns link between nodes with </span>
<span class="sd">    probability</span>

<span class="sd">    .. math::</span>
<span class="sd">            p = \alpha*exp(-d/(\beta*L)).</span>

<span class="sd">    where the distance *d* is chosen randomly in *[0,L]*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of nodes</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Model parameter chosen in *(0,1]* (higher alpha increases link density)</span>
<span class="sd">    beta : float</span>
<span class="sd">        Model parameter chosen in *(0,1]* (higher beta increases difference</span>
<span class="sd">        between density of short and long links)</span>
<span class="sd">    L : float</span>
<span class="sd">        Maximum distance between nodes.</span>
<span class="sd">    seed : int, optional</span>
<span class="sd">        Seed for random number generator (default=None). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : Topology</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Each node of G has the attributes *latitude* and *longitude*. These</span>
<span class="sd">    attributes are not expressed in degrees but in *distance_unit*.</span>
<span class="sd">    </span>
<span class="sd">    Each edge of G has the attribute *length*, which is also expressed in</span>
<span class="sd">    *distance_unit*.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1]  B. M. Waxman, Routing of multipoint connections. </span>
<span class="sd">       IEEE J. Select. Areas Commun. 6(9),(1988) 1617-1622. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># validate input parameters</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;n must be a positive integer&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">beta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;alpha and beta must be float values in (0,1]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;L must be a positive number&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;waxman_1&#39;</span><span class="p">,</span> <span class="n">distance_unit</span><span class="o">=</span><span class="n">distance_unit</span><span class="p">)</span>
    
    <span class="n">G</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;waxman_1_topology(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">L</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="o">/</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">L</span><span class="p">)):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span>

</div>
<div class="viewcode-block" id="waxman_2_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.randmodels.waxman_2_topology.html#fnss.topologies.randmodels.waxman_2_topology">[docs]</a><span class="k">def</span> <span class="nf">waxman_2_topology</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                      <span class="n">distance_unit</span><span class="o">=</span><span class="s">&#39;Km&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Return a Waxman-2 random topology.</span>

<span class="sd">    The Waxman-2 random topology models place n nodes uniformly at random</span>
<span class="sd">    in a rectangular domain. Two nodes u, v are connected with a link</span>
<span class="sd">    with probability</span>

<span class="sd">    .. math::</span>
<span class="sd">            p = \alpha*exp(-d/(\beta*L)).</span>

<span class="sd">    where the distance *d* is the Euclidean distance between the nodes u and v.</span>
<span class="sd">    and *L* is the maximum distance between all nodes in the graph.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of nodes</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Model parameter chosen in *(0,1]* (higher alpha increases link density)</span>
<span class="sd">    beta : float</span>
<span class="sd">        Model parameter chosen in *(0,1]* (higher beta increases difference</span>
<span class="sd">        between density of short and long links)</span>
<span class="sd">    domain : tuple of numbers, optional</span>
<span class="sd">         Domain size (xmin, ymin, xmax, ymax)</span>
<span class="sd">    seed : int, optional</span>
<span class="sd">        Seed for random number generator (default=None). </span>
<span class="sd">              </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : Topology</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Each edge of G has the attribute *length*</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1]  B. M. Waxman, Routing of multipoint connections. </span>
<span class="sd">       IEEE J. Select. Areas Commun. 6(9),(1988) 1617-1622. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># validate input parameters</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;n must be a positive integer&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">beta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;alpha and beta must be float values in (0,1]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;domain must be a tuple of 4 number&#39;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span> <span class="o">=</span> <span class="n">domain</span>
    <span class="k">if</span> <span class="n">xmin</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;In domain, xmin cannot be greater than xmax&#39;</span><span class="p">)</span>
    <span class="k">if</span>  <span class="n">ymin</span> <span class="o">&gt;</span> <span class="n">ymax</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;In domain, ymin cannot be greater than ymax&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;waxman_2&#39;</span><span class="p">,</span> <span class="n">distance_unit</span><span class="o">=</span><span class="n">distance_unit</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;waxman_2_topology(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    
    
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;latitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymin</span> <span class="o">+</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">))</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;longitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span> <span class="o">+</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">))</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        
    <span class="n">l</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">x_u</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;longitude&#39;</span><span class="p">]</span>
            <span class="n">x_v</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;longitude&#39;</span><span class="p">]</span>
            <span class="n">y_u</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;latitude&#39;</span><span class="p">]</span>
            <span class="n">y_v</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;latitude&#39;</span><span class="p">]</span>
            <span class="n">l</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x_u</span> <span class="o">-</span> <span class="n">x_v</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_u</span> <span class="o">-</span> <span class="n">y_v</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> 
    <span class="n">L</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="o">/</span><span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">L</span><span class="p">)):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
  
    <span class="k">return</span> <span class="n">G</span>
    

<span class="c"># This is the classical BA model, without rewiring and add </span></div>
<div class="viewcode-block" id="barabasi_albert_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.randmodels.barabasi_albert_topology.html#fnss.topologies.randmodels.barabasi_albert_topology">[docs]</a><span class="k">def</span> <span class="nf">barabasi_albert_topology</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return a random topology using Barabasi-Albert preferential attachment </span>
<span class="sd">    model.</span>
<span class="sd">        </span>
<span class="sd">    A topology of n nodes is grown by attaching new nodes each with m links</span>
<span class="sd">    that are preferentially attached to existing nodes with high degree.</span>
<span class="sd">    </span>
<span class="sd">    More precisely, the Barabasi-Albert topology is built as follows. First, a</span>
<span class="sd">    line topology with m0 nodes is created. Then at each step, one node is</span>
<span class="sd">    added and connected to m existing nodes. These nodes are selected randomly</span>
<span class="sd">    with probability </span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">            \Pi(i) = \frac{deg(i)}{sum_{v \in V} deg V}.</span>
<span class="sd">    </span>
<span class="sd">    Where i is the selected node and V is the set of nodes of the graph.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of nodes</span>
<span class="sd">    m : int</span>
<span class="sd">        Number of edges to attach from a new node to existing nodes</span>
<span class="sd">    m0 : int</span>
<span class="sd">        Number of edges initially attached to the network</span>
<span class="sd">    seed : int, optional</span>
<span class="sd">        Seed for random number generator (default=None). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : Topology</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The initialization is a graph with with m nodes connected by :math:`m -1` </span>
<span class="sd">    edges.</span>
<span class="sd">    It does not use the Barabasi-Albert method provided by NetworkX because it</span>
<span class="sd">    does not allow to specify *m0* parameter.</span>
<span class="sd">    There are no disconnected subgraphs in the topology.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] A. L. Barabasi and R. Albert &quot;Emergence of scaling in</span>
<span class="sd">       random networks&quot;, Science 286, pp 509-512, 1999.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">calc_pi</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate BA Pi function for all nodes of the graph&quot;&quot;&quot;</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">den</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">degree</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">degree</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">/</span><span class="n">den</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">())</span>
    
    <span class="c"># input parameters</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">m0</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;n, m and m0 must be positive integers&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="n">m0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;m must be &lt;= m0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;n must be &gt; m0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="c"># Step 1: Add m0 nodes. These nodes are interconnected together </span>
    <span class="c"># because otherwise they will end up isolated at the end</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="n">m0</span><span class="p">))</span>
    <span class="n">G</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ba_topology(</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m0</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ba&#39;</span>
    
    <span class="c"># Step 2: Add one node and connect it with m links</span>
    <span class="k">while</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="n">calc_pi</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">new_links</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">new_links</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">random_from_pdf</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">new_links</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">G</span>


<span class="c"># This is the extended BA model, with rewiring and add</span></div>
<div class="viewcode-block" id="extended_barabasi_albert_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.randmodels.extended_barabasi_albert_topology.html#fnss.topologies.randmodels.extended_barabasi_albert_topology">[docs]</a><span class="k">def</span> <span class="nf">extended_barabasi_albert_topology</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return a random topology using the extended Barabasi-Albert preferential </span>
<span class="sd">    attachment model.</span>
<span class="sd">            </span>
<span class="sd">    Differently from the original Barabasi-Albert model, this model takes into</span>
<span class="sd">    account the presence of local events, such as the addition of new links or</span>
<span class="sd">    the rewiring of existing links.</span>
<span class="sd">    </span>
<span class="sd">    More precisely, the Barabasi-Albert topology is built as follows. First, a </span>
<span class="sd">    topology with *m0* isolated nodes is created. Then, at each step:</span>
<span class="sd">    with probability *p* add *m* new links between existing nodes, selected </span>
<span class="sd">    with probability:</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \Pi(i) = \frac{deg(i) + 1}{\sum_{v \in V} (deg(v) + 1)}</span>

<span class="sd">    with probability *q* rewire *m* links. Each link to be rewired is selected as </span>
<span class="sd">    follows: a node i is randomly selected and a link is randomly removed from</span>
<span class="sd">    it. The node i is then connected to a new node randomly selected with </span>
<span class="sd">    probability :math:`\Pi(i)`,</span>
<span class="sd">    with probability :math:`1-p-q` add a new node and attach it to m nodes of </span>
<span class="sd">    the existing topology selected with probability :math:`\Pi(i)`</span>
<span class="sd">    </span>
<span class="sd">    Repeat the previous step until the topology comprises n nodes in total.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of nodes</span>
<span class="sd">    m : int</span>
<span class="sd">        Number of edges to attach from a new node to existing nodes</span>
<span class="sd">    m0 : int</span>
<span class="sd">        Number of edges initially attached to the network</span>
<span class="sd">    p : float</span>
<span class="sd">        The probability that new links are added</span>
<span class="sd">    q : float</span>
<span class="sd">        The probability that existing links are rewired</span>
<span class="sd">    seed : int, optional</span>
<span class="sd">        Seed for random number generator (default=None). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : Topology</span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] A. L. Barabasi and R. Albert &quot;Topology of evolving networks: local </span>
<span class="sd">       events and universality&quot;, Physical Review Letters 85(24), 2000.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">calc_pi</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate extended-BA Pi function for all nodes of the graph&quot;&quot;&quot;</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">den</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">degree</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">degree</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">den</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">())</span>

    <span class="c"># input parameters</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">m0</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;n, m and m0 must be a positive integer&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="n">m0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;m must be &lt;= m0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;n must be &gt; m0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;p must be included between 0 and 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;q must be included between 0 and 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;p + q must be &lt;= 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;extended_ba&#39;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ext_ba_topology(</span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">, </span><span class="si">%f</span><span class="s">, </span><span class="si">%f</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="c"># Step 1: Add m0 isolated nodes</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">m0</span><span class="p">))</span>
    
    <span class="k">while</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="n">calc_pi</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">:</span>
            <span class="c"># add m new links with probability p</span>
            <span class="n">n_nodes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
            <span class="n">n_edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>
            <span class="n">max_n_edges</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_nodes</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">n_edges</span> <span class="o">+</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">max_n_edges</span><span class="p">:</span> <span class="c"># cannot add m links</span>
                <span class="k">continue</span> <span class="c"># rewire or add nodes </span>
            <span class="n">new_links</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">new_links</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">random_from_pdf</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">random_from_pdf</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">v</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="n">new_links</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="k">elif</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">:</span>
            <span class="c"># rewire m links with probability q</span>
            <span class="n">rewired_links</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">rewired_links</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="c"># pick up node randomly (uniform)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># if i has no edges, I cannot rewire</span>
                    <span class="k">break</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="c"># node to be disconnected</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">random_from_pdf</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="c"># new node to be connected</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                    <span class="n">rewired_links</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># add a new node with probability 1 - p - q</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
            <span class="n">new_links</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">new_links</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">existing_node</span> <span class="o">=</span> <span class="n">random_from_pdf</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">existing_node</span><span class="p">):</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">existing_node</span><span class="p">)</span>
                    <span class="n">new_links</span> <span class="o">+=</span> <span class="mi">1</span>             
    <span class="k">return</span> <span class="n">G</span>

</div>
<div class="viewcode-block" id="glp_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.randmodels.glp_topology.html#fnss.topologies.randmodels.glp_topology">[docs]</a><span class="k">def</span> <span class="nf">glp_topology</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return a random topology using the Generalized Linear Preference (GLP)</span>
<span class="sd">    preferential attachment model.</span>
<span class="sd">        </span>
<span class="sd">    It differs from the extended Barabasi-Albert model in that there is link</span>
<span class="sd">    rewiring and a beta parameter is introduced to fine-tune preferential</span>
<span class="sd">    attachment.</span>
<span class="sd">    </span>
<span class="sd">    More precisely, the GLP topology is built as follows. First, a </span>
<span class="sd">    line topology with *m0* nodes is created. Then, at each step:</span>
<span class="sd">    with probability *p*, add *m* new links between existing nodes, selected </span>
<span class="sd">    with probability:</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \Pi(i) = \frac{deg(i) - \beta 1}{\sum_{v \in V} (deg(v) - \beta)}</span>

<span class="sd">    with probability :math:`1-p`, add a new node and attach it to m nodes of </span>
<span class="sd">    the existing topology selected with probability :math:`\Pi(i)`</span>
<span class="sd">    </span>
<span class="sd">    Repeat the previous step until the topology comprises n nodes in total.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of nodes</span>
<span class="sd">    m : int</span>
<span class="sd">        Number of edges to attach from a new node to existing nodes</span>
<span class="sd">    m0 : int</span>
<span class="sd">        Number of edges initially attached to the network</span>
<span class="sd">    p : float</span>
<span class="sd">        The probability that new links are added</span>
<span class="sd">    beta : float</span>
<span class="sd">        Parameter to fine-tune preferntial attachment: beta &lt; 1</span>
<span class="sd">    seed : int, optional</span>
<span class="sd">        Seed for random number generator (default=None). </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G : Topology</span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] T. Bu and D. Towsey &quot;On distinguishing between Internet power law</span>
<span class="sd">       topology generators&quot;, Proceeding od the 21st IEEE INFOCOM conference. </span>
<span class="sd">       IEEE, volume 2, pages 638-647, 2002.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">calc_pi</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate GLP Pi function for all nodes of the graph&quot;&quot;&quot;</span>
        <span class="c"># validate input parameter</span>
        <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;beta must be &lt; 1&#39;</span><span class="p">)</span>    
        <span class="n">degree</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">den</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">degree</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">-</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">*</span> <span class="n">beta</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">degree</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span><span class="o">/</span><span class="n">den</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">add_m_links</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add m links between existing nodes to the graph&quot;&quot;&quot;</span>
        <span class="n">n_nodes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="n">n_edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>
        <span class="n">max_n_edges</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_nodes</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">n_edges</span> <span class="o">+</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">max_n_edges</span><span class="p">:</span> <span class="c"># cannot add m links</span>
            <span class="n">add_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span> <span class="c"># add a new node instead</span>
            <span class="c"># return in any case because before doing another operation</span>
            <span class="c"># (add node or links) we need to recalculate pi</span>
            <span class="k">return</span>
        <span class="n">new_links</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">new_links</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">random_from_pdf</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">random_from_pdf</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">new_links</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add one node to the graph and connect it to m existing nodes&quot;&quot;&quot;</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
        <span class="n">new_links</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">new_links</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">existing_node</span> <span class="o">=</span> <span class="n">random_from_pdf</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">existing_node</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">existing_node</span><span class="p">)</span>
                <span class="n">new_links</span> <span class="o">+=</span> <span class="mi">1</span>
                
    <span class="c"># validate input parameters</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">m0</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;n, m and m0 must be a positive integers&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;beta must be &lt; 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="n">m0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;m must be &lt;= m0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;p must be included between 0 and 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="c"># step 1: create a graph of m0 nodes connected by n-1 edges</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="n">m0</span><span class="p">))</span>
    <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;glp&#39;</span>
    <span class="n">G</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;glp_topology(</span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">, </span><span class="si">%d</span><span class="s">, </span><span class="si">%f</span><span class="s">, </span><span class="si">%f</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
    <span class="c"># Add nodes and links now</span>
    <span class="k">while</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="n">calc_pi</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">:</span>
            <span class="c"># add m new links with probability p</span>
            <span class="n">add_m_links</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># add a new node with m new links with probability 1 - p</span>
            <span class="n">add_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">FNSS 0.6.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2014, Lorenzo Saino, Cosmin Cocora.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>