<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>fnss.topologies.topology &mdash; FNSS 0.6.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="FNSS 0.6.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">FNSS 0.6.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for fnss.topologies.topology</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Provides basic functions and classes for operating on network topologies.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">xml.etree.cElementTree</span> <span class="kn">as</span> <span class="nn">ET</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">fnss.util</span> <span class="kn">as</span> <span class="nn">util</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;Topology&#39;</span><span class="p">,</span> 
    <span class="s">&#39;DirectedTopology&#39;</span><span class="p">,</span>
    <span class="s">&#39;od_pairs_from_topology&#39;</span><span class="p">,</span>
    <span class="s">&#39;fan_in_out_capacities&#39;</span><span class="p">,</span>
    <span class="s">&#39;rename_edge_attribute&#39;</span><span class="p">,</span>
    <span class="s">&#39;rename_node_attribute&#39;</span><span class="p">,</span>
    <span class="s">&#39;read_topology&#39;</span><span class="p">,</span>
    <span class="s">&#39;write_topology&#39;</span><span class="p">,</span>
           <span class="p">]</span>


<span class="k">class</span> <span class="nc">BaseTopology</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for generic topology. Provides utility methods for listing</span>
<span class="sd">    nodes and edge properties. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">capacities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of all link capacities, keyed by link</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        capacities : dict</span>
<span class="sd">            A dictionary of link capacity, keyed by link</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;capacity&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">delays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary of all link delays, keyed by link</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        delays : dict</span>
<span class="sd">            A dictionary of link delays, keyed by link</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;delay&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of all link weights, keyed by link</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        weights : dict</span>
<span class="sd">            A dictionary of all link weights, keyed by link</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;weight&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of all buffer sizes, keyed by interface</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        buffers : dict</span>
<span class="sd">            A dictionary of buffer sizes, keyed by interface. The interface is</span>
<span class="sd">            a tuple (u, v) which is the link to which the the interface is</span>
<span class="sd">            outputting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;buffer&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">stacks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of all node stacks, keyed by node</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stacks : dict</span>
<span class="sd">            A dictionary of all node stacks, keyed by node. Each node stack is</span>
<span class="sd">            a tuple (name, properties) where name is the stack name and</span>
<span class="sd">            properties is a the dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;stack&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">applications</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of all applications deployed, keyed by node</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        applications : dict</span>
<span class="sd">            A dictionary of all applications deployed, keyed by node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;application&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Topology"><a class="viewcode-back" href="../../../apidoc/fnss.classes.html#fnss.topologies.topology.Topology">[docs]</a><span class="k">class</span> <span class="nc">Topology</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span> <span class="n">BaseTopology</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for undirected topology&quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the topology</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : input graph</span>
<span class="sd">            Data to initialize the topology.  If data=None (default) an empty</span>
<span class="sd">            topology is created. The data can be an edge list, or any</span>
<span class="sd">            FNSS Topology or NetworkX graph object.  If the corresponding</span>
<span class="sd">            optional Python packages are installed the data can also be a NumPy</span>
<span class="sd">            matrix or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.</span>
<span class="sd">        name : string, optional</span>
<span class="sd">            An optional name for the graph. Default is &quot;&quot;</span>
<span class="sd">        **kwargs : keyword arguments, optional</span>
<span class="sd">            Attributes to add to graph as key=value pairs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Topology</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Topology.copy"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.Topology.copy.html#fnss.topologies.topology.Topology.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the topology.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : Topology</span>
<span class="sd">            A copy of the topology.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_directed: return a directed copy of the topology.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This makes a complete copy of the topology including all of the</span>
<span class="sd">        node or edge attributes.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; topo = Topology()</span>
<span class="sd">        &gt;&gt;&gt; topo.add_path([0,1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; copied_topo = topo.copy()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">Topology</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        </div>
<div class="viewcode-block" id="Topology.subgraph"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.Topology.subgraph.html#fnss.topologies.topology.Topology.subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbunch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the subgraph induced on nodes in nbunch.</span>

<span class="sd">        The induced subgraph of the graph contains the nodes in nbunch</span>
<span class="sd">        and the edges between those nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nbunch : list, iterable</span>
<span class="sd">            A container of nodes which will be iterated through once.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : Topology</span>
<span class="sd">            A subgraph of the graph with the same edge attributes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The graph, edge or node attributes just point to the original graph.</span>
<span class="sd">        So changes to the node or edge structure will not be reflected in</span>
<span class="sd">        the original graph while changes to the attributes will.</span>

<span class="sd">        To create a subgraph with its own copy of the edge/node attributes use:</span>
<span class="sd">        Topology(G.subgraph(nbunch))</span>

<span class="sd">        If edge attributes are containers, a deep copy can be obtained using:</span>
<span class="sd">        G.subgraph(nbunch).copy()</span>

<span class="sd">        For an inplace reduction of a graph to a subgraph you can remove nodes:</span>
<span class="sd">        G.remove_nodes_from([ n in G if n not in set(nbunch)])</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; topo = Topology()</span>
<span class="sd">        &gt;&gt;&gt; topo.add_path([0,1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; topo2 = topo.subgraph([0,1,2])</span>
<span class="sd">        &gt;&gt;&gt; topo2.edges()</span>
<span class="sd">        [(0, 1), (1, 2)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">Topology</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nbunch</span><span class="p">))</span>
        </div>
<div class="viewcode-block" id="Topology.to_directed"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.Topology.to_directed.html#fnss.topologies.topology.Topology.to_directed">[docs]</a>    <span class="k">def</span> <span class="nf">to_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a directed representation of the topology.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : DirectedTopology</span>
<span class="sd">            A directed topology with the same name, same nodes, and with</span>
<span class="sd">            each edge (u,v,data) replaced by two directed edges</span>
<span class="sd">            (u,v,data) and (v,u,data).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This returns a &#39;deepcopy&#39; of the edge, node, and</span>
<span class="sd">        graph attributes which attempts to completely copy</span>
<span class="sd">        all of the data and references.</span>

<span class="sd">        This is in contrast to the similar D=DirectedTopology(G) which returns </span>
<span class="sd">        a shallow copy of the data.</span>

<span class="sd">        See the Python copy module for more information on shallow</span>
<span class="sd">        and deep copies, http://docs.python.org/library/copy.html.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; topo = Topology()</span>
<span class="sd">        &gt;&gt;&gt; topo.add_path([0,1])</span>
<span class="sd">        &gt;&gt;&gt; topo2 = topo.to_directed()</span>
<span class="sd">        &gt;&gt;&gt; topo2.edges()</span>
<span class="sd">        [(0, 1), (1, 0)]</span>

<span class="sd">        If already directed, return a (deep) copy</span>

<span class="sd">        &gt;&gt;&gt; topo = DirectedTopology()</span>
<span class="sd">        &gt;&gt;&gt; topo.add_path([0,1])</span>
<span class="sd">        &gt;&gt;&gt; topo2 = topo.to_directed()</span>
<span class="sd">        &gt;&gt;&gt; topo2.edges()</span>
<span class="sd">        [(0, 1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DirectedTopology</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">Topology</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_directed</span><span class="p">())</span>
    </div>
<div class="viewcode-block" id="Topology.to_undirected"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.Topology.to_undirected.html#fnss.topologies.topology.Topology.to_undirected">[docs]</a>    <span class="k">def</span> <span class="nf">to_undirected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an undirected copy of the topology.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : Topology</span>
<span class="sd">            A undirected copy of the topology.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        copy, add_edge, add_edges_from</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This returns a &#39;deepcopy&#39; of the edge, node, and</span>
<span class="sd">        graph attributes which attempts to completely copy</span>
<span class="sd">        all of the data and references.</span>

<span class="sd">        This is in contrast to the similar G=Topology(D) which returns a</span>
<span class="sd">        shallow copy of the data.</span>

<span class="sd">        See the Python copy module for more information on shallow</span>
<span class="sd">        and deep copies, http://docs.python.org/library/copy.html.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; topo = Topology()   # or MultiGraph, etc</span>
<span class="sd">        &gt;&gt;&gt; topo.add_path([0,1])</span>
<span class="sd">        &gt;&gt;&gt; topo2 = topo.to_directed()</span>
<span class="sd">        &gt;&gt;&gt; topo2.edges()</span>
<span class="sd">        [(0, 1), (1, 0)]</span>
<span class="sd">        &gt;&gt;&gt; topo3 = topo2.to_undirected()</span>
<span class="sd">        &gt;&gt;&gt; topo3.edges()</span>
<span class="sd">        [(0, 1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">Topology</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">())</span>

</div></div>
<div class="viewcode-block" id="DirectedTopology"><a class="viewcode-back" href="../../../apidoc/fnss.classes.html#fnss.topologies.topology.DirectedTopology">[docs]</a><span class="k">class</span> <span class="nc">DirectedTopology</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">,</span> <span class="n">BaseTopology</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for directed topology&quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the topology</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : input graph</span>
<span class="sd">            Data to initialize the topology.  If data=None (default) an empty</span>
<span class="sd">            topology is created. The data can be an edge list, or any</span>
<span class="sd">            FNSS Topology or NetworkX graph object.  If the corresponding</span>
<span class="sd">            optional Python packages are installed the data can also be a NumPy</span>
<span class="sd">            matrix or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.</span>
<span class="sd">        name : string, optional</span>
<span class="sd">            An optional name for the graph. Default is &quot;&quot;</span>
<span class="sd">        **kwargs : keyword arguments, optional</span>
<span class="sd">            Attributes to add to graph as key=value pairs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DirectedTopology</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="DirectedTopology.copy"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.DirectedTopology.copy.html#fnss.topologies.topology.DirectedTopology.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the topology.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : DirectedTopology</span>
<span class="sd">            A copy of the topology.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_undirected: return a undirected copy of the topology.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This makes a complete copy of the topology including all of the</span>
<span class="sd">        node or edge attributes.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; topo = DirectedTopology()</span>
<span class="sd">        &gt;&gt;&gt; topo.add_path([0,1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; copied_topo = topo.copy()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DirectedTopology</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">DirectedTopology</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        </div>
<div class="viewcode-block" id="DirectedTopology.subgraph"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.DirectedTopology.subgraph.html#fnss.topologies.topology.DirectedTopology.subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbunch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the subgraph induced on nodes in nbunch.</span>

<span class="sd">        The induced subgraph of the graph contains the nodes in nbunch</span>
<span class="sd">        and the edges between those nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nbunch : list, iterable</span>
<span class="sd">            A container of nodes which will be iterated through once.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : DirectedTopology</span>
<span class="sd">            A subgraph of the graph with the same edge attributes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The graph, edge or node attributes just point to the original graph.</span>
<span class="sd">        So changes to the node or edge structure will not be reflected in</span>
<span class="sd">        the original graph while changes to the attributes will.</span>

<span class="sd">        To create a subgraph with its own copy of the edge/node attributes use:</span>
<span class="sd">        Topology(G.subgraph(nbunch))</span>

<span class="sd">        If edge attributes are containers, a deep copy can be obtained using:</span>
<span class="sd">        G.subgraph(nbunch).copy()</span>

<span class="sd">        For an inplace reduction of a graph to a subgraph you can remove nodes:</span>
<span class="sd">        G.remove_nodes_from([ n in G if n not in set(nbunch)])</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; topo = Topology()</span>
<span class="sd">        &gt;&gt;&gt; topo.add_path([0,1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; topo2 = topo.subgraph([0,1,2])</span>
<span class="sd">        &gt;&gt;&gt; topo2.edges()</span>
<span class="sd">        [(0, 1), (1, 2)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DirectedTopology</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">DirectedTopology</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nbunch</span><span class="p">))</span>
        </div>
<div class="viewcode-block" id="DirectedTopology.to_directed"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.DirectedTopology.to_directed.html#fnss.topologies.topology.DirectedTopology.to_directed">[docs]</a>    <span class="k">def</span> <span class="nf">to_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a directed representation of the topology.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : DirectedTopology</span>
<span class="sd">            A directed topology with the same name, same nodes, and with</span>
<span class="sd">            each edge (u,v,data) replaced by two directed edges</span>
<span class="sd">            (u,v,data) and (v,u,data).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This returns a &#39;deepcopy&#39; of the edge, node, and</span>
<span class="sd">        graph attributes which attempts to completely copy</span>
<span class="sd">        all of the data and references.</span>

<span class="sd">        This is in contrast to the similar D=DirectedTopology(G) which returns </span>
<span class="sd">        a shallow copy of the data.</span>

<span class="sd">        See the Python copy module for more information on shallow</span>
<span class="sd">        and deep copies, http://docs.python.org/library/copy.html.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; topo = Topology()</span>
<span class="sd">        &gt;&gt;&gt; topo.add_path([0,1])</span>
<span class="sd">        &gt;&gt;&gt; topo2 = topo.to_directed()</span>
<span class="sd">        &gt;&gt;&gt; topo2.edges()</span>
<span class="sd">        [(0, 1), (1, 0)]</span>

<span class="sd">        If already directed, return a (deep) copy</span>

<span class="sd">        &gt;&gt;&gt; topo = DirectedTopology()</span>
<span class="sd">        &gt;&gt;&gt; topo.add_path([0,1])</span>
<span class="sd">        &gt;&gt;&gt; topo2 = topo.to_directed()</span>
<span class="sd">        &gt;&gt;&gt; topo2.edges()</span>
<span class="sd">        [(0, 1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DirectedTopology</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">DirectedTopology</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_directed</span><span class="p">())</span>
    </div>
<div class="viewcode-block" id="DirectedTopology.to_undirected"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.DirectedTopology.to_undirected.html#fnss.topologies.topology.DirectedTopology.to_undirected">[docs]</a>    <span class="k">def</span> <span class="nf">to_undirected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an undirected copy of the topology.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        topology : Topology</span>
<span class="sd">            A undirected copy of the topology.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        copy, add_edge, add_edges_from</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This returns a &#39;deepcopy&#39; of the edge, node, and</span>
<span class="sd">        graph attributes which attempts to completely copy</span>
<span class="sd">        all of the data and references.</span>

<span class="sd">        This is in contrast to the similar G=Topology(D) which returns a</span>
<span class="sd">        shallow copy of the data.</span>

<span class="sd">        See the Python copy module for more information on shallow</span>
<span class="sd">        and deep copies, http://docs.python.org/library/copy.html.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; topo = Topology()   # or MultiGraph, etc</span>
<span class="sd">        &gt;&gt;&gt; topo.add_path([0,1])</span>
<span class="sd">        &gt;&gt;&gt; topo2 = topo.to_directed()</span>
<span class="sd">        &gt;&gt;&gt; topo2.edges()</span>
<span class="sd">        [(0, 1), (1, 0)]</span>
<span class="sd">        &gt;&gt;&gt; topo3 = topo2.to_undirected()</span>
<span class="sd">        &gt;&gt;&gt; topo3.edges()</span>
<span class="sd">        [(0, 1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">DirectedTopology</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">())</span>

</div></div>
<div class="viewcode-block" id="od_pairs_from_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.od_pairs_from_topology.html#fnss.topologies.topology.od_pairs_from_topology">[docs]</a><span class="k">def</span> <span class="nf">od_pairs_from_topology</span><span class="p">(</span><span class="n">topology</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate all possible origin-destination pairs of the topology. </span>
<span class="sd">    This function does not simply calculate all possible pairs of the topology</span>
<span class="sd">    nodes. Instead, it only returns pairs of nodes connected by at least</span>
<span class="sd">    a path. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    topology : Topology or DirectedTopology</span>
<span class="sd">        The topology whose OD pairs are calculated</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    od_pair : list</span>
<span class="sd">        List containing all origin destination tuples.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import fnss</span>
<span class="sd">    &gt;&gt;&gt; topology = fnss.ring_topology(3)</span>
<span class="sd">    &gt;&gt;&gt; fnss.od_pairs_from_topology(topology)</span>
<span class="sd">    [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">topology</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="n">routes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">all_pairs_shortest_path_length</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">o</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">routes</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">routes</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="k">if</span> <span class="n">o</span> <span class="o">!=</span> <span class="n">d</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">conn_comp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">o</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">conn_comp</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">if</span> <span class="n">o</span> <span class="o">!=</span> <span class="n">d</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="fan_in_out_capacities"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.fan_in_out_capacities.html#fnss.topologies.topology.fan_in_out_capacities">[docs]</a><span class="k">def</span> <span class="nf">fan_in_out_capacities</span><span class="p">(</span><span class="n">topology</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate fan-in and fan-out capacities for all nodes of the topology.</span>
<span class="sd">    </span>
<span class="sd">    The fan-in capacity of a node is the sum of capacities of all incoming</span>
<span class="sd">    links, while the fan-out capacity is the sum of capacities of all outgoing</span>
<span class="sd">    links.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    topology : Topology</span>
<span class="sd">        The topology object whose fan-in and fan-out capacities are calculated.</span>
<span class="sd">        This topology must be annotated with link capacities.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fan_in_out_capacities : tuple (fan_in, fan_out)</span>
<span class="sd">        A tuple of two dictionaries, representing, respectively the fan-in and </span>
<span class="sd">        fan-out capacities keyed by node.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function works correctly for both directed and undirected topologies.</span>
<span class="sd">    If the topology is undirected, the returned dictionaries of fan-in and</span>
<span class="sd">    fan-out capacities are identical.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import fnss</span>
<span class="sd">    &gt;&gt;&gt; topology = fnss.star_topology(3)</span>
<span class="sd">    &gt;&gt;&gt; fnss.set_capacities_constant(topology, 10, &#39;Mbps&#39;)</span>
<span class="sd">    &gt;&gt;&gt; in_cap, out_cap = fnss.fan_in_out_capacities(topology)</span>
<span class="sd">    &gt;&gt;&gt; in_cap</span>
<span class="sd">    {0: 30, 1: 10, 2: 10, 3: 10}</span>
<span class="sd">    &gt;&gt;&gt; out_cap</span>
<span class="sd">    {0: 30, 1: 10, 2: 10, 3: 10}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">topology</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
    <span class="n">fan_in</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">fan_out</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">():</span>
        <span class="n">node_fan_in</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">node_fan_out</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">predecessor</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">node_fan_in</span> <span class="o">+=</span> <span class="n">topology</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">predecessor</span><span class="p">][</span><span class="n">node</span><span class="p">][</span><span class="s">&#39;capacity&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">successor</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">node_fan_out</span> <span class="o">+=</span> <span class="n">topology</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">successor</span><span class="p">][</span><span class="s">&#39;capacity&#39;</span><span class="p">]</span>
        <span class="n">fan_in</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_fan_in</span>
        <span class="n">fan_out</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_fan_out</span>
    <span class="k">return</span> <span class="n">fan_in</span><span class="p">,</span> <span class="n">fan_out</span>

</div>
<div class="viewcode-block" id="rename_edge_attribute"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.rename_edge_attribute.html#fnss.topologies.topology.rename_edge_attribute">[docs]</a><span class="k">def</span> <span class="nf">rename_edge_attribute</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">old_attr</span><span class="p">,</span> <span class="n">new_attr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rename all edges attributes with a specific name to a new name</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    topology : Topology</span>
<span class="sd">        The topology object</span>
<span class="sd">    old_attr : any hashable type</span>
<span class="sd">        Old attribute name</span>
<span class="sd">    new_attr : any hashable type</span>
<span class="sd">        New attribute name</span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import fnss</span>
<span class="sd">    &gt;&gt;&gt; topo = fnss.Topology()</span>
<span class="sd">    &gt;&gt;&gt; topo.add_edge(1, 2, cost=1)</span>
<span class="sd">    &gt;&gt;&gt; topo.add_edge(2, 3, cost=2)</span>
<span class="sd">    &gt;&gt;&gt; topo.edges(data=True)</span>
<span class="sd">    [(1, 2, {&#39;cost&#39;: 1}), (2, 3, {&#39;cost&#39;: 2})]</span>
<span class="sd">    &gt;&gt;&gt; fnss.rename_edge_attribute(topo, &#39;cost&#39;, &#39;weight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; topo.edges(data=True)</span>
<span class="sd">    [(1, 2, {&#39;weight&#39;: 1}), (2, 3, {&#39;weight&#39;: 2})]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">old_attr</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">topology</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">new_attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">old_attr</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">topology</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">old_attr</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="rename_node_attribute"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.rename_node_attribute.html#fnss.topologies.topology.rename_node_attribute">[docs]</a><span class="k">def</span> <span class="nf">rename_node_attribute</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">old_attr</span><span class="p">,</span> <span class="n">new_attr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rename all nodes attributes with a specific name to a new name</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    topology : Topology</span>
<span class="sd">        The topology object</span>
<span class="sd">    old_attr : any hashable type</span>
<span class="sd">        Old attribute name</span>
<span class="sd">    new_attr : any hashable type</span>
<span class="sd">        New attribute name</span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import fnss</span>
<span class="sd">    &gt;&gt;&gt; topo = fnss.Topology()</span>
<span class="sd">    &gt;&gt;&gt; topo.add_node(1, pos=(0, 0))</span>
<span class="sd">    &gt;&gt;&gt; topo.add_node(2, pos=(1, 1))</span>
<span class="sd">    &gt;&gt;&gt; topo.nodes(data=True)</span>
<span class="sd">    [(1, {&#39;pos&#39;: (0, 0)}), (2, {&#39;pos&#39;: (1, 1)})]</span>
<span class="sd">    &gt;&gt;&gt; fnss.rename_edge_attribute(topo, &#39;pos&#39;, &#39;coordinates&#39;)</span>
<span class="sd">    &gt;&gt;&gt; topo.edges(data=True)</span>
<span class="sd">    [(1, {&#39;coordinates&#39;: (0, 0)}), (2, {&#39;coordinates&#39;: (1, 1)})]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">old_attr</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">topology</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">new_attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">old_attr</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">topology</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">old_attr</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="read_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.read_topology.html#fnss.topologies.topology.read_topology">[docs]</a><span class="k">def</span> <span class="nf">read_topology</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;utf-8&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read a topology from an XML file and returns either a Topology or a </span>
<span class="sd">    DirectedTopology object</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str</span>
<span class="sd">        The path of the topology XML file to parse</span>
<span class="sd">    encoding : str, optional</span>
<span class="sd">        The encoding of the file</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    topology: Topology or DirectedTopology</span>
<span class="sd">        The parsed topology</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
    <span class="n">topology</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">()</span> <span class="k">if</span> <span class="n">head</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;linkdefault&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;undirected&#39;</span> \
                   <span class="k">else</span> <span class="n">DirectedTopology</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">head</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;property&#39;</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_cast_type</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">],</span> <span class="n">prop</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
        <span class="n">topology</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">head</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;node&#39;</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_cast_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;id.type&#39;</span><span class="p">],</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">])</span>
        <span class="n">topology</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;property&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_cast_type</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">],</span> <span class="n">prop</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
            <span class="n">topology</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;stack&#39;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;stack&#39;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ET</span><span class="o">.</span><span class="n">ParseError</span><span class="p">(</span><span class="s">&#39;Invalid topology. &#39;</span> \
                                    <span class="s">&#39;A node has more than one stack.&#39;</span><span class="p">)</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;stack&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">stack_name</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_cast_type</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name.type&#39;</span><span class="p">],</span> 
                                        <span class="n">stack</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">])</span>
            <span class="n">stack_props</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">stack</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;property&#39;</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_cast_type</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">],</span> <span class="n">prop</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                <span class="n">stack_props</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">topology</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;stack&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">stack_name</span><span class="p">,</span> <span class="n">stack_props</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;application&#39;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">topology</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;application&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">application</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;application&#39;</span><span class="p">):</span>
                <span class="n">app_name</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_cast_type</span><span class="p">(</span><span class="n">application</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name.type&#39;</span><span class="p">],</span> 
                                          <span class="n">application</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">])</span>
                <span class="n">app_props</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">application</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;property&#39;</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_cast_type</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">],</span> <span class="n">prop</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                    <span class="n">app_props</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">topology</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;application&#39;</span><span class="p">][</span><span class="n">app_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">app_props</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">head</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;link&#39;</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_cast_type</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;from&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">],</span> 
                           <span class="n">edge</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;from&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_cast_type</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;to&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">],</span> 
                           <span class="n">edge</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;to&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
        <span class="n">topology</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;property&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_cast_type</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">],</span> <span class="n">prop</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
            <span class="n">topology</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">topology</span>

</div>
<div class="viewcode-block" id="write_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.topology.write_topology.html#fnss.topologies.topology.write_topology">[docs]</a><span class="k">def</span> <span class="nf">write_topology</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;utf-8&#39;</span><span class="p">,</span> <span class="n">prettyprint</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write a topology object on an XML file</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    topology : Topology</span>
<span class="sd">        The topology object to write</span>
<span class="sd">    path : str</span>
<span class="sd">        The file ob which the topology will be written</span>
<span class="sd">    encoding : str, optional</span>
<span class="sd">        The encoding of the target file</span>
<span class="sd">    prettyprint : bool, optional</span>
<span class="sd">        Indent the XML code in the output file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s">&#39;topology&#39;</span><span class="p">)</span>
    <span class="n">head</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;linkdefault&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;directed&#39;</span> <span class="k">if</span> <span class="n">topology</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> \
                                            <span class="k">else</span> <span class="s">&#39;undirected&#39;</span> 
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="s">&#39;property&#39;</span><span class="p">)</span>
        <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">prop</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">():</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="s">&#39;node&#39;</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;id.type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="s">&#39;stack&#39;</span><span class="p">:</span>
                <span class="n">stack_name</span><span class="p">,</span> <span class="n">stack_props</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;stack&#39;</span><span class="p">]</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&#39;stack&#39;</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack_name</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name.type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_type</span><span class="p">(</span><span class="n">stack_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">prop_name</span><span class="p">,</span> <span class="n">prop_value</span> <span class="ow">in</span> <span class="n">stack_props</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">prop</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="s">&#39;property&#39;</span><span class="p">)</span>
                    <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prop_name</span>
                    <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_type</span><span class="p">(</span><span class="n">prop_value</span><span class="p">)</span>
                    <span class="n">prop</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">prop_value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">is</span> <span class="s">&#39;application&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">application_name</span><span class="p">,</span> <span class="n">application_props</span> <span class="ow">in</span> \
                            <span class="n">topology</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;application&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">application</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&#39;application&#39;</span><span class="p">)</span>
                    <span class="n">application</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">application_name</span>
                    <span class="n">application</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name.type&#39;</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">util</span><span class="o">.</span><span class="n">xml_type</span><span class="p">(</span><span class="n">application_name</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">prop_name</span><span class="p">,</span> <span class="n">prop_value</span> <span class="ow">in</span> <span class="n">application_props</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">prop</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">application</span><span class="p">,</span> <span class="s">&#39;property&#39;</span><span class="p">)</span>
                        <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prop_name</span>
                        <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_type</span><span class="p">(</span><span class="n">prop_value</span><span class="p">)</span>
                        <span class="n">prop</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">prop_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prop</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&#39;property&#39;</span><span class="p">)</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">():</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="s">&#39;link&#39;</span><span class="p">)</span>
        <span class="n">from_node</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&#39;from&#39;</span><span class="p">)</span>
        <span class="n">from_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_type</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">from_node</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">to_node</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&#39;to&#39;</span><span class="p">)</span>
        <span class="n">to_node</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">to_node</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">prop</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&#39;property&#39;</span><span class="p">)</span>
            <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">xml_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">prop</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prettyprint</span><span class="p">:</span>
        <span class="n">util</span><span class="o">.</span><span class="n">xml_indent</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
    <span class="n">ET</span><span class="o">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="n">head</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">FNSS 0.6.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2014, Lorenzo Saino, Cosmin Cocora.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>