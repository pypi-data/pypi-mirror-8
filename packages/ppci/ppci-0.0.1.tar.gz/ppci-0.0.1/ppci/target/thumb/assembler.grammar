from ..basetarget import Register, Instruction, Target, Label, Alignment
from .instructions import Add2, Sub, Sub3, Add3, Cmp, Lsl, Lsr, Orr, Add, Cmp2, Sub2, Mul, And
from .instructions import Dcd, Pop, Push, Yield, Mov2, Mov3
from .instructions import B, Bl, Bne, Beq, Blt, Bgt, Ble, Bge
from .instructions import Ldr, Str2, Ldr2, Str1, Ldr1, Ldr3, Adr

from .frame import ArmFrame
from .arminstructionselector import ArmInstructionSelector
from ..arm.registers import R0, R1, R2, R3, R4, R5, R6, R7, SP, LR, PC
from ..arm.registers import register_range
from ...assembler import BaseAssembler


%tokens section align
%tokens r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 sp lr pc
%tokens dcd yield
%tokens nop mov cmp add sub mul
%tokens lsl lsr orr and
%tokens push pop b bl blt ble bgt beq bne bge
%tokens ldr str adr
%tokens ',' ID '{' '}' '-' '[' ']' '=' ':'
%tokens val32 val16 val12 val8 val5 val3 COMMENT


%%

asmline: asmline2
       | asmline2 COMMENT;

asmline2: label instr
        | label
        | instr
        | ;

label: ID ':' { self.assembler.emit(Label(arg1.val)) };

instr: pseudoinstruction
     | instruction { self.assembler.emit(arg1) };

pseudoinstruction: nop;
pseudoinstruction: section ID { self.assembler.select_section(arg2.val) };


imm32: val32 { return arg1.val }
     | imm16 { return arg1 };
imm16: val16 { return arg1.val }
     | imm12 { return arg1 };
imm12: val12 { return arg1.val }
     | imm8 { return arg1 };
imm8: val8 { return arg1.val }
    | imm5 { return arg1 };
imm5: val5 { return arg1.val }
    | imm3 { return arg1 };
imm3: val3 { return arg1.val };


reg8: r0 { return R0 }
   | r1 { return R1 }
   | r2 { return R2 }
   | r3 { return R3 }
   | r4 { return R4 }
   | r5 { return R5 }
   | r6 { return R6 }
   | r7 { return R7 };



instruction: dcd imm32 { return Dcd(arg2) };

instruction: mov reg8 ',' reg8 { return Mov2(arg2, arg4) };
instruction: mov reg8 ',' imm8 { return Mov3(arg2, arg4) };

instruction: cmp reg8 ',' reg8 { return Cmp(arg2, arg4) };
instruction: cmp reg8 ',' imm8 { return Cmp2(arg2, arg4) };

instruction: add reg8 ',' reg8 ',' reg8 { return Add3(arg2, arg4, arg6) };
instruction: add reg8 ',' reg8 ',' imm3 { return Add2(arg2, arg4, arg6) };

instruction: add sp ',' sp ',' imm8 { return Add(SP, SP, arg6) };
instruction: sub sp ',' sp ',' imm8 { return Sub(SP, SP, arg6) };

instruction: sub reg8 ',' reg8 ',' imm3 { return Sub(arg2, arg4, arg6) };

instruction: lsl reg8 ',' reg8 { return Lsl(arg2, arg4) };
instruction: lsr reg8 ',' reg8 { return Lsr(arg2, arg4) };

instruction: and reg8 ',' reg8 { return And(arg2, arg4) };
instruction: orr reg8 ',' reg8 { return Orr(arg2, arg4) };

instruction: b ID { return B(arg2.val) };
instruction: bl ID { return Bl(arg2.val) };
instruction: beq ID { return Beq(arg2.val) };
instruction: bne ID { return Bne(arg2.val) };
instruction: blt ID { return Blt(arg2.val) };
instruction: ble ID { return Ble(arg2.val) };
instruction: bgt ID { return Bgt(arg2.val) };
instruction: bge ID { return Bge(arg2.val) };


instruction: push reg_list { return Push(arg2) };
instruction: pop reg_list { return Pop(arg2) };


reg_list: '{' reg_list_inner '}' { return arg2 };
reg_list_inner: reg_or_range { return arg1 }
              | reg_or_range ',' reg_list_inner { return arg1 | arg3 };

reg_or_range: reg8 { return set([arg1]) }
            | lr { return set([LR]) }
            | pc { return set([PC]) }
            | reg8 '-' reg8 { return register_range(arg1, arg3) };

instruction: str reg8 ',' '[' 'reg8' ',' 'imm5' ']' { return Str2(arg2, arg5, arg7) };

instruction: ldr reg8 ',' '[' 'reg8' ',' 'imm5' ']' { return Ldr2(arg2, arg5, arg7) };

instruction: ldr reg8 ',' 'ID' { return Ldr(arg2, arg4.val) };

instruction: str reg8 ',' '[' 'sp' ',' 'imm8' ']' { return Str1(arg2, arg7) };
instruction: ldr reg8 ',' '[' 'sp' ',' 'imm8' ']' { return Ldr1(arg2, arg7) };

instruction: align imm8 { return Alignment(arg2) };

instruction: adr reg8 ',' 'ID' { return Adr(arg2, arg4.val) };

instruction: yield { return Yield() };


