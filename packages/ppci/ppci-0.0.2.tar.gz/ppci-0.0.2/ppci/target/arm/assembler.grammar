from ..arm.registers import R0, R1, R2, R3, R4, R5, R6, R7
from ..arm.registers import R8, R9, R10, R11, R12, SP, LR, PC
from ..arm.registers import register_range

from .instructions import Dcd, Mov, Mov1, Add, Add2, Sub, Mul, Mov2
from .instructions import Add1, Mul1
from .instructions import Lsr, Lsl, And, Orr
from .instructions import B, Bl, Ble, Bgt, Beq, Blt, Cmp, Cmp2
from .instructions import Push, Pop, Str, Ldr, Ldr3, Str1, Ldr1, Adr
from .instructions import Mcr, Mrc
from .instructions import LdrPseudo
from ..basetarget import Label

%tokens repeat endrepeat section
%tokens r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 sp lr pc
%tokens dcd
%tokens nop mov cmp add sub mul
%tokens lsl lsr orr and
%tokens push pop b bl blt ble bgt beq
%tokens ldr str adr
%tokens ',' ID '{' '}' '-' '[' ']' '=' ':'
%tokens val32 val16 val12 val8 val5 val3 COMMENT


%tokens c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15

%tokens p8 p9 p10 p11 p12 p13 p14 p15
%tokens mcr mrc

%%

asmline: asmline2
       | asmline2 COMMENT;

asmline2: label instr
        | label
        | instr
        | ;

label: ID ':' { self.assembler.emit(Label(arg1.val)) };

instr: pseudoinstruction
     | instruction { self.assembler.emit(arg1) };

pseudoinstruction: nop;
pseudoinstruction: repeat imm32 { self.assembler.begin_repeat(arg2) };
pseudoinstruction: endrepeat { self.assembler.end_repeat() };
pseudoinstruction: section ID { self.assembler.select_section(arg2.val) };


imm32: val32 { return arg1.val }
     | imm16 { return arg1 };
imm16: val16 { return arg1.val }
     | imm12 { return arg1 };
imm12: val12 { return arg1.val }
     | imm8 { return arg1 };
imm8: val8 { return arg1.val }
    | imm5 { return arg1 };
imm5: val5 { return arg1.val }
    | imm3 { return arg1 };
imm3: val3 { return arg1.val };


reg: r0 { return R0 }
   | r1 { return R1 }
   | r2 { return R2 }
   | r3 { return R3 }
   | r4 { return R4 }
   | r5 { return R5 }
   | r6 { return R6 }
   | r7 { return R7 }
   | r8 { return R8 }
   | r9 { return R9 }
   | r10 { return R10 }
   | r11 { return R11 }
   | r12 { return R12 }
   | sp { return SP }
   | lr { return LR }
   | pc { return PC };



coreg: c0 { return 0 }
 | c1 { return 1 }
 | c2 { return 2 }
 | c3 { return 3 }
 | c4 { return 4 }
 | c5 { return 5 }
 | c6 { return 6 }
 | c7 { return 7 }
 | c8 { return 8 }
 | c9 { return 9 }
 | c10 { return 10 }
 | c11 { return 11 }
 | c12 { return 12 }
 | c13 { return 13 }
 | c14 { return 14 }
 | c15 { return 15 };

coproc: p8 { return 8 }
 | p9 { return 9 }
 | p10 { return 10 }
 | p11 { return 11 }
 | p12 { return 12 }
 | p13 { return 13 }
 | p14 { return 14 }
 | p15 { return 15 };


instruction: dcd imm32 { return Dcd(arg2) };

instruction: mov reg ',' reg { return Mov(arg2, arg4) };
instruction: mov reg ',' imm32 { return Mov(arg2, arg4) };

instruction: cmp reg ',' reg { return Cmp(arg2, arg4) };
instruction: cmp reg ',' imm32 { return Cmp(arg2, arg4) };

instruction: add reg ',' reg ',' reg { return Add(arg2, arg4, arg6) };
instruction: add reg ',' reg ',' imm32 { return Add(arg2, arg4, arg6) };
instruction: sub reg ',' reg ',' reg { return Sub(arg2, arg4, arg6) };
instruction: sub reg ',' reg ',' imm32 { return Sub(arg2, arg4, arg6) };

instruction: mul reg ',' reg ',' reg { return Mul(arg2, arg4, arg6) };

instruction: lsl reg ',' reg ',' reg { return Lsl(arg2, arg4, arg6) };
instruction: lsr reg ',' reg ',' reg { return Lsr(arg2, arg4, arg6) };
instruction: and reg ',' reg ',' reg { return And(arg2, arg4, arg6) };
instruction: orr reg ',' reg ',' reg { return Orr(arg2, arg4, arg6) };

instruction: b ID { return B(arg2.val) };
instruction: bl ID { return Bl(arg2.val) };
instruction: beq ID { return Beq(arg2.val) };
instruction: blt ID { return Blt(arg2.val) };
instruction: bgt ID { return Bgt(arg2.val) };
instruction: ble ID { return Ble(arg2.val) };

instruction: push reg_list { return Push(arg2) };
instruction: pop reg_list { return Pop(arg2) };


reg_list: '{' reg_list_inner '}' { return arg2 };
reg_list_inner: reg_or_range { return arg1 }
              | reg_or_range ',' reg_list_inner { return arg1 | arg3 };

reg_or_range: reg { return set([arg1]) }
            | reg '-' reg { return register_range(arg1, arg3) };


instruction: ldr reg ',' '[' 'reg' ',' 'imm8' ']' { return Ldr(arg2, arg5, arg7) };
instruction: ldr reg ',' 'ID' { return Ldr(arg2, arg4.val) };
instruction: ldr reg ',' '=' 'ID' { return LdrPseudo(arg2, arg5.val, self.assembler.add_literal) };


instruction: str reg ',' '[' 'reg' ',' 'imm8' ']' { return Str(arg2, arg5, arg7) };
instruction: str reg ',' '[' 'reg' ',' 'reg' ']' { return Str(arg2, arg5, arg7) };

instruction: adr reg ',' 'ID' { return Adr(arg2, arg4.val) };


instruction: mcr coproc ',' imm3 ',' reg ',' coreg ',' coreg ',' imm3 { return Mcr(arg2, arg4, arg6, arg8, arg10, arg12) };
instruction: mrc coproc ',' imm3 ',' reg ',' coreg ',' coreg ',' imm3 { return Mrc(arg2, arg4, arg6, arg8, arg10, arg12) };

