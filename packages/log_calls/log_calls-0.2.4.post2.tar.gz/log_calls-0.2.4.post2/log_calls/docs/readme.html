<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
/* Customized "Clearness.css" (.TOC)
   This file goes in ~/Library/Application Support/Mou/CSS/
 */

h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: black;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
    color: black;
    font-size: 13px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}

div.TOC {
    background-color: rgba(232, 232, 232, 0.81);    /*#fee9cc;*/
}
div.TOC h5 {
    margin-top: 0px;
    margin-bottom: 0px;
}
div.TOC > ul, div.TOC > ul + li {
    margin-top: 0px;
}

blockquote {
    padding: 13px 13px 21px 15px;
    /* margin-bottom: 18px; */
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: rgba(232, 232, 232, 0.81);    // #fee9cc;
    color: rgba(0, 0, 0, 0.95);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    background-color: #e8e8e8;

    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #e8e8e8;  // #fff;
    color:#101010;              // #737373
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}

</style>
<title>*log_calls* — A decorator for debugging and profiling</title>

</head>
<body>
<h1><em>log_calls</em> — A decorator for debugging and profiling</h1>

<hr />

<p><small><em>(This document is a work in progress: an overly fat README that I still promise or threaten to reduce alot and make more of a "quick intro". Complete documentation is <a href="http://www.pythonhosted.org/log_calls">here</a>. Thanks for your continued patience/check this space! — BTO)</em></small></p>

<p><code>log_calls</code> is a Python 3 decorator that can print much useful information
about calls to a decorated function. It can write to <code>stdout</code>, to another
stream or file, or to a logger. It can save you from writing, rewriting, copying, pasting and tweaking a lot of ad hoc, boilerplate code - and it can keep your codebase free of that clutter.</p>

<p>For each call of a decorated function, <code>log_calls</code> can show you:</p>

<ul>
<li>the caller,</li>
<li>the arguments passed to the function, and any default values used,</li>
<li>the time the function took to execute,</li>
<li>the complete call chain back to another <code>log_calls</code>-decorated caller,</li>
<li>the number of the call,</li>
<li>indentation by call level,</li>
<li>the function's return value,</li>
<li>and more!</li>
</ul>


<p>These and other features are optional and configurable settings, which can be specified for each decorated function via keyword parameters. You can also examine and change these settings on the fly using attributes with the same names as the keywords, or using a dict-like interface whose keys are the keywords.</p>

<p><code>log_calls</code> can also collect profiling data and statistics, accessible at runtime:</p>

<ul>
<li>the number of calls to a function,</li>
<li>total time taken by the function,</li>
<li>the function's entire call history (arguments, time elapsed, return values,
callers, and more), available as text in CSV format and, if <a href="http://pandas.pydata.org">Pandas</a> is installed, as a <a href="http://pandas.pydata.org/pandas-docs/stable/dsintro.html#dataframe">DataFrame</a>.</li>
</ul>


<p>The package contains two other decorators:</p>

<ul>
<li><code>record_history</code>, a stripped-down version of <code>log_calls</code>,
only collects call history and statistics, and outputs no messages;</li>
<li><code>used_unused_keywords</code> lets a function easily determine, per-call,
which of its keyword parameters were actually supplied by the caller,
and which received their default values.</li>
</ul>


<p>This document gives an overview of the decorator's features and their use. A thorough account, including many useful examples, can be found in the complete documentation for <a href="http://www.pythonhosted.org/log_calls"><code>log_calls</code></a> and <a href="http://www.pythonhosted.org/log_calls/record_history.html"><code>record_history</code></a>.</p>

<h2><span id="Version">Version</span></h2>

<p>This document describes version <code>0.2.4.post1</code> of <code>log_calls</code>.</p>

<h2><span id="What's-new">What's New</span></h2>

<ul>
<li><p><strong>0.2.4.post2</strong></p>

<ul>
<li>The <code>settings</code> parameter (formerly <code>settings_path</code>) lets you specify default values for multiple settings either as a dictionary, or as a file. The <code>settings_path</code> parameter is deprecated, as <code>settings</code> is a superset. See the documentation <a href="http://www.pythonhosted.org/log_calls#settings-parameter">here</a> for details, discussion and examples.</li>
</ul>
</li>
<li><p><strong>0.2.4.post1</strong></p>

<ul>
<li><em><code>settings_path</code> feature: allow <code>file=sys.stderr</code> in settings files, under IPython too; neater internals of settings file parsing</em></li>
</ul>
</li>
<li><p><strong>0.2.4</strong></p>

<ul>
<li>The new <code>settings_path</code> parameter lets you specify a file containing default values for multiple settings. See the documentation <a href="http://www.pythonhosted.org/log_calls#settings-parameter">here</a> for details, discussion and examples.</li>
<li>You can now use a logger name (something you'd pass to <code>logging.getLogger()</code>) as the value of the <code>logger</code> setting.</li>
<li>The <code>indent</code> setting now works with loggers too. See examples:

<ul>
<li>using <code>log_message</code> as a general output function that works as expected, whatever the destination – <code>stdout</code>, another stream, a file, or a logger [in <code>tests/test_log_calls_more.py</code>, docstring of <code>main__log_message__all_possible_output_destinations()</code>];</li>
<li>setting up a logger with a minimal formatter that looks just like the output of <code>print</code> [in <code>tests/test_log_calls_more.py</code>, docstring of  <code>main__logging_with_indent__minimal_formatters()</code>].</li>
</ul>
</li>
<li>Added the decorator <code>used_unused_keywords</code> to support the <code>settings_path</code> feature, and made it visible (you can import it from the package) because it's more broadly useful. This decorator lets a function obtain, on a per-call basis, two dictionaries of its explicit keyword arguments and their values: those which were actually passed by the caller, and those which were not and received default values. For examples, see the docstring of <code>main()</code> in <code>used_unused_kwds.py</code>.</li>
<li>When displaying returned values (<code>log_retval</code> setting is true), the maximum displayed length of values is now 77, up from 60, not counting trailing ellipsis.</li>
<li>The deprecated <code>indent_extra</code> parameter to <code>log_message</code> is gone.</li>
<li>Little bug fixes, improvements.</li>
</ul>
</li>
<li><p><strong>0.2.3</strong> and <strong>0.2.3.post</strong> <em>N</em></p>

<ul>
<li>A better signature for <a href="#log_message">the indent-aware writing method <code>log_message()</code></a>, and more, better examples of it — full docs <a href="http://www.pythonhosted.org/log_calls#log_message">here</a>.</li>
</ul>
</li>
<li><p><strong>0.2.2</strong></p>

<ul>
<li><a href="#log_message">The indent-aware writing method <code>log_message()</code></a>, which decorated functions and methods can use to write extra debugging messages that align nicely with <code>log_calls</code> messages.</li>
<li><a href="http://www.pythonhosted.org/log_calls#log_message">Documentation</a> for <code>log_message()</code>.</li>
<li><a href="http://www.pythonhosted.org/log_calls#accessing-own-attrs">Documentation</a> for how functions and methods can access the attributes that <code>log_calls</code> adds for them, within their own bodies.</li>
</ul>
</li>
<li><strong>0.2.1</strong>

<ul>
<li>The <a href="http://www.pythonhosted.org/log_calls/record_history.html#stats.history_as_DataFrame"><code>stats.history_as_DataFrame</code> attribute</a>, whose value is the call history of a decorated function as a <a href="http://pandas.pydata.org">Pandas</a> <a href="http://pandas.pydata.org/pandas-docs/stable/dsintro.html#dataframe">DataFrame</a> (if Pandas is installed; else <code>None</code>).</li>
<li>An IPython notebook (<code>log_calls/docs/history_to_pandas.ipynb</code>, browsable as HTML <a href="http://www.pythonhosted.org/log_calls/history_to_pandas.html">here</a>) which compares the performance of using <code>record_history</code> <em>vs</em> a vectorized approach using <a href="http://www.numpy.org/">numpy</a> to amass medium to large datasets, and which concludes that if you can vectorize, by all means do so.</li>
</ul>
</li>
<li><strong>0.2.0</strong>

<ul>
<li>Initial public release.</li>
</ul>
</li>
</ul>


<h2><span id="Preliminaries">Preliminaries</span></h2>

<h3><span id="Dependencies-requirements">Dependencies and requirements</span></h3>

<p>The <em>log_calls</em> package has no dependencies - it requires no other packages. All it requires is a standard distribution of Python 3.2+.</p>

<p>NOTE: This package does require the CPython implementation, as it uses internals
of stack frames which may well differ in other interpreters.</p>

<h3><span id="Installation">Installation</span></h3>

<p>You have two simple options:</p>

<ol>
<li><p>Download the compressed repository, uncompress it into a directory, and run:</p>

<p> <code>$ python setup.py install</code></p>

<p> in that directory, or</p></li>
<li><p>run</p>

<p> <code>$ pip install log_calls</code></p></li>
</ol>


<p>  to install log_calls from PyPI (the Python Package Index). Here and elsewhere, <code>$</code> at the <em>beginning</em> of a line indicates your command prompt, whatever it may be.</p>

<p>Whichever you choose, ideally you'll do it in a virtual environment (a <em>virtualenv</em>).
In Python 3.3+, virtual environments are easier than ever to set up because those
distributions include everything you need to do so. For an excellent overview of
these new capabilities, see <a href="http://www.drdobbs.com/architecture-and-design/lightweight-virtual-environments-in-pyth/240167069">Lightweight Virtual Environments in Python 3.4</a>.</p>

<h3><span id="Testing">Running the tests</span></h3>

<p>Each <code>*.py</code> file in the log_calls directory has a corresponding test file <code>test_*.py</code> in the <code>log_calls/tests/</code> directory; <code>log_calls.py</code> itself has two more. The tests provide essentially 100% coverage (98% for <code>log_calls.py</code>, 100% for the others). All tests have passed on every tested platform + Python version; however, that's a sparse matrix :) If you encounter any turbulence, do let us know.</p>

<p>You can run the test suites either before or after installing <code>log_calls</code>.</p>

<h4><span id="tests-before-install">Running the tests before installation</span></h4>

<p>To do this, download the compressed repository, as in 1. above.
After you uncompress the archive into a directory, and before you run <code>python setup.py install</code>, first run one of the following commands:</p>

<pre><code>$ python setup.py test [-q]
</code></pre>

<p>(<code>-q</code> for "quiet", recommended) or</p>

<pre><code>$ python run_tests.py [-q | -v | -h]
</code></pre>

<p>which takes switches <code>-q</code> for "quiet", <code>-v</code> for "verbose", and <code>-h</code> for "help".</p>

<h4><span id="tests-after-install">Running the tests after installation</span></h4>

<p>You can run the tests for <code>log_calls</code> after installing it, using the command:</p>

<pre><code>$ python -m unittest discover log_calls.tests
</code></pre>

<h4><span id="tests-ok">What to expect</span></h4>

<p>All the above commands run all tests in the <code>log_calls/tests/</code> directory. If you run any of them, the output you see should end like so:</p>

<pre><code>----------------------------------------------------------------------
Ran 58 tests in 0.832s

OK
</code></pre>

<p>indicating that all went well. If any tests failed, it will tell you.</p>

<h2><span id="Basic-usage">Basic usage</span></h2>

<p><code>log_calls</code> has many features, and thus many, mostly independent, keyword parameters (15 in all). This section introduces all but five of them, one at a time, though of course you can use multiple parameters in any call to the decorator:</p>

<ul>
<li><a href="#enabled-parameter"><code>enabled</code></a></li>
<li><a href="#args_sep-parameter"><code>args_sep</code></a></li>
<li><a href="#log_args-parameter"><code>log_args</code></a></li>
<li><a href="#log_retval-parameter"><code>log_retval</code></a></li>
<li><a href="#log_exit-parameter"><code>log_exit</code></a></li>
<li><a href="#log_call_numbers-parameter"><code>log_call_numbers</code></a></li>
<li><a href="#log_elapsed-parameter"><code>log_elapsed</code></a></li>
<li><a href="#indent-parameter"><code>indent</code></a></li>
<li><a href="#prefix-parameter"><code>prefix</code></a></li>
<li><a href="#file-parameter"><code>file</code></a></li>
</ul>


<p>The two parameters that let you output <code>log_calls</code> messages to a <code>Logger</code> (<a href="#logger-parameter"><code>logger</code></a> and <a href="#loglevel-parameter"><code>loglevel</code></a>) are discussed in <a href="#Logging">Using loggers</a>. The two that determine whether call history is retained (<a href="#record_history-parameter">record_history</a>), and then how much of it (<a href="#max_history-parameter">max_history</a>), are discussed in <a href="#call-history-and-statistics">Call history and statistics</a>. The one parameter that is not a "setting", <code>settings_path</code>, lets you specify a file containing default settings; it's discussed in the section <a href="http://www.pythonhosted.org/log_calls/index.html#settings_path-parameter">The <em>settings_path</em> parameter</a> of the main documentation.</p>

<p>Every example in this document uses <code>log_calls</code>, so without further ado:</p>

<pre><code>&gt;&gt;&gt; from log_calls import log_calls
</code></pre>

<h3><span id="No-parameters">Using no parameters</span></h3>

<p>First, let's see the simplest possible examples, using no parameters at all:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f(a, b, c):
...     pass
&gt;&gt;&gt; f(1, 2, 3)
f &lt;== called by &lt;module&gt;
    arguments: a=1, b=2, c=3
f ==&gt; returning to &lt;module&gt;
</code></pre>

<p>Adding another decorated function to the call chain gives useful information too:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def g(a):
...     f(a, 2*a, 3*a)
&gt;&gt;&gt; g(3)
g &lt;== called by &lt;module&gt;
    arguments: a=3
f &lt;== called by g
    arguments: a=3, b=6, c=9
f ==&gt; returning to g
g ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="enabled-parameter">The <em>enabled</em> parameter (default – <em>True</em>)</span></h3>

<p>The next most basic example:</p>

<pre><code>&gt;&gt;&gt; @log_calls(enabled=False)
... def f(a, b, c):
...     pass
&gt;&gt;&gt; f(1, 2, 3)                # no output
</code></pre>

<h3><span id="args_sep-parameter">The <em>args_sep</em> parameter (default – <code>', '</code>)</span></h3>

<p>The <code>args_sep</code> parameter specifies the character or string used to separate
arguments. If the string ends in  (or is) <code>\n</code>, additional whitespace
is appended so that arguments line up nicely:</p>

<pre><code>&gt;&gt;&gt; @log_calls(args_sep='\\n')
... def f(a, b, c, **kwargs):
...     print(a + b + c)
&gt;&gt;&gt; f(1, 2, 3, u='you')       # doctest: +NORMALIZE_WHITESPACE, +SKIP
f &lt;== called by &lt;module&gt;
    arguments:
        a=1
        b=2
        c=3
        [**]kwargs={'u': 'you'}
6
f ==&gt; returning to &lt;module&gt;
</code></pre>

<p><strong>NOTE</strong>: <em>In all the doctest examples in this document, you'll see</em> <code>'\\n'</code>
<em>where in actual code you'd write</em> <code>'\n'</code>. <em>This is a <code>doctest</code> quirk: all
the examples herein work (as tests, they pass), and they would fail if</em>
<code>'\n'</code> <em>were used. The only alternative would be to use raw character strings
and write</em> <code>r'\n'</code>, <em>which is not obviously better.</em></p>

<h3><span id="log_args-parameter">The <em>log_args</em> parameter (default – <em>True</em>)</span></h3>

<p>When true, as seen above, arguments passed to the decorated function are
logged. If the function's signature contains positional and/or keyword
"varargs" (<code>*args</code> and/or <code>**kwargs</code>), these are included if they're nonempty.
Any default values of keyword parameters with no corresponding argument are also
logged, on a separate line.</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f_a(a, *args, something='that thing', **kwargs): pass
&gt;&gt;&gt; f_a(1, 2, 3, foo='bar')
f_a &lt;== called by &lt;module&gt;
    arguments: a=1, [*]args=(2, 3), [**]kwargs={'foo': 'bar'}
    defaults:  something='that thing'
f_a ==&gt; returning to &lt;module&gt;
</code></pre>

<p>Here, no argument information is logged at all:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_args=False)
... def f_b(a, *args, something='that thing', **kwargs): pass
&gt;&gt;&gt; f_b(1, 2, 3, foo='bar')
f_b &lt;== called by &lt;module&gt;
f_b ==&gt; returning to &lt;module&gt;
</code></pre>

<p>If a function has no parameters, <code>log_calls</code> won't display any "arguments"
section:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f(): pass
&gt;&gt;&gt; f()
f &lt;== called by &lt;module&gt;
f ==&gt; returning to &lt;module&gt;
</code></pre>

<p>If a function has parameters but is passed no arguments, <code>log_calls</code>
will display <code>arguments: &lt;none&gt;</code>, plus any default values used:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def ff(*args, **kwargs): pass
&gt;&gt;&gt; ff()
ff &lt;== called by &lt;module&gt;
    arguments: &lt;none&gt;
ff ==&gt; returning to &lt;module&gt;

&gt;&gt;&gt; @log_calls()
... def fff(*args, kw='doh', **kwargs): pass
&gt;&gt;&gt; fff()
fff &lt;== called by &lt;module&gt;
    arguments: &lt;none&gt;
    defaults:  kw='doh'
fff ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="log_retval-parameter">The <em>log_retval</em> parameter (default – <em>False</em>)</span></h3>

<p>When true, this parameter displays the value returned by the function:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_retval=True)
... def f(a, b, c):
...     return a + b + c
&gt;&gt;&gt; _ = f(1, 2, 3)
f &lt;== called by &lt;module&gt;
    arguments: a=1, b=2, c=3
    f return value: 6
f ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="log_exit-parameter">The <em>log_exit</em> parameter (default – <em>True</em>)</span></h3>

<p>When false, this parameter suppresses the <code>... ==&gt; returning to ...</code> line
that indicates the function's return to its caller.</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_exit=False)
... def f(a, b, c):
...     return a + b + c
&gt;&gt;&gt; _ = f(1, 2, 3)
f &lt;== called by &lt;module&gt;
    arguments: a=1, b=2, c=3
</code></pre>

<h3><span id="log_call_numbers-parameter">The <em>log_call_numbers</em> parameter (default – <em>False</em>)</span></h3>

<p><code>log_calls</code> keeps a running tally of the number of times a decorated function
is called. You can display this (1-based) number using the <code>log_call_numbers</code> parameter:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_call_numbers=True)
... def f(): pass
&gt;&gt;&gt; for i in range(2): f()
f [1] &lt;== called by &lt;module&gt;
f [1] ==&gt; returning to &lt;module&gt;
f [2] &lt;== called by &lt;module&gt;
f [2] ==&gt; returning to &lt;module&gt;
</code></pre>

<p>The call number is also displayed when <code>log_retval</code> is true:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_call_numbers=True, log_retval=True)
... def f():
...     return 81
&gt;&gt;&gt; _ = f()
f [1] &lt;== called by &lt;module&gt;
    f [1] return value: 81
f [1] ==&gt; returning to &lt;module&gt;
</code></pre>

<p>This is particularly valuable in the presence of recursion, for example.
See the <a href="#recursion-example">recursion example</a> later, where the feature
is used to good effect.</p>

<h3><span id="log_elapsed-parameter">The <em>log_elapsed</em> parameter (default – <em>False</em>)</span></h3>

<p>For performance profiling, you can measure the time it took a function to execute by using the <code>log_elapsed</code> keyword. When true, <code>log_calls</code> reports the time the decorated function took to complete, in seconds:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_elapsed=True)
... def f(n):
...     for i in range(n):
...         # do something time-critical
...         pass
&gt;&gt;&gt; f(5000)                 # doctest: +ELLIPSIS
f &lt;== called by &lt;module&gt;
    arguments: n=5000
    elapsed time: ... [secs]
f ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="indent-parameter">The <em>indent</em> parameter (default - <em>False</em>)</span></h3>

<p>The <code>indent</code> parameter, when true, indents each new level of logged messages by 4 spaces, providing a visualization of the call hierarchy.</p>

<p>A decorated function's logged output is indented only as much as is necessary. Here, the even numbered functions don't indent, so the indented functions that they call are indented just one level more than their "inherited" indentation level:</p>

<pre><code>&gt;&gt;&gt; @log_calls(indent=True)
... def g1():
...     pass
&gt;&gt;&gt; @log_calls()    # no extra indentation for g1
... def g2():
...     g1()
&gt;&gt;&gt; @log_calls(indent=True)
... def g3():
...     g2()
&gt;&gt;&gt; @log_calls()    # no extra indentation for g3
... def g4():
...     g3()
&gt;&gt;&gt; @log_calls(indent=True)
... def g5():
...     g4()
&gt;&gt;&gt; g5()
g5 &lt;== called by &lt;module&gt;
g4 &lt;== called by g5
    g3 &lt;== called by g4
    g2 &lt;== called by g3
        g1 &lt;== called by g2
        g1 ==&gt; returning to g2
    g2 ==&gt; returning to g3
    g3 ==&gt; returning to g4
g4 ==&gt; returning to g5
g5 ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="prefix-parameter">The <em>prefix</em> parameter (default - <code>''</code>): decorating methods</span></h3>

<p>Especially useful for clarity when decorating methods, the <code>prefix</code> keyword
parameter lets you specify a string with which to prefix the name of a function or method. <code>log_calls</code> uses the prefixed name in its output:
when logging a call to, and a return from, the function; when reporting the function's return value; and when the function is at the end of a <a href="#Call-chains">call or return chain</a>.</p>

<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; class Point():
...     # NOTE: You can't decorate __init__ :D
...     def __init__(self, x, y):
...         self.x = x
...         self.y = y
...     @staticmethod
...     @log_calls(prefix='Point.')
...     def distance(pt1, pt2):
...         return math.sqrt((pt1.x - pt2.x)**2 + (pt1.y - pt2.y)**2)
...     @log_calls(log_retval=True, prefix='Point.')
...     def length(self):
...         return self.distance(self, Point(0, 0))
...     @log_calls(prefix='Point.')
...     def diag_reflect(self):
...         self.x, self.y = self.y, self.x
...         return self
...     def __repr__(self):
...         return "Point" + str((self.x, self.y))

&gt;&gt;&gt; print("Point(1, 2).diag_reflect() =", Point(1, 2).diag_reflect())
Point.diag_reflect &lt;== called by &lt;module&gt;
    arguments: self=Point(1, 2)
Point.diag_reflect ==&gt; returning to &lt;module&gt;
Point(1, 2).diag_reflect() = Point(2, 1)

&gt;&gt;&gt; print("length of Point(1, 2) =", round(Point(1, 2).length(), 2))  # doctest: +ELLIPSIS
Point.length &lt;== called by &lt;module&gt;
    arguments: self=Point(1, 2)
Point.distance &lt;== called by Point.length
    arguments: pt1=Point(1, 2), pt2=Point(0, 0)
Point.distance ==&gt; returning to Point.length
    Point.length return value: 2.236...
Point.length ==&gt; returning to &lt;module&gt;
length of Point(1, 2) = 2.24
</code></pre>

<h3><span id="file-parameter">The <em>file</em> parameter (default - <em>sys.stdout</em>)</span></h3>

<p>The <code>file</code> parameter specifies a stream (an instance of <code>io.TextIOBase</code>) to which <code>log_calls</code> will print its messages. This value is supplied to the <code>file</code> keyword parameter of the <code>print</code> function, and, like that parameter, its default value is <code>sys.stdout</code>. This parameter is ignored if you've supplied a logger for output using the <a href="#logger-parameter"><code>logger</code></a> parameter.</p>

<p>If your program writes to the console a lot, you may not want <code>log_calls</code> messages interspersed with your real output: your understanding of both logically distinct streams can be compromised, so, better to make them two actually distinct streams. It can also be advantageous to gather all, and only all, of the <code>log_calls</code> messages in one place. You can use <code>indent=True</code> with a file, and the indentations will appear as intended.</p>

<p>It's not simple to test this feature with doctest (in fact, there are subtleties to supporting this feature and using doctest at all), so we'll just give an example of writing to <code>stderr</code>, and reproduce the output:</p>

<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; @log_calls(file=sys.stderr, indent=True)
... def f(n):
...     if n &lt;= 0:
...         return 'a'
...     return '(' + f(n-1) + ')'
</code></pre>

<p>Running <code>&gt;&gt;&gt; f(2)</code> will return <code>'((a))'</code> and will write the following to <code>stderr</code>:</p>

<pre><code>f &lt;== called by &lt;module&gt;
    f &lt;== called by f
        arguments: n=1
        f &lt;== called by f
            arguments: n=0
        f ==&gt; returning to f
    f ==&gt; returning to f
f ==&gt; returning to &lt;module&gt;
</code></pre>

<h2><span id="Logging">Using loggers</span></h2>

<p><code>log_calls</code> works well with loggers obtained from Python's <code>logging</code> module –
that is, objects of type <code>logging.Logger</code>.
First, we'll set up a logger with a single handler that writes to the console.
Because <code>doctest</code> doesn't capture output written to <code>stderr</code> (the default stream
to which console handlers write), we'll send the console handler's output to
<code>stdout</code>, using the format <code>&lt;loglevel&gt;:&lt;loggername&gt;:&lt;message&gt;</code>.</p>

<pre><code>&gt;&gt;&gt; import logging
&gt;&gt;&gt; import sys
&gt;&gt;&gt; ch = logging.StreamHandler(stream=sys.stdout)
&gt;&gt;&gt; c_formatter = logging.Formatter('%(levelname)8s:%(name)s:%(message)s')
&gt;&gt;&gt; ch.setFormatter(c_formatter)
&gt;&gt;&gt; logger = logging.getLogger('a_logger')
&gt;&gt;&gt; logger.addHandler(ch)
&gt;&gt;&gt; logger.setLevel(logging.DEBUG)
</code></pre>

<h3>The <em>logger</em> parameter (default – <em>None</em>)</h3>

<p>The <code>logger</code> keyword parameter tells <code>log_calls</code> to write its output using
that logger rather than the <code>print</code> function:</p>

<pre><code>&gt;&gt;&gt; @log_calls(logger=logger)
... def somefunc(v1, v2):
...     logger.debug(v1 + v2)
&gt;&gt;&gt; somefunc(5, 16)             # doctest: +NORMALIZE_WHITESPACE
DEBUG:a_logger:somefunc &lt;== called by &lt;module&gt;
DEBUG:a_logger:    arguments: v1=5, v2=16
DEBUG:a_logger:21
DEBUG:a_logger:somefunc ==&gt; returning to &lt;module&gt;

&gt;&gt;&gt; @log_calls(logger=logger)
... def anotherfunc():
...     somefunc(17, 19)
&gt;&gt;&gt; anotherfunc()       # doctest: +NORMALIZE_WHITESPACE
DEBUG:a_logger:anotherfunc &lt;== called by &lt;module&gt;
DEBUG:a_logger:somefunc &lt;== called by anotherfunc
DEBUG:a_logger:    arguments: v1=17, v2=19
DEBUG:a_logger:36
DEBUG:a_logger:somefunc ==&gt; returning to anotherfunc
DEBUG:a_logger:anotherfunc ==&gt; returning to &lt;module&gt;
</code></pre>

<p>The value of <code>logger</code> can be either a logger instance (a <code>logging.Logger</code>) or a string
giving the name of a logger. Instead of passing the logger instance
as above, we can simply pass <code>a_logger</code>:</p>

<pre><code>&gt;&gt;&gt; @log_calls(logger='a_logger')
... def yetanotherfunc():
...     return 42
&gt;&gt;&gt; _ = yetanotherfunc()       # doctest: +NORMALIZE_WHITESPACE
DEBUG:a_logger:yetanotherfunc &lt;== called by &lt;module&gt;
DEBUG:a_logger:yetanotherfunc ==&gt; returning to &lt;module&gt;
</code></pre>

<p>This works because "all calls to [<code>logging.getLogger(name)</code>] with a given name
return the same logger instance", so that "logger instances never need to be
passed between different parts of an application",
as per the <a href="https://docs.python.org/3/library/logging.html?highlight=logging.getlogger#logging.getLogger">Python documentation for <code>logging.getLogger</code></a></p>

<h3><span id="loglevel-parameter">The <em>loglevel</em> parameter (default – <em>logging.DEBUG</em>)</span></h3>

<p><code>log_calls</code> also takes a <code>loglevel</code> keyword parameter, whose value must be
one of the <code>logging</code> module's constants - <code>logging.DEBUG</code>, <code>logging.INFO</code>, etc.
– or a custom logging level if you've added any. <code>log_calls</code> writes output messages
using <code>logger.log(loglevel, …)</code>. Thus, if the <code>logger</code>'s log level is higher than
<code>loglevel</code>, no output will appear:</p>

<pre><code>&gt;&gt;&gt; logger.setLevel(logging.INFO)   # raise logger's level to INFO
&gt;&gt;&gt; @log_calls(logger='logger_=', loglevel=logging.DEBUG)
... def f(x, y, z, **kwargs):
...     return y + z
&gt;&gt;&gt; # No log_calls output from f
&gt;&gt;&gt; # because loglevel for f &lt; level of logger
&gt;&gt;&gt; f(1,2,3, logger_=logger)       # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS
5
</code></pre>

<p>The use of loggers, and of these parameters, is explored further in the main documentation, which contains an example of <a href="http://www.pythonhosted.org/log_calls#logging-multiple-handlers">using a logger with multiple handlers that have different loglevels</a>.</p>

<h2><span id="Call-chains">Call chains</span></h2>

<p><code>log_calls</code> does its best to chase back along the call chain to find
the first <em>enabled</em> <code>log_calls</code>-decorated function on the stack.
If there's no such function, it just displays the immediate caller.
If there is such a function, however, it displays the entire list of
functions on the stack up to and including that function when reporting
calls and returns. Without this, you'd have to guess at what was called
in between calls to functions decorated by <code>log_calls</code>. If you specified
a prefix for the decorated caller on the end of a call chain, <code>log_calls</code>
will use the prefixed name:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def g1():
...     pass
&gt;&gt;&gt; def g2():
...     g1()
&gt;&gt;&gt; @log_calls(prefix='mid.')
... def g3():
...     g2()
&gt;&gt;&gt; def g4():
...     g3()
&gt;&gt;&gt; @log_calls()
... def g5():
...     g4()
&gt;&gt;&gt; g5()
g5 &lt;== called by &lt;module&gt;
mid.g3 &lt;== called by g4 &lt;== g5
g1 &lt;== called by g2 &lt;== mid.g3
g1 ==&gt; returning to g2 ==&gt; mid.g3
mid.g3 ==&gt; returning to g4 ==&gt; g5
g5 ==&gt; returning to &lt;module&gt;
</code></pre>

<p>In the next example, <code>g</code> is <code>log_calls</code>-decorated but logging is disabled,
so the reported call chain for <code>f</code> stops at its immediate caller:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f(): pass
&gt;&gt;&gt; def not_decorated(): f()
&gt;&gt;&gt; @log_calls(enabled=False, log_call_numbers=True)
... def g(): not_decorated()
&gt;&gt;&gt; g()
f &lt;== called by not_decorated
f ==&gt; returning to not_decorated
</code></pre>

<p>Elaborating on the previous example, here are longer call chains with an
intermediate decorated function that has logging disabled. We've also enabled indentation:</p>

<pre><code>&gt;&gt;&gt; @log_calls(indent=True)
... def e(): pass
&gt;&gt;&gt; def not_decorated_call_e(): e()
&gt;&gt;&gt; @log_calls(indent=True)
... def f(): not_decorated_call_e()
&gt;&gt;&gt; def not_decorated_call_f(): f()
&gt;&gt;&gt; @log_calls(enabled=False, log_call_numbers=True, indent=True)
... def g(): not_decorated_call_f()
&gt;&gt;&gt; @log_calls(indent=True)
... def h(): g()
&gt;&gt;&gt; h()
h &lt;== called by &lt;module&gt;
    f &lt;== called by not_decorated_call_f &lt;== g &lt;== h
        e &lt;== called by not_decorated_call_e &lt;== f
        e ==&gt; returning to not_decorated_call_e ==&gt; f
    f ==&gt; returning to not_decorated_call_f ==&gt; g ==&gt; h
h ==&gt; returning to &lt;module&gt;
</code></pre>

<p><code>log_calls</code> chases back to the nearest <em>enabled</em> decorated function, so that there aren't gaps between call chains.</p>

<h3><span id="recursion-example">Indentation and call numbers with recursion</span></h3>

<p>These features are especially useful in recursive and mutually recursive situations. We have to use <code>OrderedDict</code>s here because of doctest:</p>

<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; @log_calls(log_call_numbers=True, log_retval=True, indent=True)
... def depth(d, key=None):
...     if not isinstance(d, dict):
...         return 0    # base case
...     elif not d:
...         return 1
...     else:
...         return max(map(depth, d.values(), d.keys())) + 1
&gt;&gt;&gt; depth(
...     OrderedDict(
...         (('a', 0),
...          ('b', OrderedDict( (('c1', 10), ('c2', 11)) )),
...          ('c', 'text'))
...     )
... )
depth [1] &lt;== called by &lt;module&gt;
    arguments: d=OrderedDict([('a', 0), ('b', OrderedDict([('c1', 10), ('c2', 11)])), ('c', 'text')])
    defaults:  key=None
    depth [2] &lt;== called by depth [1]
        arguments: d=0, key='a'
        depth [2] return value: 0
    depth [2] ==&gt; returning to depth [1]
    depth [3] &lt;== called by depth [1]
        arguments: d=OrderedDict([('c1', 10), ('c2', 11)]), key='b'
        depth [4] &lt;== called by depth [3]
            arguments: d=10, key='c1'
            depth [4] return value: 0
        depth [4] ==&gt; returning to depth [3]
        depth [5] &lt;== called by depth [3]
            arguments: d=11, key='c2'
            depth [5] return value: 0
        depth [5] ==&gt; returning to depth [3]
        depth [3] return value: 1
    depth [3] ==&gt; returning to depth [1]
    depth [6] &lt;== called by depth [1]
        arguments: d='text', key='c'
        depth [6] return value: 0
    depth [6] ==&gt; returning to depth [1]
    depth [1] return value: 2
depth [1] ==&gt; returning to &lt;module&gt;
2
</code></pre>

<p><strong>NOTE</strong>: <em>The optional</em> <code>key</code> <em>parameter is for instructional purposes, so you can see the key that's paired with the value of</em> <code>d</code> <em>in the caller's dictionary. Typically the signature of this function would be just</em> <code>def depth(d)</code>, <em>and the recursive case would return</em> <code>max(map(depth, d.values())) + 1</code>.</p>

<h2><span id="log_message">The indent-aware writing method <em>log_message()</em></span></h2>

<p><code>log_calls</code> exposes the method it uses to write its messages, <code>log_message</code>,
whose full signature is:</p>

<pre><code>`log_message(msg, *msgs, sep=' ', 
             extra_indent_level=1, prefix_with_name=False)`
</code></pre>

<p>This method takes one or more "messages" (anything you want to see as a string),
and writes one final output message formed by joining those messages separated by <code>sep</code>.</p>

<p><code>extra_indent_level</code> is a number of 4-column-wide <em>indent levels</em> specifying
where to begin writing that message. This value x 4 is an offset in columns
from the left margin of the visual frame established by log_calls – that is,
an offset from the column in which the function entry/exit messages begin. The default
of 1 aligns the message with the "arguments: " line of <code>log_calls</code>'s output.</p>

<p><code>prefix_with_name</code> is a <code>bool</code>. If true, the final message is prefaced with the
 possibly prefixed name of the function (using the <code>prefix</code> setting),
 plus possibly its call number in  square brackets (if the <code>log_call_numbers</code> setting
 is true).</p>

<p>If a decorated function or method writes debugging messages, even multiline
messages, it can use this method to write them so that they sit nicely within
the <code>log_calls</code> visual frame.</p>

<p>Consider the following function:</p>

<pre><code>&gt;&gt;&gt; @log_calls(indent=True, log_call_numbers=True)
... def f(n):
...     if n &lt;= 0:
...         print("*** Base case n &lt;= 0")
...     else:
...         print("*** n=%d is %s,\\n    but we knew that."
...                       % (n, "odd" if n%2 else "even"))
...         print("*** (n=%d) We'll be right back, after this:" % n)
...         f(n-1)
...         print("*** (n=%d) We're back." % n)
&gt;&gt;&gt; f(2)                                            # doctest: +SKIP
f [1] &lt;== called by &lt;module&gt;
    arguments: n=2
*** n=2 is even,
    but we knew that.
*** (n=2) We'll be right back, after this:
    f [2] &lt;== called by f [1]
        arguments: n=1
*** n=1 is odd,
    but we knew that.
*** (n=1) We'll be right back, after this:
        f [3] &lt;== called by f [2]
            arguments: n=0
*** Base case n &lt;= 0
        f [3] ==&gt; returning to f [2]
*** (n=1) We're back.
    f [2] ==&gt; returning to f [1]
*** (n=2) We're back.
f [1] ==&gt; returning to &lt;module&gt;
</code></pre>

<p>The debugging messages written by <code>f</code> literally "stick out", and it becomes difficult,
especially in more complex situations with multiple functions and methods,
to figure out who actually wrote which message; hence the "(n=%d)" tag. If instead
<code>f</code> uses <code>log_message</code>, all of its messages from each invocation align neatly
within the <code>log_calls</code> visual frame. We take this opportunity to also
illustrate the keyword parameters of <code>log_message</code>:</p>

<pre><code>&gt;&gt;&gt; @log_calls(indent=True, log_call_numbers=True)
... def f(n):
...     if n &lt;= 0:
...         f.log_message("Base case n =", n, prefix_with_name=True)
...     else:
...         f.log_message("*** n=%d is %s,\\n    but we knew that."
...                       % (n, "odd" if n%2 else "even"),
...                       extra_indent_level=0)
...         f.log_message("We'll be right back", "after this:",
...                       sep=", ", prefix_with_name=True)
...         f(n-1)
...         f.log_message("We're back.", prefix_with_name=True)
&gt;&gt;&gt; f(2)                                            # doctest: +SKIP
f [1] &lt;== called by &lt;module&gt;
    arguments: n=2
*** n=2 is even,
    but we knew that.
    f [1]: We'll be right back, after this:
    f [2] &lt;== called by f [1]
        arguments: n=1
    *** n=1 is odd,
        but we knew that.
        f [2]: We'll be right back, after this:
        f [3] &lt;== called by f [2]
            arguments: n=0
            f [3]: Base case n = 0
        f [3] ==&gt; returning to f [2]
        f [2]: We're back.
    f [2] ==&gt; returning to f [1]
    f [1]: We're back.
f [1] ==&gt; returning to &lt;module&gt;
</code></pre>

<p>The <code>log_message()</code> method works whether the output destination is <code>stdout</code>,
another stream, a file, or a logger. The test file <code>test_log_calls_more.py</code>
contains an example <code>main__log_message__all_possible_output_destinations()</code>
which illustrates that.</p>

<p>See the full documentation for <a href="http://www.pythonhosted.org/log_calls#log_message">the <code>log_message</code> method</a> for notes
and internal links to further examples.</p>

<h2><span id="Advanced-features">Advanced Features</span></h2>

<p><code>log_calls</code> provides a number of features beyond those already described. We'll only give an overview of them here. For a full account, see <a href="http://www.pythonhosted.org/log_calls">the complete documentation</a>.</p>

<h3><span id="dynamic-control-of-settings">Dynamic control of settings</span></h3>

<p>Sometimes, you'll need or want to change a <code>log_calls</code> setting for a decorated function on the fly. The major impediment to doing so is that the values  of the <code>log_calls</code> parameters are set once the decorated function is interpreted.
Those values are established once and for all when the Python interpreter
parses the definition of a decorated function and creates a function object.</p>

<h4><span id="log_call_settings">The problem, and two <em>log_calls</em> solutions</span></h4>

<p>Even if a variable is used as a parameter value, its value at the time
Python processes the definition is "frozen" for the created function object.
Subsequently changing the value of the variable will <em>not</em> affect the behavior
of the decorator.</p>

<p>For example, suppose <code>DEBUG</code> is a module-level variable initialized to <code>False</code>:</p>

<pre><code>&gt;&gt;&gt; DEBUG = False
</code></pre>

<p>and you use this code:</p>

<pre><code>&gt;&gt;&gt; @log_calls(enabled=DEBUG)
... def foo(**kwargs):
...     pass
&gt;&gt;&gt; foo()       # No log_calls output: DEBUG is False
</code></pre>

<p>If later you set <code>Debug = True</code> and call <code>foo</code>, that call won't be logged,
because the decorated <code>foo</code>'s <em>enabled</em> setting is bound to the original value
of <code>DEBUG</code>, established when the definition was processed:</p>

<pre><code>&gt;&gt;&gt; DEBUG = True
&gt;&gt;&gt; foo()       # Still no log_calls output
</code></pre>

<p><code>log_calls</code> provides <em>two</em> ways to overcome this limitation and dynamically control the settings of a decorated function:</p>

<ul>
<li><a href="#log_call_settings">the <code>log_calls_settings</code> attribute</a>, which provides a mapping interface and an attribute-based interface to settings, and</li>
<li><a href="#Indirect-values">indirect values</a>.</li>
</ul>


<p>The following two subsections give a brief introduction to these features, which <a href="(http://www.pythonhosted.org/log_calls">the main documentation</a> presents in depth.</p>

<h4><span id="log_call_settings">The <em>log_calls_settings</em> attribute</span></h4>

<p><code>log_calls</code> adds an attribute <code>log_calls_settings</code>
to a decorated function, through which you can access the decorator settings for that function. This attribute is an object which lets you control the settings for a decorated function via a mapping (<code>dict</code>-like) interface, and equivalently, via attributes of the object. The mapping keys and the attribute names are simply the <code>log_calls</code> keywords. <code>log_calls_settings</code> also implements many of the standard <code>dict</code> methods for interacting with the settings in familiar ways.</p>

<h5><span id="mapping-interface">The mapping interface and the attribute interface to settings</span></h5>

<p>Once you've decorated a function with <code>log_calls</code>,</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f(*args, **kwargs):
...     return 91
</code></pre>

<p>you can access and change its settings via the <code>log_calls_settings</code> attribute
of the decorated function, which behaves like a dictionary. You can read and
write settings using the <code>log_calls</code> keywords as keys:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings['enabled']
True
&gt;&gt;&gt; f.log_calls_settings['enabled'] = False
&gt;&gt;&gt; _ = f()                   # no output (not even 91, because of "_ = ")
&gt;&gt;&gt; f.log_calls_settings['enabled']
False
&gt;&gt;&gt; f.log_calls_settings['log_retval']
False
&gt;&gt;&gt; f.log_calls_settings['log_retval'] = True
&gt;&gt;&gt; f.log_calls_settings['log_elapsed']
False
&gt;&gt;&gt; f.log_calls_settings['log_elapsed'] = True
</code></pre>

<p>You can also use the same keywords as attributes of <code>log_calls_settings</code>
instead of as keywords to the mapping interface; they're completely
equivalent:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.log_elapsed
True
&gt;&gt;&gt; f.log_calls_settings.log_call_numbers
False
&gt;&gt;&gt; f.log_calls_settings.log_call_numbers = True
&gt;&gt;&gt; f.log_calls_settings.enabled = True     # turn it back on!
&gt;&gt;&gt; _ = f()                                 # doctest: +ELLIPSIS
f [1] &lt;== called by &lt;module&gt;
    arguments: &lt;none&gt;
    f [1] return value: 91
    elapsed time: ... [secs]
f [1] ==&gt; returning to &lt;module&gt;

&gt;&gt;&gt; f.log_calls_settings.log_args = False
&gt;&gt;&gt; f.log_calls_settings.log_elapsed = False
&gt;&gt;&gt; f.log_calls_settings.log_retval = False
&gt;&gt;&gt; _ = f()                                 # doctest: +ELLIPSIS
f [2] &lt;== called by &lt;module&gt;
f [2] ==&gt; returning to &lt;module&gt;
</code></pre>

<p>The <code>log_calls_settings</code> attribute has a length (14), its keys and <code>items()</code> can be iterated through, you can use <code>in</code> to test for key membership, and it has an <code>update()</code> method. As with an ordinary dictionary, attempting to access a nonexistent setting
raises <code>KeyError</code>. Unlike an ordinary dictionary, you can't add new keys – the <code>log_calls_settings</code> dictionary is closed to new members, and attempts to add one will also raise <code>KeyError</code>.</p>

<h6><span id="update-as_etc">The <em>update()</em>, <em>as_OrderedDict()</em> and <em>as_dict()</em> methods – and a typical use-case</span></h6>

<p>The <code>update()</code> method of the <code>log_calls_settings</code> object lets you update several settings at once:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.update(
...     log_args=True, log_elapsed=False, log_call_numbers=False,
...     log_retval=False)
&gt;&gt;&gt; _ = f()
f &lt;== called by &lt;module&gt;
    arguments: &lt;none&gt;
f ==&gt; returning to &lt;module&gt;
</code></pre>

<p>You can retrieve the entire collection of settings as either an <code>OrderedDict</code> using the <code>as_OrderedDict()</code> method, or as a <code>dict</code> using <code>as_dict()</code>.
Either can serve as a snapshot of the settings, so that you can change settings temporarily, use the new settings, and then use <code>update()</code> to restore settings from the snapshot.
in addition to taking keyword arguments, as shown above, <code>update()</code> can take one or more dicts – in particular, a dictionary retrieved from one of the <code>as_*</code> methods. For example:</p>

<p>Retrieve settings (here, as an <code>OrderedDict</code> because those are more doctest-friendly, but using <code>as_dict()</code> suffices):</p>

<pre><code>&gt;&gt;&gt; od = f.log_calls_settings.as_OrderedDict()
&gt;&gt;&gt; od                      # doctest: +NORMALIZE_WHITESPACE
OrderedDict([('enabled', True),           ('args_sep', ', '),
             ('log_args', True),          ('log_retval', False),
             ('log_elapsed', False),      ('log_exit', True),
             ('indent', False),           ('log_call_numbers', False),
             ('prefix', ''),              ('file', None),
             ('logger', None),            ('loglevel', 10),
             ('record_history', False),   ('max_history', 0)])
</code></pre>

<p>change settings temporarily:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.update(
...     log_args=False, log_elapsed=True, log_call_numbers=True,
...     log_retval=True)
</code></pre>

<p>use the new settings for <code>f</code>:</p>

<pre><code>&gt;&gt;&gt; _ = f()                     # doctest: +ELLIPSIS
f [4] &lt;== called by &lt;module&gt;
    f [4] return value: 91
    elapsed time: ... [secs]
f [4] ==&gt; returning to &lt;module&gt;
</code></pre>

<p>and restore original settings, this time passing the retrieved settings
dictionary rather than keywords (we <em>could</em> pass <code>**od</code>, but that's unnecessary and a pointless expense):</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.update(od)
&gt;&gt;&gt; od == f.log_calls_settings.as_OrderedDict()
True
</code></pre>

<h4><span id="Indirect-values">Indirect values</span></h4>

<p><code>log_calls</code> provides a second way to access and change settings on the fly. The decorator lets you specify any parameter
except <code>prefix</code> or <code>max_history</code> with one level of indirection, by using
<em>indirect values</em>: an indirect value is a string that names a keyword argument
<em>of the decorated function</em>. It can be an explicit keyword argument present
in the signature of the function, or an implicit keyword argument that ends up
in <code>**kwargs</code> (if that's present in the function's signature). When the decorated
function is called, the arguments passed by keyword, and the decorated function's
explicit keyword parameters with default values, are both searched for the named
parameter; if it is found and of the correct type, <em>its</em> value is used; otherwise
the default value for the <code>log_calls</code> parameter is used.</p>

<p>To specify an indirect value for a parameter whose normal values are or can be <code>str</code>s (only <code>args_sep</code> and <code>logger</code>, at present), append an <code>'='</code> to the value.  For consistency,
any indirect value can end in a trailing <code>'='</code>, which is stripped. Thus,
<code>enabled='enable_='</code> indicates an indirect value <em>to be supplied</em> by the keyword (argument or parameter) <code>enable_</code> of the decorated function.</p>

<p>For example, in:</p>

<pre><code>&gt;&gt;&gt; @log_calls(args_sep='sep=', prefix="*** ")
... def f(a, b, c, sep='|'): pass
</code></pre>

<p><code>args_sep</code> has an indirect value which names <code>f</code>'s explicit keyword parameter <code>sep</code>,
and <code>prefix</code> has a direct value as it always does. A call can dynamically override the default
value '|' in the signature of <code>f</code> by supplying a value:</p>

<pre><code>&gt;&gt;&gt; f(1, 2, 3, sep=' / ')
*** f &lt;== called by &lt;module&gt;
    arguments: a=1 / b=2 / c=3 / sep=' / '
*** f ==&gt; returning to &lt;module&gt;
</code></pre>

<p>or it can use <code>f</code>'s default value by not supplying a <code>sep</code> argument:</p>

<pre><code>&gt;&gt;&gt; f(1, 2, 3)
*** f &lt;== called by &lt;module&gt;
    arguments: a=1|b=2|c=3
    defaults:  sep='|'
*** f ==&gt; returning to &lt;module&gt;
</code></pre>

<p><em>A decorated function doesn't have to explicitly declare the parameter
named as an indirect value</em>, if its signature includes <code>**kwargs</code>:
the intermediate parameter can be an implicit keyword parameter,
passed by a caller but not present in the function's signature.
Consider:</p>

<pre><code>&gt;&gt;&gt; @log_calls(enabled='enable')
... def func1(a, b, c, **kwargs): pass
&gt;&gt;&gt; @log_calls(enabled='enable')
... def func2(z, **kwargs): func1(z, z+1, z+2, **kwargs)
</code></pre>

<p>When the following statement is executed, the calls to both <code>func1</code> and <code>func2</code> will be logged:</p>

<pre><code>&gt;&gt;&gt; func2(17, enable=True)
func2 &lt;== called by &lt;module&gt;
    arguments: z=17, [**]kwargs={'enable': True}
func1 &lt;== called by func2
    arguments: a=17, b=18, c=19, [**]kwargs={'enable': True}
func1 ==&gt; returning to func2
func2 ==&gt; returning to &lt;module&gt;
</code></pre>

<p>whereas neither of the following two statements will trigger logging:</p>

<pre><code>&gt;&gt;&gt; func2(42, enable=False)     # no log_calls output
&gt;&gt;&gt; func2(99)                   # no log_calls output
</code></pre>

<p>See the section in the full documentation on <a href="http://www.pythonhosted.org/log_calls#Indirect-values">indirect values</a> for several more examples and useful techniques involving indirect values. The test suite <code>log_calls/tests/test_log_calls_more.py</code> also contains further doctests/examples.</p>

<h3><span id="call-history-and-statistics">Call history and statistics</span></h3>

<p><code>log_calls</code> always collects a few basic statistics about calls to a decorated
function. It can collect the entire history of calls to a function if asked
to, or just the most recent <code>n</code> calls; the *_history parameters, discussed next, determine these settings. The statistics and history are accessible via the <code>stats</code> attribute which <code>log_calls</code> adds to a decorated function.</p>

<h4><span id="_history-parameters">The <em>record_history</em> and <em>max_history</em> parameters</span></h4>

<p>The two settings parameters we haven't yet discussed govern the recording of a decorated function's call history.</p>

<h5><span id="record_history-parameter">The <em>record_history</em> parameter (default – <em>False</em>)</span></h5>

<p>When the <code>record_history</code> setting is true for a decorated function <code>f</code>, <code>log_calls</code> will retain a sequence of records holding the details of each logged call to that function. That history is accessible via attributes of the <code>stats</code> object.</p>

<p>Let's define a function <code>f</code> with <code>record_history</code> set to true:</p>

<pre><code>&gt;&gt;&gt; @log_calls(record_history=True, log_call_numbers=True, log_exit=False)
... def f(a, *args, x=1, **kwargs): pass
</code></pre>

<p>In the following subsections, we'll call this function, manipulate its settings, and examine its statistics.</p>

<h5><span id="max_history-parameter">The <em>max_history</em> parameter (default – 0)</span></h5>

<p>The <code>max_history</code> parameter determines how many call history records are retained for a decorated function whose call history is recorded. If this value is 0 or negative, unboundedly many records are retained (unless or until
you set the <code>record_history</code> setting to false, or call the
<a href="#stats.clear_history"><code>stats.clear_history()</code></a> method). If the value of <code>max_history</code> is > 0, <code>log_calls</code> will retain at most that many records, discarding the oldest records to make room for newer ones if the history reaches capacity.</p>

<p>You cannot change <code>max_history</code> using the mapping interface or the attribute
of the same name; attempts to do so raise <code>ValueError</code>. The only way to change its value is with the <a href="#stats.clear_history"><code>stats.clear_history()</code></a> method, discussed below.</p>

<h4><span id="stats-attribute">The <em>stats</em> attribute and <em>its</em> attributes</span></h4>

<p>The <code>stats</code> attribute of a decorated function is an object that provides statistics and data about calls to a decorated function:</p>

<ul>
<li><a href="#stats.num_calls_logged"><code>stats.num_calls_logged</code></a></li>
<li><a href="#stats.num_calls_total"><code>stats.num_calls_total</code></a></li>
<li><a href="#elapsed_secs_logged"><code>stats.elapsed_secs_logged</code></a></li>
<li><a href="#stats.history"><code>stats.history</code></a></li>
<li><a href="#stats.history_as_csv"><code>stats.history_as_csv</code></a></li>
<li><a href="#stats.history_as_DataFrame"><code>stats.history_as_DataFrame</code></a></li>
</ul>


<p>The first three don't depend on the <code>record_history</code> setting at all.The last three yield empty results unless <code>record_history</code> is true.</p>

<p>The <code>stats</code> attribute also provides one method, <a href="#stats.clear_history"><code>stats.clear_history()</code></a>.</p>

<p>Let's call the function <code>f</code> twice:</p>

<pre><code>&gt;&gt;&gt; f(0)
f [1] &lt;== called by &lt;module&gt;
    arguments: a=0
    defaults:  x=1
&gt;&gt;&gt; f(1, 100, 101, x=1000, y=1001)
f [2] &lt;== called by &lt;module&gt;
    arguments: a=1, [*]args=(100, 101), x=1000, [**]kwargs={'y': 1001}
</code></pre>

<p>and explore its <code>stats</code>.</p>

<h5><span id="stats.num_calls_logged">The <em>num_calls_logged</em> attribute</span></h5>

<p>The <code>stats.num_calls_logged</code> attribute contains the number of the most
recent logged call to a decorated function. Thus, <code>f.stats.num_calls_logged</code>
will equal 2:</p>

<pre><code>&gt;&gt;&gt; f.stats.num_calls_logged
2
</code></pre>

<p>This counter gets incremented when a decorated function is called that has logging enabled, even if its <code>log_call_numbers</code> setting is false.</p>

<h5><span id="stats.num_calls_total">The <em>num_calls_total</em> attribute</span></h5>

<p>The <code>stats.num_calls_total</code> attribute holds the <em>total</em> number of calls
to a decorated function. This counter gets incremented even when logging
is disabled for a function.</p>

<p>For example, let's now <em>disable</em> logging for <code>f</code> and call it 3 more times:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.enabled = False
&gt;&gt;&gt; for i in range(3): f(i)
</code></pre>

<p>Now <code>stats.num_calls_total</code> will equal 5, but <code>f.stats.num_calls_logged</code>
will still equal 2:</p>

<pre><code>&gt;&gt;&gt; f.stats.num_calls_total
5
&gt;&gt;&gt; f.stats.num_calls_logged
2
</code></pre>

<p>Finally, let's re-enable logging for <code>f</code> and call it again.
The displayed call number will be the number of the <em>logged</em> call, 3, the same
value as <code>f.stats.num_calls_logged</code> after the call:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.enabled = True
&gt;&gt;&gt; f(10, 20, z=5000)
f [3] &lt;== called by &lt;module&gt;
    arguments: a=10, [*]args=(20,), [**]kwargs={'z': 5000}
    defaults:  x=1

&gt;&gt;&gt; f.stats.num_calls_total
6
&gt;&gt;&gt; f.stats.num_calls_logged
3
</code></pre>

<p><strong>ATTENTION</strong>: <em>Thus,</em> <code>log_calls</code> <em>has some overhead even when it's disabled, and somewhat more when it's enabled. So,</em> <strong>comment it out in production code!</strong></p>

<h5><span id="elapsed_secs_logged">The <em>elapsed_secs_logged</em> attribute</span></h5>

<p>The <code>stats.elapsed_secs_logged</code> attribute holds the sum of the elapsed times of
all logged calls to a decorated function, in seconds. Here's its value for the 3 logged calls to <code>f</code> above:</p>

<pre><code>&gt;&gt;&gt; f.stats.elapsed_secs_logged   # doctest: +SKIP
6.67572021484375e-06
</code></pre>

<h5><span id="stats.history">The <em>history</em> attribute</span></h5>

<p>The <code>stats.history</code> attribute of a decorated function provides the call history
of logged calls to the function as a tuple of records. Each record is a <code>namedtuple</code>of type <code>CallRecord</code>. Here's <code>f</code>'s call history,
in (almost) human-readable form:</p>

<pre><code>&gt;&gt;&gt; print('\\n'.join(map(str, f.stats.history)))   # doctest: +SKIP
CallRecord(call_num=1, argnames=['a'], argvals=(0,), varargs=(),
                       explicit_kwargs=OrderedDict(),
                       defaulted_kwargs=OrderedDict([('x', 1)]), implicit_kwargs={},
                       retval=None, elapsed_secs=2.1457672119140625e-06,
                       timestamp='10/28/14 15:56:13.733763',
                       prefixed_func_name='f', caller_chain=['&lt;module&gt;'])
CallRecord(call_num=2, argnames=['a'], argvals=(1,), varargs=(100, 101),
                       explicit_kwargs=OrderedDict([('x', 1000)]),
                       defaulted_kwargs=OrderedDict(), implicit_kwargs={'y': 1001},
                       retval=None, elapsed_secs=1.9073486328125e-06,
                       timestamp='10/28/14 15:56:13.734102',
                       prefixed_func_name='f', caller_chain=['&lt;module&gt;'])
CallRecord(call_num=3, argnames=['a'], argvals=(10,), varargs=(20,),
                       explicit_kwargs=OrderedDict(),
                       defaulted_kwargs=OrderedDict([('x', 1)]), implicit_kwargs={'z': 5000},
                       retval=None, elapsed_secs=2.1457672119140625e-06,
                       timestamp='10/28/14 15:56:13.734412',
                       prefixed_func_name='f', caller_chain=['&lt;module&gt;'])
</code></pre>

<p>The CSV representation pairs
the <code>argnames</code> with their values in <code>argvals</code> (the <code>argnames</code> become column headings),
making it even more human-readable, especially when viewed in a program that
presents CSVs nicely.</p>

<h5><span id="stats.history_as_csv">The <em>history_as_csv</em> attribute</span></h5>

<p>The value <code>stats.history_as_csv</code> attribute is a text representation in CSV format
of a decorated function's call history. You can save this string
and import it into the program or tool of your choice for further analysis.
(<em>Note: if your tool of choice is <a href="http://pandas.pydata.org">Pandas</a>, you can use
the <code>stats</code> attribute <a href="#stats.history_as_DataFrame"><code>stats.history_as_DataFrame</code></a> to obtain history
directly in the representation you really want.</em>)
The CSV representation
breaks out each argument into its own column, throwing away
information about whether an argument's value was passed or is a default.</p>

<p>The CSV separator is '|' rather than ',' because some of the fields – <code>args</code>,  <code>kwargs</code>
and <code>caller_chain</code> – use commas intrinsically. Let's examine one more
<code>history_as_csv</code> for a function that has all of those fields:</p>

<pre><code>&gt;&gt;&gt; @log_calls(record_history=True, log_call_numbers=True,
...            log_exit=False, log_args=False)
... def f(a, *extra_args, x=1, **kw_args): pass
&gt;&gt;&gt; def g(a, *args, **kwargs): f(a, *args, **kwargs)
&gt;&gt;&gt; @log_calls(log_exit=False, log_args=False)
... def h(a, *args, **kwargs): g(a, *args, **kwargs)
&gt;&gt;&gt; h(0)
h &lt;== called by &lt;module&gt;
f [1] &lt;== called by g &lt;== h
&gt;&gt;&gt; h(10, 17, 19, z=100)
h &lt;== called by &lt;module&gt;
f [2] &lt;== called by g &lt;== h
&gt;&gt;&gt; h(20, 3, 4, 6, x=5, y='Yarborough', z=100)
h &lt;== called by &lt;module&gt;
f [3] &lt;== called by g &lt;== h
</code></pre>

<p>Here's the call history in CSV format:</p>

<pre><code>&gt;&gt;&gt; print(f.stats.history_as_csv)        # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS
call_num|a|extra_args|x|kw_args|retval|elapsed_secs|timestamp|prefixed_fname|caller_chain
1|0|()|1|{}|None|...|...|'f'|['g', 'h']
2|10|(17, 19)|1|{'z': 100}|None|...|...|'f'|['g', 'h']
3|20|(3, 4, 6)|5|{'y': 'Yarborough', 'z': 100}|None|...|...|'f'|['g', 'h']
&lt;BLANKLINE&gt;
</code></pre>

<p>Ellipses are for the <code>elapsed_secs</code> and <code>timestamp</code> fields. As usual, <code>log_calls</code> will use whatever names you use for <em>varargs</em> parameters
(here, <code>extra_args</code> and <code>kw_args</code>). Whatever the name of the <code>kwargs</code> parameter,
items within that field are guaranteed to be in sorted order.</p>

<h5><span id="stats.history_as_DataFrame">The <em>history_as_DataFrame</em> attribute</span></h5>

<p>The <code>stats.history_as_DataFrame</code> attribute returns the history of a decorated
function as a <a href="http://pandas.pydata.org">Pandas</a> <a href="http://pandas.pydata.org/pandas-docs/stable/dsintro.html#dataframe">DataFrame</a>,
if the Pandas library is installed. This saves you the intermediate step of
calling <code>DataFrame.from_csv</code> with the proper arguments (and also saves you from
having to know or care what those are).</p>

<p>If Pandas is not installed, the value of this attribute is <code>None</code>.</p>

<p>The documentation for the <code>record_history</code> decorator contains an <a href="./record_history.html#stats.history_as_DataFrame">example of the <code>history_as_DataFrame</code> attribute</a>
which also illustrates its use in an IPython notebook.</p>

<h5><span id="stats.clear_history">The <em>clear_history(max_history=0)</em> method</span></h5>

<p>As you might expect, the <code>stats.clear_history(max_history=0)</code> method clears
the call history of a decorated function. In addition, it resets all running sums:
<code>num_calls_total</code> and <code>num_calls_logged</code> are reset to 0, and
<code>elapsed_secs_logged</code> is reset to 0.0.</p>

<p><strong>It is the only way to change the value of the <code>max_history</code> setting</strong>, via
the optional keyword parameter for which you can supply any (integer) value,
by default 0.</p>

<p>The function <code>f</code> has a nonempty history, as we just saw. Let's clear <code>f</code>'s history, setting <code>max_history</code> to 33, and check that settings
and <code>stats</code> tallies are reset:</p>

<pre><code>&gt;&gt;&gt; f.stats.clear_history(max_history=33)
&gt;&gt;&gt; f.log_calls_settings.max_history
33
&gt;&gt;&gt; f.stats.num_calls_logged
0
&gt;&gt;&gt; f.stats.num_calls_total
0
&gt;&gt;&gt; f.stats.elapsed_secs_logged
0.0
</code></pre>

<h2><span id="record_history-decorator">The <em>record_history</em> decorator</span></h2>

<p>The <code>record_history</code> decorator is a stripped-down version of <code>log_calls</code> which
records calls to a decorated function but writes no messages. You can think
of it as <code>log_calls</code> with the <code>record_history</code> and <code>log_call_numbers</code> settings
always true, and without any of the message-logging apparatus.</p>

<p><code>record_history</code> has only three keyword parameters:</p>

<ul>
<li><code>enabled</code></li>
<li><code>prefix</code></li>
<li><code>max_history</code></li>
</ul>


<p>Just as the settings of <code>log_calls</code> for a decorated function are accessible
dynamically through the <code>log_calls_settings</code> attribute, these settings of
<code>record_history</code> are exposed via a <code>record_history_settings</code> attribute.
<code>record_history_settings</code> is an object of the same type as <code>log_calls_settings</code>,
so it has the same methods and behaviors described in the <a href="#log_call_settings"><code>log_calls_settings</code></a> section.</p>

<p>Functions decorated by <code>record_history</code> have a full-featured <code>stats</code> attribute,
as described in the <a href="#call-history-and-statistics">Call history and statistics</a> section above.</p>

<p>See the documentation for <a href="http://www.pythonhosted.org/log_calls/record_history.html"><code>record_history</code></a> for examples and tests.</p>

<p><strong>ATTENTION</strong>: <em>Like</em> <code>log_calls</code>, <code>record_history</code> <em>has some overhead. So,</em> <strong>comment it out in production code!</strong></p>

<h2><span id="KeywordParametersReference">Appendix – Keyword Parameters Reference</span></h2>

<p>The <code>log_calls</code> decorator takes various keyword arguments, all with hopefully sensible defaults:</p>

<table>
<thead>
<tr>
<th align="right">Keyword parameter </th>
<th align="left"> Default value </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right"><code>enabled</code>    </td>
<td align="left"> <code>True</code>          </td>
<td align="left"> An <code>int</code>. If true, then <code>log_calls</code> will output (or "log") messages.</td>
</tr>
<tr>
<td align="right"><code>args_sep</code>   </td>
<td align="left"> <code>', '</code>          </td>
<td align="left"> <code>str</code> used to separate arguments. The default is  <code>', '</code>, which lists all args on the same line. If <code>args_sep='\n'</code> is used, or more generally if the <code>args_sep</code> string ends in <code>\n</code>, then additional spaces are appended to the separator for a neater display. Other separators in which <code>'\n'</code> occurs are left unchanged, and are untested – experiment/use at your own risk.</td>
</tr>
<tr>
<td align="right"><code>log_args</code>   </td>
<td align="left"> <code>True</code>          </td>
<td align="left"> If true, arguments passed to the decorated function, and default values used by the function, will be logged.</td>
</tr>
<tr>
<td align="right"><code>log_retval</code> </td>
<td align="left"> <code>False</code>         </td>
<td align="left"> If true, log what the decorated function returns. At most 60 chars are printed, with a trailing ellipsis if the value is truncated.</td>
</tr>
<tr>
<td align="right"><code>log_exit</code>   </td>
<td align="left"> <code>True</code>          </td>
<td align="left"> If true, the decorator will log an exiting message after calling the function of the form <code>f returning to ==&gt; caller</code>, and before returning what the function returned.</td>
</tr>
<tr>
<td align="right"><code>log_call_number</code> </td>
<td align="left"> <code>False</code>    </td>
<td align="left"> If true, display the (1-based) number of the function call, e.g. <code>f [3] called by &lt;== &lt;module&gt;</code> and <code>f [3] returning to ==&gt; &lt;module&gt;</code> for the 3rd logged call. This would correspond to the 3rd record in the function's call history, if <code>record_history</code> is true.</td>
</tr>
<tr>
<td align="right"><code>log_elapsed</code> </td>
<td align="left"> <code>False</code>        </td>
<td align="left"> If true, display how long it took the function to execute, in seconds.</td>
</tr>
<tr>
<td align="right"><code>indent</code>     </td>
<td align="left"> <code>False</code>         </td>
<td align="left"> The <code>indent</code> parameter indents each new level  of logged messages by 4 spaces, giving a visualization of the call hierarchy.</td>
</tr>
<tr>
<td align="right"><code>prefix</code>     </td>
<td align="left"> <code>''</code>            </td>
<td align="left"> A <code>str</code> to prefix the function name with in logged messages: on entry, in reporting return value (if <code>log_retval</code> is true) and on exit (if <code>log_exit</code> is true).</td>
</tr>
<tr>
<td align="right"><code>file</code>     </td>
<td align="left"> <code>sys.stdout</code>      </td>
<td align="left"> If <code>logger</code> is <code>None</code>, a stream (an instance of type <code>io.TextIOBase</code>) to which <code>log_calls</code> will print its messages. This value is supplied to the <code>file</code> keyword parameter of the <code>print</code> function.</td>
</tr>
<tr>
<td align="right"><code>logger</code>     </td>
<td align="left"> <code>None</code>          </td>
<td align="left"> If not <code>None</code>, either a logger (a <code>logging.Logger</code> instance), or the name of a logger (a <code>str</code> that will be passed to <code>logging.getLogger()</code>); that logger will be used to write messages, provided it exists/has handlers. Otherwise, <code>print</code> is used.</td>
</tr>
<tr>
<td align="right"><code>loglevel</code>   </td>
<td align="left"> <code>logging.DEBUG</code> </td>
<td align="left"> Logging level, ignored unless a logger is specified. This should be one of the logging levels recognized by the <code>logging</code> module – one of the constants defined by that module, or a custom level you've added.</td>
</tr>
<tr>
<td align="right"><code>record_history</code> </td>
<td align="left"> <code>False</code>     </td>
<td align="left"> If true, a list of records will be kept, one for each logged call to the function. Each record holds: call number (1-based), arguments and defaulted keyword arguments, return value, time elapsed, time of call, prefixed function name, caller (call chain). The value of this attribute is a <code>tuple</code>.</td>
</tr>
<tr>
<td align="right"><code>max_history</code> </td>
<td align="left"> <code>0</code>            </td>
<td align="left"> An <code>int</code>. <em>value</em> > 0 --> store at most <em>value</em>-many records, oldest records overwritten; <em>value</em> ≤ 0 --> store unboundedly many records. Ignored unless <code>record_history</code> is true.</td>
</tr>
<tr>
<td align="right"><code>settings</code> </td>
<td align="left"> <code>None</code>            </td>
<td align="left"> A dictionary containing settings and values, or a string giving the pathname to a <em>settings file</em> containing settings and values. If the pathname is a directory and not a file, <code>log_calls</code> looks for a file <code>.log_calls</code> in that directory; otherwise, it looks for the named file. The format of a settings file is: zero or more lines of the form <em>setting</em> = <em>value</em>; lines whose first non-whitespace character is '#' are comments. These settings are defaults: other settings passed to <code>log_calls</code> override their values.</td>
</tr>
</tbody>
</table>


<h4>— Brian O'Neill, October-November 2014, NYC</h4>
</body>
</html>