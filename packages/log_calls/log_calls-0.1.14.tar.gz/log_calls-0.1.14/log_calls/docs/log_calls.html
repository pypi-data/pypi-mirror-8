<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
/* Customized "Clearness.css" (.TOC) */

h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: black;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
    color: black;
    font-size: 13px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}

div.TOC {
    background-color: rgba(232, 232, 232, 0.81);    /*#fee9cc;*/
}
div.TOC h5 {
    margin-top: 0px;
    margin-bottom: 0px;
}
div.TOC > ul, div.TOC > ul + li {
    margin-top: 0px;
}

blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: rgba(232, 232, 232, 0.81);    // #fee9cc;
    color: rgba(0, 0, 0, 0.95);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    background-color: #e8e8e8;

    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #e8e8e8;  // #fff;
    color:#101010;              // #737373
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}

</style>
<title>*log_calls* — A decorator for debugging and profiling</title>

</head>
<body>
<h1><em>log_calls</em> — A decorator for debugging and profiling</h1>

<hr />

<p><code>log_calls</code> is a Python 3 decorator that can display a great deal of useful information about calls to a decorated function, such as:</p>

<ul>
<li>the caller of the function,</li>
<li>the number of the call,</li>
<li>the arguments passed to the function, and any default values used,</li>
<li>the time the function took to execute,</li>
<li>display of the complete call chain back to another <code>log_calls</code>-decorated caller,</li>
<li>indentation by call level,</li>
<li>the function's return value,</li>
<li>the function's return to the caller.</li>
</ul>


<p>It can also collect profiling data and statistics, accessible dynamically:</p>

<ul>
<li>the number of calls to a function,</li>
<li>total time taken by the function,</li>
<li>the function's entire call history (arguments, time elapsed, return values, callers, and more), optionally as text in CSV format.</li>
</ul>


<p>The decorator can print its messages, to stdout or another stream, or can write
to a Python logger. These features and others are optional and configurable settings, which can be specified for each decorated function via keyword parameters of the decorator. You can also dynamically get and set these settings using attributes with the same names as the keywords, or using a dict-like interface whose keys are the keywords. In fact, through a mechanism of "indirect parameter values", with just a modest amount of cooperation between decorated functions a calling function can ensure uniform settings for all <code>log_calls</code>-decorated functions in call chains beneath it.</p>

<p>In short, <code>log_calls</code> can save you from writing, rewriting, copying, pasting and tweaking
a lot of ad hoc, boilerplate code - and can keep your code free of that clutter.</p>

<p>This document will explain all of these features and illustrate how to use them, somewhat exhaustively: this is both thorough documentation and a test suite. The TL;DR version is README.md, also in the <code>log_calls/docs</code> directory. It doesn't dot every <code>i</code> and cross every <code>t</code> but will get you started effectively.</p>

<div class="TOC">
<h2>Table Of Contents</h2>

<h5><a href="#Preliminaries">Preliminaries</a></h5>
<ul>
<li><a href="#Version">Version</a></li>
<li><a href="#Dependencies-requirements">Dependencies and requirements</a></li>
<li><a href="#Installation">Installation</a></li>
<li><a href="#Testing">Running the tests</a></li>
<ul>
<li><a href="#tests-before-install">Running the tests before installation</a></li>
<li><a href="#tests-after-install">Running the tests after installation</a></li>
<li><a href="#tests-ok">What to expect</a></li>

<li><a href="#run-this-document">Run this document</a></li>
</ul>
<li><a href="#Acknowledgements">Acknowledgements</a></li>
</ul>
<h5><a href="#Basic-usage">Basic Usage</a></h5>
<ul>
<li><a href="#No-parameters">Using no parameters</a></li>
<li><a href="#enabled-parameter">The <em>enabled</em> parameter</a></li>
<li><a href="#args_sep-parameter">The <em>args_sep</em> parameter</a></li>
<li><a href="#log_args-parameter">The <em>log_args</em> parameter</a></li>
<li><a href="#log_retval-parameter">The <em>log_retval</em> parameter</a></li>
<li><a href="#log_exit-parameter">The <em>log_exit</em> parameter</a></li>
<li><a href="#log_call_numbers-parameter">The <em>log_call_numbers</em> parameter</a></li>
<li><a href="#log_elapsed-parameter">The <em>log_elapsed</em> parameter</a></li>
<li><a href="#indent-parameter">The <em>indent</em> parameter</a></li>
<li><a href="#prefix-parameter">The <em>prefix</em> parameter</a></li>
<li><a href="#file-parameter">The <em>file</em> parameter</a></li>
</ul>
<h5><a href="#Logging">Using loggers</a></h5>
<ul>
<li><a href="#logger-parameter">The <em>logger</em> parameter</a></li>
<li><a href="#loglevel-parameter">The <em>loglevel</em> parameter</a></li>
</ul>
<h5><a href="#Call-chains">Call chains</a></h5>
<ul>
<li><a href="#indent-parameter-another">Another <em>indent</em> example</a></li>
<li><a href="#Call-chains-inner-functions">Call chains and inner functions</a></li>
<li><a href="#Call-chains-log_call_numbers">Call chains and <em>log_call_numbers</em></a></li>
<li><a href="#recursion-example">Indentation and call numbers with recursion</a></li>
</ul>
<h5><a href="#Dynamic-control-log_calls_settings">Dynamic control of settings using the <em>log_calls_settings</em> attribute</a></h5>
<ul>
<li><a href="#problem">The problem</a></li>
<li><a href="#solutions">Solutions</a></li>
<li><a href="#log_calls_settings">The <em>log_calls_settings</em> attribute</a></li>
<li><a href="#mapping-interface">The mapping interface and the attribute interface to settings</a></li>
<li><a href="#update-as_etc">The <em>update()</em>, <em>as_OrderedDict()</em> and <em>as_dict()</em> methods</a></li>
</ul>
<h5><a href="#Indirect-values">Dynamic control of settings with indirect values</a></h5>
<ul>
<li><a href="#format-from-above">Controlling format 'from above'</a>
<ul>
<li><a href="#indent-from-above">Controlling indentation 'from above'</a></li>
</ul>
</li>
<li><a href="#enabling-with-ints">Enabling with <em>int</em>s rather than <em>bool</em>s</a></li>
<li><a href="#log_call_settings-indirect">Using <em>log_calls_settings</em> to set indirect values</a></li>
<li><a href="#lkwarg-paradigm">Paradigms for handling keyword parameters</a></li>

</ul>
<h5><a href="#call-history-and-statistics">Call history and statistics – the <em>stats</em> attribute and the <em>*_history</em> parameters</a></h5>
<ul>
<li><a href="#stats-attribute">The <em>stats</em> attribute and <em>its</em> attributes</a></li>
<li><a href="#stats.num_calls_logged">The <em>num_calls_logged</em> attribute</a></li>
<li><a href="#stats.num_calls_total">The <em>num_calls_total</em> attribute</a></li>
<li><a href="#elapsed_secs_logged">The <em>elapsed_secs_logged</em> attribute</a></li>
<li><a href="#record_history-parameter">The <em>record_history</em> parameter</a></li>
<li><a href="#max_history-parameter">The <em>max_history</em> parameter</a></li>
<li><a href="#stats.call_history">The <em>call_history</em> attribute</a></li>
<ul>
<li><a href="#CallRecord-namedtuple">The <em>CallRecord</em> namedtuple</a></li>
<li><a href="#elapsed_secs_logged-equal-sum-etc"><em>stats.elapsed_secs_logged</em> == sum of <em>elapsed_secs</em> "column" of <em>stats.call_history</em></a></li>
</ul>
<li><a href="#stats.call_history_as_csv">The <em>call_history_as_csv</em> attribute</a></li>
<li><a href="#stats.clear_history">The <em>clear_history()</em> method</a></li>
</ul>
<h5><a href="#record_history-decorator">The <em>record_history</em> decorator</a></h5>
<h5><a href="#realistic-examples">Realistic examples</a></h5>
<ul>
<li><a href="#logging-multiple-handlers">Using a logger with multiple handlers that have different loglevels</a></li>
<li><a href="#A-metaclass-example">A metaclass example</a></li>
</ul>
<h5><a href="#KeywordParametersReference">Appendix – Keyword Parameters Reference</a></h5>
</div>


<p>  <!--TOC--></p>

<h2><span id="Preliminaries">Preliminaries</span></h2>

<h3><span id="Version">Version</span></h3>

<p>This document describes version <code>0.1.14</code> of <code>log_calls</code>.</p>

<h3><span id="Dependencies-requirements">Dependencies and requirements</span></h3>

<p>Th log_calls package has no dependencies - it requires no other packages. All it does require is a standard distribution of Python 3.2+. (The software proper probably works with 3.0 and 3.1 but hasn't been tested with those earlier versions. )</p>

<p>NOTE: This package does require the CPython implementation, as it makes assumptions about stack frame internals which may not be valid in other interpreters.</p>

<h3><span id="Installation">Installation</span></h3>

<p>You have two simple options:</p>

<ol>
<li><p>Download the compressed repository, uncompress it into a directory, and run:</p>

<p> <code>$ python setup.py install</code></p>

<p> in that directory, or</p></li>
<li><p>run</p>

<p> <code>$ pip install log_calls</code></p></li>
</ol>


<p>  to install log_calls from PyPI (the Python Package Index). Here and elsewhere,
  <code>$</code> at the <em>beginning</em> of a line indicates your command prompt, whatever it may be.</p>

<p>Whichever you choose, ideally you'll do it in a virtual environment (a <em>virtualenv</em>).</p>

<h3><span id="Testing">Running the tests</span></h3>

<p>Each <code>*.py</code> file in the log_calls directory has a corresponding test file <code>test_*.py</code> in the <code>log_calls/tests/</code> directory; <code>log_calls.py</code> has a second, <code>test_log_calls_more.py</code>. The tests provide essentially 100% coverage (98% for <code>log_calls.py</code>, 100% for the others),. All tests have passed on every tested platform + Python version; however, that's a sparse matrix :) If you encounter any turbulence, do let us know.</p>

<p>You can run the test suites either before or after installing <code>log_calls</code>.</p>

<h4><span id="tests-before-install">Running the tests before installation</span></h4>

<p>To do this, you'll need to download the compressed repository, as in 1. above.
After you uncompress the archive into a directory, and before you run the <code>python setup.py install</code> command, first run:</p>

<pre><code>$ python setup.py test
</code></pre>

<p>This will run all tests in the <code>log_calls/tests/</code> directory. This command writes a lot to the console – first its dealings with the "egg" format, then one line for each test in the test suites. To suppress the per-test output, use the "quiet" switch:</p>

<pre><code>$ python setup.py test -q
</code></pre>

<p>As an alternative, just run <code>run_tests.py</code>, in the same directory as <code>setup.py</code>:</p>

<pre><code>$ python run_tests.py [-q | -v | -h]
</code></pre>

<p>which takes switches <code>-q</code> for "quiet", <code>-v</code> for "verbose", and <code>-h</code> for "help".</p>

<h4><span id="tests-after-install">Running the tests after installation</span></h4>

<p>You can run the tests for <code>log_calls</code> after installing it, by using the command:</p>

<pre><code>$ python -m unittest discover log_calls.tests
</code></pre>

<h4><span id="tests-ok">What to expect</span></h4>

<p>All the above commands run all tests in the <code>log_calls/tests/</code> directory. If you run any of them, the output you see should end like so:</p>

<pre><code>----------------------------------------------------------------------
Ran 48 tests in 0.122s

OK
</code></pre>

<p>indicating that all went well. If any test fails, it will say so.</p>

<h4><span id="run-this-document">Run this document</span></h4>

<p>Through the magic of <code>doctest</code>, this is runnable documentation. When run in the <code>log_calls/docs/</code> directory, which contains the file <code>log_calls.md</code>, the command:</p>

<pre><code>$ python -m doctest log_calls.md
</code></pre>

<p>should return you to the prompt ($) with no other output, assuming no errors occurred in the more than 200 "tests" (in the doctest sense of "test" – any statement at the <code>&gt;&gt;&gt;</code> prompt). Verbose output from <code>doctest</code> can be had by adding the <code>-v</code> (verbose) option:</p>

<pre><code>$ python -m doctest -v log_calls.md
</code></pre>

<p>Admittedly, running this document is a bit of a stunt – at least in this case, we applaud because it can be run at all, not because it does that so well. A few of the tests had to be skipped using the <code>#doctest: +SKIP</code> directive, due to "newline" problems that don't arise with those same doctests in <code>test_doc_calls.py</code>. The module <code>test_doc_calls.py</code> has the same tests as this document, and none of them are skipped. It's part of the suite of
test suites in <code>log_calls/tests/</code>. Furthermore, the tests subdirectory <code>log_calls/tests/</code> contains tests of the other modules in the <code>log_calls</code> package, which this file doesn't attempt. So, if you're concerned enough to run any of <code>log_calls</code>'s tests at all, you may as well run all of them.</p>

<h3><span id="log_calls-path-command">The <em>log_calls-path-to-docs</em> command</span></h3>

<p>The log_calls package includes one executable Python script, <code>log_calls-path-to-docs</code>, which the installer copies to one of two places on your <code>PATH</code>:</p>

<ul>
<li><code>/usr/local/bin</code>, or</li>
<li>the <code>bin</code> directory of the <em>virtualenv</em> in which you installed the package, if you installed the package in one.</li>
</ul>


<p>This script simply prints the pathname of the HTML version of this document. If you installed <code>log_calls</code> in a <em>virtualenv</em>, you'll see something like this:</p>

<pre><code>$ log_calls-path-to-docs
_path-to-virtualenv_/lib/python3.4/site-packages/log_calls/docs/log_calls.html
</code></pre>

<p>On *nix systems you can use the output of this command in another command
that actually opens the document. On Mac OS X:</p>

<pre><code>$ open $(log_calls-path-to-docs)
</code></pre>

<p>displays the full documentation for <code>log_calls</code> in the default browser.
On other *nixes, the following will do the same:</p>

<pre><code>$ xdg-open $(log_calls-path-to-docs)
</code></pre>

<p>provided the <code>xdg-open</code> command is installed (as it is on many Linuxes).
In the absence of that command, you can explicitly specify the browser:</p>

<pre><code>$ firefox $(log_calls-path-to-docs)
</code></pre>

<p>On Windows, the file can be opened in the default browser using:</p>

<pre><code>$ log_calls-path-to-docs | cmd
</code></pre>

<p>Supplying the <code>-h</code> flag repeats these examples.</p>

<p><strong>Note</strong>: <em>If you installed</em> <code>log_calls</code> <em>in a</em> virtualenv, <em>the</em> <code>log_calls-path-to-docs</code> <em>command will only be available when that</em> virtualenv <em>is activated (and probably not otherwise – activating the</em> virtualenv <em>puts its</em> <code>bin</code> <em>directory on your</em> PATH<em>).</em></p>

<h3><span id="Acknowledgements">Acknowledgements</span></h3>

<p>Argument logging is based on the Python 2 decorator:
        <a href="https://wiki.python.org/moin/PythonDecoratorLibrary#Easy_Dump_of_Function_Arguments">https://wiki.python.org/moin/PythonDecoratorLibrary#Easy_Dump_of_Function_Arguments</a></p>

<p>Changes and improvements to the arg logging of that decorator:</p>

<ul>
<li>updated for Python 3 (names of function attributes and the like),</li>
<li>configurable separator for args,</li>
<li>handling of *args,</li>
<li>improved handling of keyword args, properly reflecting what the function receives:

<ul>
<li>the decorated function's explicit keyword args are listed one by one, and</li>
<li>if the function declares <code>**kwargs</code>, the implicit keyword args are collected in that dictionary.</li>
</ul>
</li>
<li>display of parameter default values used by calls to decorated functions.</li>
</ul>


<p><code>log_calls</code> provides a lot of flexibility. This document contains many examples covering a wide range of uses, and includes several <em>tips und tricks</em>.</p>

<h2><span id="Basic-usage">Basic usage</span></h2>

<p><code>log_calls</code> has many features, and thus many, mostly independent, keyword parameters
(14 in all). This section introduces all but four of them, one at a time,
though of course you can use multiple parameters in any call to the decorator::</p>

<ul>
<li><a href="#enabled-parameter"><code>enabled</code></a></li>
<li><a href="#args_sep-parameter"><code>args_sep</code></a></li>
<li><a href="#log_args-parameter"><code>log_args</code></a></li>
<li><a href="#log_retval-parameter"><code>log_retval</code></a></li>
<li><a href="#log_exit-parameter"><code>log_exit</code></a></li>
<li><a href="#log_call_numbers-parameter"><code>log_call_numbers</code></a></li>
<li><a href="#log_elapsed-parameter"><code>log_elapsed</code></a></li>
<li><a href="#indent-parameter"><code>indent</code></a></li>
<li><a href="#prefix-parameter"><code>prefix</code></a></li>
<li><a href="#file-parameter"><code>file</code></a></li>
</ul>


<p>The two parameters that let you output <code>log_calls</code> messages to a <code>Logger</code> (<a href="#logger-parameter"><code>logger</code></a> and <a href="#loglevel-parameter"><code>loglevel</code></a>) are discussed in <a href="#Logging">Using loggers</a>. The two that determine whether call history is retained (<a href="#record_history-parameter">record_history</a>), and then how much of it (<a href="#max_history-parameter">max_history</a>), are discussed in <a href="#call-history-and-statistics">Call history and statistics – the <em>stats</em> attribute and the <em>*_history</em> parameters</a>.</p>

<p>Every example in this document uses <code>log_calls</code>, so without further ado:</p>

<pre><code>&gt;&gt;&gt; from log_calls import log_calls
</code></pre>

<h3><span id="No-parameters">Using no parameters</span></h3>

<p>First, let's see the simplest possible examples, using no parameters at all:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f(a, b, c):
...     pass
&gt;&gt;&gt; f(1, 2, 3)
f &lt;== called by &lt;module&gt;
    arguments: a=1, b=2, c=3
f ==&gt; returning to &lt;module&gt;
</code></pre>

<p>Adding another decorated function to the call chain gives useful information too:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def g(a):
...     f(a, 2*a, 3*a)
&gt;&gt;&gt; g(3)
g &lt;== called by &lt;module&gt;
    arguments: a=3
f &lt;== called by g
    arguments: a=3, b=6, c=9
f ==&gt; returning to g
g ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="enabled-parameter">The <em>enabled</em> parameter (default – <em>True</em>)</span></h3>

<p>The next most basic example:</p>

<pre><code>&gt;&gt;&gt; @log_calls(enabled=False)
... def f(a, b, c):
...     pass
&gt;&gt;&gt; f(1, 2, 3)                # no output
</code></pre>

<h3><span id="args_sep-parameter">The <em>args_sep</em> parameter (default – <code>', '</code>)</span></h3>

<p>The <code>args_sep</code> parameter specifies the character or string used to separate
arguments. If the string ends in  (or is) <code>\n</code>, additional whitespace
is appended so that arguments line up nicely:</p>

<pre><code>&gt;&gt;&gt; @log_calls(args_sep='\\n')
... def f(a, b, c, **kwargs):
...     print(a + b + c)
&gt;&gt;&gt; f(1, 2, 3, u='you')       # doctest: +NORMALIZE_WHITESPACE, +SKIP
f &lt;== called by &lt;module&gt;
    arguments:
        a=1
        b=2
        c=3
        [**]kwargs={'u': 'you'}
6
f ==&gt; returning to &lt;module&gt;
</code></pre>

<p><strong>NOTE</strong>: <em>In all the doctest examples in this document, you'll see</em> <code>'\\n'</code>
<em>where in actual code you'd write</em> <code>'\n'</code>. <em>This is a <code>doctest</code> quirk: all
the examples herein work (as tests, they pass), and they would fail if</em>
<code>'\n'</code> <em>were used. The only alternative would be to use raw character strings
and write</em> <code>r'\n'</code>, <em>which is not obviously better.</em></p>

<h3><span id="log_args-parameter">The <em>log_args</em> parameter (default – <em>True</em>)</span></h3>

<p>When true, as seen above, arguments passed to the decorated function are
logged. If the function's signature contains positional and/or keyword
"varargs" (<code>*args</code> and/or <code>**kwargs</code>), these are included if they're nonempty.
Any default values of keyword parameters with no corresponding argument are also
logged, on a separate line.</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f_a(a, *args, something='that thing', **kwargs): pass
&gt;&gt;&gt; f_a(1, 2, 3, foo='bar')
f_a &lt;== called by &lt;module&gt;
    arguments: a=1, [*]args=(2, 3), [**]kwargs={'foo': 'bar'}
    defaults:  something='that thing'
f_a ==&gt; returning to &lt;module&gt;
</code></pre>

<p>Here, no argument information is logged at all:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_args=False)
... def f_b(a, *args, something='that thing', **kwargs): pass
&gt;&gt;&gt; f_b(1, 2, 3, foo='bar')
f_b &lt;== called by &lt;module&gt;
f_b ==&gt; returning to &lt;module&gt;
</code></pre>

<p>If a function has no parameters, <code>log_calls</code> won't display any "arguments"
section:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f(): pass
&gt;&gt;&gt; f()
f &lt;== called by &lt;module&gt;
f ==&gt; returning to &lt;module&gt;
</code></pre>

<p>If a function has parameters but is passed no arguments, <code>log_calls</code>
will display <code>arguments: &lt;none&gt;</code>, plus any default values used:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def ff(*args, **kwargs): pass
&gt;&gt;&gt; ff()
ff &lt;== called by &lt;module&gt;
    arguments: &lt;none&gt;
ff ==&gt; returning to &lt;module&gt;

&gt;&gt;&gt; @log_calls()
... def fff(*args, kw='doh', **kwargs): pass
&gt;&gt;&gt; fff()
fff &lt;== called by &lt;module&gt;
    arguments: &lt;none&gt;
    defaults:  kw='doh'
fff ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="log_retval-parameter">The <em>log_retval</em> parameter (default – <em>False</em>)</span></h3>

<p>When true, this parameter displays the value returned by the function:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_retval=True)
... def f(a, b, c):
...     return a + b + c
&gt;&gt;&gt; _ = f(1, 2, 3)
f &lt;== called by &lt;module&gt;
    arguments: a=1, b=2, c=3
    f return value: 6
f ==&gt; returning to &lt;module&gt;
</code></pre>

<p>Return values longer than 60 characters are truncated and end with
a trailing ellipsis:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_retval=True)
... def return_long_str():
...     return '*' * 100
&gt;&gt;&gt; return_long_str()           # doctest: +NORMALIZE_WHITESPACE
return_long_str &lt;== called by &lt;module&gt;
return_long_str return value: ************************************************************...
return_long_str ==&gt; returning to &lt;module&gt;
'****************************************************************************************************'
</code></pre>

<h3><span id="log_exit-parameter">The <em>log_exit</em> parameter (default – <em>True</em>)</span></h3>

<p>When false, this parameter suppresses the <code>... ==&gt; returning to ...</code> line
that indicates the function's return to its caller.</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_exit=False)
... def f(a, b, c):
...     return a + b + c
&gt;&gt;&gt; _ = f(1, 2, 3)
f &lt;== called by &lt;module&gt;
    arguments: a=1, b=2, c=3
</code></pre>

<h3><span id="log_call_numbers-parameter">The <em>log_call_numbers</em> parameter (default – <em>False</em>)</span></h3>

<p><code>log_calls</code> keeps a running tally of the number of times a decorated function
is called. You can display this (1-based) number using the <code>log_call_numbers</code> parameter:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_call_numbers=True)
... def f(): pass
&gt;&gt;&gt; for i in range(2): f()
f [1] &lt;== called by &lt;module&gt;
f [1] ==&gt; returning to &lt;module&gt;
f [2] &lt;== called by &lt;module&gt;
f [2] ==&gt; returning to &lt;module&gt;
</code></pre>

<p>The call number is also displayed when <code>log_retval</code> is true:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_call_numbers=True, log_retval=True)
... def f():
...     return 81
&gt;&gt;&gt; _ = f()
f [1] &lt;== called by &lt;module&gt;
    f [1] return value: 81
f [1] ==&gt; returning to &lt;module&gt;
</code></pre>

<p>This is particularly valuable in the presence of recursion, for example.
See the <a href="#recursion-example">recursion example</a> later, where the feature
is used to good effect.</p>

<p><strong>NOTE</strong>: <em>As we'll see later, logging for a decorated function
can be turned on and off dynamically. In fact,</em> <code>log_calls</code> <em>also tracks the total
number of calls to a decorated function, and that number is accessible too –
see the section on <a href="#stats.num_calls_total">the<em> <code>stats.num_calls_total</code> </em>attribute</a>.
When the</em> <code>log_call_numbers</code> <em>setting is true, the call number displayed is
the logged call number - the rank of that call among the calls to the function
when logging has been enabled. For example, suppose you call</em> <code>f</code> <em>17 times with logging
enabled and with</em> <code>log_call_numbers</code> <em>enabled; then you turn logging off and call</em> <code>f</code>
<em>3 times; finally you re-enable logging and call</em> <code>f</code> <em>again: the number displayed will
be 18, not 21.</em></p>

<h3><span id="log_elapsed-parameter">The <em>log_elapsed</em> parameter (default – <em>False</em>)</span></h3>

<p>For performance profiling, you can measure the time it took a function to execute
by using the <code>log_elapsed</code> keyword. When true, <code>log_calls</code> reports the time the
decorated function took to complete, in seconds:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_elapsed=True)
... def f(n):
...     for i in range(n):
...         # do something time-critical
...         pass
&gt;&gt;&gt; f(5000)                 # doctest: +ELLIPSIS
f &lt;== called by &lt;module&gt;
    arguments: n=5000
    elapsed time: ... [secs]
f ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="indent-parameter">The <em>indent</em> parameter (default - <em>False</em>)</span></h3>

<p>The <code>indent</code> parameter, when true, indents each new level of logged messages
by 4 spaces, providing a visualization of the call hierarchy.
(<code>log_calls</code> indents only when using <code>print</code>, not when <a href="#Logging">using loggers</a>.)</p>

<p>A decorated function's logged output is indented only as much as is necessary.
Here, the even numbered functions don't indent, so the indented functions
that they call are indented just one level more than their "inherited"
indentation level:</p>

<pre><code>&gt;&gt;&gt; @log_calls(indent=True)
... def g1():
...     pass
&gt;&gt;&gt; @log_calls()    # no extra indentation for g1
... def g2():
...     g1()
&gt;&gt;&gt; @log_calls(indent=True)
... def g3():
...     g2()
&gt;&gt;&gt; @log_calls()    # no extra indentation for g3
... def g4():
...     g3()
&gt;&gt;&gt; @log_calls(indent=True)
... def g5():
...     g4()
&gt;&gt;&gt; g5()
g5 &lt;== called by &lt;module&gt;
g4 &lt;== called by g5
    g3 &lt;== called by g4
    g2 &lt;== called by g3
        g1 &lt;== called by g2
        g1 ==&gt; returning to g2
    g2 ==&gt; returning to g3
    g3 ==&gt; returning to g4
g4 ==&gt; returning to g5
g5 ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="prefix-parameter">The <em>prefix</em> parameter (default - <code>''</code>): decorating methods</span></h3>

<p>Especially useful for clarity when decorating methods, the <code>prefix</code> keyword
parameter lets you specify a string with which to prefix the name of the
method. <code>log_calls</code> uses the prefixed name in its output: when logging
a call to, and a return from, the method; when reporting the method's return
value; and when the method is at the end of a <a href="#Call-chains">call or return chain</a>.</p>

<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; class Point():
...     # NOTE: You can't decorate __init__ :D
...     def __init__(self, x, y):
...         self.x = x
...         self.y = y
...     @staticmethod
...     @log_calls(prefix='Point.')
...     def distance(pt1, pt2):
...         return math.sqrt((pt1.x - pt2.x)**2 + (pt1.y - pt2.y)**2)
...     @log_calls(log_retval=True, prefix='Point.')
...     def length(self):
...         return self.distance(self, Point(0, 0))
...     @log_calls(prefix='Point.')
...     def diag_reflect(self):
...         self.x, self.y = self.y, self.x
...         return self
...     def __repr__(self):
...         return "Point" + str((self.x, self.y))

&gt;&gt;&gt; print("Point(1, 2).diag_reflect() =", Point(1, 2).diag_reflect())
Point.diag_reflect &lt;== called by &lt;module&gt;
    arguments: self=Point(1, 2)
Point.diag_reflect ==&gt; returning to &lt;module&gt;
Point(1, 2).diag_reflect() = Point(2, 1)

&gt;&gt;&gt; print("length of Point(1, 2) =", round(Point(1, 2).length(), 2))  # doctest: +ELLIPSIS
Point.length &lt;== called by &lt;module&gt;
    arguments: self=Point(1, 2)
Point.distance &lt;== called by Point.length
    arguments: pt1=Point(1, 2), pt2=Point(0, 0)
Point.distance ==&gt; returning to Point.length
    Point.length return value: 2.236...
Point.length ==&gt; returning to &lt;module&gt;
length of Point(1, 2) = 2.24
</code></pre>

<p>The test suite <code>tests/test_log_calls_more.py</code> contains more examples of using
<code>log_calls</code> with methods of all kinds – instance methods, classmethods and staticmethods.</p>

<h3><span id="file-parameter">The <em>file</em> parameter (default - <em>sys.stdout</em>)</span></h3>

<p>The <code>file</code> parameter specifies a stream (an instance of <code>io.TextIOBase</code>) to which
<code>log_calls</code> will print its messages. This value is supplied to the <code>file</code> keyword
parameter of the <code>print</code> function, and, like that parameter, its default value is
<code>sys.stdout</code>. This parameter is ignored if you've supplied a logger for output
using the <a href="#logger-parameter"><code>logger</code></a> parameter.</p>

<p>If your program writes to the console a lot, you may not want <code>log_calls</code> messages
interspersed with your real output: your understanding of both logically distinct
streams can be compromised, so, better to make them two actually distinct streams.
It can also be advantageous to gather all, and only all, of the log_calls messages
in one place. You can use <code>indent=True</code> with a file, and the indentations will
appear as intended, whereas that's not possible with loggers.</p>

<p>It's not possible to test this feature with doctest (in fact, there are subtleties
to supporting this feature and using doctest at all), so we'll just give an example
of writing to <code>stderr</code>, and reproduce the output:</p>

<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; @log_calls(file=sys.stderr, indent=True)
... def f(n):
...     if n &lt;= 0:
...         return 'a'
...     return '(' + f(n-1) + ')'
</code></pre>

<p>Running <code>&gt;&gt;&gt; f(2)</code> will return '((a))' and will write the following to <code>stderr</code>:</p>

<pre><code>f &lt;== called by &lt;module&gt;
    f &lt;== called by f
        arguments: n=1
        f &lt;== called by f
            arguments: n=0
        f ==&gt; returning to f
    f ==&gt; returning to f
f ==&gt; returning to &lt;module&gt;
</code></pre>

<h2><span id="Logging">Using loggers</span></h2>

<p><code>log_calls</code> works well with loggers obtained from Python's <code>logging</code> module.
First, we'll set up a logger with a single handler that writes to the console.
Because <code>doctest</code> doesn't capture output written to <code>stderr</code> (the default stream
to which console handlers write), we'll send the console handler's output to
<code>stdout</code>, using the format <code>&lt;loglevel&gt;:&lt;loggername&gt;:&lt;message&gt;</code>.</p>

<pre><code>&gt;&gt;&gt; import logging
&gt;&gt;&gt; import sys
&gt;&gt;&gt; ch = logging.StreamHandler(stream=sys.stdout)
&gt;&gt;&gt; c_formatter = logging.Formatter('%(levelname)8s:%(name)s:%(message)s')
&gt;&gt;&gt; ch.setFormatter(c_formatter)
&gt;&gt;&gt; logger = logging.getLogger('a_logger')
&gt;&gt;&gt; logger.addHandler(ch)
&gt;&gt;&gt; logger.setLevel(logging.DEBUG)
</code></pre>

<h3><span id="logger-parameter">The <em>logger</em> parameter (default – <em>None</em>)</span></h3>

<p>The <code>logger</code> keyword parameter tells <code>log_calls</code> to write its output using
that logger rather than the <code>print</code> function:</p>

<pre><code>&gt;&gt;&gt; @log_calls(logger=logger)
... def somefunc(v1, v2):
...     logger.debug(v1 + v2)
&gt;&gt;&gt; somefunc(5, 16)             # doctest: +NORMALIZE_WHITESPACE
DEBUG:a_logger:somefunc &lt;== called by &lt;module&gt;
DEBUG:a_logger:    arguments: v1=5, v2=16
DEBUG:a_logger:21
DEBUG:a_logger:somefunc ==&gt; returning to &lt;module&gt;

&gt;&gt;&gt; @log_calls(logger=logger)
... def anotherfunc():
...     somefunc(17, 19)
&gt;&gt;&gt; anotherfunc()       # doctest: +NORMALIZE_WHITESPACE
DEBUG:a_logger:anotherfunc &lt;== called by &lt;module&gt;
DEBUG:a_logger:somefunc &lt;== called by anotherfunc
DEBUG:a_logger:    arguments: v1=17, v2=19
DEBUG:a_logger:36
DEBUG:a_logger:somefunc ==&gt; returning to anotherfunc
DEBUG:a_logger:anotherfunc ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="loglevel-parameter">The <em>loglevel</em> parameter (default – <em>logging.DEBUG</em>)</span></h3>

<p><code>log_calls</code> also takes a <code>loglevel</code> keyword parameter, whose value must be
one of the <code>logging</code> module's constants - <code>logging.DEBUG</code>, <code>logging.INFO</code>, etc.
– or a custom logging level if you've added any. <code>log_calls</code> writes output messages
using <code>logger.log(loglevel, …)</code>. Thus, if the <code>logger</code>'s log level is higher than
<code>loglevel</code>, no output will appear:</p>

<pre><code>&gt;&gt;&gt; logger.setLevel(logging.INFO)   # raise logger's level to INFO
&gt;&gt;&gt; @log_calls(logger='logger_=', loglevel=logging.DEBUG)
... def f(x, y, z, **kwargs):
...     return y + z
&gt;&gt;&gt; # No log_calls output from f
&gt;&gt;&gt; # because loglevel for f &lt; level of logger
&gt;&gt;&gt; f(1,2,3, enable=True, sep_='\\n', logger_=logger)       # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS
5
</code></pre>

<p>The use of loggers, and of these parameters, is explored further in the later
example <a href="#logging-multiple-handlers">Using a logger with multiple handlers that have different loglevels</a>.</p>

<h2><span id="Call-chains">Call chains</span></h2>

<p><code>log_calls</code> does its best to chase back along the call chain to find
the first <em>enabled</em> <code>log_calls</code>-decorated function on the stack.
If there's no such function, it just displays the immediate caller.
If there is such a function, however, it displays the entire list of
functions on the stack up to and including that function when reporting
calls and returns. Without this, you'd have to guess at what was called
in between calls to functions decorated by <code>log_calls</code>. If you specified
a prefix for the decorated caller on the end of a call chain, <code>log_calls</code>
will use the prefixed name:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def g1():
...     pass
&gt;&gt;&gt; def g2():
...     g1()
&gt;&gt;&gt; @log_calls(prefix='mid.')
... def g3():
...     g2()
&gt;&gt;&gt; def g4():
...     g3()
&gt;&gt;&gt; @log_calls()
... def g5():
...     g4()
&gt;&gt;&gt; g5()
g5 &lt;== called by &lt;module&gt;
mid.g3 &lt;== called by g4 &lt;== g5
g1 &lt;== called by g2 &lt;== mid.g3
g1 ==&gt; returning to g2 ==&gt; mid.g3
mid.g3 ==&gt; returning to g4 ==&gt; g5
g5 ==&gt; returning to &lt;module&gt;
</code></pre>

<p>In the next example, <code>g</code> is <code>log_calls</code>-decorated but logging is disabled,
so the reported call chain for <code>f</code> stops at its immediate caller:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f(): pass
&gt;&gt;&gt; def not_decorated(): f()
&gt;&gt;&gt; @log_calls(enabled=False, log_call_numbers=True)
... def g(): not_decorated()
&gt;&gt;&gt; g()
f &lt;== called by not_decorated
f ==&gt; returning to not_decorated
</code></pre>

<p>Elaborating on the previous example, here are longer call chains with an
intermediate decorated function that has logging disabled:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def e(): pass
&gt;&gt;&gt; def not_decorated_call_e(): e()
&gt;&gt;&gt; @log_calls()
... def f(): not_decorated_call_e()
&gt;&gt;&gt; def not_decorated_call_f(): f()
&gt;&gt;&gt; @log_calls(enabled=False, log_call_numbers=True)
... def g(): not_decorated_call_f()
&gt;&gt;&gt; @log_calls()
... def h(): g()
&gt;&gt;&gt; h()
h &lt;== called by &lt;module&gt;
f &lt;== called by not_decorated_call_f &lt;== g &lt;== h
e &lt;== called by not_decorated_call_e &lt;== f
e ==&gt; returning to not_decorated_call_e ==&gt; f
f ==&gt; returning to not_decorated_call_f ==&gt; g ==&gt; h
h ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="indent-parameter-another">Another <em>indent</em> example</span></h3>

<p>In the next example, <code>g3</code> has logging disabled, so calls to it are not logged.
<code>log_calls</code> chases back to the nearest <em>enabled</em> decorated function, so that there
aren't gaps between call chains. The indentation levels are as you'd hope them to be:</p>

<pre><code>&gt;&gt;&gt; @log_calls(indent=True)
... def g1():
...     pass
&gt;&gt;&gt; def g2():
...     g1()
&gt;&gt;&gt; @log_calls(enabled=False, indent=True)    # not logged, causes no indentation for g1
... def g3():
...     g2()
&gt;&gt;&gt; @log_calls(indent=True)
... def g4():
...     g3()
&gt;&gt;&gt; @log_calls(indent=True)
... def g5():
...     g4()
&gt;&gt;&gt; g5()
g5 &lt;== called by &lt;module&gt;
    g4 &lt;== called by g5
        g1 &lt;== called by g2 &lt;== g3 &lt;== g4
        g1 ==&gt; returning to g2 ==&gt; g3 ==&gt; g4
    g4 ==&gt; returning to g5
g5 ==&gt; returning to &lt;module&gt;
</code></pre>

<p>We'll continue to use <code>indent</code> throughout this section.</p>

<h3><span id="Call-chains-inner-functions">Call chains and inner functions</span></h3>

<p>When chasing back along the stack, <code>log_calls</code> also detects inner functions that it has decorated:</p>

<pre><code>&gt;&gt;&gt; @log_calls(indent=True)
... def h0(z):
...     pass
&gt;&gt;&gt; def h1(x):
...     @log_calls(indent=True)
...     def h1_inner(y):
...         h0(x*y)
...     return h1_inner
&gt;&gt;&gt; def h2():
...     h1(2)(3)
&gt;&gt;&gt; def h3():
...     h2()
&gt;&gt;&gt; def h4():
...     @log_calls(indent=True)
...     def h4_inner():
...         h3()
...     return h4_inner
&gt;&gt;&gt; @log_calls(indent=True)
... def h5():
...     h4()()
&gt;&gt;&gt; h5()
h5 &lt;== called by &lt;module&gt;
    h4_inner &lt;== called by h5
        h1_inner &lt;== called by h2 &lt;== h3 &lt;== h4_inner
            arguments: y=3
            h0 &lt;== called by h1_inner
                arguments: z=6
            h0 ==&gt; returning to h1_inner
        h1_inner ==&gt; returning to h2 ==&gt; h3 ==&gt; h4_inner
    h4_inner ==&gt; returning to h5
h5 ==&gt; returning to &lt;module&gt;
</code></pre>

<p>... even when the inner function is called from within the outer function
it's defined in:</p>

<pre><code>&gt;&gt;&gt; @log_calls(indent=True)
... def j0():
...     pass
&gt;&gt;&gt; def j1():
...     j0()
&gt;&gt;&gt; def j2():
...     @log_calls(indent=True)
...     def j2_inner():
...         j1()
...     j2_inner()
&gt;&gt;&gt; @log_calls(indent=True)
... def j3():
...     j2()
&gt;&gt;&gt; j3()
j3 &lt;== called by &lt;module&gt;
    j2_inner &lt;== called by j2 &lt;== j3
        j0 &lt;== called by j1 &lt;== j2_inner
        j0 ==&gt; returning to j1 ==&gt; j2_inner
    j2_inner ==&gt; returning to j2 ==&gt; j3
j3 ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="Call-chains-log_call_numbers">Call chains and <em>log_call_numbers</em></span></h3>

<p>If a decorated function <code>g</code> calls another decorated function <code>f</code>,
and if <code>f</code> is enabled and has <code>log_call_numbers</code> set to true,
then the call number of f will be displayed in the call chain:</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f(): pass
&gt;&gt;&gt; def not_decorated(): f()
&gt;&gt;&gt; @log_calls(log_call_numbers=True)
... def g(): not_decorated()
&gt;&gt;&gt; g()
g [1] &lt;== called by &lt;module&gt;
f &lt;== called by not_decorated &lt;== g [1]
f ==&gt; returning to not_decorated ==&gt; g [1]
g [1] ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="recursion-example">Indentation and call numbers with recursion</span></h3>

<p>These features are especially useful in recursive and mutually recursive situations. We have to use <code>OrderedDict</code>s here because of doctest:</p>

<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; @log_calls(log_call_numbers=True, log_retval=True, indent=True)
... def depth(d, key=None):
...     if not isinstance(d, dict):
...         return 0    # base case
...     elif not d:
...         return 1
...     else:
...         return max(map(depth, d.values(), d.keys())) + 1
&gt;&gt;&gt; depth(
...     OrderedDict(
...         (('a', 0),
...          ('b', OrderedDict( (('c1', 10), ('c2', 11)) )),
...          ('c', 'text'))
...     )
... )
depth [1] &lt;== called by &lt;module&gt;
    arguments: d=OrderedDict([('a', 0), ('b', OrderedDict([('c1', 10), ('c2', 11)])), ('c', 'text')])
    defaults:  key=None
    depth [2] &lt;== called by depth [1]
        arguments: d=0, key='a'
        depth [2] return value: 0
    depth [2] ==&gt; returning to depth [1]
    depth [3] &lt;== called by depth [1]
        arguments: d=OrderedDict([('c1', 10), ('c2', 11)]), key='b'
        depth [4] &lt;== called by depth [3]
            arguments: d=10, key='c1'
            depth [4] return value: 0
        depth [4] ==&gt; returning to depth [3]
        depth [5] &lt;== called by depth [3]
            arguments: d=11, key='c2'
            depth [5] return value: 0
        depth [5] ==&gt; returning to depth [3]
        depth [3] return value: 1
    depth [3] ==&gt; returning to depth [1]
    depth [6] &lt;== called by depth [1]
        arguments: d='text', key='c'
        depth [6] return value: 0
    depth [6] ==&gt; returning to depth [1]
    depth [1] return value: 2
depth [1] ==&gt; returning to &lt;module&gt;
2
</code></pre>

<p><strong>NOTE</strong>: <em>The optional</em> <code>key</code> <em>parameter is for instructional purposes,
so you can see the key that's paired with the value of</em> <code>d</code> <em>in the caller's
dictionary. Typically the signature of this function would be just</em> <code>def depth(d)</code>,
<em>and the recursive case would return</em> <code>max(map(depth, d.values())) + 1</code>.</p>

<h2><span id="Dynamic-control-log_calls_settings">Dynamic control of settings using the <em>log_calls_settings</em> attribute</span></h2>

<p>The values given for the parameters of <code>log_calls</code>, e.g. <code>enabled=True</code>,
<code>args_sep=" / "</code>, are set once the decorated function is interpreted.
The values are established once and for all when the Python interpreter
parses the definition of a decorated function and creates a function object.</p>

<h3><span id="problem">The problem</span></h3>

<p>Even if a variable is used as a parameter value, its value at the time
Python processes the definition is "frozen" for the created function object.
Subsequently changing the value of the variable will <em>not</em> affect the behavior
of the decorator.</p>

<p>For example, suppose <code>DEBUG</code> is a module-level variable initialized to <code>False</code>:</p>

<pre><code>&gt;&gt;&gt; DEBUG = False
</code></pre>

<p>and you use this code:</p>

<pre><code>&gt;&gt;&gt; @log_calls(enabled=DEBUG)
... def foo(**kwargs):
...     pass
&gt;&gt;&gt; foo()       # No log_calls output: DEBUG is False
</code></pre>

<p>If later you set <code>Debug = True</code> and call <code>foo</code>, that call won't be logged,
because the decorated <code>foo</code>'s <em>enabled</em> setting is bound to the original value
of <code>DEBUG</code>, established when the definition was processed:</p>

<pre><code>&gt;&gt;&gt; DEBUG = True
&gt;&gt;&gt; foo()       # Still no log_calls output
</code></pre>

<h3><span id="solutions">Solutions</span></h3>

<p><code>log_calls</code> provides <em>two</em> ways to dynamically control the settings of a decorated function.
This section presents one of them – using <code>log_calls_settings</code>. The next section,
on <a href="#Indirect-values">indirect values</a>, discusses another, rather different solution,
one which is more intrusive but which affords even more control.</p>

<h3><span id="log_calls_settings">The <em>log_calls_settings</em> attribute</span></h3>

<p>The <code>log_calls</code> decorator adds an attribute <code>log_calls_settings</code>
to a decorated function, through which you can access the decorator settings
for that function. This attribute is an object which lets you control
the settings for a decorated function via a mapping (dict-like) interface,
and equivalently, via attributes of the object. The mapping keys and
the attribute names are simply the <code>log_calls</code> keywords. <code>log_calls_settings</code>
also implements many of the standard <code>dict</code> methods for interacting with the
settings in familiar ways. It's an instance of the <code>DecoSettingsMapping</code> class,
defined in <code>deco_settings.py</code>.
That class has its own tests, in <code>log_calls/tests/test_deco_settings.py</code>,
so there's no need to test it exhaustively here; we'll just go over how to use it.</p>

<h3><span id="mapping-interface">The mapping interface and the attribute interface to settings</span></h3>

<p>Once you've decorated a function with <code>log_calls</code>,</p>

<pre><code>&gt;&gt;&gt; @log_calls()
... def f(*args, **kwargs):
...     return 91
</code></pre>

<p>you can access and change its settings via the <code>log_calls_settings</code> attribute
of the decorated function, which behaves like a dictionary. You can read and
write settings using the <code>log_calls</code> keywords as keys:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings['enabled']
True
&gt;&gt;&gt; f.log_calls_settings['enabled'] = False
&gt;&gt;&gt; _ = f()                   # no output (not even 91, because of "_ = ")
&gt;&gt;&gt; f.log_calls_settings['enabled']
False
&gt;&gt;&gt; f.log_calls_settings['log_retval']
False
&gt;&gt;&gt; f.log_calls_settings['log_retval'] = True
&gt;&gt;&gt; f.log_calls_settings['log_elapsed']
False
&gt;&gt;&gt; f.log_calls_settings['log_elapsed'] = True
</code></pre>

<p>The <code>log_calls_settings</code> attribute has a length:</p>

<pre><code>&gt;&gt;&gt; len(f.log_calls_settings)
14
</code></pre>

<p>Its keys and items can be iterated through:</p>

<pre><code>&gt;&gt;&gt; keys = []
&gt;&gt;&gt; for k in f.log_calls_settings: keys.append(k)
&gt;&gt;&gt; keys                                            # doctest: +NORMALIZE_WHITESPACE
['enabled', 'args_sep', 'log_args', 
'log_retval', 'log_elapsed', 'log_exit', 
 'indent', 'log_call_numbers',
 'prefix', 'file',
 'logger', 'loglevel',
 'record_history', 'max_history']
&gt;&gt;&gt; items = []
&gt;&gt;&gt; for k, v in f.log_calls_settings.items(): items.append((k, v))
&gt;&gt;&gt; items                                           # doctest: +NORMALIZE_WHITESPACE
[('enabled', False), ('args_sep', ', '), ('log_args', True), 
 ('log_retval', True), ('log_elapsed', True), ('log_exit', True), 
 ('indent', False), ('log_call_numbers', False),
 ('prefix', ''), ('file', None),
 ('logger', None), ('loglevel', 10),
 ('record_history', False), ('max_history', 0)]
</code></pre>

<p>You can use <code>in</code> to test for key membership:</p>

<pre><code>&gt;&gt;&gt; 'enabled' in f.log_calls_settings
True
&gt;&gt;&gt; 'no_such_setting' in f.log_calls_settings
False
</code></pre>

<p>As with an ordinary dictionary, attempting to access a nonexistent setting
raises <code>KeyError</code>:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings['new_key']                 # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
    ...
KeyError: ...
</code></pre>

<p>Unlike an ordinary dictionary, you can't add new keys – the <code>log_calls_settings</code>
dictionary is closed to new members, and attempts to add one will raise <code>KeyError</code>:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings['new_key'] = 'anything'    # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
    ...
KeyError: ...
</code></pre>

<p>You can use the same keywords as attributes of <code>log_calls_settings</code>
instead of as keywords to the mapping interface; they're completely
equivalent:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.log_elapsed
True
&gt;&gt;&gt; f.log_calls_settings.log_call_numbers
False
&gt;&gt;&gt; f.log_calls_settings.log_call_numbers = True
&gt;&gt;&gt; f.log_calls_settings.enabled = True     # turn it back on!
&gt;&gt;&gt; _ = f()                                 # doctest: +ELLIPSIS
f [1] &lt;== called by &lt;module&gt;
    arguments: &lt;none&gt;
    f [1] return value: 91
    elapsed time: ... [secs]
f [1] ==&gt; returning to &lt;module&gt;
&gt;&gt;&gt; f.log_calls_settings.log_args = False
&gt;&gt;&gt; f.log_calls_settings.log_elapsed = False
&gt;&gt;&gt; f.log_calls_settings.log_retval = False
&gt;&gt;&gt; f()                                     # doctest: +ELLIPSIS
f [2] &lt;== called by &lt;module&gt;
f [2] ==&gt; returning to &lt;module&gt;
91
</code></pre>

<p>The only difference is that you <em>can</em> add a new attribute to <code>log_calls_settings</code>,
simply by using it:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.new_attr = 'something'
&gt;&gt;&gt; f.log_calls_settings.new_attr
'something'
</code></pre>

<p>But, of course, the new attribute does not become a decorator setting:</p>

<pre><code>&gt;&gt;&gt; 'new_attr' in f.log_calls_settings
False
</code></pre>

<h3><span id="update-as_etc">The <em>update()</em>, <em>as_OrderedDict()</em> and <em>as_dict()</em> methods</span></h3>

<p>The <code>log_calls_settings</code> object provides an <code>update()</code> method so that
you can update several settings at once:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.update(
...     log_args=True, log_elapsed=False, log_call_numbers=False,
...     log_retval=False)
&gt;&gt;&gt; _ = f()
f &lt;== called by &lt;module&gt;
    arguments: &lt;none&gt;
f ==&gt; returning to &lt;module&gt;
</code></pre>

<p>You can retrieve the entire collection of settings as either an <code>OrderedDict</code>
using the <code>as_OrderedDict()</code> method, or as a <code>dict</code> using <code>as_dict()</code>.
Either can serve as a snapshot of the settings, so that you can change settings
temporarily, use the new settings, and then restore settings from the snapshot.
in addition to taking keyword arguments, as shown above, the <code>update()</code> method
can take one or more dicts – in particular, a dictionary retrieved from one of
the <code>as_*</code> methods. For example:</p>

<p>Retrieve settings (here, as an <code>OrderedDict</code> because it's more doctest-friendly,
but using <code>as_dict()</code> is sufficient):</p>

<pre><code>&gt;&gt;&gt; od = f.log_calls_settings.as_OrderedDict()
&gt;&gt;&gt; od                      # doctest: +NORMALIZE_WHITESPACE
OrderedDict([('enabled', True),           ('args_sep', ', '),
             ('log_args', True),          ('log_retval', False),
             ('log_elapsed', False),      ('log_exit', True),
             ('indent', False),           ('log_call_numbers', False),
             ('prefix', ''),              ('file', None),
             ('logger', None),            ('loglevel', 10),
             ('record_history', False),   ('max_history', 0)])
</code></pre>

<p>change settings temporarily:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.update(
...     log_args=False, log_elapsed=True, log_call_numbers=True,
...     log_retval=True)
</code></pre>

<p>use the new settings for <code>f</code>:</p>

<pre><code>&gt;&gt;&gt; _ = f()                     # doctest: +ELLIPSIS
f [4] &lt;== called by &lt;module&gt;
    f [4] return value: 91
    elapsed time: ... [secs]
f [4] ==&gt; returning to &lt;module&gt;
</code></pre>

<p>and restore original settings, this time passing the retrieved settings
dictionary rather than keywords:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.update(od)
&gt;&gt;&gt; od == f.log_calls_settings.as_OrderedDict()
True
</code></pre>

<p><strong>NOTES</strong>:</p>

<ol>
<li><p><em>The <a href="#max_history-parameter"><code>max_history</code></a> setting is immutable (no other setting is), and attempts to change it
directly (e.g.</em> <code>f.log_calls_settings.max_history = anything</code>) <em>raise</em> <code>ValueError</code>.
<em>Nevertheless, it</em> is <em>an item in the retrieved settings dictionaries. To allow for
the use-case just illustrated, <code>update()</code> is considerate enough to skip over
immutable settings.</em></p></li>
<li><p><code>log_calls</code> <em>continues to track call numbers even when it isn't reporting
them. The last call to</em> <code>f</code> <em>was the 4th, as shown, although the call number of
the 3rd call wasn't displayed.</em></p></li>
</ol>


<h2><span id="Indirect-values">Dynamic control of settings with indirect values</span></h2>

<p>Every parameter of <code>log_calls</code> except <code>prefix</code> and <code>max_history</code> can take
two kinds of values: <em>direct</em> and <em>indirect</em>, which you can think of as
<em>static</em> and <em>dynamic</em> respectively. Direct/static values are actual values
used when the decorated function is interpreted, e.g. <code>enabled=True</code>,
<code>args_sep=" / "</code>. As discussed in the previous section on
<a href="#Dynamic-control-log_calls_settings"><code>log_call_settings</code></a>, the values of
parameters are set once and for all when the Python interpreter creates
a function object from the source code of a decorated function. Even if you
use a variable as the value of a setting, subsequently changing the variable's
value has no effect on the decorator's setting.</p>

<p><code>log_calls</code> provides a second way to overcome this limitation. The decorator
lets you specify any parameter
except <code>prefix</code> or <code>max_history</code> with one level of indirection, by using
<em>indirect values</em>: an indirect value is a string that names a keyword argument
<em>of the decorated function</em>. It can be an explicit keyword argument present
in the signature of the function, or an implicit keyword argument that ends up
in <code>**kwargs</code> (if that's present in the function's signature). When the decorated
function is called, the arguments passed by keyword, and the decorated function's
explicit keyword parameters with default values, are both searched for the named
parameter; if it is found and of the correct type, <em>its</em> value is used; otherwise
a default value is used.</p>

<p>To specify an indirect value for a parameter whose normal type is <code>str</code> (only
<code>args_sep</code>, at present), append an <code>'='</code> to the value.  For consistency's sake,
any indirect value can end in a trailing <code>'='</code>, which is stripped. Thus,
<code>enabled='enable_='</code> indicates an indirect value supplied by the keyword (argument or
parameter) <code>enable_</code> of the decorated function.</p>

<p>Thus, in:</p>

<pre><code>&gt;&gt;&gt; @log_calls(args_sep='sep=', prefix="*** ")
... def f(a, b, c, sep='|'): pass
</code></pre>

<p><code>args_sep</code> has an indirect value which names <code>f</code>'s explicit keyword parameter <code>sep</code>,
and <code>prefix</code> has a direct value. A call can dynamically override the default
value '|' in the signature of <code>f</code> by supplying a value:</p>

<pre><code>&gt;&gt;&gt; f(1, 2, 3, sep=' / ')
*** f &lt;== called by &lt;module&gt;
    arguments: a=1 / b=2 / c=3 / sep=' / '
*** f ==&gt; returning to &lt;module&gt;
</code></pre>

<p>or it can use <code>f</code>'s default value by not supplying a <code>sep</code> argument:</p>

<pre><code>&gt;&gt;&gt; f(1, 2, 3)
*** f &lt;== called by &lt;module&gt;
    arguments: a=1|b=2|c=3
    defaults:  sep='|'
*** f ==&gt; returning to &lt;module&gt;
</code></pre>

<p><em>A decorated function doesn't have to explicitly declare the parameter
named as an indirect value</em>, if its signature includes <code>**kwargs</code>:
the intermediate parameter can be an implicit keyword parameter,
passed by a caller but not present in the function's signature.
Consider:</p>

<pre><code>&gt;&gt;&gt; @log_calls(enabled='enable')
... def func1(a, b, c, **kwargs): pass
&gt;&gt;&gt; @log_calls(enabled='enable')
... def func2(z, **kwargs): func1(z, z+1, z+2, **kwargs)
</code></pre>

<p>When the following statement is executed, the calls to both <code>func1</code> and <code>func2</code> will be logged:</p>

<pre><code>&gt;&gt;&gt; func2(17, enable=True)
func2 &lt;== called by &lt;module&gt;
    arguments: z=17, [**]kwargs={'enable': True}
func1 &lt;== called by func2
    arguments: a=17, b=18, c=19, [**]kwargs={'enable': True}
func1 ==&gt; returning to func2
func2 ==&gt; returning to &lt;module&gt;
</code></pre>

<p>whereas neither of the following two statements will trigger logging:</p>

<pre><code>&gt;&gt;&gt; func2(42, enable=False)     # no log_calls output
&gt;&gt;&gt; func2(99)                   # no log_calls output
</code></pre>

<p><strong>NOTE</strong>: <em>This last example illustrates a subtle point:
if you omit the</em> <code>enabled</code> <em>parameter altogether, logging will occur,
as the default value is (the direct value)</em> <code>True</code>; <em>however, if you
specify an indirect value for</em> <code>enabled</code> <em>and the named indirect
keyword is not supplied in a call, then that call</em> won't <em>be logged.
In other words, if you specify an indirect value for the</em> <code>enabled</code> <em>parameter
then the effective default value of the enabled setting is</em> <code>False</code><em> --
calls are not logged unless the named parameter is found and its value is true.</em></p>

<h3><span id="format-from-above">Controlling format 'from above'</span></h3>

<p>This indirection mechanism allows a calling function to control the appearance
of logged calls to functions lower in the call chain, provided they all use
the same indirect parameter keywords.</p>

<p>In the next example, the separator value supplied to <code>g</code> by keyword argument
propagates to <code>f</code>. Note that the arguments <code>42</code> and <code>99</code> end up in <code>g</code>'s
positional <em>varargs</em> tuple. We've used non-generic names for the <em>varargs</em>
to illustrate that whatever you call these parameters, their roles are
unambiguous and their names are available to <code>log_calls</code>, which will use them:</p>

<pre><code>&gt;&gt;&gt; @log_calls(args_sep='sep=')
... def f(a, b, c, **kwargs): pass
&gt;&gt;&gt; @log_calls(args_sep='sep=')
... def g(a, b, c, *g_args, **g_kwargs):
...     f(a, b, c, **g_kwargs)
&gt;&gt;&gt; g(1,2,3, 42, 99, sep='\\n')       # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS, +SKIP
g &lt;== called by &lt;module&gt;
    arguments:
        a=1
        b=2
        c=3
        [*]g_args=(42, 99)
        [**]g_kwargs={'sep': '\\n'}
f &lt;== called by g
    arguments:
        a=1
        b=2
        c=3
        [**]kwargs={'sep': '\\n'}
f ==&gt; returning to g
g ==&gt; returning to &lt;module&gt;
</code></pre>

<h4><span id="indent-from-above">Controlling indentation 'from above'</span></h4>

<p>Similarly, you can control indentation from above.</p>

<pre><code>&gt;&gt;&gt; @log_calls(indent='lc_indent', log_call_numbers=True)
... def f(n, **kwargs):
...     if n &lt;= 0:
...         return
...     f(n-1, **kwargs)
&gt;&gt;&gt; @log_calls(indent='lc_indent')
... def g(n, **kwargs):
...     f(n+1, **kwargs)
</code></pre>

<p>Without an indirect value for <code>indent</code>, <code>log_calls</code> displays this calls to
<code>f</code> and <code>g</code> in a "flat" way:</p>

<pre><code>&gt;&gt;&gt; g(1) #, lc_indent=True)
g &lt;== called by &lt;module&gt;
    arguments: n=1
f [1] &lt;== called by g
    arguments: n=2
f [2] &lt;== called by f [1]
    arguments: n=1
f [3] &lt;== called by f [2]
    arguments: n=0
f [3] ==&gt; returning to f [2]
f [2] ==&gt; returning to f [1]
f [1] ==&gt; returning to g
g ==&gt; returning to &lt;module&gt;
</code></pre>

<p>But the call hierarchy is represented visually when you pass the specified
indirect value:</p>

<pre><code>&gt;&gt;&gt; g(2, lc_indent=True)
g &lt;== called by &lt;module&gt;
    arguments: n=2, [**]kwargs={'lc_indent': True}
    f [4] &lt;== called by g
        arguments: n=3, [**]kwargs={'lc_indent': True}
        f [5] &lt;== called by f [4]
            arguments: n=2, [**]kwargs={'lc_indent': True}
            f [6] &lt;== called by f [5]
                arguments: n=1, [**]kwargs={'lc_indent': True}
                f [7] &lt;== called by f [6]
                    arguments: n=0, [**]kwargs={'lc_indent': True}
                f [7] ==&gt; returning to f [6]
            f [6] ==&gt; returning to f [5]
        f [5] ==&gt; returning to f [4]
    f [4] ==&gt; returning to g
g ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="enabling-with-ints">Enabling with <em>int</em>s rather than <em>bool</em>s</span></h3>

<p>Sometimes it's desirable for a function to print or log debugging messages
as it executes. It's the oldest form of debugging! Instead of a simple <code>bool</code>,
you can use a nonnegative <code>int</code> as the enabling value and treat it as a level
of verbosity.</p>

<pre><code>&gt;&gt;&gt; DEBUG_MSG_BASIC = 1
&gt;&gt;&gt; DEBUG_MSG_VERBOSE = 2
&gt;&gt;&gt; DEBUG_MSG_MOREVERBOSE = 3  # etc.
&gt;&gt;&gt; @log_calls(enabled='debuglevel')
... def do_stuff_with_commentary(*args, debuglevel=0):
...     if debuglevel &gt;= DEBUG_MSG_VERBOSE:
...         print("*** extra debugging info ***")
</code></pre>

<p>No output:</p>

<pre><code>&gt;&gt;&gt; do_stuff_with_commentary()
</code></pre>

<p>Only <code>log_calls</code> output:</p>

<pre><code>&gt;&gt;&gt; do_stuff_with_commentary(debuglevel=DEBUG_MSG_BASIC)
do_stuff_with_commentary &lt;== called by &lt;module&gt;
    arguments: debuglevel=1
do_stuff_with_commentary ==&gt; returning to &lt;module&gt;
</code></pre>

<p><code>log_calls</code> output plus the function's debugging reportage:</p>

<pre><code>&gt;&gt;&gt; do_stuff_with_commentary(debuglevel=DEBUG_MSG_VERBOSE)
do_stuff_with_commentary &lt;== called by &lt;module&gt;
    arguments: debuglevel=2
*** extra debugging info ***
do_stuff_with_commentary ==&gt; returning to &lt;module&gt;
</code></pre>

<p>The <a href="#A-metaclass-example">metaclass example</a> below also makes use of this technique.</p>

<h3><span id="log_call_settings-indirect">Using <em>log_calls_settings</em> to set indirect values</span></h3>

<p>is perfectly legitimate:</p>

<pre><code>&gt;&gt;&gt; @log_calls(enabled=False)
... def g(*args, **kwargs):
...     return sum(args)
&gt;&gt;&gt; g.log_calls_settings.enabled = 'enable_log_calls='
&gt;&gt;&gt; g(1, 2, 3, enable_log_calls=True)
g &lt;== called by &lt;module&gt;
    arguments: [*]args=(1, 2, 3), [**]kwargs={'enable_log_calls': True}
g ==&gt; returning to &lt;module&gt;
6
</code></pre>

<h3><span id="kwarg-paradigm">Paradigms for handling keyword parameters</span></h3>

<p>Several uses of "indirect values" described in this section rely on multiple functions and methods treating <code>**kwargs</code> as a kind of "common area" or "bulletin board" – a central store for data of common interest. This paradigm for <code>**kwargs</code> handling conflicts with the one usually espoused, for example in discussions about the design of composable classes which cooperatively call <code>super()</code>. In his article* <a href="http://rhettinger.wordpress.com/2011/05/26/super-considered-super/">Python's super() considered super!</a>, Raymond Hettinger cogently describes that approach as one in which:</p>

<blockquote>
every method [f, say,  is] cooperatively designed to accept keyword arguments and a keyword-arguments dictionary, to remove any arguments that it needs, and to forward the remaining arguments using **kwds [via super().f(…, **kwds), where … are positional args], eventually leaving the dictionary empty for the final call in the chain.
</blockquote>


<p>Taken literally, this implies that no two implementations of the same method in different classes should ever share a keyword parameter, as the first one to "need" it will "remove it" before passing the baton to its kinfolk further on down the mro. Certainly that's a clear if stringent approach to cooperation, one consistent with the behavior of certain "final calls in the chain" that land in core Python; for example, <code>object.__init__</code> and <code>type.__init__</code> raise an exception if they receive any <code>**kwargs</code>. But the "bulletin board" paradigm of cooperation is also valid and useful, and causes no harm as long as it's clear what all cooperating parties are agreeing <strong>to</strong>.</p>

<h2><span id="call-history-and-statistics">Call history and statistics – the <em>stats</em> attribute and the <em>*_history</em> parameters</span></h2>

<p><code>log_calls</code> always collects a few basic statistics about calls to a decorated
function. It can collect the entire history of calls to a function if asked
to (using the <a href="#record_history-parameter"><code>record_history</code> parameter</a>).
The statistics and history are accessible via the <code>stats</code> attribute
which <code>log_calls</code> adds to a decorated function.</p>

<h3><span id="stats-attribute">The <em>stats</em> attribute and <em>its</em> attributes</span></h3>

<p>The <code>stats</code> attribute is an object of class <code>ClassInstanceAttrProxy</code>, defined
in <code>log_calls/proxy_descriptors.py</code>. That class has its own test suite,
in <code>log_calls/tests/test_proxy_descriptors.py</code>; here, we only have to
test and illustrate its use by <code>log_calls</code>.</p>

<p>Let's define a decorated function with call number logging turned on,
but with exit logging turned off for brevity:</p>

<pre><code>&gt;&gt;&gt; @log_calls(log_call_numbers=True, log_exit=False)
... def f(a, *args, x=1, **kwargs): pass
</code></pre>

<p>Now call it 2 times:</p>

<pre><code>&gt;&gt;&gt; f(0)
f [1] &lt;== called by &lt;module&gt;
    arguments: a=0
    defaults:  x=1
&gt;&gt;&gt; f(1, 100, 101, x=1000, y=1001)
f [2] &lt;== called by &lt;module&gt;
    arguments: a=1, [*]args=(100, 101), x=1000, [**]kwargs={'y': 1001}
</code></pre>

<p>and start to explore the <code>stats</code> attribute.</p>

<h3><span id="stats.num_calls_logged">The <em>num_calls_logged</em> attribute</span></h3>

<p>The <code>stats.num_calls_logged</code> attribute contains the number of the most
recent logged call to a decorated function. Thus, <code>f.stats.num_calls_logged</code>
will equal 2:</p>

<pre><code>&gt;&gt;&gt; f.stats.num_calls_logged
2
</code></pre>

<p>This counter gets incremented when a decorated function is called that has logging enabled, even if its <code>log_call_numbers</code> setting is false.</p>

<h3><span id="stats.num_calls_total">The <em>num_calls_total</em> attribute</span></h3>

<p>The <code>stats.num_calls_total</code> attribute holds the <em>total</em> number of calls
to a decorated function. This counter gets incremented even when logging
is disabled for a function.</p>

<p>For example, let's now <em>disable</em> logging for <code>f</code> and call it 3 more times:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.enabled = False
&gt;&gt;&gt; for i in range(3): f(i)
</code></pre>

<p>Now <code>stats.num_calls_total</code> will equal 5, but <code>f.stats.num_calls_logged</code>
will still equal 2:</p>

<pre><code>&gt;&gt;&gt; f.stats.num_calls_total
5
&gt;&gt;&gt; f.stats.num_calls_logged
2
</code></pre>

<p>As a further illustration, let's re-enable logging for <code>f</code> and call it again.
The displayed call number will the number of the <em>logged</em> call, 3, the same
value as <code>f.stats.num_calls_logged</code> after the call:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.enabled = True
&gt;&gt;&gt; f(10, 20, z=5000)
f [3] &lt;== called by &lt;module&gt;
    arguments: a=10, [*]args=(20,), [**]kwargs={'z': 5000}
    defaults:  x=1

&gt;&gt;&gt; f.stats.num_calls_total
6
&gt;&gt;&gt; f.stats.num_calls_logged
3
</code></pre>

<h3><span id="elapsed_secs_logged">The <em>elapsed_secs_logged</em> attribute</span></h3>

<p>The <code>stats.elapsed_secs_logged</code> attribute holds the sum of the elapsed times of
all logged calls to a decorated function, in seconds. We'll just exhibit its value for the 3 logged calls to <code>f</code> above:</p>

<pre><code>&gt;&gt;&gt; f.stats.elapsed_secs_logged   # doctest: +SKIP
6.67572021484375e-06
</code></pre>

<h3><span id="record_history-parameter">The <em>record_history</em> parameter (default – <em>False</em>)</span></h3>

<p>When the <code>record_history</code> setting is true for a decorated function <code>f</code>, <code>log_calls</code> will
retain a sequence of records holding the details of each logged call to that function.
That history is accessible via attributes of the <code>stats</code> object. We'll illustrate
with a familiar example.</p>

<p>Let's define <code>f</code> just as before, but with <code>record_history</code> set to true:</p>

<pre><code>&gt;&gt;&gt; @log_calls(record_history=True, log_call_numbers=True, log_exit=False)
... def f(a, *args, x=1, **kwargs): pass
</code></pre>

<p>With logging enabled, let's call f three times:</p>

<pre><code>&gt;&gt;&gt; f(0)
f [1] &lt;== called by &lt;module&gt;
    arguments: a=0
    defaults:  x=1
&gt;&gt;&gt; f(1, 100, 101, x=1000, y=1001)
f [2] &lt;== called by &lt;module&gt;
    arguments: a=1, [*]args=(100, 101), x=1000, [**]kwargs={'y': 1001}
&gt;&gt;&gt; f(10, 20, z=5000)
f [3] &lt;== called by &lt;module&gt;
    arguments: a=10, [*]args=(20,), [**]kwargs={'z': 5000}
    defaults:  x=1
</code></pre>

<p>No surprises there. But now, f has a call history, which we'll examine next.</p>

<h3><span id="stats.call_history">The <em>call_history</em> attribute</span></h3>

<p>The <code>stats.call_history</code> attribute of a decorated function provides the call history
of logged calls to the function as a tuple of records. Here's <code>f</code>'s call history,
in hand-formatted to be human-readable (ok, almost human-readable!).</p>

<pre><code>&gt;&gt;&gt; print('\\n'.join(map(str, f.stats.call_history)))   # doctest: +SKIP
CallRecord(call_num=1, argnames=['a'], argvals=(0,), varargs=(),
                       explicit_kwargs=OrderedDict(),
                       defaulted_kwargs=OrderedDict([('x', 1)]), implicit_kwargs={},
                       retval=None, elapsed_secs=2.1457672119140625e-06,
                       timestamp='10/28/14 15:56:13.733763',
                       prefixed_func_name='f', caller_chain=['&lt;module&gt;'])
CallRecord(call_num=2, argnames=['a'], argvals=(1,), varargs=(100, 101),
                       explicit_kwargs=OrderedDict([('x', 1000)]),
                       defaulted_kwargs=OrderedDict(), implicit_kwargs={'y': 1001},
                       retval=None, elapsed_secs=1.9073486328125e-06,
                       timestamp='10/28/14 15:56:13.734102',
                       prefixed_func_name='f', caller_chain=['&lt;module&gt;'])
CallRecord(call_num=3, argnames=['a'], argvals=(10,), varargs=(20,),
                       explicit_kwargs=OrderedDict(),
                       defaulted_kwargs=OrderedDict([('x', 1)]), implicit_kwargs={'z': 5000},
                       retval=None, elapsed_secs=2.1457672119140625e-06,
                       timestamp='10/28/14 15:56:13.734412',
                       prefixed_func_name='f', caller_chain=['&lt;module&gt;'])
</code></pre>

<p>The CSV representation pairs
the <code>argnames</code> with their values in <code>argvals</code> (the <code>argnames</code> become column headings),
making it even more human-readable, especially when viewed in a program that
presents CSVs nicely.</p>

<h4><span id="CallRecord-namedtuple">The <em>CallRecord</em> namedtuple</span></h4>

<p>For the record, the records that comprise a decorated function's call_history are
<code>namedtuple</code>s of type <code>CallRecord</code>, whose fields are:</p>

<pre><code>call_num
argnames
argvals
varargs
explicit_kwargs
defaulted_kwargs
implicit_kwargs
retval
elapsed_secs
timestamp
prefixed_func_name
caller_chain
</code></pre>

<p>By now, the significance of each field should be clear.</p>

<h4><span id="elapsed_secs_logged-equal-sum-etc"><em>stats.elapsed_secs_logged</em> == sum of <em>elapsed_secs</em> "column" of <em>stats.call_history</em></span></h4>

<p>as you would expect. This is <a href="./record_history.html#elapsed_secs_logged-equal-sum-etc">demonstrated</a> in the documentation for the <code>record_history</code> decorator, a subset of <code>log_calls</code> which records call history and statistics but writes no messages.</p>

<h3><span id="max_history-parameter">The <em>max_history</em> parameter (default – 0)</span></h3>

<p>The <code>max_history</code> parameter determines how many call history records are retained
for a decorated function whose call history is recorded. If this value is 0
(the default) or negative, unboundedly many records are retained (unless or until
you set the <code>record_history</code> setting to false, or call the
<a href="#stats.clear_history"><code>stats.clear_history()</code></a> method). If the value of <code>max_history</code>
is > 0, <code>log_calls</code> will retain at most that many records, discarding the oldest
records to make room for newer ones if the history reaches capacity.</p>

<p>An example:</p>

<pre><code>&gt;&gt;&gt; @log_calls(record_history=True, max_history=2,
...            log_args=False, log_exit=False, log_call_numbers=True)
... def g(a): pass
&gt;&gt;&gt; for i in range(3): g(i)
g [1] &lt;== called by &lt;module&gt;
g [2] &lt;== called by &lt;module&gt;
g [3] &lt;== called by &lt;module&gt;
</code></pre>

<p>Here's <code>g</code>'s call history:</p>

<pre><code>&gt;&gt;&gt; print('\\n'.join(map(str, g.stats.call_history)))    # doctest: +SKIP
CallRecord(call_num=2, argnames=['a'], argvals=(1,), varargs=(),
                       explicit_kwargs=OrderedDict(),
                       defaulted_kwargs=OrderedDict(), implicit_kwargs={},
                       retval=None, elapsed_secs=2.1457672119140625e-06,
                       timestamp='10/28/14 20:51:12.376714',
                       prefixed_func_name='g', caller_chain=['&lt;module&gt;'])
CallRecord(call_num=3, argnames=['a'], argvals=(2,), varargs=(),
                       explicit_kwargs=OrderedDict(),
                       defaulted_kwargs=OrderedDict(), implicit_kwargs={},
                       retval=None, elapsed_secs=2.1457672119140625e-06,
                       timestamp='10/28/14 20:51:12.376977',
                       prefixed_func_name='g', caller_chain=['&lt;module&gt;'])
</code></pre>

<p>The first call (<code>call_num=1</code>) was discarded to make room for the last call
(<code>call_num=3</code>) because the call history size is set to 2.</p>

<p>You cannot change <code>max_history</code> using the mapping interface or the attribute
of the same name; attempts to do so raise <code>ValueError</code>:</p>

<pre><code>&gt;&gt;&gt; g.log_calls_settings.max_history = 17   # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
ValueError: ...

&gt;&gt;&gt; g.log_calls_settings['max_history'] = 17   # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
ValueError: ...
</code></pre>

<p>The only way to change its value is with the <a href="#stats.clear_history"><code>stats.clear_history()</code></a> method, discussed below.</p>

<h3><span id="stats.call_history_as_csv">The <em>call_history_as_csv</em> attribute</span></h3>

<p>The value <code>stats.call_history_as_csv</code> attribute is a text representation in CSV format of a decorated function's call history.
You can save this string
and import it into the program or tool of your choice for further analysis.
CSV format is only partially human-friendly, but this representation
breaks out each argument into its own column, throwing away information about
whether an argument's value was passed or is a default.</p>

<pre><code>&gt;&gt;&gt; print(g.stats.call_history_as_csv)        # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS
'call_num'|'a'|'retval'|'elapsed_secs'|'timestamp'|'prefixed_fname'|'caller_chain'
2|1|None|...|...|'g'|['&lt;module&gt;']
3|2|None|...|...|'g'|['&lt;module&gt;']
&lt;BLANKLINE&gt;
</code></pre>

<p>Ellipses above are for the <code>elapsed_secs</code> and <code>timestamp</code> fields.</p>

<p>The CSV separator is '|' rather than ',' because some of the fields – <code>args</code>,  <code>kwargs</code>
and <code>caller_chain</code> – use commas intrinsically. Let's examine one more
<code>call_history_as_csv</code> for a function that has all of those fields:</p>

<pre><code>&gt;&gt;&gt; @log_calls(record_history=True, log_call_numbers=True,
...            log_exit=False, log_args=False)
... def f(a, *extra_args, x=1, **kw_args): pass
&gt;&gt;&gt; def g(a, *args, **kwargs): f(a, *args, **kwargs)
&gt;&gt;&gt; @log_calls(log_exit=False, log_args=False)
... def h(a, *args, **kwargs): g(a, *args, **kwargs)
&gt;&gt;&gt; h(0)
h &lt;== called by &lt;module&gt;
f [1] &lt;== called by g &lt;== h
&gt;&gt;&gt; h(10, 17, 19, z=100)
h &lt;== called by &lt;module&gt;
f [2] &lt;== called by g &lt;== h
&gt;&gt;&gt; h(20, 3, 4, 6, x=5, y='Yarborough', z=100)
h &lt;== called by &lt;module&gt;
f [3] &lt;== called by g &lt;== h
&gt;&gt;&gt; print(f.stats.call_history_as_csv)        # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS
'call_num'|'a'|'extra_args'|'x'|'kw_args'|'retval'|'elapsed_secs'|'timestamp'|'prefixed_fname'|'caller_chain'
1|0|()|1|{}|None|...|...|'f'|['g', 'h']
2|10|(17, 19)|1|{'z': 100}|None|...|...|'f'|['g', 'h']
3|20|(3, 4, 6)|5|{'y': 'Yarborough', 'z': 100}|None|...|...|'f'|['g', 'h']
&lt;BLANKLINE&gt;
</code></pre>

<p>As usual, <code>log_calls</code> will use whatever names you use for <em>varargs</em> parameters
(here, <code>extra_args</code> and <code>kw_args</code>). Whatever the name of the <code>kwargs</code> parameter,
items within that field are guaranteed to be in sorted order (otherwise this
last example would sometimes fail as a doctest).</p>

<h3><span id="stats.clear_history">The <em>clear_history(max_history=0)</em> method</span></h3>

<p>As you might expect, the <code>stats.clear_history(max_history=0)</code> method clears
the call history of a decorated function. In addition, it resets all running sums:
<code>num_calls_total</code> and <code>num_calls_logged</code> are reset to 0, and
<code>elapsed_secs_logged</code> is reset to 0.0.</p>

<p><strong>It is the only way to change the value of the <code>max_history</code> setting</strong>, via
the optional keyword parameter for which you can supply any (integer) value,
by default 0.</p>

<p>The function <code>f</code> has a nonempty history, as we just saw. Let's confirm the
values of all relevant settings and counters:</p>

<pre><code>&gt;&gt;&gt; f.log_calls_settings.max_history
0
&gt;&gt;&gt; f.stats.num_calls_logged
3
&gt;&gt;&gt; f.stats.num_calls_total
3
&gt;&gt;&gt; f.stats.elapsed_secs_logged     # doctest: +SKIP
1.4066696166992188e-05
</code></pre>

<p>Now let's clear <code>f</code>'s history, setting <code>max_history</code> to 33, and check that settings
and <code>stats</code> tallies are reset:</p>

<pre><code>&gt;&gt;&gt; f.stats.clear_history(max_history=33)
&gt;&gt;&gt; f.log_calls_settings.max_history
33
&gt;&gt;&gt; f.stats.num_calls_logged
0
&gt;&gt;&gt; f.stats.num_calls_total
0
&gt;&gt;&gt; f.stats.elapsed_secs_logged
0.0
</code></pre>

<h2><span id="record_history-decorator">The <em>record_history</em> decorator</span></h2>

<p>The <code>record_history</code> decorator is a stripped-down version of <code>log_calls</code> which
records calls to a decorated function but writes no messages. You can think
of it as <code>log_calls</code> with the <code>record_history</code> and <code>log_call_numbers</code> settings
always true, and without any of the message-logging apparatus.</p>

<p>Just as the settings of <code>log_calls</code> for a decorated function are accessible
dynamically through the <code>log_calls_settings</code> attribute, the settings of
<code>record_history</code> are exposed via a <code>record_history_settings</code> attribute.
<code>record_history_settings</code> is an object of the same type as <code>log_calls_settings</code>,
so it has the same methods and behaviors described in the <a href="#Dynamic-control-log_calls_settings"><code>log_calls_settings</code></a> section.</p>

<p>Functions decorated by <code>record_history</code> have a full-featured <code>stats</code> attribute,
as described in the <a href="#call-history-and-statistics">Call history and statistics</a> section.</p>

<p>See the <a href="./record_history.html">documentation for <code>record_history</code></a> for examples and tests.</p>

<h2><span id="realistic-examples">Realistic examples</span></h2>

<h3><span id="logging-multiple-handlers">Using a logger with multiple handlers that have different loglevels</span></h3>

<p>First let's set up a logging with a console handler that writes to <code>stdout</code>:</p>

<pre><code>&gt;&gt;&gt; import logging
&gt;&gt;&gt; import sys
&gt;&gt;&gt; ch = logging.StreamHandler(stream=sys.stdout)
&gt;&gt;&gt; c_formatter = logging.Formatter('%(levelname)s:%(name)s:%(message)s')
&gt;&gt;&gt; ch.setFormatter(c_formatter)
&gt;&gt;&gt; logger = logging.getLogger('mylogger')
&gt;&gt;&gt; logger.addHandler(ch)
&gt;&gt;&gt; logger.setLevel(logging.DEBUG)
</code></pre>

<p>Now let's add another handler, also sent to <code>stdout</code> but best thought of as writing
to a log file. We'll set up the existing console handler with level <code>INFO</code>, and
the "file" handler with level <code>DEBUG</code> - a typical setup: you want to log all
details to the file, but you only want to write more important messages to
the console.</p>

<pre><code>&gt;&gt;&gt; fh = logging.StreamHandler(stream=sys.stdout)
&gt;&gt;&gt; f_formatter = logging.Formatter('[FILE] %(levelname)8s:%(name)s: %(message)s')
&gt;&gt;&gt; fh.setFormatter(f_formatter)
&gt;&gt;&gt; fh.setLevel(logging.DEBUG)
&gt;&gt;&gt; logger.addHandler(fh)
&gt;&gt;&gt; ch.setLevel(logging.INFO)
</code></pre>

<p>Suppose we have two functions: one that's lower-level/often-called,
and another that's "higher-level"/infrequently called.</p>

<pre><code>&gt;&gt;&gt; @log_calls(logger=logger, loglevel=logging.DEBUG)
... def popular():
...     pass
&gt;&gt;&gt; @log_calls(logger=logger, loglevel=logging.INFO)
... def infrequent():
...     popular()
</code></pre>

<p>Set logger level to <code>DEBUG</code> –
  the console handler logs calls only for <code>infrequent</code>,
  but the "file" handler logs calls for both functions.</p>

<pre><code>&gt;&gt;&gt; logger.setLevel(logging.DEBUG)
&gt;&gt;&gt; infrequent()       # doctest: +NORMALIZE_WHITESPACE
INFO:mylogger:infrequent &lt;== called by &lt;module&gt;
[FILE]     INFO:mylogger: infrequent &lt;== called by &lt;module&gt;
[FILE]    DEBUG:mylogger: popular &lt;== called by infrequent
[FILE]    DEBUG:mylogger: popular ==&gt; returning to infrequent
INFO:mylogger:infrequent ==&gt; returning to &lt;module&gt;
[FILE]     INFO:mylogger: infrequent ==&gt; returning to &lt;module&gt;
</code></pre>

<p>Now set logger level to <code>INFO</code> –
  both handlers logs calls only for <code>infrequent</code>:</p>

<pre><code>&gt;&gt;&gt; logger.setLevel(logging.INFO)
&gt;&gt;&gt; infrequent()       # doctest: +NORMALIZE_WHITESPACE
INFO:mylogger:infrequent &lt;== called by &lt;module&gt;
[FILE]     INFO:mylogger: infrequent &lt;== called by &lt;module&gt;
INFO:mylogger:infrequent ==&gt; returning to &lt;module&gt;
[FILE]     INFO:mylogger: infrequent ==&gt; returning to &lt;module&gt;
</code></pre>

<h3><span id="A-metaclass-example">A metaclass example</span></h3>

<p>The following class <code>A_meta</code> will serve as the metaclass for classes defined subsequently:</p>

<pre><code>&gt;&gt;&gt; # - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - -
&gt;&gt;&gt; # A_meta, a metaclass
&gt;&gt;&gt; # - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - -
&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; separator = '\n'    # default ', ' gives rather long lines

&gt;&gt;&gt; A_DBG_BASIC = 1
&gt;&gt;&gt; A_DBG_INTERNAL = 2

&gt;&gt;&gt; class A_meta(type):
...     @classmethod
...     @log_calls(prefix='A_meta.', args_sep=separator, enabled='A_debug')
...     def __prepare__(mcs, cls_name, bases, *, A_debug=0, **kwargs):
...         if A_debug &gt;= A_DBG_INTERNAL:
...             print("    mro =", mcs.__mro__)
...         super_dict = super().__prepare__(cls_name, bases, **kwargs)
...         if A_debug &gt;= A_DBG_INTERNAL:
...             print("    dict from super() = %r" % super_dict)
...         super_dict = OrderedDict(super_dict)
...         super_dict['key-from-__prepare__'] = 1729
...         if A_debug &gt;= A_DBG_INTERNAL:
...             print("    Returning dict: %s" % super_dict)
...         return super_dict
...
...     @log_calls(prefix='A_meta.', args_sep=separator, enabled='A_debug')
...     def __new__(mcs, cls_name, bases, cls_members: dict, *, A_debug=0, **kwargs):
...         cls_members['key-from-__new__'] = "No, Hardy!"
...         if A_debug &gt;= A_DBG_INTERNAL:
...             print("    calling super() with cls_members = %s" % cls_members)
...         return super().__new__(mcs, cls_name, bases, cls_members, **kwargs)
...
...     @log_calls(prefix='A_meta.', args_sep=separator, enabled='A_debug')
...     def __init__(cls, cls_name, bases, cls_members: dict, *, A_debug=0, **kwargs):
...         if A_debug &gt;= A_DBG_INTERNAL:
...             print("    cls.__mro__:", str(cls.__mro__))
...             print("    type(cls).__mro__[1] =", type(cls).__mro__[1])
...         try:
...             super().__init__(cls_name, bases, cls_members, **kwargs)
...         except TypeError as e:
...             # call type.__init__
...             if A_debug &gt;= A_DBG_INTERNAL:
...                 print("    calling type.__init__ with no kwargs")
...             type.__init__(cls, cls_name, bases, cls_members)
</code></pre>

<p>The class <code>A_meta</code> is a metaclass: it derives from <code>type</code>,
and defines (overrides) methods <code>__prepare__</code>, <code>__new__</code> and <code>__init__</code>.
All of its methods take an explicit keyword parameter <code>A_debug</code>,
used as the indirect value of the <code>log_calls</code> keyword parameter <code>enabled</code>.
When we include <code>A_debug=True</code> as a keyword argument to a class that
uses <code>A_meta</code> as its metaclass, that argument gets passed to all of
<code>A_meta</code>'s methods, so calls to them will be logged, and those methods
will also print extra debugging information:</p>

<pre><code>&gt;&gt;&gt; class A(metaclass=A_meta, A_debug=A_DBG_INTERNAL):    # doctest: +NORMALIZE_WHITESPACE
...     pass
A_meta.__prepare__ &lt;== called by &lt;module&gt;
    arguments:
        mcs=&lt;class '__main__.A_meta'&gt;
        cls_name='A'
        bases=()
        A_debug=2
    mro = (&lt;class '__main__.A_meta'&gt;, &lt;class 'type'&gt;, &lt;class 'object'&gt;)
    dict from super() = {}
    Returning dict: OrderedDict([('key-from-__prepare__', 1729)])
A_meta.__prepare__ ==&gt; returning to &lt;module&gt;
A_meta.__new__ &lt;== called by &lt;module&gt;
    arguments:
        mcs=&lt;class '__main__.A_meta'&gt;
        cls_name='A'
        bases=()
        cls_members=OrderedDict([('key-from-__prepare__', 1729),
                                 ('__module__', '__main__'),
                                 ('__qualname__', 'A')])
        A_debug=2
    calling super() with cls_members = OrderedDict([('key-from-__prepare__', 1729),
                                                    ('__module__', '__main__'),
                                                    ('__qualname__', 'A'),
                                                    ('key-from-__new__', 'No, Hardy!')])
A_meta.__new__ ==&gt; returning to &lt;module&gt;
A_meta.__init__ &lt;== called by &lt;module&gt;
    arguments:
        cls=&lt;class '__main__.A'&gt;
        cls_name='A'
        bases=()
        cls_members=OrderedDict([('key-from-__prepare__', 1729),
                                 ('__module__', '__main__'),
                                 ('__qualname__', 'A'),
                                 ('key-from-__new__', 'No, Hardy!')])
        A_debug=2
    cls.__mro__: (&lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)
    type(cls).__mro__[1] = &lt;class 'type'&gt;
A_meta.__init__ ==&gt; returning to &lt;module&gt;
</code></pre>

<p>If we had passed <code>A_debug=A_DBG_BASIC</code>, then only <code>log_calls</code> output would have
been printed: the metaclass methods would not have printed their extra debugging
statements.</p>

<p>If we pass <code>A_debug=0</code> (or omit it), we get no printed output at all either from
<code>log_calls</code> or from <code>A_meta</code>'s methods:</p>

<pre><code>&gt;&gt;&gt; class AA(metaclass=A_meta, A_debug=False):    # no output
...     pass
</code></pre>

<h2><span id="KeywordParametersReference">Appendix – Keyword Parameters Reference</span></h2>

<p>The <code>log_calls</code> decorator takes various keyword arguments, all with hopefully sensible defaults:</p>

<table>
<thead>
<tr>
<th align="right">Keyword parameter </th>
<th align="left"> Default value </th>
<th align="left"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right"><code>enabled</code>    </td>
<td align="left"> <code>True</code>          </td>
<td align="left"> An <code>int</code>. If true, then <code>log_calls</code> will output (or "log") messages.</td>
</tr>
<tr>
<td align="right"><code>args_sep</code>   </td>
<td align="left"> <code>', '</code>          </td>
<td align="left"> <code>str</code> used to separate arguments. The default is  <code>', '</code>, which lists all args on the same line. If <code>args_sep='\n'</code> is used, or more generally if the <code>args_sep</code> string ends in <code>\n</code>, then additional spaces are appended to the separator for a neater display. Other separators in which <code>'\n'</code> occurs are left unchanged, and are untested – experiment/use at your own risk.</td>
</tr>
<tr>
<td align="right"><code>log_args</code>   </td>
<td align="left"> <code>True</code>          </td>
<td align="left"> arguments passed to the decorated function, and default values used by the function, will be logged.</td>
</tr>
<tr>
<td align="right"><code>log_retval</code> </td>
<td align="left"> <code>False</code>         </td>
<td align="left"> If true, log what the decorated function returns. At most 60 chars are printed, with a trailing ellipsis if the value is truncated.</td>
</tr>
<tr>
<td align="right"><code>log_exit</code>   </td>
<td align="left"> <code>True</code>          </td>
<td align="left"> If true, the decorator will log an exiting message after calling the function of the form <code>f returning to ==&gt; caller</code>, and before returning what the function returned.</td>
</tr>
<tr>
<td align="right"><code>log_call_number</code> </td>
<td align="left"> <code>False</code>    </td>
<td align="left"> If true, display the (1-based) number of the function call, e.g. <code>f [3] called by &lt;== &lt;module&gt;</code> and <code>f [3] returning to ==&gt; &lt;module&gt;</code> for the 3rd logged call. This would correspond to the 3rd record in the function's call history, if <code>record_history</code> is true.</td>
</tr>
<tr>
<td align="right"><code>log_elapsed</code> </td>
<td align="left"> <code>False</code>        </td>
<td align="left"> If true, display how long it took the function to execute, in seconds.</td>
</tr>
<tr>
<td align="right"><code>indent</code>     </td>
<td align="left"> <code>False</code>         </td>
<td align="left"> The <code>indent</code> parameter indents each new level  of logged messages by 4 spaces, giving a visualization of the call hierarchy.</td>
</tr>
<tr>
<td align="right"><code>prefix</code>     </td>
<td align="left"> <code>''</code>            </td>
<td align="left"> A <code>str</code> to prefix the function name with in logged messages: on entry, in reporting return value (if <code>log_retval</code> is true) and on exit (if <code>log_exit</code> is true).</td>
</tr>
<tr>
<td align="right"><code>file</code>     </td>
<td align="left"> <code>sys.stdout</code>      </td>
<td align="left"> If <code>logger</code> is <code>None</code>, a stream (an instance of type <code>io.TextIOBase</code>) to which <code>log_calls</code> will print its messages. This value is supplied to the <code>file</code> keyword parameter of the <code>print</code> function.</td>
</tr>
<tr>
<td align="right"><code>logger</code>     </td>
<td align="left"> <code>None</code>          </td>
<td align="left"> If not <code>None</code>, a <code>Logger</code> which will be used to write all messages. Otherwise, <code>print</code> is used.</td>
</tr>
<tr>
<td align="right"><code>loglevel</code>   </td>
<td align="left"> <code>logging.DEBUG</code> </td>
<td align="left"> Logging level, ignored unless a logger is specified. This should be one of the logging levels recognized by the <code>logging</code> module – one of the constants defined by that module, or a custom level you've added.</td>
</tr>
<tr>
<td align="right"><code>record_history</code> </td>
<td align="left"> <code>False</code>     </td>
<td align="left"> If true, a list of records will be kept, one for each call to the function. Each record holds: call number (1-based), arguments and defaulted keyword arguments, return value, time elapsed, time of call, caller (call chain), prefixed function name. The value of this attribute is a <code>tuple</code>.</td>
</tr>
<tr>
<td align="right"><code>max_history</code> </td>
<td align="left"> <code>0</code>            </td>
<td align="left"> An <code>int</code>. <em>value</em> > 0 --> store at most <em>value</em>-many records, oldest records overwritten; <em>value</em> ≤ 0 --> store unboundedly many records. Ignored unless <code>record_history</code> is true.</td>
</tr>
</tbody>
</table>


<h4>— Brian O'Neill, October 2014, NYC</h4>
</body>
</html>