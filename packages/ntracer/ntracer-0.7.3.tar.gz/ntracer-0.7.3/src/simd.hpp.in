#ifndef simd_hpp
#define simd_hpp

#include <cstdint>
#include <cmath>
#include <algorithm>
#include <cassert>

#include "compatibility.hpp"


#if defined(__linux__) || defined(__linux) || defined(linux)
    #include <stdlib.h>

    #define USE_POSIX
#elif defined(_WIN32) || defined(__WIN32__) || defined(__TOS_WIN__) || defined(__WINDOWS__)
    #include <malloc.h>

    #define USE_WIN
#endif


#if defined(__x86_64__) || defined(_M_X64)
    #define SUPPORT_X64
#endif

#ifndef DISABLE_SIMD

#if defined(__AVX512PF__)
    #define SUPPORT_AVX512PF
#endif

#if defined(__AVX512ER__)
    #define SUPPORT_AVX512ER
#endif

#if defined(__AVX512CD__)
    #define SUPPORT_AVX512CD
#endif

#if defined(SUPPORT_AVX512PF) || defined(SUPPORT_AVX512ER) || defined(SUPPORT_512CD) || defined(__AVX512F__)
    #define SUPPORT_AVX512F
#endif

// #if defined(?)
//     #define SUPPORT_FMA
// #endif

#if defined(SUPPORT_AVX512F) || defined(__AVX2__)
    #define SUPPORT_AVX2
#endif

#if defined(SUPPORT_AVX2) || defined(__AVX__)
    #define SUPPORT_AVX
#endif

#if defined(SUPPORT_FMA) || defined(SUPPORT_AVX)
    #include <immintrin.h>
#endif

#if defined(SUPPORT_AVX) || defined(__SSE4_2__)
    #define SUPPORT_SSE4_2
    #include <nmmintrin.h>
#endif

#if defined(SUPPORT_SSE4_2) || defined(__SSE4_1__)
    #define SUPPORT_SSE4_1
    #include <smmintrin.h>
#endif

#if defined(SUPPORT_SSE4_1) || defined(__SSSE3__)
    #define SUPPORT_SSSE3
    #include <tmmintrin.h>
#endif

#if defined(SUPPORT_SSSE3) || defined(__SSE3__)
    #define SUPPORT_SSE3
    #include <pmmintrin.h>
#endif

#if defined(SUPPORT_SSE3) || defined(__SSE2__) || (defined(_M_IX86_FP) && _M_IX86_FP >= 2)
    #define SUPPORT_SSE2
    #include <emmintrin.h>
#endif

#if defined(SUPPORT_SSE2) || defined(__SSE__) || (defined(_M_IX86_FP) && _M_IX86_FP >= 1)
    #define SUPPORT_SSE
    #include <xmmintrin.h>
#endif


#endif


#define V_INIT_CODE(T,P,S) T() = default; \
    FORCE_INLINE T(P _data) { this->data.p = _data; } \
    FORCE_INLINE T(const T &b) { this->data.p = b.data.p; } \
    explicit T(scalar<S> b) { this->from_item(b.data); } \
    FORCE_INLINE T &operator=(const T &b) { this->data.p = b.data.p; return *this; }

#define S_INIT_CODE(P) type() = default; \
    FORCE_INLINE type(P _data) { data = _data; } \
    FORCE_INLINE type &operator=(type b) { data = b.data; return *this; }

#define V_R_MULT(T) FORCE_INLINE T operator*(T::item_t a,const T &b) {\
    return T::repeat(a) * b;\
}


namespace simd {
    namespace impl {
#ifdef SUPPORT_SSE
        template<typename T> T cast(__m128 x);
        template<> FORCE_INLINE __m128 cast<__m128>(__m128 x) { return x; }

  #ifdef SUPPORT_SSE2
        template<> FORCE_INLINE __m128d cast<__m128d>(__m128 x) { return _mm_castps_pd(x); }
        template<> FORCE_INLINE __m128i cast<__m128i>(__m128 x) { return _mm_castps_si128(x); }
        
        template<typename T> T cast(__m128d x);
        template<> FORCE_INLINE __m128d cast<__m128d>(__m128d x) { return x; }
        template<> FORCE_INLINE __m128 cast<__m128>(__m128d x) { return _mm_castpd_ps(x); }
        template<> FORCE_INLINE __m128i cast<__m128i>(__m128d x) { return _mm_castpd_si128(x); }
        
        template<typename T> T cast(__m128i x);
        template<> FORCE_INLINE __m128i cast<__m128i>(__m128i x) { return x; }
        template<> FORCE_INLINE __m128 cast<__m128>(__m128i x) { return _mm_castsi128_ps(x); }
        template<> FORCE_INLINE __m128d cast<__m128d>(__m128i x) { return _mm_castsi128_pd(x); }
        
    #ifdef SUPPORT_AVX
        template<typename T> T cast(__m256 x);
        template<> FORCE_INLINE __m256 cast<__m256>(__m256 x) { return x; }
        template<> FORCE_INLINE __m256d cast<__m256d>(__m256 x) { return _mm256_castps_pd(x); }
        
        template<typename T> T cast(__m256d x);
        template<> FORCE_INLINE __m256d cast<__m256d>(__m256d x) { return x; }
        template<> FORCE_INLINE __m256 cast<__m256>(__m256d x) { return _mm256_castpd_ps(x); }
        
      #ifdef SUPPORT_AVX2
        template<> FORCE_INLINE __m256i cast<__m256i>(__m256 x) { return _mm256_castps_si256(x); }
        template<> FORCE_INLINE __m256i cast<__m256i>(__m256d x) { return _mm256_castpd_si256(x); }
        
        template<typename T> T cast(__m256i x);
        template<> FORCE_INLINE __m256i cast<__m256i>(__m256i x) { return x; }
        template<> FORCE_INLINE __m256 cast<__m256>(__m256i x) { return _mm256_castsi256_ps(x); }
        template<> FORCE_INLINE __m256d cast<__m256d>(__m256i x) { return _mm256_castsi256_pd(x); }
      #endif
    #endif
        
    #ifdef SUPPORT_AVX512F
        template<typename T> T cast(__m512 x);
        template<> FORCE_INLINE __m512 cast<__m512>(__m512 x) { return x; }
        template<> FORCE_INLINE __m512d cast<__m512d>(__m512 x) { return _mm512_castps_pd(x); }
        template<> FORCE_INLINE __m512i cast<__m512i>(__m512 x) { return _mm512_castps_si512(x); }
        
        template<typename T> T cast(__m512d x);
        template<> FORCE_INLINE __m512d cast<__m512d>(__m512d x) { return x; }
        template<> FORCE_INLINE __m512 cast<__m512>(__m512d x) { return _mm512_castpd_ps(x); }
        template<> FORCE_INLINE __m512i cast<__m512i>(__m512d x) { return _mm512_castpd_si512(x); }
        
        template<typename T> T cast(__m512i x);
        template<> FORCE_INLINE __m512i cast<__m512i>(__m512i x) { return x; }
        template<> FORCE_INLINE __m512 cast<__m512>(__m512i x) { return _mm512_castsi512_ps(x); }
        template<> FORCE_INLINE __m512d cast<__m512d>(__m512i x) { return _mm512_castsi512_pd(x); }
    #endif
  #endif
#endif
    }
    
    template<typename T> struct _single {};
    
#ifdef SUPPORT_SSE2
    template<> struct _single<double> {
        struct type {
            S_INIT_CODE(__m128d)
    #ifdef SUPPORT_AVX512F
            FORCE_INLINE type(__m512d b) {
                data = _mm512_castpd512_pd128(b);
            }
    #endif
    #ifdef SUPPORT_AVX
            FORCE_INLINE type(__m256d b) {
                data = _mm256_castpd256_pd128(b);
            }
    #endif
            
            FORCE_INLINE operator double() const {
                return _mm_cvtsd_f64(data);
            }
            
            __m128d data;
        };
    };
    template<> struct _single<int64_t> {
        struct type {
            S_INIT_CODE(__m128i)
    #ifdef SUPPORT_AVX512F
            FORCE_INLINE type(__m512i b) {
                data = _mm512_castsi512_si128(b);
            }
    #endif
    #ifdef SUPPORT_AVX2
            FORCE_INLINE type(__m256i b) {
                data = _mm256_castsi256_si128(b);
            }
    #endif
            
            FORCE_INLINE operator int64_t() const {
    #ifdef SUPPORT_X64
                return _mm_cvtsi128_si64(data);
    #else
                union {
                    __m128i p;
                    int64_t s;
                } tmp;
                tmp.p = data;
                return tmp.s;
    #endif
            }
            
            __m128i data;
        };
    };
    template<> struct _single<int32_t> {
        struct type {
            S_INIT_CODE(__m128i)
    #ifdef SUPPORT_AVX512F
            FORCE_INLINE type(__m512i b) {
                data = _mm512_castsi512_si128(b);
            }
    #endif
    #ifdef SUPPORT_AVX2
            FORCE_INLINE type(__m256i b) {
                data = _mm256_castsi256_si128(b);
            }
    #endif
            
            FORCE_INLINE operator int32_t() const {
                return _mm_cvtsi128_si32(data);
            }
            
            __m128i data;
        };
    };
    template<> struct _single<int16_t> {
        struct type {
            S_INIT_CODE(__m128i)
    #ifdef SUPPORT_AVX2
            FORCE_INLINE type(__m256i b) {
                data = _mm256_castsi256_si128(b);
            }
    #endif
            
            FORCE_INLINE operator int16_t() const {
                return _mm_cvtsi128_si32(data) >> 16;
            }
            
            __m128i data;
        };
    };
    template<> struct _single<int8_t> {
        struct type {
            S_INIT_CODE(__m128i)
    #ifdef SUPPORT_AVX2
            FORCE_INLINE type(__m256i b) {
                data = _mm256_castsi256_si128(b);
            }
    #endif
            
            FORCE_INLINE operator int8_t() const {
                return _mm_cvtsi128_si32(data) >> 24;
            }
            
            __m128i data;
        };
    };
#endif
#ifdef SUPPORT_SSE
    template<> struct _single<float> {
        struct type {
            S_INIT_CODE(__m128)
    #ifdef SUPPORT_AVX512F
            FORCE_INLINE type(__m512 b) {
                data = _mm512_castps512_ps128(b);
            }
    #endif
    #ifdef SUPPORT_AVX
            FORCE_INLINE type(__m256 b) {
                data = _mm256_castps256_ps128(b);
            }
    #endif
            
            FORCE_INLINE operator float() const {
                return _mm_cvtss_f32(data);
            }
            
            __m128 data;
        };
    };
#endif
    
    template<typename T> using single = typename _single<T>::type;
    
    
    template<typename T> struct v_sizes;
    
    template<typename T,size_t Size> struct _v_type {};
    template<typename T,size_t Size=v_sizes<T>::value[0]> using v_type = typename _v_type<T,Size>::type;
    
    template<size_t ItemSize,size_t Size> struct _v_mask {};
    template<size_t ItemSize,size_t Size> using v_mask = typename _v_mask<ItemSize,Size>::type;
    
    namespace impl {
        template<typename T> struct negation_mask;
        
        template<typename T,typename Packed,typename Item> struct common {
            typedef Item item_t;
            
            static const size_t size = sizeof(Packed) / sizeof(Item);
            
            Item &operator[](size_t i) {
                return data.s[i];
            }
            
            Item operator[](size_t i) const {
                return data.s[i];
            }
            
            FORCE_INLINE T operator-() const {
                //return *reinterpret_cast<const T*>(negation_mask<Item>::value) ^ *static_cast<const T*>(this);
                return T::zeros() - *static_cast<const T*>(this);
            }
            
            template<typename F> T apply(F f) const {
                T r;
                for(size_t i=0; i<size; ++i) r.data.s[i] = f(data.s[i]);
                return r;
            }
            
            template<typename F> Item reduce(F f) const {
                Item r = data.s[0];
                for(size_t i=1; i<size; ++i) r = f(r,data.s[i]);
                return r;
            }
            
            void from_item(Item x) {
                data.s[0] = x;
                for(size_t i=1; i<size; ++i) data.s[i] = 0;
            }
            
            explicit operator bool() const;
            
            union {
                Packed p;
                Item s[size];
            } data;
            
            
            static constexpr bool has_vec_reduce_add = false;
            
            // fall-back implementations for missing SIMD functions
            T abs() const { return apply(static_cast<Item (*)(Item)>(&std::abs)); }
            Item reduce_max() const { return reduce(&std::max<Item>); }
            Item reduce_min() const { return reduce(&std::min<Item>); }
            Item reduce_add() const { return reduce(std::plus<Item>()); }
            FORCE_INLINE T &mask_set(const v_mask<sizeof(Item),size> &m,const T &b)  {
                data.p = (static_cast<T*>(this)->nzfilter(m) | b.zfilter(m)).data.p;
                return *static_cast<T*>(this);
            }
            FORCE_INLINE T nzfilter(const v_mask<sizeof(Item),size> &m) const {
                return static_cast<T*>(this)->zfilter(!m);
            }
            
            static T repeat(Item x) {
                T r;
                for(size_t i=0; i<size; ++i) r.data.s[i] = x;
                return r;
            }
        };
        
        template<typename T,typename Packed,typename Item> struct common_real : common<T,Packed,Item> {
            FORCE_INLINE T operator*(Item b) const {
                return *static_cast<const T*>(this) * T::repeat(b);
            }
            FORCE_INLINE T operator*(const single<Item> &b) const {
                return *static_cast<const T*>(this) * T::repeat(b);
            }
            FORCE_INLINE T& operator*=(Item b) {
                return *static_cast<T*>(this) *= T::repeat(b);
            }
            FORCE_INLINE T& operator*=(const single<Item> &b) {
                return *static_cast<T*>(this) *= T::repeat(b);
            }
            
            FORCE_INLINE T operator/(Item b) const {
                return *static_cast<const T*>(this) / T::repeat(b);
            }
            FORCE_INLINE T operator/(const single<Item> &b) const {
                return *static_cast<const T*>(this) / T::repeat(b);
            }
            FORCE_INLINE T& operator/=(Item b) {
                return *static_cast<T*>(this) /= T::repeat(b);
            }
            FORCE_INLINE T& operator/=(const single<Item> &b) {
                return *static_cast<T*>(this) /= T::repeat(b);
            }
            
            // fall-back implementations for missing SIMD functions
            T add_sub(T b) const {
                static_assert(common<T,Packed,Item>::size % 2 == 0,"this algorithm assumes there is an even number of elements");
                
                T r;
                for(int i=0; i<common<T,Packed,Item>::size; i+=2) {
                    r.data.s[i] = this->data.s[i] + b.data.s[i];
                    r.data.s[i+1] = this->data.s[i+1] - b.data.s[i-1];
                }
                return r;
            }
            
            T ceil() const { return this->apply(static_cast<Item (*)(Item)>(&std::ceil)); }
            T floor() const { return this->apply(static_cast<Item (*)(Item)>(&std::floor)); }
        };
        
        template<typename T,typename Packed,typename Item> FORCE_INLINE T operator*(Item a,const common_real<T,Packed,Item> &b) {
            return T::repeat(a) * static_cast<const T&>(b);
        }
        template<typename T,typename Packed,typename Item> FORCE_INLINE T operator*(const typename T::single &a,const common_real<T,Packed,Item> &b) {
            return T::repeat(a) * static_cast<const T&>(b);
        }
        
        template<typename T,size_t Size,size_t Granularity=1> struct mask_common {
            static const size_t size = Size;
            static const size_t bit_granularity = Granularity;
            
            bool any() const {
                auto bits = static_cast<const T*>(this)->to_bits();
                assert((bits & ((1 << (Size * Granularity)) - 1)) == bits);
                return bits != 0;
            }
            bool all() const {
                auto bits = static_cast<const T*>(this)->to_bits();
                assert((bits & ((1 << (Size * Granularity)) - 1)) == bits);
                return bits == (1 << (Size * Granularity)) - 1;
            }
        };
    }
    
    struct mask_s : impl::mask_common<mask_s,1> {
        bool data;
        
        int to_bits() const {
            return data ? 1 : 0;
        }
        explicit mask_s(bool cond) : data(cond) {}
        
        static mask_s zeros() { return mask_s(false); }
        
        mask_s operator&&(mask_s b) const {
            return mask_s(data && b.data);
        }
        mask_s operator||(mask_s b) const {
            return mask_s(data || b.data);
        }
        mask_s operator!() const {
            return mask_s(!data);
        }
    };
    inline mask_s l_andn(mask_s a,mask_s b) {
        return mask_s(a.data && !b.data);
    }
    inline mask_s l_xor(mask_s a,mask_s b) {
        return mask_s(a.data != b.data);
    }
    inline mask_s l_xnor(mask_s a,mask_s b) {
        return mask_s(a.data == b.data);
    }
    
    template<size_t Size> struct _v_mask<Size,1> { typedef mask_s type; };
    
    /* de-interleaved vector arrays will have a type of
        scalar<v_type<type,size> > */
        
    template<typename T,bool=std::is_arithmetic<T>::value> struct support {
        typedef mask_s mask;
        
        static constexpr bool is_float = std::is_floating_point<T>::value;
        
        static inline T sqrt(T x) { return std::sqrt(x); }
        static inline T rsqrt(T x) { return T(1) / std::sqrt(x); }
        static inline T floor(T x) { return std::floor(x); }
        static inline T ceil(T x) { return std::ceil(x); }
        static inline T abs(T x) { return std::abs(x); }
        static inline T zeros() { return T(0); }
    };
    
    template<typename T> struct support<T,false> {
        typedef typename T::mask mask;
        
        static constexpr bool is_float = std::is_floating_point<typename T::item_t>::value;
        
        static inline T sqrt(T x) { return x.sqrt(); }
        static inline T rsqrt(T x) { return x.rsqrt(); }
        static inline T floor(T x) { return x.floor(); }
        static inline T ceil(T x) { return x.ceil(); }
        static inline T abs(T x) { return x.abs(); }
        static inline T zeros() { return T::zeros(); }
    };

    namespace impl {
        template<typename T,typename This> struct scalar {
            typedef T item_t;
            typedef typename support<T>::mask mask;
            
            scalar() = default;
            scalar(T data) : data(data) {}
            
            static const size_t size = 1;
            
            This operator+(This b) const { return data + b.data; }
            This& operator+=(This b) { data += b.data; return *static_cast<This*>(this); }
            
            This operator-(This b) const { return data - b.data; }
            This& operator-=(This b) { data -= b.data; return *static_cast<This*>(this); }
            
            This operator-() const { return -data; }
            
            This operator&(This b) const { return data & b.data; }
            This& operator&=(This b) { data &= b.data; return *static_cast<This*>(this); }
            
            This operator|(This b) const { return data | b.data; }
            This& operator|=(This b) { data |= b.data; return *static_cast<This*>(this); }
            
            This operator^(This b) const { return data ^ b.data; }
            This& operator^=(This b) { data ^= b.data; return *static_cast<This*>(this); }
            
            T &operator[](size_t i) {
                assert(i == 0);
                return data;
            }
            
            T operator[](size_t i) const {
                assert(i == 0);
                return data;
            }
            
            mask operator==(This b) const { return mask(data == b.data); }
            mask operator!=(This b) const { return mask(data != b.data); }
            mask operator<(This b) const { return mask(data < b.data); }
            mask operator<=(This b) const { return mask(data <= b.data); }
            mask operator>(This b) const { return mask(data > b.data); }
            mask operator>=(This b) const { return mask(data >= b.data); }
            
            template<typename F> This apply(F f) const {
                return This(f(data));
            }
            
            This abs() const { return support<T>::abs(data); }
            
            T reduce_max() const { return data; }
            T reduce_min() const { return data; }
            T reduce_add() const { return data; }
            
            static This load(const T *source) { return *source; }
            static This loadu(const T *source) { return *source; }
            
            void store(T *dest) const { *dest = data; }
            void storeu(T *dest) const { *dest = data; }
            
            This zfilter(mask m) const { return m.data ? data : 0; }
            This nzfilter(mask m) const { return m.data ? 0 : data; }
            
            static This repeat(T x) { return x; }
            
            static This zeros() { return support<T>::zeros(); }
            
            static constexpr bool has_vec_reduce_add = false;
            
            explicit operator bool() const {
                return data != 0;
            }
            
            This &mask_set(mask m,This b) {
                if(m.data) data = b.data;
                return *static_cast<This*>(this);
            }
            
            T data;
        };
    }
    
    template<typename T,bool IsFloat=support<T>::is_float> struct scalar : impl::scalar<T,scalar<T,IsFloat> > {
        scalar() = default;
        scalar(T data) : impl::scalar<T,scalar>(data) {}
    };
    
    template<typename T> struct scalar<T,true> : impl::scalar<T,scalar<T,true> > {
        scalar() = default;
        scalar(T data) : impl::scalar<T,scalar>(data) {}
        
        // a template to support e.g.: scalar<float>() * scalar<float_v_128>()
        template<typename U> scalar<decltype(std::declval<T>() * std::declval<U>())> operator*(scalar<U> b) const { return this->data * b.data; }
        
        scalar& operator*=(scalar b) { this->data *= b.data; return *this; }
        
        scalar operator/(scalar b) const { return this->data / b.data; }
        scalar& operator/=(scalar b) { this->data /= b.data; return *this; }
        
        scalar sqrt() const { return support<T>::sqrt(this->data); }
        scalar rsqrt() const { return support<T>::rsqrt(this->data); }
        scalar ceil() const { return support<T>::ceil(this->data); }
        scalar floor() const { return support<T>::floor(this->data); }
    };
    
    /* a second template argument to support e.g.:
       float() * scalar<float_v_128>() */
    template<typename T,typename U> scalar<decltype(std::declval<T>() * std::declval<U>()),true> operator*(T a,scalar<U,true> b) {
        return a * b.data;
    }

    template<typename T> struct _v_type<T,1> { typedef scalar<T> type; };

    
#ifdef SUPPORT_AVX512F    
    struct mask64_v_512 : impl::mask_common<mask64_v_512,8> {
        __mmask8 data;
        FORCE_INLINE int to_bits() const { return static_cast<int>(data); }
        
        explicit FORCE_INLINE mask64_v_512(__mmask8 data) : data(data) {}
        
        // [[[mask-64-512]]]
    };
    // [[[mask-64-512-outer]]]
    
    struct mask32_v_512 : impl::mask_common<mask32_v_512,16> {
        __mmask16 data;
        FORCE_INLINE int to_bits() const { return static_cast<int>(data); }
        
        explicit FORCE_INLINE mask32_v_512(__mmask16 data) : data(data) {}
        
        // [[[mask-32-512]]]
    };
    // [[[mask-32-512-outer]]]
    
    template<> struct _v_mask<8,8> { typedef mask64_v_512 type; };
    template<> struct _v_mask<4,16> { typedef mask32_v_512 type; };
    
    struct double_v_256;
    struct float_v_256;
    struct int64_v_256;
    struct int32_v_256;
    
    struct double_v_128;
    struct float_v_128;
    struct int64_v_128;
    struct int32_v_128;
    
    struct double_v_512 : impl::common_real<double_v_512,__m512d,double> {
        typedef impl::common_real<double_v_512,__m512d,double> base_t;
        typedef mask64_v_512 mask;
        
        V_INIT_CODE(double_v_512,__m512d,double)
        
        // [[[double-512]]]
        
        using base_t::operator*;
        using base_t::operator/;
        using base_t::operator*=;
        using base_t::operator/=;
        using base_t::operator-;
    };
    V_R_MULT(double_v_512)
    struct float_v_512 : impl::common_real<float_v_512,__m512,float> {
        typedef impl::common_real<float_v_512,__m512,float> base_t;
        typedef mask32_v_512 mask;
        
        V_INIT_CODE(float_v_512,__m512,float)
        
        // [[[float-512]]]
        
        using base_t::operator*;
        using base_t::operator/;
        using base_t::operator*=;
        using base_t::operator/=;
        using base_t::operator-;
    };
    V_R_MULT(float_v_512)
    struct int64_v_512 : impl::common<int64_v_512,__m512i,int64_t> {
        typedef impl::common<int64_v_512,__m512i,int64_t> base_t;
        typedef mask64_v_512 mask;
        
        V_INIT_CODE(int64_v_512,__m512i,int64_t)
        
        // [[[int64_t-512]]]
        
        using base_t::operator-;
    };
    struct int32_v_512 : impl::common<int32_v_512,__m512i,int32_t> {
        typedef impl::common<int32_v_512,__m512i,int32_t> base_t;
        typedef mask32_v_512 mask;
        
        V_INIT_CODE(int32_v_512,__m512i,int32_t)
        
        // [[[int32_t-512]]]
        
        using base_t::operator-;
    };
    
    template<> struct _v_type<double,8> { typedef double_v_512 type; };
    template<> struct _v_type<float,16> { typedef float_v_512 type; };
    template<> struct _v_type<int64_t,8> { typedef int64_v_512 type; };
    template<> struct _v_type<int32_t,16> { typedef int32_v_512 type; };
#endif


#ifdef SUPPORT_AVX
    struct mask64_v_256 : impl::mask_common<mask64_v_256,4> {
        __m256d data;
        FORCE_INLINE int to_bits() const { return _mm256_movemask_pd(data); }
        
        explicit FORCE_INLINE mask64_v_256(__m256d data) : data(data) {}
        explicit FORCE_INLINE mask64_v_256(__m256i data) : data(impl::cast<__m256d>(data)) {}
        
        // [[[mask-64-256]]]
    };
    // [[[mask-64-256-outer]]]

    struct mask32_v_256 : impl::mask_common<mask32_v_256,8> {
        __m256 data;
        FORCE_INLINE int to_bits() const { return _mm256_movemask_ps(data); }
        
        explicit FORCE_INLINE mask32_v_256(__m256 data) : data(data) {}
        explicit FORCE_INLINE mask32_v_256(__m256i data) : data(impl::cast<__m256>(data)) {}
        
        // [[[mask-32-256]]]
    };
    // [[[mask-32-256-outer]]]
    
    template<> struct _v_mask<8,4> { typedef mask64_v_256 type; };
    template<> struct _v_mask<4,8> { typedef mask32_v_256 type; };
#endif


#ifdef SUPPORT_AVX2
    struct mask16_v_256 : impl::mask_common<mask16_v_256,16,2> {
        __m256i data;
        
        /* there is no 16-bit version of movemask but using the 8-bit version
           will give the same result */
        FORCE_INLINE int to_bits() const { return _mm256_movemask_epi8(data); }
        
        explicit FORCE_INLINE mask16_v_256(__m256i data) : data(data) {}
        
        // [[[mask-16-256]]]
    };
    // [[[mask-16-256-outer]]]

    struct mask8_v_256 : impl::mask_common<mask8_v_256,32> {
        __m256i data;
        FORCE_INLINE int to_bits() const { return _mm256_movemask_epi8(data); }
        
        explicit FORCE_INLINE mask8_v_256(__m256i data) : data(data) {}
        
        // [[[mask-8-256]]]
    };
    // [[[mask-8-256-outer]]]
    
    template<> struct _v_mask<2,16> { typedef mask16_v_256 type; };
    template<> struct _v_mask<1,32> { typedef mask8_v_256 type; };

    struct int64_v_128;
    struct int32_v_128;
    struct int16_v_128;
    struct int8_v_128;
    
    struct int64_v_256 : impl::common<int64_v_256,__m256i,int64_t> {
        typedef impl::common<int64_v_256,__m256i,int64_t> base_t;
        typedef mask64_v_256 mask;
        
        V_INIT_CODE(int64_v_256,__m256i,int64_t)
        
        // [[[int64_t-256]]]
        
        using base_t::operator-;
    };
    struct int32_v_256 : impl::common<int32_v_256,__m256i,int32_t> {
        typedef impl::common<int32_v_256,__m256i,int32_t> base_t;
        typedef mask32_v_256 mask;
        
        V_INIT_CODE(int32_v_256,__m256i,int32_t)
        
        // [[[int32_t-256]]]
        
        using base_t::operator-;
    };
    struct int16_v_256 : impl::common<int16_v_256,__m256i,int16_t> {
        typedef impl::common<int16_v_256,__m256i,int16_t> base_t;
        typedef mask16_v_256 mask;
        
        V_INIT_CODE(int16_v_256,__m256i,int16_t)
        
        // [[[int16_t-256]]]
        
        using base_t::operator-;
    };
    struct int8_v_256 : impl::common<int8_v_256,__m256i,int8_t> {
        typedef impl::common<int8_v_256,__m256i,int8_t> base_t;
        typedef mask8_v_256 mask;
        
        V_INIT_CODE(int8_v_256,__m256i,int8_t)
        
        // [[[int8_t-256]]]
        
        using base_t::operator-;
    };
    
    #ifdef SUPPORT_AVX512F
    // [[[int64_t-512-256]]]
    // [[[int32_t-512-256]]]
    #endif
    
    template<> struct _v_type<int64_t,4> { typedef int64_v_256 type; };
    template<> struct _v_type<int32_t,8> { typedef int32_v_256 type; };
    template<> struct _v_type<int16_t,16> { typedef int16_v_256 type; };
    template<> struct _v_type<int8_t,32> { typedef int8_v_256 type; };
#endif

#ifdef SUPPORT_AVX
    struct double_v_128;
    struct float_v_128;
    
    struct double_v_256 : impl::common_real<double_v_256,__m256d,double> {
        typedef impl::common_real<double_v_256,__m256d,double> base_t;
        typedef mask64_v_256 mask;
        
        V_INIT_CODE(double_v_256,__m256d,double)
        
        // [[[double-256]]]
        
        using base_t::operator*;
        using base_t::operator/;
        using base_t::operator*=;
        using base_t::operator/=;
        using base_t::operator-;
    };
    V_R_MULT(double_v_256)
    struct float_v_256 : impl::common_real<float_v_256,__m256,float> {
        typedef impl::common_real<float_v_256,__m256,float> base_t;
        typedef mask32_v_256 mask;
        
        V_INIT_CODE(float_v_256,__m256,float)
        
        // [[[float-256]]]
        
        using base_t::operator*;
        using base_t::operator/;
        using base_t::operator*=;
        using base_t::operator/=;
        using base_t::operator-;
    };
    V_R_MULT(float_v_256)
    
    #ifdef SUPPORT_AVX512F
    // [[[double-512-256]]]
    // [[[float-512-256]]]
    #endif
    
    template<> struct _v_type<double,4> { typedef double_v_256 type; };
    template<> struct _v_type<float,8> { typedef float_v_256 type; };
#endif


#ifdef SUPPORT_SSE
    struct mask32_v_128 : impl::mask_common<mask32_v_128,4> {
        __m128 data;
        FORCE_INLINE int to_bits() const { return _mm_movemask_ps(data); }
        
        explicit FORCE_INLINE mask32_v_128(__m128 data) : data(data) {}
    #ifdef SUPPORT_SSE2
        explicit FORCE_INLINE mask32_v_128(__m128i data) : data(impl::cast<__m128>(data)) {}
    #endif
        
        // [[[mask-32-128]]]
    };
    // [[[mask-32-128-outer]]]
    
    template<> struct _v_mask<4,4> { typedef mask32_v_128 type; };
#endif
    
#ifdef SUPPORT_SSE2
    struct mask64_v_128 : impl::mask_common<mask64_v_128,2> {
        __m128d data;
        FORCE_INLINE int to_bits() const { return _mm_movemask_pd(data); }
        
        explicit FORCE_INLINE mask64_v_128(__m128d data) : data(data) {}
        explicit FORCE_INLINE mask64_v_128(__m128i data) : data(impl::cast<__m128d>(data)) {}
        
        // [[[mask-64-128]]]
    };
    // [[[mask-64-128-outer]]]

    struct mask16_v_128 : impl::mask_common<mask16_v_128,8,2> {
        __m128i data;
        
        /* there is no 16-bit version of movemask but using the 8-bit version
           will give the same result */
        FORCE_INLINE int to_bits() const { return _mm_movemask_epi8(data); }
        
        explicit FORCE_INLINE mask16_v_128(__m128i data) : data(data) {}
        
        // [[[mask-16-128]]]
    };
    // [[[mask-16-128-outer]]]

    struct mask8_v_128 : impl::mask_common<mask8_v_128,16> {
        __m128i data;
        FORCE_INLINE int to_bits() const { return _mm_movemask_epi8(data); }
        
        explicit FORCE_INLINE mask8_v_128(__m128i data) : data(data) {}
        
        // [[[mask-8-128]]]
    };
    // [[[mask-8-128-outer]]]
    
    template<> struct _v_mask<8,2> { typedef mask64_v_128 type; };
    template<> struct _v_mask<2,8> { typedef mask16_v_128 type; };
    template<> struct _v_mask<1,16> { typedef mask8_v_128 type; };
    
    struct double_v_128 : impl::common_real<double_v_128,__m128d,double> {
        typedef impl::common_real<double_v_128,__m128d,double> base_t;
        typedef mask64_v_128 mask;
        
        V_INIT_CODE(double_v_128,__m128d,double)
        
        // [[[double-128]]]
        
        using base_t::operator*;
        using base_t::operator/;
        using base_t::operator*=;
        using base_t::operator/=;
        using base_t::operator-;
    };
    V_R_MULT(double_v_128)
    struct int64_v_128 : impl::common<int64_v_128,__m128i,int64_t> {
        typedef impl::common<int64_v_128,__m128i,int64_t> base_t;
        typedef mask64_v_128 mask;
        
        V_INIT_CODE(int64_v_128,__m128i,int64_t)
        
        // [[[int64_t-128]]]
        
        using base_t::operator-;
    };
    struct int32_v_128 : impl::common<int32_v_128,__m128i,int32_t> {
        typedef impl::common<int32_v_128,__m128i,int32_t> base_t;
        typedef mask32_v_128 mask;
        
        V_INIT_CODE(int32_v_128,__m128i,int32_t)
        
        // [[[int32_t-128]]]
        
        using base_t::operator-;
    };
    struct int16_v_128 : impl::common<int16_v_128,__m128i,int16_t> {
        typedef impl::common<int16_v_128,__m128i,int16_t> base_t;
        typedef mask16_v_128 mask;
        
        V_INIT_CODE(int16_v_128,__m128i,int16_t)
        
        // [[[int16_t-128]]]
        
        using base_t::operator-;
    };
    struct int8_v_128 : impl::common<int8_v_128,__m128i,int8_t> {
        typedef impl::common<int8_v_128,__m128i,int8_t> base_t;
        typedef mask8_v_128 mask;
        
        V_INIT_CODE(int8_v_128,__m128i,int8_t)
        
        // [[[int8_t-128]]]
        
        using base_t::operator-;
    };
    
    #ifdef SUPPORT_AVX512F
    // [[[double-512-128]]]
    // [[[int64_t-512-128]]]
    // [[[int32_t-512-128]]]
    #endif
    
    #ifdef SUPPORT_AVX2
    // [[[int64_t-256-128]]]
    // [[[int32_t-256-128]]]
    // [[[int16_t-256-128]]]
    // [[[int8_t-256-128]]]
    #endif
    
    #ifdef SUPPORT_AVX
    // [[[double-256-128]]]
    #endif
    
    template<> struct _v_type<double,2> { typedef double_v_128 type; };
    template<> struct _v_type<int64_t,2> { typedef int64_v_128 type; };
    template<> struct _v_type<int32_t,4> { typedef int32_v_128 type; };
    template<> struct _v_type<int16_t,8> { typedef int16_v_128 type; };
    template<> struct _v_type<int8_t,16> { typedef int8_v_128 type; };
#endif


#ifdef SUPPORT_SSE
    struct float_v_128 : impl::common_real<float_v_128,__m128,float> {
        typedef impl::common_real<float_v_128,__m128,float> base_t;
        typedef mask32_v_128 mask;
        
        V_INIT_CODE(float_v_128,__m128,float)
        
        // [[[float-128]]]
        
        using base_t::operator*;
        using base_t::operator/;
        using base_t::operator*=;
        using base_t::operator/=;
        using base_t::operator-;
    };
    V_R_MULT(float_v_128)
    
    #ifdef SUPPORT_AVX512F
    // [[[float-512-128]]]
    #endif
    
    #ifdef SUPPORT_AVX
    // [[[float-256-128]]]
    #endif
    
    template<> struct _v_type<float,4> { typedef float_v_128 type; };
#endif
    
    
    /* the zeros at the end are just so "largest_fit" (defined below) doesn't
       need to check if its argument is zero */
    namespace impl {
        struct v_sizes_default {
            static constexpr size_t value[] = {1,0};
        };
    }
    
    template<typename T> struct v_sizes : impl::v_sizes_default {};
    
#ifdef SUPPORT_SSE
    template<> struct v_sizes<float> {
        static constexpr size_t value[] = {
    #ifdef SUPPORT_AVX
      #ifdef SUPPORT_AVX512F
            16,
      #endif
            8,
    #endif
            4,1,0};
    };
    
  #ifdef SUPPORT_SSE2
    template<> struct v_sizes<double> {
        static constexpr size_t value[] = {
    #ifdef SUPPORT_AVX
      #ifdef SUPPORT_AVX512F
            8,
      #endif
            4,
    #endif
            2,1,0};
    };
    
    template<> struct v_sizes<int64_t> {
        static constexpr size_t value[] = {
    #ifdef SUPPORT_AVX2
      #ifdef SUPPORT_AVX512F
            8,
      #endif
            4,
    #endif
            2,1,0};
    };
    
    template<> struct v_sizes<int32_t> {
        static constexpr size_t value[] = {
    #ifdef SUPPORT_AVX2
      #ifdef SUPPORT_AVX512F
            16,
      #endif
            8,
    #endif
            4,1,0};
    };
    
    template<> struct v_sizes<int16_t> {
        static constexpr size_t value[] = {
    #ifdef SUPPORT_AVX2
            16,
    #endif
            8,1,0};
    };
    
    template<> struct v_sizes<int8_t> {
        static constexpr size_t value[] = {
    #ifdef SUPPORT_AVX2
            32,
    #endif
            16,1,0};
    };
  #endif
#endif
    
    namespace impl {
        //template<typename T> struct negation_mask_item {
        //    struct type {
        //        T value;
        //        constexpr type() : value(T(1) << (sizeof(T)*8 - 1)) {}
        //    };
        //};
        //template<> struct negation_mask_item<float> {
        //    struct type {
        //        float value;
        //        constexpr type() : value(-0.0f) {}
        //    };
        //};
        //template<> struct negation_mask_item<double> {
        //    struct type {
        //        double value;
        //        constexpr type() : value(-0.0) {}
        //    };
        //};
        
        //template<typename T> struct negation_mask {
        //    /* we have to use alignof because when using GCC 4.7, alignas is
        //       just a macro wrapping __attribute__ ((aligned (X))) */
        //    alignas(alignof(v_type<T,v_sizes<T>::value[0]>)) static constexpr typename negation_mask_item<T>::type value[v_sizes<T>::value[0]] = {};
        //};
        
        
        // hide the second argument
        
        template<typename T> constexpr size_t largest_fit(size_t size,size_t i) {
            return size >= v_sizes<T>::value[i] ? v_sizes<T>::value[i] : largest_fit<T>(size,i+1);
        }

        template<typename T> constexpr size_t padded_size(size_t size,size_t i) {
            typedef v_sizes<T> s;
            
            //return size >= s::value[i+1] ?
            return size >= s::value[i] ?
                (size / s::value[i] * s::value[i])
                    + (size % s::value[i] == 0 ? 0 : (size % s::value[i] == s::value[i+1] ? s::value[i+1] : s::value[i])) :
                padded_size<T>(size,i+1);
        }
    }
    template<typename T> constexpr size_t largest_fit(size_t size) {
        return impl::largest_fit<T>(size,0);
    }
    
    template<typename T> constexpr size_t padded_size(size_t size) {
        return size > 1 ? impl::padded_size<T>(size,0) : size;
    }
    
    
    template<typename T> scalar<T> max(scalar<T> a,scalar<T> b) {
        return a.data > b.data ? a : b;
    }

    template<typename T> scalar<T> min(scalar<T> a,scalar<T> b) {
        return a.data < b.data ? a : b;
    }

    template<typename T> mask_s cmp_nlt(scalar<T> a,scalar<T> b) {
        return mask_s(!(a.data < b.data));
    }

    template<typename T> mask_s cmp_nle(scalar<T> a,scalar<T> b) {
        return mask_s(!(a.data <= b.data));
    }

    template<typename T> mask_s cmp_ngt(scalar<T> a,scalar<T> b) {
        return mask_s(!(a.data > b.data));
    }

    template<typename T> mask_s cmp_nge(scalar<T> a,scalar<T> b) {
        return mask_s(!(a.data >= b.data));
    }
    
    template<typename T> int test_z(scalar<T> a,scalar<T> b) {
        return a.data & b.data ? 1 : 0;
    }

    template<typename T> int test_z(scalar<T> a) {
        return a.data ? 1 : 0;
    }

    template<typename T> scalar<T> mask_blend(mask_s m,scalar<T> a,scalar<T> b) {
        return m.data ? a : b;
    }

    // fall-back implementations for missing SIMD functions
    template<typename T> FORCE_INLINE int test_z(T a,T b) {
        return ((a & b) == T::zeros()).all() ? 1 : 0;
    }

    template<typename T> FORCE_INLINE int test_z(T a) {
        return (a == T::zeros()).all() ? 1 : 0;
    }

    template<typename T> FORCE_INLINE T mask_blend(typename T::mask m,T a,T b)  {
        return a.zfilter(m) | b.nzfilter(m);
    }
    // end of fall-back functions

    
    // [[[functions]]]
    
    
    namespace impl {
        template<typename T,typename Packed,typename Item> FORCE_INLINE common<T,Packed,Item>::operator bool() const {
            return test_z(*static_cast<const T*>(this));
        }
    }
    

    inline void *aligned_alloc(size_t align,size_t size) {
        void *dest;
#if defined(USE_POSIX)
        if(posix_memalign(&dest,std::max(align,sizeof(void*)),size)) throw std::bad_alloc();
#elif defined(USE_WIN)
        if(!(dest = _aligned_malloc(size,align))) throw std::bad_alloc();
#else
        size_t extra = (sizeof(void*) >= align ? 0 : align - sizeof(void*)) + sizeof(void*);
        void *original = malloc(size + extra)
        if(!original) throw std::bad_alloc();
        dest = (reinterpret_cast<char*>(original) + extra) / align * align;
        reinterpret_cast<void**>(*dest)[-1] = original;
#endif
        return dest;
    }
    
    inline void aligned_free(void *m) noexcept {
#if defined(USE_POSIX)
        free(m);
#elif defined(USE_WIN)
        _aligned_free(m);
#else
        free(reinterpret_cast<void**>(m)[-1]);
#endif
    }
    
    
    template<typename T> struct aligned_allocator {
        static_assert(sizeof(T) % alignof(T) == 0,"The object's size needs to be a multiple of its alignment");
        
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef T* pointer;
        typedef const T* const_pointer;
        typedef T& reference;
        typedef const T& const_reference;
        typedef T value_type;
        
        template<typename U> struct rebind { typedef aligned_allocator<U> other; };
        
        pointer address(reference x) const { return &x; }
        const_pointer address(const_reference x) const { return &x; }
        
        pointer allocate(size_type n,void *hint = 0) const {
            return reinterpret_cast<pointer>(aligned_alloc(alignof(T),n * sizeof(T)));
        }
        
        void deallocate(pointer p,size_type) const {
            aligned_free(p);
        }
        
        size_type max_size() const throw() { return size_type(-1) / sizeof(T); }
        
        void construct(pointer p,const_reference val) { new(p) T(val); }
        
        void destroy(pointer p) { p->~T(); }
    };
    
    namespace impl {
        template<typename T,bool need_align=(alignof(T) > alignof(std::max_align_t))> struct allocator {
            typedef std::allocator<T> type;
        };
        template<typename T> struct allocator<T,true> {
            typedef aligned_allocator<T> type;
        };
    }
    
    /* aliases std::allocator or aligned_allocator depending on whether T needs
       extra alignment */
    template<typename T> using allocator = typename impl::allocator<T>::type;
}

#endif
