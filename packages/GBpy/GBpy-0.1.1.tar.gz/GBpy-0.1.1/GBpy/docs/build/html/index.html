<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to GBPy’s documentation! &mdash; GBPy 1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="GBPy 1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">GBPy 1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-gbpy-s-documentation">
<h1>Welcome to GBPy&#8217;s documentation!<a class="headerlink" href="#welcome-to-gbpy-s-documentation" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
</div>
<div class="section" id="module-lattice">
<span id="lattice-class"></span><h1>Lattice Class<a class="headerlink" href="#module-lattice" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="lattice.Lattice">
<em class="property">class </em><tt class="descclassname">lattice.</tt><tt class="descname">Lattice</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/lattice.html#Lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lattice.Lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>This class contains all the crystallographic information required for each
atom type. Currently there are only two pre-configured atoms available in
class i.e. &#8216;Al&#8217; and &#8216;Mg&#8217;. Up on need user can create a new instance of this
class with the same attributes. The attributes of this class are:
...</p>
<p class="rubric">Notes</p>
<p>Examples of elem_type
elem_type = &#8216;Mg&#8217;;
elem_type = &#8216;Al&#8217;;
elem_type = &#8216;Cu&#8217;;
elem_type = &#8216;Ni&#8217;;
elem_type = &#8216;cF_Id&#8217;;
elem_type = &#8216;cI_Id&#8217;;
elem_type = &#8216;cP_Id&#8217;;
elem_type = &#8216;hP_Id&#8217;;</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>elem_type: string</td>
<td>Element of Interest</td>
</tr>
<tr class="row-even"><td>pearson: string</td>
<td>Pearson symbol for the lattice</td>
</tr>
<tr class="row-odd"><td>lat_params: dictionary</td>
<td>Lattice parameters (&#8216;a&#8217;, &#8216;b&#8217;, &#8216;c&#8217;, &#8216;alpha&#8217;, &#8216;beta&#8217;, &#8216;gamma&#8217;)</td>
</tr>
<tr class="row-even"><td>l_g_go: numpy array</td>
<td>Primitve basis of the lattice</td>
</tr>
<tr class="row-odd"><td>basis_atoms:</td>
<td>Location of the basis atoms in the primitive lattice</td>
</tr>
<tr class="row-even"><td>cryst_ptgrp: string</td>
<td>Crystallographic point group of the lattice</td>
</tr>
<tr class="row-odd"><td>burgers_mag: float</td>
<td>The smallest burgers vector in the lattice</td>
</tr>
<tr class="row-even"><td>eam_file:</td>
<td>eam_file name for atomistic simulations</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="79%" />
<col width="21%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>str</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Method for printing the lattice class</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-quaternion">
<span id="geometry"></span><h1>Geometry<a class="headerlink" href="#module-quaternion" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="quaternion.quaternion">
<em class="property">class </em><tt class="descclassname">quaternion.</tt><tt class="descname">quaternion</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quaternion.html#quaternion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quaternion.quaternion" title="Permalink to this definition">¶</a></dt>
<dd><p>The quaternion class is defined to define the quaternion parameterization
of rotation and their operations
...</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="70%" />
<col width="30%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>quaternion: numpy array</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>5 x n dimensions</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">all</span></tt>([axis,&nbsp;out])</td>
<td>Returns True if all elements evaluate to True.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">any</span></tt>([axis,&nbsp;out])</td>
<td>Returns True if any of the elements of <cite>a</cite> evaluate to True.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">argmax</span></tt>([axis,&nbsp;out])</td>
<td>Return indices of the maximum values along the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">argmin</span></tt>([axis,&nbsp;out])</td>
<td>Return indices of the minimum values along the given axis of <cite>a</cite>.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">argpartition</span></tt>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would partition this array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">argsort</span></tt>([axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would sort this array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">astype</span></tt>(dtype[,&nbsp;order,&nbsp;casting,&nbsp;subok,&nbsp;copy])</td>
<td>Copy of the array, cast to a specified type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">byteswap</span></tt>(inplace)</td>
<td>Swap the bytes of the array elements</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">choose</span></tt>(choices[,&nbsp;out,&nbsp;mode])</td>
<td>Use an index array to construct a new array from a set of choices.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">clip</span></tt>(a_min,&nbsp;a_max[,&nbsp;out])</td>
<td>Return an array whose values are limited to <tt class="docutils literal"><span class="pre">[a_min,</span> <span class="pre">a_max]</span></tt>.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compress</span></tt>(condition[,&nbsp;axis,&nbsp;out])</td>
<td>Return selected slices of this array along given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">conj</span></tt>()</td>
<td>Complex-conjugate all elements.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">conjugate</span></tt>()</td>
<td>Return the complex conjugate, element-wise.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>([order])</td>
<td>Return a copy of the array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cumprod</span></tt>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative product of the elements along the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cumsum</span></tt>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative sum of the elements along the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">diagonal</span></tt>([offset,&nbsp;axis1,&nbsp;axis2])</td>
<td>Return specified diagonals.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">dot</span></tt>(b[,&nbsp;out])</td>
<td>Dot product of two arrays.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">dump</span></tt>(file)</td>
<td>Dump a pickle of the array to the specified file.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">dumps</span></tt>()</td>
<td>Returns the pickle of the array as a string.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fill</span></tt>(value)</td>
<td>Fill the array with a scalar value.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">flatten</span></tt>([order])</td>
<td>Return a copy of the array collapsed into one dimension.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">getfield</span></tt>(dtype[,&nbsp;offset])</td>
<td>Returns a field of the given array as a certain type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">item</span></tt>(*args)</td>
<td>Copy an element of an array to a standard Python scalar and return it.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">itemset</span></tt>(*args)</td>
<td>Insert scalar into an array (scalar is cast to array&#8217;s dtype, if possible)</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>([axis,&nbsp;out])</td>
<td>Return the maximum along a given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Returns the average of the array elements along given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>([axis,&nbsp;out])</td>
<td>Return the minimum along a given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">newbyteorder</span></tt>([new_order])</td>
<td>Return the array with the same data viewed with a different byte order.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">nonzero</span></tt>()</td>
<td>Return the indices of the elements that are non-zero.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">partition</span></tt>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Rearranges the elements in the array in such a way that value of the element in kth position is in the position it would be in a sorted array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">prod</span></tt>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the product of the array elements over the given axis</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">ptp</span></tt>([axis,&nbsp;out])</td>
<td>Peak to peak (maximum - minimum) value along a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">put</span></tt>(indices,&nbsp;values[,&nbsp;mode])</td>
<td>Set <tt class="docutils literal"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></tt> for all <cite>n</cite> in indices.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">ravel</span></tt>([order])</td>
<td>Return a flattened array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">repeat</span></tt>(repeats[,&nbsp;axis])</td>
<td>Repeat elements of an array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reshape</span></tt>(shape[,&nbsp;order])</td>
<td>Returns an array containing the same data with a new shape.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">resize</span></tt>(new_shape[,&nbsp;refcheck])</td>
<td>Change shape and size of array in-place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">round</span></tt>([decimals,&nbsp;out])</td>
<td>Return <cite>a</cite> with each element rounded to the given number of decimals.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">searchsorted</span></tt>(v[,&nbsp;side,&nbsp;sorter])</td>
<td>Find indices where elements of v should be inserted in a to maintain order.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">setfield</span></tt>(val,&nbsp;dtype[,&nbsp;offset])</td>
<td>Put a value into a specified place in a field defined by a data-type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">setflags</span></tt>([write,&nbsp;align,&nbsp;uic])</td>
<td>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sort</span></tt>([axis,&nbsp;kind,&nbsp;order])</td>
<td>Sort an array, in-place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>([axis])</td>
<td>Remove single-dimensional entries from the shape of <cite>a</cite>.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof])</td>
<td>Returns the standard deviation of the array elements along given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the sum of the array elements over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">swapaxes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">take</span></tt>(indices[,&nbsp;axis,&nbsp;out,&nbsp;mode])</td>
<td>Return an array formed from the elements of <cite>a</cite> at the given indices.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">tofile</span></tt>(fid[,&nbsp;sep,&nbsp;format])</td>
<td>Write array to a file as text or binary (default).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">tolist</span></tt>()</td>
<td>Return the array as a (possibly nested) list.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">tostring</span></tt>([order])</td>
<td>Construct a Python string containing the raw data bytes in the array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">trace</span></tt>([offset,&nbsp;axis1,&nbsp;axis2,&nbsp;dtype,&nbsp;out])</td>
<td>Return the sum along diagonals of the array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">transpose</span></tt>(*axes)</td>
<td>Returns a view of the array with axes transposed.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof])</td>
<td>Returns the variance of the array elements, along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">view</span></tt>([dtype,&nbsp;type])</td>
<td>New view of array with the same data.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-integer_manipulations">
<span id="integer-manipulations"></span><h1>Integer Manipulations<a class="headerlink" href="#module-integer_manipulations" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="integer_manipulations.gcd_array">
<tt class="descclassname">integer_manipulations.</tt><tt class="descname">gcd_array</tt><big>(</big><em>input</em>, <em>order='all'</em><big>)</big><a class="reference internal" href="_modules/integer_manipulations.html#gcd_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#integer_manipulations.gcd_array" title="Permalink to this definition">¶</a></dt>
<dd><p>The function computes the GCD of an array of numbers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : numpy array or list of intgers</p>
<p><strong>Input n-D array of integers (most suitable for 1D and 2D arrays)</strong></p>
<p><strong>order</strong> : {&#8216;rows&#8217;, &#8216;columns&#8217;, &#8216;col&#8217;, &#8216;all&#8217;}, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Agcd: numpy array</p>
<p class="last">An array of greatest common divisors of the input</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">gcd</span></tt></dt>
<dd>from fractions module for computing gcd of two integers</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li>If order = <strong>all</strong>, the input array is flattened and the GCD is calculated</li>
<li>If order = <strong>rows</strong>, GCD of elements in each row is calculated</li>
<li>If order = <strong>columns</strong> or <strong>cols</strong>, GCD of elements in each column is calculated</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="integer_manipulations.lcm_vec">
<tt class="descclassname">integer_manipulations.</tt><tt class="descname">lcm_vec</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="reference internal" href="_modules/integer_manipulations.html#lcm_vec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#integer_manipulations.lcm_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>The function computes the LCM of two 1D array of integers of length
and retruns a 1D array of lcm values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a, b</strong> : numpy array</p>
<p><strong>Input 1D arrays of integers</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">lcm_vector: numpy array</p>
<p class="last">Output 1D array of integers</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">lcm_arry</span></tt></p>
</div>
</dd></dl>

<dl class="function">
<dt id="integer_manipulations.lcm_array">
<tt class="descclassname">integer_manipulations.</tt><tt class="descname">lcm_array</tt><big>(</big><em>input</em>, <em>order</em><big>)</big><a class="reference internal" href="_modules/integer_manipulations.html#lcm_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#integer_manipulations.lcm_array" title="Permalink to this definition">¶</a></dt>
<dd><p>The function computes the LCM of an array of numbers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : numpy array or list of intgers</p>
<p><strong>Input n-D array of integers (most suitable for 1D and 2D arrays)</strong></p>
<p><strong>order</strong> : {&#8216;rows&#8217;, &#8216;columns&#8217;, &#8216;col&#8217;, &#8216;all&#8217;}, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Alcm: numpy array</p>
<p class="last">An array of least common multiples of the input</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#integer_manipulations.gcd_array" title="integer_manipulations.gcd_array"><tt class="xref py py-obj docutils literal"><span class="pre">gcd_array</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li>If order = <strong>all</strong>, the input array is flattened and the LCM is calculated</li>
<li>If order = <strong>rows</strong>, LCM of elements in each row is calculated</li>
<li>If order = <strong>columns</strong> or <strong>cols</strong>, LCM of elements in each column is calculated</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="integer_manipulations.int_check">
<tt class="descclassname">integer_manipulations.</tt><tt class="descname">int_check</tt><big>(</big><em>input</em>, <em>precis=6</em><big>)</big><a class="reference internal" href="_modules/integer_manipulations.html#int_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#integer_manipulations.int_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the input variable (arrays) is an interger or not.
A precision value is specified and the integer check is performed
up to that decimal point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : numpy array or list</p>
<p><strong>Input n-D array of floats</strong></p>
<p><strong>precis</strong> : Integer</p>
<p><strong>Default = 6</strong></p>
<p><strong>A value that specifies the precision to which the number is an</strong></p>
<p><strong>integer. *precis = 6* implies a precision of :math:`10^{-6}`.</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">cond: Boolean</p>
<p><strong>True</strong> if the element is an integer to a certain precision,</p>
<p class="last"><strong>False</strong> otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="integer_manipulations.rat">
<tt class="descclassname">integer_manipulations.</tt><tt class="descname">rat</tt><big>(</big><em>input</em>, <em>tol=1e-06</em><big>)</big><a class="reference internal" href="_modules/integer_manipulations.html#rat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#integer_manipulations.rat" title="Permalink to this definition">¶</a></dt>
<dd><p>The function returns a rational (p/q) approximation of a given
floating point array to a given precision</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : numpy array or list of real numbers</p>
<p><strong>tol</strong> : floating point tolerance value</p>
<p><strong>Default = 1e-06</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">N, D: Integer numpy arrays</p>
<p>N and D contain the numerators (p) and denominators (q) of the</p>
<p class="last">rational approximations</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="integer_manipulations.int_finder">
<tt class="descclassname">integer_manipulations.</tt><tt class="descname">int_finder</tt><big>(</big><em>input</em>, <em>tol=1e-06</em>, <em>order='all'</em>, <em>tol1=1e-06</em><big>)</big><a class="reference internal" href="_modules/integer_manipulations.html#int_finder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#integer_manipulations.int_finder" title="Permalink to this definition">¶</a></dt>
<dd><p>The function computes the scaling factor required to multiply the
given input array to obtain an integer array. The integer array is
returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : numpy array or list of real numbers</p>
<p><strong>tol</strong> : floating point tolerance value</p>
<p><strong>Default = 1e-06</strong></p>
<p><strong>order</strong> : {&#8216;rows&#8217;, &#8216;columns&#8217;, &#8216;col&#8217;, &#8216;all&#8217;}</p>
<p><strong>Defualt = &#8216;all&#8217;</strong></p>
<p><strong>tol1:</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: numpy float array</p>
<p class="last">An array of integers obtained by scaling input</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#integer_manipulations.gcd_array" title="integer_manipulations.gcd_array"><tt class="xref py py-obj docutils literal"><span class="pre">gcd_array</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li>If order = <strong>all</strong>, the input array is flattened and then scaled</li>
<li>If order = <strong>rows</strong>, elements in each row are scaled</li>
<li>If order = <strong>columns</strong> or <strong>cols</strong>, elements in each column are scaled</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="integer_manipulations.int_mult">
<tt class="descclassname">integer_manipulations.</tt><tt class="descname">int_mult</tt><big>(</big><em>input</em>, <em>tol=1e-06</em><big>)</big><a class="reference internal" href="_modules/integer_manipulations.html#int_mult"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#integer_manipulations.int_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>The function computes the scaling factor required to multiply the
given input array to obtain an integer array. The integer array is
returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : numpy array or list of real numbers</p>
<p><strong>tol</strong> : floating point tolerance value</p>
<p><strong>Default = 1e-06</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">N: numpy float array</p>
<p>An array of integers obtained by scaling input</p>
<p>Int_Mat: numpy float array</p>
<p class="last">An array of integers obtained by scaling input</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#integer_manipulations.int_finder" title="integer_manipulations.int_finder"><tt class="xref py py-obj docutils literal"><span class="pre">int_finder</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p><strong>Change this function to accept rows and columns as input</strong></p>
</dd></dl>

</div>
<div class="section" id="module-csl_utility_functions">
<span id="csl-utility-function"></span><h1>CSL Utility Function<a class="headerlink" href="#module-csl_utility_functions" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="csl_utility_functions.csl_rotations">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">csl_rotations</tt><big>(</big><em>sigma</em>, <em>sig_type</em>, <em>lat_type</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#csl_rotations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.csl_rotations" title="Permalink to this definition">¶</a></dt>
<dd><p>The function computes the CSL rotation matrices r_g1tog2_g1 corresponding
to a give sigma and lattice</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sigma</strong> : int</p>
<p><strong>Sigma corresponding to the transformation matrix</strong></p>
<p><strong>sig_type: {&#8216;common&#8217;, &#8216;specific&#8217;}</strong></p>
<p><strong>If the sigma generating function depends on the lattice type, then</strong></p>
<p><strong>sig_type is &#8216;specific&#8217;, otherwise it is &#8216;common&#8217;</strong></p>
<p><strong>lat_type: Lattice class</strong></p>
<p><strong>Attributes of the underlying lattice</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">sig_rots: dictionary</p>
<p>keys: &#8216;N&#8217;, &#8216;D&#8217;</p>
<p>sig_rots[&#8216;N&#8217;], sig_rots[&#8216;D&#8217;]: Numerator and Integer matrices</p>
<p>The transformation matrix is N/D in the g1 reference frame</p>
<p class="last">(i.e. r_g1tog2_g1)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The following steps are considered to obtain the sigma rotation:</p>
<ul>
<li><p class="first">compute_inp_params: computes tau and kmax that fixes the range of
integer qudruples sampled</p>
</li>
<li><p class="first">mesh_muvw: Creates the integer quadruples that depend on sigma,
tau, kmax, crystallographic point group</p>
</li>
<li><p class="first">eliminate_idrots: Eliminates Identity rotations</p>
</li>
<li><dl class="first docutils">
<dt>If specific rotations are desired:</dt>
<dd><ul class="first last simple">
<li>mesh_muvw_fz: Restricts quadruples to fundamental zone</li>
<li>check_fsig_int: Filters out quadruples that do not meet the
condition specified in this function</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">sigtype_muvw: Filters out quadruple combinations depending on
the type of sigma rotation</p>
</li>
<li><p class="first">eliminate_mults: Eliminates integer quadruples that are same except for
a scaling factor</p>
</li>
<li><p class="first">check_sigma: Returns integer quadruples that result in the sigma rotation</p>
</li>
<li><p class="first">compute_tmat: Computes the transformation matrix from the integer
quadruple</p>
</li>
<li><p class="first">disorient_sigmarots: Converts all the transformations to the fundamental
zone of the corresponding crystallogrphic point group</p>
</li>
<li><p class="first">check_sigma_rots: Checks that the transformation matrix is a sigma
rotation and returns them as numerator and denominator matrices</p>
</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.proper_ptgrp">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">proper_ptgrp</tt><big>(</big><em>cryst_ptgrp</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#proper_ptgrp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.proper_ptgrp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the proper point group corresponding to a crystallographic point
group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cryst_ptgrp: string</strong></p>
<p><strong>Crystallogrphic point group in Schoenflies notation</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">proper_ptgrp: string</p>
<p class="last">Proper point group in Schoenflies notation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.largest_odd_factor">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">largest_odd_factor</tt><big>(</big><em>var_arr</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#largest_odd_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.largest_odd_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that computes the larges odd factors of an array of integers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>var_arr: numpy array</strong></p>
<p><strong>Array of integers whose largest odd factors needs to be computed</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">odd_d: numpy array</p>
<p class="last">Array of largest odd factors of each integer in var_arr</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.compute_inp_params">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">compute_inp_params</tt><big>(</big><em>lattice</em>, <em>sig_type</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#compute_inp_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.compute_inp_params" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>tau and kmax necessary for possible integer quadruple combinations
are computed</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>lattice: Lattice class</strong></p>
<blockquote>
<div><p>Attributes of the underlying lattice</p>
<p>sig_type: {&#8216;common&#8217;, &#8216;specific&#8217;}</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tau, kmax: floats</p>
<blockquote>
<div><p>tau is a rational number $=</p>
</div></blockquote>
<p>rac{nu}{mu}$</p>
<blockquote>
<div><p>kmax is an integer that depends on $mu$ and $</p>
</div></blockquote>
<p class="last">u$</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.mesh_muvw">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">mesh_muvw</tt><big>(</big><em>cryst_ptgrp</em>, <em>sigma</em>, <em>sig_type</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#mesh_muvw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.mesh_muvw" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute max allowed values of [m,U,V,W] and generates an array
of integer quadruples</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cryst_ptgrp: string</strong></p>
<p><strong>Proper point group in Schoenflies notation</strong></p>
<p><strong>sigma: integer</strong></p>
<p><strong>Sigma number</strong></p>
<p><strong>sig_type: {&#8216;common&#8217;, &#8216;specific&#8217;}</strong></p>
<p><strong>args[0]: dictionary</strong></p>
<p><strong>keys: &#8216;nu&#8217;, &#8216;mu&#8217;, &#8216;kmax&#8217;</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Integer quadruple numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.mesh_muvw_fz">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">mesh_muvw_fz</tt><big>(</big><em>quad_int</em>, <em>cryst_ptgrp</em>, <em>sig_type</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#mesh_muvw_fz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.mesh_muvw_fz" title="Permalink to this definition">¶</a></dt>
<dd><p>For given integer quadruples, the set belonging to the corresponding
fundamental zone are separated out and retruned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quad_int: numpy array</strong></p>
<p><strong>Integer quadruples</strong></p>
<p><strong>cryst_ptgrp: string</strong></p>
<p><strong>Proper point group in Schoenflies notation</strong></p>
<p><strong>sig_type: {&#8216;common&#8217;, &#8216;specific&#8217;}</strong></p>
<p><strong>args[0]: dictionary</strong></p>
<p><strong>keys: &#8216;nu&#8217;, &#8216;mu&#8217;, &#8216;kmax&#8217;</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Integer quadruple numpy array belonging to the fundamental zone</p>
<p class="last">of the corresponding crystallographic point group</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.check_fsig_int">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">check_fsig_int</tt><big>(</big><em>quad_int</em>, <em>cryst_ptgrp</em>, <em>sigma</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#check_fsig_int"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.check_fsig_int" title="Permalink to this definition">¶</a></dt>
<dd><p>For specific sigma rotations, a function of m, U, V, W (fsig) is computed.
The ratio of fsig and sigma should be a divisor of kmax. This
condition is checked and those integer quadruples that satisfy
this condition are returned</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quad_int: numpy array</strong></p>
<p><strong>Integer quadruples</strong></p>
<p><strong>cryst_ptgrp: string</strong></p>
<p><strong>Proper point group in Schoenflies notation</strong></p>
<p><strong>sigma: float</strong></p>
<p><strong>sigma number</strong></p>
<p><strong>args[0]: dictionary</strong></p>
<p><strong>keys: &#8216;nu&#8217;, &#8216;mu&#8217;, &#8216;kmax&#8217;</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">quad_int: numpy array</p>
<p class="last">Integer quadruple array that satisfy the above mentioned condition</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.eliminate_idrots">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">eliminate_idrots</tt><big>(</big><em>quad_int</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#eliminate_idrots"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.eliminate_idrots" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate the roations that belong to the identity matrix and return the
integer quadruples</p>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.sigtype_muvw">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">sigtype_muvw</tt><big>(</big><em>quad_int</em>, <em>cryst_ptgrp</em>, <em>sig_type</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#sigtype_muvw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.sigtype_muvw" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of integer quadruples are different for common and specific sigma
rotations. For example, for D4 point group, common rotations satisfy the
condition u = 0 and v = 0 or m = 0 and w = 0. The specific rotations belong
to the complimentary set. Depending on the sig_type (common, specific), the
appropriate set of the integer quadruples are returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quad_int: numpy array</strong></p>
<p><strong>Integer quadruples</strong></p>
<p><strong>cryst_ptgrp: string</strong></p>
<p><strong>Proper point group in Schoenflies notation</strong></p>
<p><strong>sig_type: {&#8216;common&#8217;, &#8216;specific&#8217;}</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">quad_int: numpy array</p>
<p class="last">Integer quadruple array that satisfy the above mentioned condition</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.eliminate_mults">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">eliminate_mults</tt><big>(</big><em>quad_int</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#eliminate_mults"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.eliminate_mults" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide all the integer quadruples by their corresponding least common
multiples and return the unique set of integer quadruples</p>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.check_sigma">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">check_sigma</tt><big>(</big><em>quad_int</em>, <em>sigma</em>, <em>cryst_ptgrp</em>, <em>sig_type</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#check_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.check_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>The integer quadruples that correspond to a sigma rotation satisfy
certain conditions. These conditions are checked and all the
quadruples that do not meet these requirements are filtered
out. These conditions depend on the rotation type (common or
specific) and the lattice type (crystallogrphic point group and mu, nu)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quad_int: numpy array</strong></p>
<p><strong>Integer quadruples</strong></p>
<p><strong>cryst_ptgrp: string</strong></p>
<p><strong>Proper point group in Schoenflies notation</strong></p>
<p><strong>sig_type: {&#8216;common&#8217;, &#8216;specific&#8217;}</strong></p>
<p><strong>args[0]: dictionary</strong></p>
<p><strong>keys: &#8216;nu&#8217;, &#8216;mu&#8217;, &#8216;kmax&#8217;</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">quad_int: numpy array</p>
<p class="last">Integer quadruple array that satisfy the above mentioned condition</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#csl_utility_functions.check_fsig_int" title="csl_utility_functions.check_fsig_int"><tt class="xref py py-obj docutils literal"><span class="pre">check_fsig_int</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.gcd1d_arr">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">gcd1d_arr</tt><big>(</big><em>arr_tup</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#gcd1d_arr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.gcd1d_arr" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple of one-D arrays are passed with equal size and the gcd of
their rows is computed</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>arr_tup: tuple</strong></p>
<p><strong>one-D arrays of integers of equal size</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">GCD of rows of 1D arrays of integers</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.compute_tmat">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">compute_tmat</tt><big>(</big><em>quad_int</em>, <em>tau</em>, <em>lat_type</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#compute_tmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.compute_tmat" title="Permalink to this definition">¶</a></dt>
<dd><p>The transformation matrix (r_g1tog2_g1) corresponding to the integer
quadruple is computed. The matrix elements depend on m, U, V, W and the
crystallographic point group and tau = (nu/mu)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quad_int: numpy array</strong></p>
<p><strong>Integer quadruples</strong></p>
<p><strong>tau: float</strong></p>
<p><strong>nu/mu</strong></p>
<p><strong>lat_type: Lattice class</strong></p>
<p><strong>Attributes of the underlying lattice</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>g</strong> : numpy array</p>
<p class="last">dimension = 3, n x 3 x  3 transformation matrices</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.disorient_sigmarots">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">disorient_sigmarots</tt><big>(</big><em>r_g1tog2_g1</em>, <em>l_g_go</em>, <em>cryst_ptgrp</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#disorient_sigmarots"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.disorient_sigmarots" title="Permalink to this definition">¶</a></dt>
<dd><p>The disorientation corresponding to each rotation matrix is computed
and the unique set is returned</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r_g1tog2_g1: numpy array (n x 3 x 3)</strong></p>
<p><strong>Transformation matrices in g1 reference frame</strong></p>
<p><strong>l_g_go: numpy array</strong></p>
<p><strong>The primitive basis vectors of the underlying lattice in the orthogonal</strong></p>
<p><strong>reference frame</strong></p>
<p><strong>cryst_ptgrp: string</strong></p>
<p><strong>Proper point group in Schoenflies notation</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">rots_g1tog2_g1: numpy array (n x 3 x 3)</p>
<p class="last">Transformation matrices in g1 reference frame in the fundamental zone</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="csl_utility_functions.check_sigma_rots">
<tt class="descclassname">csl_utility_functions.</tt><tt class="descname">check_sigma_rots</tt><big>(</big><em>r_g1tog2_g1</em>, <em>sigma</em><big>)</big><a class="reference internal" href="_modules/csl_utility_functions.html#check_sigma_rots"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csl_utility_functions.check_sigma_rots" title="Permalink to this definition">¶</a></dt>
<dd><p>The sigma transformation matrix has the property that sigma is the
smallest integer such that sigma*T is an integer matrix. This condition
is checked and the numerator and denominatr(sigma) matrices are
returned</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r_g1tog2_g1: numpy array (n x 3 x 3)</strong></p>
<p><strong>Transformation matrices in g1 reference frame</strong></p>
<p><strong>sigma: float</strong></p>
<p><strong>sigma number</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">{&#8216;N&#8217;: rots_n, &#8216;D&#8217;: rots_d}: dictionary</p>
<p>rots_n: numpy array numerator matrices n x 3 x3</p>
<p class="last">rots_d: numpy array denominator matrices n x 3 x3</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-find_csl_dsc">
<span id="csl-dsc-computation"></span><h1>CSL/DSC Computation<a class="headerlink" href="#module-find_csl_dsc" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="find_csl_dsc.find_csl_dsc">
<tt class="descclassname">find_csl_dsc.</tt><tt class="descname">find_csl_dsc</tt><big>(</big><em>L_G1_GO1</em>, <em>R_G1ToG2_G1</em><big>)</big><a class="reference internal" href="_modules/find_csl_dsc.html#find_csl_dsc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#find_csl_dsc.find_csl_dsc" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls the csl_finder and dsc_finder and returns
the CSL and DSC basis vectors in &#8216;g1&#8217; reference frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>L_G1_GO1: numpy array</strong></p>
<p><strong>The three basis vectors for the primitive unit cell</strong></p>
<p><strong>(as columns) are given with respect to the GO1 reference</strong></p>
<p><strong>frame.</strong></p>
<p><strong>R_G1ToG2_G1: 3X3 numpy array The rotation matrix defining the</strong></p>
<p><strong>transformation in &#8216;G1&#8217; reference frame. The subscript &#8216;G1&#8217; refers</strong></p>
<p><strong>to the primitive unit cell of G lattice.</strong></p>
<p><strong>Returns</strong></p>
<p><strong>l_csl_g1, l_dsc_g1: numpy arrays</strong></p>
<p class="last"><strong>The basis vectors of csl and dsc lattices in the g1 reference frame</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="find_csl_dsc.sigma_calc">
<tt class="descclassname">find_csl_dsc.</tt><tt class="descname">sigma_calc</tt><big>(</big><em>t_g1tog2_g1</em><big>)</big><a class="reference internal" href="_modules/find_csl_dsc.html#sigma_calc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#find_csl_dsc.sigma_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sigma of the transformation matrix</p>
<ul class="simple">
<li>if det(T) = det(T^{-1}) then sigma1 = sigma2 is returned</li>
<li>if det(T) neq det(T^{-1}) then max(sigma1, sigma2) is returned</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="find_csl_dsc.reciprocal_mat">
<tt class="descclassname">find_csl_dsc.</tt><tt class="descname">reciprocal_mat</tt><big>(</big><em>l_g_go</em><big>)</big><a class="reference internal" href="_modules/find_csl_dsc.html#reciprocal_mat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#find_csl_dsc.reciprocal_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>The reciprocal matrix with reciprocal basis vectors is computed for the
input matrix with primitve basis vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l_g_go: numpy array</strong></p>
<p><strong>The primitive basis vectors b1x, b1y, b1z</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">rl_g_go: numpy array</p>
<p class="last">The primitve reciprocal basis vectors</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="find_csl_dsc.csl_elem_div_thm_l1">
<tt class="descclassname">find_csl_dsc.</tt><tt class="descname">csl_elem_div_thm_l1</tt><big>(</big><em>T0</em>, <em>l_g1n_g1</em><big>)</big><a class="reference internal" href="_modules/find_csl_dsc.html#csl_elem_div_thm_l1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#find_csl_dsc.csl_elem_div_thm_l1" title="Permalink to this definition">¶</a></dt>
<dd><p>The csl basis vectors are obtained from the diagonal matrix using the
algorithm specified in doi:10.1107/S056773947601231X. There are two
algorithms specified based on numerators or denominators of the T0 matrix.
The numerators are used in this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>T0: numpy array</strong></p>
<p><strong>The transformation matrix in G1n reference frame</strong></p>
<p><strong>l_g1n_g1: numpy array</strong></p>
<p><strong>The &#8216;new&#8217; basis vectors of g1 lattice (g1n) in g1 reference frame</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">l_csl_g1: numpy array</p>
<p class="last">The CSL basis vectors in g1 reference frame</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="find_csl_dsc.csl_elem_div_thm_l2">
<tt class="descclassname">find_csl_dsc.</tt><tt class="descname">csl_elem_div_thm_l2</tt><big>(</big><em>t0</em>, <em>l_g2n_g2</em><big>)</big><a class="reference internal" href="_modules/find_csl_dsc.html#csl_elem_div_thm_l2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#find_csl_dsc.csl_elem_div_thm_l2" title="Permalink to this definition">¶</a></dt>
<dd><p>The csl basis vectors are obtained from the diagonal matrix using the
algorithm specified in doi:10.1107/S056773947601231X. There are two
algorithms specified based on numerators or denominators of the T0 matrix.
The denominators are used in this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>T0: numpy array</strong></p>
<p><strong>The transformation matrix in G1n reference frame</strong></p>
<p><strong>l_g2n_g2: numpy array</strong></p>
<p><strong>The &#8216;new&#8217; basis vectors of g2 lattice (g2n) in g2 reference frame</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">l_csl_g2: numpy array</p>
<p class="last">The CSL basis vectors in g2 reference frame</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="find_csl_dsc.csl_finder_smith">
<tt class="descclassname">find_csl_dsc.</tt><tt class="descname">csl_finder_smith</tt><big>(</big><em>r_g1tog2_g1</em><big>)</big><a class="reference internal" href="_modules/find_csl_dsc.html#csl_finder_smith"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#find_csl_dsc.csl_finder_smith" title="Permalink to this definition">¶</a></dt>
<dd><p>This funciton extracts the CSL basis when transformation between the two
lattices is given (r_g1tog2_g1). The algorithms used are based on the
following article: doi:10.1107/S056773947601231X)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r_g1tog2_g1: numpy array</strong></p>
<p><strong>The 3x3 transformation matrix in g1 reference frame</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">l_csl_g1: numpy array</p>
<p class="last">3 x 3 matrix with the csl basis vectors as columns</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The &#8220;Reduced&#8221; refer to the use of LLL algorithm to compute a
basis that is as close to orthogonal as possible.
(Refer to <a class="reference external" href="http://en.wikipedia.org/wiki/Lattice_reduction">http://en.wikipedia.org/wiki/Lattice_reduction</a>) for further
detials on the concept of Lattice Reduction</p>
</dd></dl>

<dl class="function">
<dt id="find_csl_dsc.check_csl_finder_smith">
<tt class="descclassname">find_csl_dsc.</tt><tt class="descname">check_csl_finder_smith</tt><big>(</big><em>r_g1tog2_g1</em>, <em>Sigma</em>, <em>L_G1_GO1</em>, <em>L_CSL_G1</em><big>)</big><a class="reference internal" href="_modules/find_csl_dsc.html#check_csl_finder_smith"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#find_csl_dsc.check_csl_finder_smith" title="Permalink to this definition">¶</a></dt>
<dd><p>This function checks the obtained CSL basis vectors are correct by
using the following conditions:
* The CSL basis vectors are integer combinations of basis vectors of
lattice 1
* The CSL basis vectors are integer combinations of basis vectors of
lattice 2
* The volume enclosed by the CSL is sigma times the volume of lattice 1</p>
</dd></dl>

<dl class="function">
<dt id="find_csl_dsc.dsc_finder">
<tt class="descclassname">find_csl_dsc.</tt><tt class="descname">dsc_finder</tt><big>(</big><em>L_G2_G1</em>, <em>L_G1_GO1</em><big>)</big><a class="reference internal" href="_modules/find_csl_dsc.html#dsc_finder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#find_csl_dsc.dsc_finder" title="Permalink to this definition">¶</a></dt>
<dd><p>The DSC lattice is computed for the bi-crystal, if the transformation
matrix l_g2_g1 is given and the basis vectors of the underlying crystal
l_g_go (in the orthogonal reference go frame) are known. The following
relationship is used: <strong>The reciprocal of the coincidence site lattice of
the reciprocal lattices is the DSC lattice</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l_g2_g1: numpy array</strong></p>
<p><strong>transformation matrix (r_g1tog2_g1)</strong></p>
<p><strong>l_g1_go1: numpy array</strong></p>
<p><strong>basis vectors (as columns) of the underlying lattice expressed in the</strong></p>
<p><strong>orthogonal &#8216;go&#8217; reference frame</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">l_dsc_g1: numpy array</p>
<p class="last">The dsc lattice basis vectors (as columns) expressed in the g1 reference</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The &#8220;Reduced&#8221; refer to the use of LLL algorithm to compute a
basis that is as close to orthogonal as possible.
(Refer to <a class="reference external" href="http://en.wikipedia.org/wiki/Lattice_reduction">http://en.wikipedia.org/wiki/Lattice_reduction</a>) for further
detials on the concept of Lattice Reduction</p>
</dd></dl>

<dl class="function">
<dt id="find_csl_dsc.check_dsc_finder">
<tt class="descclassname">find_csl_dsc.</tt><tt class="descname">check_dsc_finder</tt><big>(</big><em>R_G1ToG2_G1</em>, <em>Sigma</em>, <em>L_G1_GO1</em>, <em>L_DSC_G1</em>, <em>L_CSL_G1</em><big>)</big><a class="reference internal" href="_modules/find_csl_dsc.html#check_dsc_finder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#find_csl_dsc.check_dsc_finder" title="Permalink to this definition">¶</a></dt>
<dd><p>This function checks the obtained DSC basis vectors are correct by
using the following conditions:
* Lattice 1 basis vectors are integer combinations of basis vectors of
the DSC lattice
* Lattice 2 basis vectors are integer combinations of basis vectors of
the DSC lattice
* The volume enclosed by the DSC is 1/sigma times the volume of lattice 1</p>
</dd></dl>

</div>
<div class="section" id="module-bp_basis">
<span id="boundary-plane-basis"></span><h1>Boundary Plane Basis<a class="headerlink" href="#module-bp_basis" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="bp_basis.check_int_mats">
<tt class="descclassname">bp_basis.</tt><tt class="descname">check_int_mats</tt><big>(</big><em>l1</em>, <em>l2</em><big>)</big><a class="reference internal" href="_modules/bp_basis.html#check_int_mats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bp_basis.check_int_mats" title="Permalink to this definition">¶</a></dt>
<dd><p>The function checks whether or not the elements of
$A_{left}^{-1}$*B are integers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>l1, l2</strong> : numpy arrays of same dimensions</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">cond: numpy boolean array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bp_basis.check_2d_csl">
<tt class="descclassname">bp_basis.</tt><tt class="descname">check_2d_csl</tt><big>(</big><em>l_pl1_g1</em>, <em>l_pl2_g1</em>, <em>l_csl_g1</em><big>)</big><a class="reference internal" href="_modules/bp_basis.html#check_2d_csl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bp_basis.check_2d_csl" title="Permalink to this definition">¶</a></dt>
<dd><p>The function checks whether or not the CSL basis may be expressed
as a linear integer combination of the plane bases of planes 1 and 2</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l_pl1_g1, l_pl2_g1: numpy arrays of basis vectors for plane 1 and 2</strong></p>
<p class="last"><strong>in the g1 reference frame</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bp_basis.lbi_dioph_soln">
<tt class="descclassname">bp_basis.</tt><tt class="descname">lbi_dioph_soln</tt><big>(</big><em>a</em>, <em>b</em>, <em>c</em><big>)</big><a class="reference internal" href="_modules/bp_basis.html#lbi_dioph_soln"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bp_basis.lbi_dioph_soln" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the diophantaine solution for the equation ax + by = c</p>
</dd></dl>

<dl class="function">
<dt id="bp_basis.compute_basis_vec">
<tt class="descclassname">bp_basis.</tt><tt class="descname">compute_basis_vec</tt><big>(</big><em>d_eq</em><big>)</big><a class="reference internal" href="_modules/bp_basis.html#compute_basis_vec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bp_basis.compute_basis_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>The function computes y1, y2, y3 such that h*y1 + k*y2 + l*y3 = 0
and modulus of y1 is a minimum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>d_eq: numpy array or list of size 3 and dimension 1</strong></p>
<p><strong>h = d_eq[0], k = d_eq[1], l = d_eq[2]</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">np.array([y1, y2, y3])</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bp_basis.bp_basis">
<tt class="descclassname">bp_basis.</tt><tt class="descname">bp_basis</tt><big>(</big><em>bp_g1</em>, <em>lattice</em><big>)</big><a class="reference internal" href="_modules/bp_basis.html#bp_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bp_basis.bp_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The function computes the primitve basis of the plane if the
boundary plane normal and the underlying lattice are specified</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bp_g1: numpy array</strong></p>
<p><strong>Boundary plane normal in &#8216;g1&#8217; reference frame</strong></p>
<p><strong>lattice: Lattice class</strong></p>
<p><strong>Attributes of the under lattice</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">l_pl_g1: numpy array</p>
<p class="last">The primitive basis of the plane with boundary plane normal bp_g1</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bp_basis.pl_density">
<tt class="descclassname">bp_basis.</tt><tt class="descname">pl_density</tt><big>(</big><em>l_pl_g1</em>, <em>l_g1_go1</em><big>)</big><a class="reference internal" href="_modules/bp_basis.html#pl_density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bp_basis.pl_density" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given two-dimensional plane basis, the planar density is
computed</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l_pl_g1: numpy array</strong></p>
<p><strong>l_g1_go1: numpy array</strong></p>
<p><strong>Basis vectors of the underlying lattice with respect to the</strong></p>
<p><strong>orthogonal reference frame &#8216;go1&#8217;</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">pd: float</p>
<p class="last">Planar density = (1/area covered by plane basis)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bp_basis.csl_finder_2d">
<tt class="descclassname">bp_basis.</tt><tt class="descname">csl_finder_2d</tt><big>(</big><em>l_pl1_g1</em>, <em>l_pl2_g1</em><big>)</big><a class="reference internal" href="_modules/bp_basis.html#csl_finder_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bp_basis.csl_finder_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two plane bases, the 2D CSL bases are obtined by utilizing the
smith normal form of the transformation between the two bases</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l_pl1_g1, l_pl2_g1: numpy array</strong></p>
<p><strong>Basis vectors of planes 1 and 2 expressed in g1 reference frame</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">l_2d_csl_g1: numpy array</p>
<p class="last">The basis vectors of the 2D CSL expressed in g1 reference frame</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bp_basis.gb_2d_csl">
<tt class="descclassname">bp_basis.</tt><tt class="descname">gb_2d_csl</tt><big>(</big><em>bp1_g1</em>, <em>t_g1tog2_g1</em>, <em>lattice</em><big>)</big><a class="reference internal" href="_modules/bp_basis.html#gb_2d_csl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bp_basis.gb_2d_csl" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given boundary plane normal &#8216;bp1_g1&#8217; and the misorientation
matrix &#8216;t_g1tog2_g1&#8217;, the two-dimensional CSL lattice is computed</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bp1_g1: numpy array</strong></p>
<p><strong>t_g1tog2_g1: numpy array</strong></p>
<p><strong>lattice: Lattice class</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">l_2d_csl_g1: numpy array</p>
<p>The basis vectors of the 2D CSL expressed in g1 reference frame</p>
<p>l_pl1_g1, l_pl2_g1: numpy arrays</p>
<p class="last">Basis vectors of planes 1 and 2 expressed in g1 reference frame</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bp_basis.bicryst_planar_den">
<tt class="descclassname">bp_basis.</tt><tt class="descname">bicryst_planar_den</tt><big>(</big><em>bp1_go1</em>, <em>t_g1tog2_go1</em>, <em>lattice</em><big>)</big><a class="reference internal" href="_modules/bp_basis.html#bicryst_planar_den"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bp_basis.bicryst_planar_den" title="Permalink to this definition">¶</a></dt>
<dd><p>The function computes the planar densities of the planes
1 and 2 and the two-dimensional CSL</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bp1_go1: numpy array</strong></p>
<p><strong>The boundary plane normal components in go1 reference frame</strong></p>
<p><strong>t_g1tog2_go1: numpy array</strong></p>
<p><strong>Transformation matrix from g1 to g2 in go1 reference frame</strong></p>
<p><strong>lattice: Lattice class</strong></p>
<p><strong>Attributes of the underlying lattice</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">pl_den_pl1, pl_den_pl2: numpy array</p>
<p>The planar density of planes 1 and 2</p>
<p>pl_den_csl: numpy array</p>
<p class="last">The planare density of the two-dimensional CSL</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-misorient_fz">
<span id="misorientation-fundamental-zones"></span><h1>Misorientation Fundamental Zones<a class="headerlink" href="#module-misorient_fz" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="misorient_fz.misorient_fz">
<tt class="descclassname">misorient_fz.</tt><tt class="descname">misorient_fz</tt><big>(</big><em>misquats</em>, <em>cryst_ptgrp</em>, <em>tol=1e-12</em><big>)</big><a class="reference internal" href="_modules/misorient_fz.html#misorient_fz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#misorient_fz.misorient_fz" title="Permalink to this definition">¶</a></dt>
<dd><p>The function takes as input the misorientations and the corresponding
crystallographic point group. It converts them using symmetry operations
and returns the disorientations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>misquats: Quaternion class</strong></p>
<p><strong>Quaternion misorientations</strong></p>
<p><strong>cryst_ptgrp: string</strong></p>
<p><strong>Crystallogrphic point group in Schoenflies notation</strong></p>
<p><strong>tol: float</strong></p>
<p><strong>Tolerance for the disorientation to belong in the fundamental zone</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">disquats: quaternion class</p>
<p class="last">Disorientations for the given misorientations</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="misorient_fz.check_cond">
<tt class="descclassname">misorient_fz.</tt><tt class="descname">check_cond</tt><big>(</big><em>g</em>, <em>cryst_ptgrp</em>, <em>tol</em><big>)</big><a class="reference internal" href="_modules/misorient_fz.html#check_cond"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#misorient_fz.check_cond" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g: quaternion object</strong></p>
<p><strong>Misorientation</strong></p>
<p><strong>cryst_ptgrp: string</strong></p>
<p><strong>Crystallogrphic point group in Schoenflies notation</strong></p>
<p><strong>tol: float</strong></p>
<p><strong>Tolerance for the misorientation to belong in the fundamental zone</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True or False</p>
<p class="last">Depending on whether or not the misorientation is a disorientation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-generate_symm_ops">
<span id="generate-symmetry-operators"></span><h1>Generate Symmetry Operators<a class="headerlink" href="#module-generate_symm_ops" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="generate_symm_ops.generate_symm_mats">
<tt class="descclassname">generate_symm_ops.</tt><tt class="descname">generate_symm_mats</tt><big>(</big><em>cryst_ptgrp</em>, <em>tol=1e-10</em><big>)</big><a class="reference internal" href="_modules/generate_symm_ops.html#generate_symm_mats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#generate_symm_ops.generate_symm_mats" title="Permalink to this definition">¶</a></dt>
<dd><p>Give crystallographic point group, this function generates all the symmetry
operations (as matrices) that belong to the point group using &#8216;generators&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cryst_ptgrp: string</strong></p>
<p><strong>Crystallogrphic point group in Schoenflies notation</strong></p>
<p><strong>tol: float</strong></p>
<p><strong>The tolerance used to check if two matrices are the same</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">symm_mat: numpy array</p>
<p>Size: n x 3 x3</p>
<p class="last">Symmetry operations as matrices for the corresponding point group</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="generate_symm_ops.generate_symm_quats">
<tt class="descclassname">generate_symm_ops.</tt><tt class="descname">generate_symm_quats</tt><big>(</big><em>cryst_ptgrp</em>, <em>tol=1e-10</em><big>)</big><a class="reference internal" href="_modules/generate_symm_ops.html#generate_symm_quats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#generate_symm_ops.generate_symm_quats" title="Permalink to this definition">¶</a></dt>
<dd><p>Give crystallographic point group, this function generates all the symmetry
operations (as quaternions) that belong to the point group
using &#8216;generators&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cryst_ptgrp: string</strong></p>
<p><strong>Crystallogrphic point group in Schoenflies notation</strong></p>
<p><strong>tol: float</strong></p>
<p><strong>The tolerance used to check if two matrices are the same</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">symm_quat: quaternion array</p>
<p>Size: n x 5</p>
<p class="last">Symmetry operations as matrices for the corresponding point group</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="generate_symm_ops.save_symm_pkl">
<tt class="descclassname">generate_symm_ops.</tt><tt class="descname">save_symm_pkl</tt><big>(</big><em>cryst_ptgrp</em>, <em>op_type</em><big>)</big><a class="reference internal" href="_modules/generate_symm_ops.html#save_symm_pkl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#generate_symm_ops.save_symm_pkl" title="Permalink to this definition">¶</a></dt>
<dd><p>A pkl file with the symmetry operations of op_type (matrices or
quaternions) are created and stored in the &#8216;pkl_files&#8217; directory</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cryst_ptgrp: string</strong></p>
<p><strong>Crystallogrphic point group in Schoenflies notation</strong></p>
<p><strong>op_type: {&#8216;matrices&#8217;, &#8216;quats&#8217;}</strong></p>
<p class="last"><strong>Creates matrices or quaternion symmetry operations depending on op_type</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to GBPy&#8217;s documentation!</a></li>
<li><a class="reference internal" href="#module-lattice">Lattice Class</a></li>
<li><a class="reference internal" href="#module-quaternion">Geometry</a></li>
<li><a class="reference internal" href="#module-integer_manipulations">Integer Manipulations</a></li>
<li><a class="reference internal" href="#module-csl_utility_functions">CSL Utility Function</a></li>
<li><a class="reference internal" href="#module-find_csl_dsc">CSL/DSC Computation</a></li>
<li><a class="reference internal" href="#module-bp_basis">Boundary Plane Basis</a></li>
<li><a class="reference internal" href="#module-misorient_fz">Misorientation Fundamental Zones</a></li>
<li><a class="reference internal" href="#module-generate_symm_ops">Generate Symmetry Operators</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">GBPy 1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Srikanth Patala, Arash D. Banadaki.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>