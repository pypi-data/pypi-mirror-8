<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tutorial &mdash; vegas 2.2.2 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="vegas 2.2.2 documentation" href="index.html" />
    <link rel="next" title="How vegas Works" href="background.html" />
    <link rel="prev" title="vegas Documentation" href="index.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="background.html" title="How vegas Works"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="vegas Documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">vegas 2.2.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Class <a class="reference internal" href="vegas.html#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a> gives Monte Carlo estimates of arbitrary
multidimensional integrals using the <em>vegas</em> algorithm
(G. P. Lepage, J. Comput. Phys. 27 (1978) 192).
The algorithm has two components.
First an automatic transformation is applied to to the integration variables
in an attempt to flatten the integrand. Then a Monte Carlo estimate of the
integral is made using the  transformed variables. Flattening the integrand
makes the integral easier and improves the estimate.  The transformation
applied to the integration variables is optimized
over several iterations of the algorithm: information about the integrand that
is collected during one iteration is used to  improve the transformation used
in the next iteration.</p>
<p>Monte Carlo integration makes few assumptions about the
integrand &#8212; it needn&#8217;t be analytic nor even continuous. This
makes Monte Carlo integation unusually robust. It also makes it well suited
for adaptive integration. Adaptive strategies are essential for
multidimensional integration, especially in high dimensions, because
multidimensional space is large, with  lots of corners, making it
easy to lose important features in the integrand.</p>
<p>Monte Carlo integration also provides efficient and reliable methods for
estimating the
accuracy of its results. In particular, each Monte Carlo
estimate of an integral is a random number from a distribution
whose mean is the correct value of the integral. This distribution is
Gaussian or normal provided
the number of integrand samples is sufficiently large.
In practive we generate multiple
estimates of the integral
in order to verify that the distribution is indeed Gaussian.
Error analysis is straightforward if the
integral estimates are Gaussian.</p>
<p>The <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> algorithm has been in use for decades and implementations are
available in many programming languages, including Fortran (the original
version), C and C++. The algorithm used here is significantly improved over
the original implementation, and that used in most other implementations.
It uses two adaptive strategies: importance sampling, as in the original
implementation, and adaptive stratified sampling, which is new.</p>
<p>This module is written in Cython, so it is almost as fast as compiled Fortran or
C, particularly when the integrand is also coded in Cython (or some other
compiled language), as discussed below.</p>
<p>The following sections describe how to use <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>. Almost every
example shown is a complete code, which can be copied into a file
and run with python. It is worthwhile playing with the parameters to see how
things change.</p>
<p><em>About Printing:</em> The examples in this tutorial use the print function as it is
used in Python 3. Drop the outermost parenthesis in each print statement if
using Python 2, or add</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
</pre></div>
</div>
<p>at the start of your file.</p>
</div>
<div class="section" id="basic-integrals">
<h2>Basic Integrals<a class="headerlink" href="#basic-integrals" title="Permalink to this headline">¶</a></h2>
<p>Here we illustrate the use of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> by estimating the integral</p>
<div class="math">
<p><img src="_images/math/6244294f0d3f5b3d277be2ce990e79ab6b0d36bd.png" alt="C\int_{-1}^1 dx_0 \int_0^1 dx_1 \int_0^1 dx_2 \int_0^1 dx_3
\,\,\mathrm{e}^{- 100 \sum_{d}(x_d-0.5)^2}  ,"/></p>
</div><p>where constant <img class="math" src="_images/math/8fa64911ca045226c2a3a17ca519d1fa11bbca5c.png" alt="C" style="vertical-align: 0px"/> is chosen so that the exact integral is 1.
The following code shows how this can be done:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dx2</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1013.2118364296088</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;result = </span><span class="si">%s</span><span class="s">    Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>First we define the integrand <tt class="docutils literal"><span class="pre">f(x)</span></tt> where <tt class="docutils literal"><span class="pre">x[d]</span></tt> specifies a  point in the
4-dimensional space. We then create an  integrator, <tt class="docutils literal"><span class="pre">integ</span></tt>, which is an
integration operator  that can be applied to any 4-dimensional function. It is
where we specify the integration volume.
Finally we apply <tt class="docutils literal"><span class="pre">integ</span></tt> to our integrand <tt class="docutils literal"><span class="pre">f(x)</span></tt>,
telling the integrator to estimate  the integral using <tt class="docutils literal"><span class="pre">nitn=10</span></tt> iterations
of the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> algorithm, each of which uses no more than <tt class="docutils literal"><span class="pre">neval=1000</span></tt>
evaluations of the integrand. Each iteration produces an independent
estimate of the integral. The final estimate is the weighted average of
the results from all 10 iterations, and is returned by <tt class="docutils literal"><span class="pre">integ(f</span> <span class="pre">...)</span></tt>.
The call <tt class="docutils literal"><span class="pre">result.summary()</span></tt> returns
a summary of results from each iteration.</p>
<p>This code produces the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>itn   integral        wgt average     chi2/dof        Q
-------------------------------------------------------
  1   2.4(1.9)        2.4(1.9)            0.00     1.00
  2   1.19(32)        1.23(32)            0.42     0.52
  3   0.910(90)       0.934(87)           0.68     0.51
  4   1.041(70)       0.999(55)           0.76     0.52
  5   1.090(43)       1.055(34)           1.00     0.41
  6   0.984(34)       1.020(24)           1.24     0.29
  7   1.036(27)       1.027(18)           1.07     0.38
  8   0.987(22)       1.011(14)           1.20     0.30
  9   0.995(18)       1.005(11)           1.11     0.35
 10   0.993(17)       1.0015(91)          1.02     0.42

result = 1.0015(91)    Q = 0.42
</pre></div>
</div>
<p>There are several things to note here:</p>
<blockquote>
<div><p><strong>Adaptation:</strong> Integration estimates are shown for
each of the 10 iterations,
giving both the estimate from just that iteration, and the weighted
average of results from all iterations up to that point. The
estimates from the first two iterations are not accurate at
all, with errors equal to 30&#8211;190% of the final result.
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> initially has no information about the integrand
and so does a relatively poor job of estimating the integral.
It uses information from the samples in one iteration, however,
to remap the integration variables for subsequent iterations,
concentrating samples where the function is largest and reducing
errors.
As a result, the per-iteration error
is reduced to 4.3% by the fifth iteration, and below 2% by
the end &#8212; an improvement by almost two orders of
magnitude from the start. Eventually the per-iteration error
stops decreasing because <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> has found the optimal remapping,
at which point
it has fully adapted to the integrand.</p>
<p><strong>Weighted Average:</strong> The final result, 1.0015 ± 0.0091,
is obtained from a weighted
average of the separate results from each iteration:
estimates are weighted by the inverse variance, thereby giving
much less weight to the early iterations, where the errors are
largest.
The individual estimates are statistical: each
is a random number drawn from a distribution whose mean
equals the correct value of the integral, and the errors
quoted are estimates of the standard deviations of those
distributions. The distributions are Gaussian provided
the number of integrand evaluations per iteration (<tt class="docutils literal"><span class="pre">neval</span></tt>)
is sufficiently large, in which case the standard deviation
is a reliable estimate of the error.
The weighted average <img class="math" src="_images/math/a9728d3ad96d53f09eb3d4304f3a5addca90fdb2.png" alt="\overline I" style="vertical-align: 0px"/>  minimizes</p>
<div class="math">
<p><img src="_images/math/94ad9a77a01173df435557cb5634436651c82995.png" alt="\chi^2 \,\equiv\, \sum_i \frac{(I_i - \overline I)^2}{\sigma_{i}^2}"/></p>
</div><p>where <img class="math" src="_images/math/27527eee2aa2df761e82323f937910f9c64decfe.png" alt="I_i \pm \sigma_{i}" style="vertical-align: -4px"/> are the estimates from
individual iterations. If the <img class="math" src="_images/math/78258a434c6d027278da3883bb9f8acf4be2eff8.png" alt="I_i" style="vertical-align: -4px"/> are Gaussian,
<img class="math" src="_images/math/7d2384c3884c89853f86abe7c46ec2bb4ff36d8e.png" alt="\chi^2" style="vertical-align: -3px"/> should be of order the number of degrees of
freedom (plus or minus the square root of that number);
here the number of degrees of freedom is the number of
iterations minus 1.</p>
<p>The distributions are likely non-Gaussian, and error estimates
unreliable, if <img class="math" src="_images/math/7d2384c3884c89853f86abe7c46ec2bb4ff36d8e.png" alt="\chi^2" style="vertical-align: -3px"/> is
much larger than the number of iterations. This criterion is quantified
by the <em>Q</em> or <em>p-value</em> of the <img class="math" src="_images/math/7d2384c3884c89853f86abe7c46ec2bb4ff36d8e.png" alt="\chi^2" style="vertical-align: -3px"/>,
which is the probability that a
larger <img class="math" src="_images/math/7d2384c3884c89853f86abe7c46ec2bb4ff36d8e.png" alt="\chi^2" style="vertical-align: -3px"/> could result from random (Gaussian)
fluctuations. A very small <em>Q</em> (less than 0.05-0.1) indicates
that the <img class="math" src="_images/math/7d2384c3884c89853f86abe7c46ec2bb4ff36d8e.png" alt="\chi^2" style="vertical-align: -3px"/> is too large to be accounted for by
statistical fluctuations &#8212; that is, the estimates of the integral
from different iterations do not agree with each other to
within errors. This means that <tt class="docutils literal"><span class="pre">neval</span></tt> is not sufficiently
large to guarantee Gaussian behavior, and must be increased
if the error estimates are to be trusted.</p>
<p><tt class="docutils literal"><span class="pre">integ(f...)</span></tt> returns a weighted-average object,
of type <a class="reference internal" href="vegas.html#vegas.RAvg" title="vegas.RAvg"><tt class="xref py py-class docutils literal"><span class="pre">vegas.RAvg</span></tt></a>, that has the following
attributes:</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">result.mean</span></tt> &#8212; weighted average of all estimates of the integral;</p>
<p><tt class="docutils literal"><span class="pre">result.sdev</span></tt> &#8212; standard deviation of the weighted average;</p>
<p><tt class="docutils literal"><span class="pre">result.chi2</span></tt> &#8212; <img class="math" src="_images/math/7d2384c3884c89853f86abe7c46ec2bb4ff36d8e.png" alt="\chi^2" style="vertical-align: -3px"/> of the weighted average;</p>
<p><tt class="docutils literal"><span class="pre">result.dof</span></tt> &#8212; number of degrees of freedom;</p>
<p><tt class="docutils literal"><span class="pre">result.Q</span></tt> &#8212; <em>Q</em> or <em>p-value</em> of the weighted average&#8217;s <img class="math" src="_images/math/7d2384c3884c89853f86abe7c46ec2bb4ff36d8e.png" alt="\chi^2" style="vertical-align: -3px"/>;</p>
<p><tt class="docutils literal"><span class="pre">result.itn_results</span></tt> &#8212; list of the integral estimates
from each iteration.</p>
</div></blockquote>
<p>In this example the final <em>Q</em> is 0.42, indicating that the
<img class="math" src="_images/math/7d2384c3884c89853f86abe7c46ec2bb4ff36d8e.png" alt="\chi^2" style="vertical-align: -3px"/> for this average is not particularly unlikely and
thus the error estimate is most likely reliable.</p>
<p><strong>Precision:</strong> The precision of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> estimates is
determined by <tt class="docutils literal"><span class="pre">nitn</span></tt>, the number of iterations
of the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> algorithm,
and by <tt class="docutils literal"><span class="pre">neval</span></tt>, the maximum number of integrand evaluation
made per iteration.
The computing cost is typically proportional to the
product of <tt class="docutils literal"><span class="pre">nitn</span></tt> and <tt class="docutils literal"><span class="pre">neval</span></tt>.
The number of integrand
evaluations per iteration
varies from iteration to iteration,
here between 486 and 959. Typically <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> needs more
integration points in early iterations, before it has fully
adapted to the integrand.</p>
<p>We can increase precision by increasing either <tt class="docutils literal"><span class="pre">nitn</span></tt> or <tt class="docutils literal"><span class="pre">neval</span></tt>,
but it is
generally far better to increase <tt class="docutils literal"><span class="pre">neval</span></tt>. For example,
adding the following lines to the code above</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;larger nitn  =&gt; </span><span class="si">%s</span><span class="s">    Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">1e4</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;larger neval =&gt; </span><span class="si">%s</span><span class="s">    Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>generates the following results:</p>
<div class="highlight-python"><div class="highlight"><pre>larger nitn  =&gt; 0.9968(15)    Q = 0.43
larger neval =&gt; 0.99978(67)    Q = 0.42
</pre></div>
</div>
<p>The total number of integrand evaluations, <tt class="docutils literal"><span class="pre">nitn</span> <span class="pre">*</span> <span class="pre">neval</span></tt>, is
about the same in both cases, but increasing <tt class="docutils literal"><span class="pre">neval</span></tt> is more
than twice as accurate as increasing <tt class="docutils literal"><span class="pre">nitn</span></tt>. Typically you
want to use no more than 10 or 20 iterations beyond the
point where <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> has fully adapted. You want some number of
iterations so that you can verify Gaussian behavior by
checking the <img class="math" src="_images/math/7d2384c3884c89853f86abe7c46ec2bb4ff36d8e.png" alt="\chi^2" style="vertical-align: -3px"/> and <em>Q</em>, but not too many.</p>
<p>It is also generally useful to compare two or more
results from values of <tt class="docutils literal"><span class="pre">neval</span></tt> that differ by a
significant factor (4&#8211;10, say). These should agree within
errors. If they do not, it could be due to non-Gaussian
artifacts caused by a small <tt class="docutils literal"><span class="pre">neval</span></tt>. <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>
estimates have two sources of error. One is the statistical
error, which is what is quoted by <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>. The other is
a systematic error due to residual non-Gaussian
effects. The systematic error vanishes like
<tt class="docutils literal"><span class="pre">1/neval</span></tt> and so becomes negligible compared with
the statistical error as <tt class="docutils literal"><span class="pre">neval</span></tt> increases.
The systematic error can bias the Monte Carlo estimate, however,
if <tt class="docutils literal"><span class="pre">neval</span></tt> is insufficiently large. This usually
results in a large <img class="math" src="_images/math/7d2384c3884c89853f86abe7c46ec2bb4ff36d8e.png" alt="\chi^2" style="vertical-align: -3px"/> (and small <em>Q</em>), but a
more reliable check is to compare
results that use signficantly different values of <tt class="docutils literal"><span class="pre">neval</span></tt>.
The systematic errors due to non-Gaussian behavior are
likely negligible if the different estimates agree to
within the statistical errors.</p>
<p>The possibility of systematic biases
is another reason for increasing <tt class="docutils literal"><span class="pre">neval</span></tt>
rather than <tt class="docutils literal"><span class="pre">nitn</span></tt> to obtain more precision.
Making <tt class="docutils literal"><span class="pre">neval</span></tt> larger and larger is guaranteed
to improve the Monte Carlo estimate, as the statistical
error decreases (at least as fast as <tt class="docutils literal"><span class="pre">sqrt(1/neval)</span></tt>
and often faster) and the
systematic error decreases even more quickly (like
<tt class="docutils literal"><span class="pre">1/neval</span></tt>).
Making <tt class="docutils literal"><span class="pre">nitn</span></tt> larger and larger, on the other hand,
is guaranteed eventually to give the wrong
answer. This is because at some point the statistical error
(which falls as <tt class="docutils literal"><span class="pre">sqrt(1/nitn)</span></tt>) will no longer
mask the systematic error (which is unaffected by <tt class="docutils literal"><span class="pre">nitn</span></tt>).
The systematic error for the integral
above (with <tt class="docutils literal"><span class="pre">neval=1000</span></tt>) is about -0.0008(1), which
is negligible compared to the statistical error unless
<tt class="docutils literal"><span class="pre">nitn</span></tt> is of order 1500 or larger &#8212; so systematic errors
aren&#8217;t a problem with <tt class="docutils literal"><span class="pre">nitn=10</span></tt>.</p>
<p><strong>Early Iterations:</strong> Integral estimates from early iterations,
before <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> has adapted, can be quite
crude. With very peaky integrands, these are often far from
the correct answer with highly unreliable error estimates. For
example, the integral above becomes more
difficult if we double the length of each side of the
integration volume by redefining <tt class="docutils literal"><span class="pre">integ</span></tt> as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</pre></div>
</div>
<p>The code above then gives:</p>
<div class="highlight-python"><div class="highlight"><pre>itn   integral        wgt average     chi2/dof        Q
-------------------------------------------------------
  1   0.013(13)       0.013(13)           0.00     1.00
  2   0.0165(80)      0.0154(67)          0.07     0.79
  3   2.07(96)        0.0155(67)          2.31     0.10
  4   0.86(26)        0.0160(67)          5.06     0.00
  5   1.01(11)        0.0199(67)         25.01     0.00
  6   0.963(64)       0.0302(67)         63.06     0.00
  7   1.032(41)       0.0561(66)        149.77     0.00
  8   0.924(31)       0.0924(64)        232.41     0.00
  9   1.037(28)       0.1410(63)        341.52     0.00
 10   0.976(22)       0.2026(60)        448.77     0.00

result = 0.2026(60)    Q = 0.00
</pre></div>
</div>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> misses the peak completely in the first two iterations,
giving estimates that are completely
wrong (by 76 and 123 standard deviations!).
Some of its samples hit the peak&#8217;s shoulders, so <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> is
eventually able to find the peak (by iterations 5&#8211;6), but
the integrand estimates are wildly non-Gaussian before that
point. This results in a non-sensical final result, as
indicated by the <tt class="docutils literal"><span class="pre">Q</span> <span class="pre">=</span> <span class="pre">0.00</span></tt>.</p>
<p>It is common practice in using <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> to discard
estimates from the first several iterations, before the
algorithm has adapted, in order to avoid ruining the
final result in this way. This is done by replacing the
single call to <tt class="docutils literal"><span class="pre">integ(f...)</span></tt> in the original code
with two calls:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># step 1 -- adapt to f; discard results</span>
<span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c"># step 2 -- integ has adapted to f; keep results</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;result = </span><span class="si">%s</span><span class="s">    Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>The integrator is trained in the first
step, as it adapts to the integrand, and so is more or less
fully adapted from the start in the second step, which yields:</p>
<div class="highlight-python"><div class="highlight"><pre>itn   integral        wgt average     chi2/dof        Q
-------------------------------------------------------
  1   1.042(26)       1.042(26)           0.00     1.00
  2   1.010(18)       1.020(15)           0.99     0.32
  3   0.999(14)       1.009(10)           1.05     0.35
  4   0.965(16)       0.9963(86)          2.47     0.06
  5   0.994(15)       0.9958(74)          1.86     0.11
  6   1.001(15)       0.9968(66)          1.51     0.18
  7   0.999(15)       0.9971(61)          1.26     0.27
  8   0.994(13)       0.9965(55)          1.09     0.37
  9   1.017(22)       0.9977(53)          1.05     0.39
 10   0.981(16)       0.9961(50)          1.04     0.40

result = 0.9961(50)    Q = 0.40
</pre></div>
</div>
<p>The final result is now reliable.</p>
<p><strong>Other Integrands:</strong> Once <tt class="docutils literal"><span class="pre">integ</span></tt> has been trained on <tt class="docutils literal"><span class="pre">f(x)</span></tt>,
it can be usefully applied
to other functions with similar structure. For example, adding
the following at the end of the original code,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;result = </span><span class="si">%s</span><span class="s">    Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>gives the following new output:</p>
<div class="highlight-python"><div class="highlight"><pre>itn   integral        wgt average     chi2/dof        Q
-------------------------------------------------------
  1   0.5015(83)      0.5015(83)          0.00     1.00
  2   0.5099(68)      0.5065(53)          0.61     0.43
  3   0.4992(73)      0.5040(43)          0.63     0.53
  4   0.5121(61)      0.5066(35)          0.81     0.49
  5   0.5046(73)      0.5062(32)          0.62     0.65
  6   0.4918(63)      0.5033(28)          1.34     0.25
  7   0.5053(99)      0.5035(27)          1.12     0.35
  8   0.4997(69)      0.5030(25)          1.00     0.43
  9   0.5016(81)      0.5029(24)          0.88     0.54
 10   0.4951(75)      0.5021(23)          0.88     0.54

result = 0.5021(23)    Q = 0.54
</pre></div>
</div>
<p>Again the grid is almost optimal for <tt class="docutils literal"><span class="pre">g(x)</span></tt> from the start,
because <tt class="docutils literal"><span class="pre">g(x)</span></tt> peaks in the same region as <tt class="docutils literal"><span class="pre">f(x)</span></tt>.
The exact value for this integral is very close to 0.5.</p>
<p>Note that <a class="reference internal" href="vegas.html#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a>s can be saved in files and reloaded later using
Python&#8217;s <tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt> module: for example,
<tt class="docutils literal"><span class="pre">pickle.dump(integ,</span> <span class="pre">openfile)</span></tt> saves integrator <tt class="docutils literal"><span class="pre">integ</span></tt>
in file <tt class="docutils literal"><span class="pre">openfile</span></tt>, and
<tt class="docutils literal"><span class="pre">integ</span> <span class="pre">=</span> <span class="pre">pickle.load(openfile)</span></tt> reloads it. The is useful for costly
integrations that might need to be reanalyzed later since the integrator
remembers the variable transformations made to minimize errors, and
so need not be readapted to the integrand when used later.</p>
<p><strong>Non-Rectangular Volumes:</strong> <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> can integrate over volumes of
non-rectangular shape. For example, we can replace integrand <tt class="docutils literal"><span class="pre">f(x)</span></tt>
above
by the same Gaussian, but restricted to a 4-sphere of radius 0.2,
centered on the Gaussian:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">f_sph</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">dx2</span> <span class="o">&lt;</span> <span class="mf">0.2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dx2</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1115.3539360527281318</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>           <span class="c"># adapt the grid</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>  <span class="c"># estimate the integral</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;result = </span><span class="si">%s</span><span class="s">    Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>The normalization is adjusted to again make the
exact integral equal 1. Integrating as before gives:</p>
<div class="highlight-python"><div class="highlight"><pre>itn   integral        wgt average     chi2/dof        Q
-------------------------------------------------------
  1   1.005(41)       1.005(41)           0.00     1.00
  2   1.055(37)       1.033(27)           0.82     0.37
  3   1.048(63)       1.035(25)           0.43     0.65
  4   1.051(63)       1.037(23)           0.31     0.82
  5   0.994(23)       1.015(16)           0.68     0.61
  6   1.008(33)       1.014(15)           0.55     0.74
  7   1.030(34)       1.016(13)           0.49     0.82
  8   0.971(18)       1.000(11)           0.99     0.43
  9   1.005(34)       1.001(10)           0.87     0.54
 10   1.039(29)       1.0049(97)          0.94     0.48

result = 1.0049(97)    Q = 0.48
</pre></div>
</div>
<p>It is a good idea to make the actual integration volume as large a
fraction as possible of the total volume used by <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> &#8212;
by choosing integration variables properly &#8212; so
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> doesn&#8217;t spend lots of effort on regions where the integrand
is exactly 0. Also, it can be challenging for <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>
to find the region of
non-zero integrand in high dimensions: integrating <tt class="docutils literal"><span class="pre">f_sph(x)</span></tt>
in 20 dimensions instead of 4, for example,
would require <tt class="docutils literal"><span class="pre">neval=1e16</span></tt>
integrand evaluations per iteration to have any chance of
finding the region of non-zero integrand, because the volume of
the 20-dimensional sphere is a tiny fraction of the total
integration volume. The final error in the example above would have
been cut in half had we used the integration volume
<tt class="docutils literal"><span class="pre">4</span> <span class="pre">*</span> <span class="pre">[[0.3,</span> <span class="pre">0.7]]</span></tt> instead of <tt class="docutils literal"><span class="pre">[[-1,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1]]</span></tt>.</p>
<p>Note, finally, that integration to infinity is also possible:
map the relevant variable into a different variable
of finite range. For example,  an integral over <img class="math" src="_images/math/692b23ea1ed0554e7230c49a4d1cd70f6737c7d1.png" alt="x\equiv\tan(\theta)" style="vertical-align: -3px"/>
from 0 to infinity is easily reexpressed as
an integral over <img class="math" src="_images/math/c4e7f88efa6ee900acb57baf4b4855de8a56d495.png" alt="\theta" style="vertical-align: 0px"/> from 0 to <img class="math" src="_images/math/b633076aee7c1f897fc65a97ff10ea5e184d78fd.png" alt="\pi/2" style="vertical-align: -1px"/>.</p>
<p><strong>Damping:</strong> This result in the previous section
can be improved somewhat by slowing down
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>’s adaptation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">...</span>
<span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Parameter <tt class="docutils literal"><span class="pre">alpha</span></tt> controls the speed with which <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>
adapts, with smaller <tt class="docutils literal"><span class="pre">alpha</span></tt>s giving slower adaptation.
Here we reduce <tt class="docutils literal"><span class="pre">alpha</span></tt> to 0.1, from its default value of 0.5, and get
the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>itn   integral        wgt average     chi2/dof        Q
-------------------------------------------------------
  1   1.004(21)       1.004(21)           0.00     1.00
  2   0.988(24)       0.997(16)           0.26     0.61
  3   1.023(24)       1.005(13)           0.56     0.57
  4   0.996(19)       1.002(11)           0.43     0.73
  5   1.009(25)       1.0032(99)          0.34     0.85
  6   0.981(22)       0.9995(90)          0.44     0.82
  7   1.010(22)       1.0010(84)          0.40     0.88
  8   0.979(20)       0.9978(77)          0.48     0.85
  9   1.068(25)       1.0037(74)          1.29     0.24
 10   0.973(24)       1.0010(71)          1.32     0.22

result = 1.0031(72)    Q = 0.14
</pre></div>
</div>
<p>Notice how the errors fluctuate less from iteration to iteration
with the smaller <tt class="docutils literal"><span class="pre">alpha</span></tt> in this case.
Persistent, large fluctuations in the size
of the per-iteration errors is often a signal that <tt class="docutils literal"><span class="pre">alpha</span></tt> should
be reduced. With larger <tt class="docutils literal"><span class="pre">alpha</span></tt>s, <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> can over-react
to random fluctuations it encounters as it samples the integrand.</p>
<p>In general, we want <tt class="docutils literal"><span class="pre">alpha</span></tt> to be large enough so that <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> adapts
quickly to the integrand, but not so large that it has difficulty
holding on to the optimal tuning once it has found it. The best value
depends upon the integrand.</p>
<p><strong>adapt=False:</strong> Adaptation can be turned off completely
by setting parameter <tt class="docutils literal"><span class="pre">adapt=False</span></tt>. There are three reasons one
might do this. The first is if <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> is exhibiting the
kind of instability discussed in the previous section &#8212; one might
use the following code, instead of that presented there:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">...</span>
<span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The second reason is that <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> runs slightly faster when it is
no longer adapting to the integrand. The difference is not signficant
for complicated integrands, but is noticable in simpler cases.</p>
<p>The third reason for turning off adaptation is that <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> uses
unweighted averages, rather than weighted averages, to combine
results from different iterations when <tt class="docutils literal"><span class="pre">adapt=False</span></tt>.
Unweighted averages are not biased. They have no systematic error
of the sort discussed above, and so give correct results even
for very large numbers of iterations, <tt class="docutils literal"><span class="pre">nitn</span></tt>.</p>
<p>The lack of systematic biases is <em>not</em> a strong reason for turning
off adaptation, however, since the biases are
usually negligible (see above). Also, again,
errors tend to fall faster if the number of evaluations per iteration
<tt class="docutils literal"><span class="pre">neval</span></tt> is increased rather than the number of iterations. Finally
in practice it is difficult to know precisely when <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> is
finished adapting. One often finds (modest) continued improvement after
the training step, leading to more accurate final results.</p>
<p>Training the integrator and then setting <tt class="docutils literal"><span class="pre">adapt=False</span></tt> for the
final results works best if the number of evaluations per iteration
(<tt class="docutils literal"><span class="pre">neval</span></tt>) is the same in both steps. This is because the second
of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>&#8216;s adaptation strategies (adaptive stratified sampling) is
usually reinitialized when <tt class="docutils literal"><span class="pre">neval</span></tt> changes, and so is not
used at all when <tt class="docutils literal"><span class="pre">neval</span></tt> is changed at the same time <tt class="docutils literal"><span class="pre">adapt=False</span></tt>
is set.</p>
</div></blockquote>
</div>
<div class="section" id="multiple-integrands-simultaneously">
<h2>Multiple Integrands Simultaneously<a class="headerlink" href="#multiple-integrands-simultaneously" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> can be used to integrate multiple integrands simultaneously, using
the same integration points for each of the integrands. This is useful
in situations where the integrands have similar structure, with peaks in
the same locations. There can be  signficant advantages in sampling
different integrands at precisely the same points in x space, because
then Monte Carlo estimates for the different integrals are correlated.
If the integrands are very similar to each other, the correlations can be
very strong. This leads to greatly reduced errors in ratios or differences
of the resulting integrals as the fluctuations cancel.</p>
<p>Consider a simple example. We want to compute
the normalization and first two moments of a
sharply peaked probability distribution:</p>
<div class="math">
<p><img src="_images/math/f89ad1672e85a3edad7c44077670927e7e592f45.png" alt="I_0 &amp;\equiv \int_0^1 d^4x\;
    \mathrm{e}^{- 200 \sum_{d}(x_d-0.5)^2}\\
I_1 &amp;\equiv \int_0^1 d^4x\; x_0 \;
    \mathrm{e}^{- 200 \sum_{d}(x_d-0.5)^2} \\
I_2 &amp;\equiv \int_0^1 d^4x\; x_0^2 \;
    \mathrm{e}^{- 200 \sum_{d}(x_d-0.5)^2}"/></p>
</div><p>From these integrals we determine the mean and width of the distribution
projected onto one of the axes:</p>
<div class="math">
<p><img src="_images/math/dbe4cddfa4222a4d1b1af0ecf4063bc8453c60d7.png" alt="\langle x \rangle &amp;\equiv I_1 / I_0 \\[1ex]
\sigma_x^2 &amp;\equiv \langle x^2 \rangle - \langle x \rangle^2 \\
           &amp;= I_2 / I_0 - (I_1 / I_0)^2"/></p>
</div><p>This can be done using the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="c"># adapt grid</span>
<span class="n">training</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c"># final analysis</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;I[0] =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;  I[1] =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;  I[2] =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Q = </span><span class="si">%.2f</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;&lt;x&gt; =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span>
    <span class="s">&#39;sigma_x**2 = &lt;x**2&gt; - &lt;x&gt;**2 =&#39;</span><span class="p">,</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">correlation matrix:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">evalcorr</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
<p>The code is very similar to that used in the previous section. The
main difference is that the integrand function and <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>
return arrays of results &#8212; in
both cases, one result for each of the three integrals. <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> always adapts to
the first integrand in the array. The <tt class="docutils literal"><span class="pre">Q</span></tt> value is for all three
of the integrals, taken together.</p>
<p>The code produces the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>I[0] = 0.00024686(26)   I[1] = 0.00012347(13)   I[2] = 0.000062372(72)
Q = 0.86

&lt;x&gt; = 0.50016(11)
sigma_x**2 = &lt;x**2&gt; - &lt;x&gt;**2 = 0.002506(15)

correlation matrix:
 [[ 1.          0.98054444  0.92734262]
 [ 0.98054444  1.          0.98207749]
 [ 0.92734262  0.98207749  1.        ]]
</pre></div>
</div>
<p>The estimates for the individual integrals are separately accurate to
about ±0.1%,
but the estimate for <img class="math" src="_images/math/3896a13c95ef36dd89adfcc73d27dfbdd258645a.png" alt="\langle x \rangle = I_1/I_0" style="vertical-align: -4px"/>
is accurate to ±0.02%.
This is almost an order
of magnitude (7x) more accurate than we would obtain absent correlations.
The correlation matrix shows that there is 98% correlation between the
statistical fluctuations in estimates for <img class="math" src="_images/math/1aac7189c0c3ecd30b3206945889849d09e7a988.png" alt="I_0" style="vertical-align: -3px"/> and <img class="math" src="_images/math/166a449596545aa6ed34c4808e99660683af1606.png" alt="I_1" style="vertical-align: -3px"/>,
and so the bulk of these fluctuations cancel in the ratio.
The estimate for the variance <img class="math" src="_images/math/580763986e6b9a5e3f106827b822d99870eb2a4c.png" alt="\sigma^2_x" style="vertical-align: -8px"/>
is 45x more accurate than we would
have obtained had the integrals been evaluated separately. Both estimates
are correct to within the quoted errors.</p>
<p>The individual results are objects of type <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>, which
represent Gaussian random variables. Such objects have means
(<tt class="docutils literal"><span class="pre">result[i].mean</span></tt>) and standard deviations (<tt class="docutils literal"><span class="pre">result[i].sdev</span></tt>), but
also can be statistically correlated with other <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s.
Such correlations are handled automatically by <tt class="xref py py-mod docutils literal"><span class="pre">gvar</span></tt> when
<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s are combined with each other or with numbers in
arithmetical expressions. <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> provides a simplified implementation
of <tt class="docutils literal"><span class="pre">GVar</span></tt>s for use if the <tt class="xref py py-mod docutils literal"><span class="pre">gvar</span></tt> module is not installed, but that
version does <em>not</em> handle correlations at all (and, therefore, won&#8217;t
allow a statement like <tt class="docutils literal"><span class="pre">result[1]</span> <span class="pre">/</span> <span class="pre">result[0]</span></tt> above). To make full
use of this <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> feature install the <tt class="xref py py-mod docutils literal"><span class="pre">gvar</span></tt> module. It can be
installed as part of the <tt class="docutils literal"><span class="pre">lsqfit</span></tt> distribution (e.g., <tt class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">lsqfit</span></tt>)
or by itself (e.g., <tt class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">gvar</span></tt>); source code can be found at
<a class="reference external" href="https://github.com/gplepage/lsqfit.git">https://github.com/gplepage/lsqfit.git</a>.</p>
</div>
<div class="section" id="faster-integrands">
<h2>Faster Integrands<a class="headerlink" href="#faster-integrands" title="Permalink to this headline">¶</a></h2>
<p>The computational cost of a realistic multidimensional integral
comes mostly from
the cost of evaluating the integrand at the Monte Carlo sample
points. Integrands written in pure Python are probably fast
enough for problems where <tt class="docutils literal"><span class="pre">neval=1e3</span></tt> or <tt class="docutils literal"><span class="pre">neval=1e4</span></tt> gives
enough precision. Some problems, however, require
hundreds of thousands or millions of function evaluations, or more.</p>
<p>We can significantly reduce the cost of evaluating the integrand
by using <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>&#8216;s batch mode. For example, replacing</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="n">dim</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">norm</span> <span class="o">=</span> <span class="mf">1013.2118364296088</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f_scalar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="n">dim</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">integ</span><span class="p">(</span><span class="n">f_scalar</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f_scalar</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;result = </span><span class="si">%s</span><span class="s">   Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">f_batch</span><span class="p">(</span><span class="n">vegas</span><span class="o">.</span><span class="n">BatchIntegrand</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="mf">1013.2118364296088</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c"># evaluate integrand at multiple points simultaneously</span>
        <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">f_batch</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">nhcube_batch</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;result = </span><span class="si">%s</span><span class="s">   Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>reduces the cost of the integral by almost an order of magnitude.
Internally <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> processes integration points in batches, where
parameter <tt class="docutils literal"><span class="pre">nhcube_batch</span></tt> determines the number of points per
batch (typically 1000s).
In batch mode, <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> presents all of the integration points
from a batch together, in a single array, to the integrand
function, rather than offering them one at a time. Here, for example,
an instance <tt class="docutils literal"><span class="pre">f</span></tt> of class <tt class="docutils literal"><span class="pre">f_batch</span></tt> behaves like a function <tt class="docutils literal"><span class="pre">f(x)</span></tt> of
an array of integration points &#8212; <tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt> where <tt class="docutils literal"><span class="pre">i=0...</span></tt>
labels the integration point and <tt class="docutils literal"><span class="pre">d=0...</span></tt> the direction &#8212; and
returns an array of integrand values corresponding  to these points.</p>
<p>We derive class <tt class="docutils literal"><span class="pre">f_batch</span></tt> from <a class="reference internal" href="vegas.html#vegas.BatchIntegrand" title="vegas.BatchIntegrand"><tt class="xref py py-class docutils literal"><span class="pre">vegas.BatchIntegrand</span></tt></a> to
signal to <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> that it should present integration points in
batches to the integrand function.</p>
<p>An alternative to deriving from <a class="reference internal" href="vegas.html#vegas.BatchIntegrand" title="vegas.BatchIntegrand"><tt class="xref py py-class docutils literal"><span class="pre">vegas.BatchIntegrand</span></tt></a> is
to apply the <a class="reference internal" href="vegas.html#vegas.batchintegrand" title="vegas.batchintegrand"><tt class="xref py py-func docutils literal"><span class="pre">vegas.batchintegrand()</span></tt></a> decorator to a batch
function for the integrand: e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">dim</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">norm</span> <span class="o">=</span> <span class="mf">1013.2118364296088</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">)</span>

<span class="nd">@vegas.batchintegrand</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c"># evaluate integrand at multiple points simultaneously</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="n">dim</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">nhcube_batch</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">200000</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">200000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;result = </span><span class="si">%s</span><span class="s">   Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>This batch integrand is fast because it is expressed in terms
<tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> operators that act on entire arrays. That optimization
is unnecessary
(and the result is faster) if we write the integrand in Cython, which
is a compiled hybrid of Python and C. The Cython version
of this code is:</p>
<div class="highlight-python"><div class="highlight"><pre># file: cython_integrand.pyx

cimport vegas                   # for BatchIntegrand
from libc.math cimport exp      # use exp() from C library

import vegas
import numpy

cdef class f_cython(vegas.BatchIntegrand):
    cdef double norm
    cdef readonly int dim

    def __init__(self, dim):
        self.dim = dim
        self.norm = 1013.2118364296088 ** (dim / 4.)

    def __call__(self, double[:, ::1] x):
        cdef int i, d
        cdef double dx2
        cdef double[::1] f = numpy.empty(x.shape[0], float)
        for i in range(f.shape[0]):
            dx2 = 0.0
            for d in range(self.dim):
                dx2 += (x[i, d] - 0.5) ** 2
            f[i] = exp(-100. * dx2) * self.norm
        return f
</pre></div>
</div>
<p>We put this in a separate file called, say,
<tt class="docutils literal"><span class="pre">cython_integrand.pyx</span></tt>, and rewrite the main code as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pyximport</span><span class="p">;</span> <span class="n">pyximport</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>

<span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">from</span> <span class="nn">cython_integrand</span> <span class="kn">import</span> <span class="n">f_cython</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">f_cython</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">nhcube_batch</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">200000</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">200000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;result = </span><span class="si">%s</span><span class="s">   Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>The first line (<tt class="docutils literal"><span class="pre">import</span> <span class="pre">pyximport;</span> <span class="pre">...</span></tt>) causes the Cython
module <tt class="docutils literal"><span class="pre">cython_integrand.pyx</span></tt> to be compiled the first time
it is called. The compiled code is stored and used in subsequent
calls, so compilation occurs only once.</p>
<p>Batch mode is also a good idea for array-valued integrands.
The code from the previous section could have been written as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">dim</span> <span class="o">=</span> <span class="mi">4</span>

<span class="nd">@vegas.batchintegrand</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">ans</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
    <span class="n">ans</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ans</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">ans</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ans</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ans</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="c"># adapt grid</span>
<span class="n">training</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c"># final analysis</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;I[0] =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;  I[1] =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;  I[2] =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Q = </span><span class="si">%.2f</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;&lt;x&gt; =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span>
    <span class="s">&#39;sigma_x**2 = &lt;x**2&gt; - &lt;x&gt;**2 =&#39;</span><span class="p">,</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">correlation matrix:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">evalcorr</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the batch index (here <tt class="docutils literal"><span class="pre">:</span></tt>) always comes first.</p>
<p>Cython code can also link easily to compiled C or Fortran code,
so integrands written in these languages can be used as well (and
would be faster than pure Python).</p>
</div>
<div class="section" id="multiple-processors">
<h2>Multiple Processors<a class="headerlink" href="#multiple-processors" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> code normally runs on a single CPU. It is possible
to distribute the evaluation of the integrand over multiple processors
by using the batch mode described in the previous section. This
becomes worthwhile when the integrand becomes more expensive to
evaluate.</p>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> comes with a decorator, <a class="reference internal" href="vegas.html#vegas.MPIintegrand" title="vegas.MPIintegrand"><tt class="xref py py-class docutils literal"><span class="pre">vegas.MPIintegrand</span></tt></a>, that  adapts
batch integrands for multiprocessor use through MPI. It assumes that Python
module <tt class="xref py py-mod docutils literal"><span class="pre">mpi4py</span></tt> is installed (and MPI, of course). To illustrate its use
consider an integrand consisting of 1000 narrow Gaussians distributed evenly
along the diagonal of a 4-dimensional unit hypercube. To maximize speed, we
implement the integrand in Cython, putting the result in a file <tt class="docutils literal"><span class="pre">ridge.pyx</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre># file: ridge.pyx

from libc.math cimport exp      # use exp() from C library
import numpy as np

def f(double[:, ::1] x):
    cdef double dx2, x0
    cdef int d, i, j
    cdef int dim=4
    cdef int N=1000
    cdef double[::1] ans = np.zeros(x.shape[0], float)
    for i in range(x.shape[0]):
        for j in range(N):
            x0 = j / (N - 1.)
            dx2 = 0.0
            for d in range(dim):
                dx2 += (x[i, d] - x0) ** 2
            ans[i] += exp(-100. * dx2)
        ans[i] *= (100. / np.pi) ** 2 / N
    return ans
</pre></div>
</div>
<p>This is a standard batch integrand; it could have been written in Fortran
or C almost as easily, or in Python. The main integration code,
in file <tt class="docutils literal"><span class="pre">mpi-integral.py</span></tt>, is then:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># file: mpi-integral.py</span>

<span class="kn">import</span> <span class="nn">pyximport</span><span class="p">;</span> <span class="n">pyximport</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>  <span class="c"># compiles ridge.pyx</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">ridge</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="c"># convert ridge.f into an MPI integrand</span>
    <span class="n">fparallel</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">MPIintegrand</span><span class="p">(</span><span class="n">ridge</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
    <span class="c"># adapt</span>
    <span class="n">integ</span><span class="p">(</span><span class="n">fparallel</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">1e5</span><span class="p">)</span>
    <span class="c"># final results</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">fparallel</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">1e5</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fparrallel</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c"># result should be approximately 0.851</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;result = </span><span class="si">%s</span><span class="s">    Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>The integrand and main program are identical to what one would use for
a batch integral except that <tt class="docutils literal"><span class="pre">vegas.MPIintegrand(ridge.f)</span></tt> is used
in place of <tt class="docutils literal"><span class="pre">vegas.batchintegrand(ridge.f)</span></tt>, and we check the MPI
rank of the process to avoid printing out multiple copies of the result,
after the integration. To run this code on 4 CPUs, we might execute:</p>
<div class="highlight-python"><div class="highlight"><pre>mpirun -np 4 python mpi-integral.py
</pre></div>
</div>
<p>This code runs 2.5&#8211;3 times faster on 4 CPUs than on a single CPU.
One might have hoped that 4 CPUs would be 4x faster, but they aren&#8217;t
quite that fast because of the time needed to transfer integration
information between the processes on the different CPUs.
Multiple CPUs are efficient only for costly integrands.</p>
<p>There are many other ways to implement multiprocessing for <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>.
All methods work with <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> in batch mode, and distribute different
integration points to different CPUs. For example, a class similar
in function to <a class="reference internal" href="vegas.html#vegas.MPIintegrand" title="vegas.MPIintegrand"><tt class="xref py py-class docutils literal"><span class="pre">vegas.MPIintegrand</span></tt></a>, but where Python&#8217;s
<tt class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></tt> module replaces MPI, is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vegas</span>

<span class="k">class</span> <span class="nc">parallelintegrand</span><span class="p">(</span><span class="n">vegas</span><span class="o">.</span><span class="n">BatchIntegrand</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert (batch) integrand into multiprocessor integrand.</span>

<span class="sd">    Integrand should return a numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="s">&quot; Save integrand; create pool of nproc processes. &quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fcn</span> <span class="o">=</span> <span class="n">fcn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="n">nproc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">nproc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot; Standard cleanup. &quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s">&quot; Divide x into self.nproc chunks, feeding one to each process. &quot;</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c"># launch evaluation of self.fcn for each chunk, in parallel</span>
        <span class="n">po</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">map_async</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fcn</span><span class="p">,</span>
            <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">nx</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nproc</span><span class="p">)],</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c"># harvest the results</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">po</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="c"># convert list of results into a single numpy array</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<p>Then <tt class="docutils literal"><span class="pre">fparallel</span> <span class="pre">=</span> <span class="pre">parallelintegrand(f,</span> <span class="pre">4)</span></tt>, for example, will create a
new integrand <tt class="docutils literal"><span class="pre">fparallel(x)</span></tt> that uses 4 CPUs. This particular
implementation of parallelism is not as efficient as the
<a class="reference internal" href="vegas.html#vegas.MPIintegrand" title="vegas.MPIintegrand"><tt class="xref py py-class docutils literal"><span class="pre">vegas.MPIintegrand</span></tt></a>.</p>
</div>
<div class="section" id="sums-with-vegas">
<h2>Sums with <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a><a class="headerlink" href="#sums-with-vegas" title="Permalink to this headline">¶</a></h2>
<p>The code in the previous sections is inefficient in the way it
handles the sum over 1000 Gaussians. It is not necessary to include every
term in the sum for every integration point. Rather we can sample the sum,
using <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> to do the sampling. The trick is to replace the sum with
an equivalent integral:</p>
<div class="math">
<p><img src="_images/math/f2ebd8f90502cba3ffd86bfbd66ee5a5023ab011.png" alt="\sum_{i=0}^{N-1} f(i) = N \int_0^1 dx \; f(\mathrm{floor}(x N))"/></p>
</div><p>where <img class="math" src="_images/math/2be12ba603f33ecca023f6092bed262ccd5d162c.png" alt="\mathrm{floor}(x)" style="vertical-align: -3px"/> is the largest
integer smaller than <img class="math" src="_images/math/6ae387606cd8532c2be4273520d87f3cd863cf42.png" alt="x" style="vertical-align: -1px"/>. The
resulting integral can then be handed to <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>. Using this trick,
the integral in the previous section can be re-cast as a 5-dimensional
integral (again in Cython),</p>
<div class="highlight-python"><div class="highlight"><pre># file: ridge.pyx

from libc.math cimport exp, floor
import numpy as np

def fsum(double[:, ::1] x):
    cdef double dx2, x0, j
    cdef int d, i
    cdef int dim=4
    cdef int N=1000
    cdef double[::1] ans = np.zeros(x.shape[0], float)
    for i in range(x.shape[0]):
        j = floor(x[i, -1] * N)
        x0 = j / (N - 1.)
        dx2 = 0.0
        for d in range(dim):
            dx2 += (x[i, d] - x0) ** 2
        ans[i] += exp(-100. * dx2)
        # drop 1/N because multiplying by N
        ans[i] *= (100. / np.pi) ** 2
    return np.asarray(ans)
</pre></div>
</div>
<p>and the main program becomes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pyximport</span><span class="p">;</span> <span class="n">pyximport</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">ridge</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">batchintegrand</span><span class="p">(</span><span class="n">ridge</span><span class="o">.</span><span class="n">fsum</span><span class="p">)</span>
    <span class="c"># adapt</span>
    <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">5e5</span><span class="p">)</span>
    <span class="c"># final results</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">5e5</span><span class="p">)</span>
    <span class="c"># result should be approximately 0.851</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;result = </span><span class="si">%s</span><span class="s">    Q = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>This gives about the same precision but is 3x faster (on a laptop in 2014)
than the code in the previous section.</p>
<p>The same trick can be generalized to sums over multiple indices, including sums
to infinity. <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> will provide Monte Carlo estimates of the sums, emphasizing
the more important terms.</p>
</div>
<div class="section" id="vegas-as-a-random-number-generator">
<h2><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> as a Random Number Generator<a class="headerlink" href="#vegas-as-a-random-number-generator" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> integrator generates random points in its integration volume from a
distribution that is optimized for integrals of whatever function it
was trained on. The integrator
provides low-level access to the random-point generator
through the iterators <a class="reference internal" href="vegas.html#vegas.Integrator.random" title="vegas.Integrator.random"><tt class="xref py py-meth docutils literal"><span class="pre">vegas.Integrator.random()</span></tt></a> and
<a class="reference internal" href="vegas.html#vegas.Integrator.random_batch" title="vegas.Integrator.random_batch"><tt class="xref py py-meth docutils literal"><span class="pre">vegas.Integrator.random_batch()</span></tt></a>.</p>
<p>To illustrate, the following code snippet estimates the integral of function
<tt class="docutils literal"><span class="pre">f(x)</span></tt> using integrator <tt class="docutils literal"><span class="pre">integ</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integral</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span> <span class="ow">in</span> <span class="n">integ</span><span class="o">.</span><span class="n">random</span><span class="p">():</span>
    <span class="n">integral</span> <span class="o">+=</span> <span class="n">wgt</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">x[d]</span></tt> is a random point in the integration volume and <tt class="docutils literal"><span class="pre">wgt</span></tt> is the
weight <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> assigns to that point in an integration. The iterator generates
integration points and weights corresponding to a single iteration of the
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> algorithm. In practice, we would train <tt class="docutils literal"><span class="pre">integ</span></tt> on a function whose
shape is similar to that of <tt class="docutils literal"><span class="pre">f(x)</span></tt> before using it to estimate the integral
of <tt class="docutils literal"><span class="pre">f(x)</span></tt>.</p>
<p>It is usually more efficient to generate and use integration points in
batches. The <a class="reference internal" href="vegas.html#vegas.Integrator.random_batch" title="vegas.Integrator.random_batch"><tt class="xref py py-meth docutils literal"><span class="pre">vegas.Integrator.random_batch()</span></tt></a> iterator does just
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integral</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span> <span class="ow">in</span> <span class="n">integ</span><span class="o">.</span><span class="n">random_batch</span><span class="p">():</span>
    <span class="n">integral</span> <span class="o">+=</span> <span class="n">wgt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">batch_f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt> is an array of integration points, <tt class="docutils literal"><span class="pre">wgt[i]</span></tt> contains the
corresponding weights, and <tt class="docutils literal"><span class="pre">batch_f(x)</span></tt> returns an array containing the
corresponding integrand values.</p>
<p>The random points generated by <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> are stratified into hypercubes: <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>
uses transformed integration variables to improve its Monte Carlo
estimates. It further improves those estimates by subdividing the
integration volume in the transformed variables into a large number of
hypercubes, and doing a Monte Carlo integral in each hypercube separately.
The final result is the sum of the results from all the hypercubes.
To mimic a full <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> integral estimate using the iterators above, we need
to know which points belong to which hypercubes. The following code
shows how this is done:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integral</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">variance</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span><span class="p">,</span> <span class="n">hcube</span> <span class="ow">in</span> <span class="n">integ</span><span class="o">.</span><span class="n">random_batch</span><span class="p">(</span><span class="n">yield_hcube</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">wgt_fx</span> <span class="o">=</span> <span class="n">wgt</span> <span class="o">*</span> <span class="n">batch_f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c"># iterate over hypercubes: compute variance for each,</span>
    <span class="c">#                          and accumulate for final result</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hcube</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hcube</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcube</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>          <span class="c"># select array items for h-cube i</span>
        <span class="n">nwf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>           <span class="c"># number of points in h-cube i</span>
        <span class="n">wf</span> <span class="o">=</span> <span class="n">wgt_fx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">sum_wf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wf</span><span class="p">)</span>         <span class="c"># sum of wgt * f(x) for h-cube i</span>
        <span class="n">sum_wf2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wf</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>   <span class="c"># sum of (wgt * f(x)) ** 2</span>
        <span class="n">integral</span> <span class="o">+=</span> <span class="n">sum_wf</span>
        <span class="n">variance</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sum_wf2</span> <span class="o">*</span> <span class="n">nwf</span> <span class="o">-</span> <span class="n">sum_wf</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nwf</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span>
<span class="c"># answer = integral;   standard deviation = variance ** 0.5</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">integral</span><span class="p">,</span> <span class="n">variance</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">hcube[i]</span></tt> identifies the hypercube containing <tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt>.</p>
</div>
<div class="section" id="implementation-notes">
<h2>Implementation Notes<a class="headerlink" href="#implementation-notes" title="Permalink to this headline">¶</a></h2>
<p>This implementation relies upon Cython for its speed and
numpy for array processing. It also uses matplotlib
for graphics, but graphics is optional.</p>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> also uses the <tt class="xref py py-mod docutils literal"><span class="pre">gvar</span></tt> module from the <tt class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></tt>
distribution if that package is installed (<tt class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">lsqfit</span></tt>
or <tt class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">gvar</span></tt> for just <tt class="docutils literal"><span class="pre">gvar</span></tt>).
Integration results are returned as objects of type
<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>, which is a class representing Gaussian
random variables (i.e., something with a mean and standard
deviation). These objects can be combined with numbers and
with each other in arbitrary arithmetic expressions to
get new <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s with the correct standard
deviations, and properly correlated with other
<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s &#8212; that is the tricky part.</p>
<p>If <tt class="xref py py-mod docutils literal"><span class="pre">gvar</span></tt> is not installed, <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> uses a limited substitute
that supports arithmetic between <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s
and numbers, but not between <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s and other
<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s. It also supports <tt class="docutils literal"><span class="pre">log</span></tt>, <tt class="docutils literal"><span class="pre">sqrt</span></tt>
and <tt class="docutils literal"><span class="pre">exp</span></tt> of <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s, but not trig functions
&#8212; for these install the <tt class="docutils literal"><span class="pre">gvar</span></tt> module. Most importantly
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> will not provide correlation information for
integrals of array-valued integrands unless the <tt class="xref py py-mod docutils literal"><span class="pre">gvar</span></tt>
module is available.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tutorial</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#basic-integrals">Basic Integrals</a></li>
<li><a class="reference internal" href="#multiple-integrands-simultaneously">Multiple Integrands Simultaneously</a></li>
<li><a class="reference internal" href="#faster-integrands">Faster Integrands</a></li>
<li><a class="reference internal" href="#multiple-processors">Multiple Processors</a></li>
<li><a class="reference internal" href="#sums-with-vegas">Sums with <tt class="docutils literal"><span class="pre">vegas</span></tt></a></li>
<li><a class="reference internal" href="#vegas-as-a-random-number-generator"><tt class="docutils literal"><span class="pre">vegas</span></tt> as a Random Number Generator</a></li>
<li><a class="reference internal" href="#implementation-notes">Implementation Notes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">vegas Documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="background.html"
                        title="next chapter">How <tt class="docutils literal"><span class="pre">vegas</span></tt> Works</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="background.html" title="How vegas Works"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="vegas Documentation"
             >previous</a> |</li>
        <li><a href="index.html">vegas 2.2.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013-14, G.P. Lepage.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>