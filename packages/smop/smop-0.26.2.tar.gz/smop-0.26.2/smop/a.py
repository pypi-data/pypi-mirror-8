# Autogenerated with SMOP version 0.26.1-7-g27f718a
# main.py -X legend.m octave-3.8.2/scripts/polynomial/roots.m octave-3.8.2/scripts/polynomial/ppint.m octave-3.8.2/scripts/polynomial/polyder.m octave-3.8.2/scripts/polynomial/spline.m octave-3.8.2/scripts/polynomial/pchip.m octave-3.8.2/scripts/polynomial/polygcd.m octave-3.8.2/scripts/polynomial/polyvalm.m octave-3.8.2/scripts/polynomial/unmkpp.m octave-3.8.2/scripts/polynomial/polyint.m octave-3.8.2/scripts/polynomial/compan.m octave-3.8.2/scripts/polynomial/ppval.m octave-3.8.2/scripts/polynomial/private/__splinefit__.m octave-3.8.2/scripts/polynomial/polyreduce.m octave-3.8.2/scripts/polynomial/residue.m octave-3.8.2/scripts/polynomial/ppder.m octave-3.8.2/scripts/polynomial/polyval.m octave-3.8.2/scripts/polynomial/polyeig.m octave-3.8.2/scripts/polynomial/deconv.m octave-3.8.2/scripts/polynomial/splinefit.m octave-3.8.2/scripts/polynomial/polyfit.m octave-3.8.2/scripts/polynomial/conv.m octave-3.8.2/scripts/polynomial/polyaffine.m octave-3.8.2/scripts/polynomial/mkpp.m octave-3.8.2/scripts/polynomial/ppjumps.m octave-3.8.2/scripts/polynomial/mpoles.m octave-3.8.2/scripts/polynomial/polyout.m octave-3.8.2/scripts/polynomial/poly.m octave-3.8.2/scripts/elfun/tand.m octave-3.8.2/scripts/elfun/sech.m octave-3.8.2/scripts/elfun/cscd.m octave-3.8.2/scripts/elfun/cosd.m octave-3.8.2/scripts/elfun/secd.m octave-3.8.2/scripts/elfun/asind.m octave-3.8.2/scripts/elfun/acotd.m octave-3.8.2/scripts/elfun/atan2d.m octave-3.8.2/scripts/elfun/sind.m octave-3.8.2/scripts/elfun/asecd.m octave-3.8.2/scripts/elfun/acsch.m octave-3.8.2/scripts/elfun/acosd.m octave-3.8.2/scripts/elfun/sec.m octave-3.8.2/scripts/elfun/acscd.m octave-3.8.2/scripts/elfun/asech.m octave-3.8.2/scripts/elfun/acsc.m octave-3.8.2/scripts/elfun/asec.m octave-3.8.2/scripts/elfun/csch.m octave-3.8.2/scripts/elfun/acoth.m octave-3.8.2/scripts/elfun/cot.m octave-3.8.2/scripts/elfun/coth.m octave-3.8.2/scripts/elfun/cotd.m octave-3.8.2/scripts/elfun/atand.m octave-3.8.2/scripts/elfun/acot.m octave-3.8.2/scripts/elfun/csc.m octave-3.8.2/scripts/pkg/pkg.m octave-3.8.2/scripts/pkg/private/load_packages_and_dependencies.m octave-3.8.2/scripts/pkg/private/packinfo_copy_file.m octave-3.8.2/scripts/pkg/private/save_order.m octave-3.8.2/scripts/pkg/private/getarch.m octave-3.8.2/scripts/pkg/private/create_pkgadddel.m octave-3.8.2/scripts/pkg/private/generate_lookfor_cache.m octave-3.8.2/scripts/pkg/private/print_package_description.m octave-3.8.2/scripts/pkg/private/fix_version.m octave-3.8.2/scripts/pkg/private/build.m octave-3.8.2/scripts/pkg/private/get_forge_download.m octave-3.8.2/scripts/pkg/private/repackage.m octave-3.8.2/scripts/pkg/private/getarchprefix.m octave-3.8.2/scripts/pkg/private/shell.m octave-3.8.2/scripts/pkg/private/rebuild.m octave-3.8.2/scripts/pkg/private/fix_depends.m octave-3.8.2/scripts/pkg/private/write_index.m octave-3.8.2/scripts/pkg/private/uninstall.m octave-3.8.2/scripts/pkg/private/load_package_dirs.m octave-3.8.2/scripts/pkg/private/get_forge_pkg.m octave-3.8.2/scripts/pkg/private/install.m octave-3.8.2/scripts/pkg/private/finish_installation.m octave-3.8.2/scripts/pkg/private/list_forge_packages.m octave-3.8.2/scripts/pkg/private/prepare_installation.m octave-3.8.2/scripts/pkg/private/get_unsatisfied_deps.m octave-3.8.2/scripts/pkg/private/extract_pkg.m octave-3.8.2/scripts/pkg/private/describe.m octave-3.8.2/scripts/pkg/private/installed_packages.m octave-3.8.2/scripts/pkg/private/load_packages.m octave-3.8.2/scripts/pkg/private/parse_pkg_idx.m octave-3.8.2/scripts/pkg/private/is_architecture_dependent.m octave-3.8.2/scripts/pkg/private/unload_packages.m octave-3.8.2/scripts/pkg/private/getarchdir.m octave-3.8.2/scripts/pkg/private/verify_directory.m octave-3.8.2/scripts/pkg/private/configure_make.m octave-3.8.2/scripts/pkg/private/dirempty.m octave-3.8.2/scripts/pkg/private/copy_files.m octave-3.8.2/scripts/pkg/private/get_description.m octave-3.8.2/scripts/signal/blackman.m octave-3.8.2/scripts/signal/arma_rnd.m octave-3.8.2/scripts/signal/spencer.m octave-3.8.2/scripts/signal/fftshift.m octave-3.8.2/scripts/signal/arch_fit.m octave-3.8.2/scripts/signal/sinc.m octave-3.8.2/scripts/signal/arch_test.m octave-3.8.2/scripts/signal/sinewave.m octave-3.8.2/scripts/signal/bartlett.m octave-3.8.2/scripts/signal/freqz_plot.m octave-3.8.2/scripts/signal/fftconv.m octave-3.8.2/scripts/signal/synthesis.m octave-3.8.2/scripts/signal/fftfilt.m octave-3.8.2/scripts/signal/private/rectangle_lw.m octave-3.8.2/scripts/signal/private/triangle_lw.m octave-3.8.2/scripts/signal/private/rectangle_sw.m octave-3.8.2/scripts/signal/private/triangle_sw.m octave-3.8.2/scripts/signal/diffpara.m octave-3.8.2/scripts/signal/arch_rnd.m octave-3.8.2/scripts/signal/autoreg_matrix.m octave-3.8.2/scripts/signal/unwrap.m octave-3.8.2/scripts/signal/hurst.m octave-3.8.2/scripts/signal/yulewalker.m octave-3.8.2/scripts/signal/freqz.m octave-3.8.2/scripts/signal/durbinlevinson.m octave-3.8.2/scripts/signal/spectral_adf.m octave-3.8.2/scripts/signal/hamming.m octave-3.8.2/scripts/signal/stft.m octave-3.8.2/scripts/signal/ifftshift.m octave-3.8.2/scripts/signal/sinetone.m octave-3.8.2/scripts/signal/hanning.m octave-3.8.2/scripts/signal/periodogram.m octave-3.8.2/scripts/signal/fractdiff.m octave-3.8.2/scripts/signal/filter2.m octave-3.8.2/scripts/signal/detrend.m octave-3.8.2/scripts/signal/spectral_xdf.m octave-3.8.2/scripts/optimization/pqpnonneg.m octave-3.8.2/scripts/optimization/qp.m octave-3.8.2/scripts/optimization/glpk.m octave-3.8.2/scripts/optimization/__all_opts__.m octave-3.8.2/scripts/optimization/fsolve.m octave-3.8.2/scripts/optimization/private/__fdjac__.m octave-3.8.2/scripts/optimization/fzero.m octave-3.8.2/scripts/optimization/optimset.m octave-3.8.2/scripts/optimization/optimget.m octave-3.8.2/scripts/optimization/fminsearch.m octave-3.8.2/scripts/optimization/sqp.m octave-3.8.2/scripts/optimization/fminbnd.m octave-3.8.2/scripts/optimization/lsqnonneg.m octave-3.8.2/scripts/optimization/fminunc.m octave-3.8.2/scripts/image/imformats.m octave-3.8.2/scripts/image/iscolormap.m octave-3.8.2/scripts/image/rainbow.m octave-3.8.2/scripts/image/cmpermute.m octave-3.8.2/scripts/image/hsv2rgb.m octave-3.8.2/scripts/image/brighten.m octave-3.8.2/scripts/image/colorcube.m octave-3.8.2/scripts/image/imagesc.m octave-3.8.2/scripts/image/gray.m octave-3.8.2/scripts/image/colormap.m octave-3.8.2/scripts/image/cool.m octave-3.8.2/scripts/image/ind2rgb.m octave-3.8.2/scripts/image/spring.m octave-3.8.2/scripts/image/gmap40.m octave-3.8.2/scripts/image/copper.m octave-3.8.2/scripts/image/imwrite.m octave-3.8.2/scripts/image/imread.m octave-3.8.2/scripts/image/gray2ind.m octave-3.8.2/scripts/image/private/imwrite_filename.m octave-3.8.2/scripts/image/private/__imfinfo__.m octave-3.8.2/scripts/image/private/__imwrite__.m octave-3.8.2/scripts/image/private/ind2x.m octave-3.8.2/scripts/image/private/imageIO.m octave-3.8.2/scripts/image/private/__imread__.m octave-3.8.2/scripts/image/image.m octave-3.8.2/scripts/image/imfinfo.m octave-3.8.2/scripts/image/winter.m octave-3.8.2/scripts/image/cmunique.m octave-3.8.2/scripts/image/rgb2ind.m octave-3.8.2/scripts/image/rgb2ntsc.m octave-3.8.2/scripts/image/jet.m octave-3.8.2/scripts/image/rgb2hsv.m octave-3.8.2/scripts/image/flag.m octave-3.8.2/scripts/image/ntsc2rgb.m octave-3.8.2/scripts/image/ind2gray.m octave-3.8.2/scripts/image/rgbplot.m octave-3.8.2/scripts/image/hot.m octave-3.8.2/scripts/image/prism.m octave-3.8.2/scripts/image/hsv.m octave-3.8.2/scripts/image/pink.m octave-3.8.2/scripts/image/bone.m octave-3.8.2/scripts/image/ocean.m octave-3.8.2/scripts/image/summer.m octave-3.8.2/scripts/image/contrast.m octave-3.8.2/scripts/image/spinmap.m octave-3.8.2/scripts/image/white.m octave-3.8.2/scripts/image/autumn.m octave-3.8.2/scripts/image/lines.m octave-3.8.2/scripts/image/imshow.m octave-3.8.2/scripts/sparse/spconvert.m octave-3.8.2/scripts/sparse/sprandn.m octave-3.8.2/scripts/sparse/bicg.m octave-3.8.2/scripts/sparse/bicgstab.m octave-3.8.2/scripts/sparse/nonzeros.m octave-3.8.2/scripts/sparse/speye.m octave-3.8.2/scripts/sparse/treelayout.m octave-3.8.2/scripts/sparse/svds.m octave-3.8.2/scripts/sparse/spstats.m octave-3.8.2/scripts/sparse/private/__sprand_impl__.m octave-3.8.2/scripts/sparse/pcr.m octave-3.8.2/scripts/sparse/spy.m octave-3.8.2/scripts/sparse/spones.m octave-3.8.2/scripts/sparse/gmres.m octave-3.8.2/scripts/sparse/pcg.m octave-3.8.2/scripts/sparse/sprand.m octave-3.8.2/scripts/sparse/spaugment.m octave-3.8.2/scripts/sparse/spfun.m octave-3.8.2/scripts/sparse/gplot.m octave-3.8.2/scripts/sparse/colperm.m octave-3.8.2/scripts/sparse/cgs.m octave-3.8.2/scripts/sparse/etreeplot.m octave-3.8.2/scripts/sparse/sprandsym.m octave-3.8.2/scripts/sparse/treeplot.m octave-3.8.2/scripts/sparse/eigs.m octave-3.8.2/scripts/sparse/spdiags.m octave-3.8.2/scripts/set/setxor.m octave-3.8.2/scripts/set/ismember.m octave-3.8.2/scripts/set/powerset.m octave-3.8.2/scripts/set/unique.m octave-3.8.2/scripts/set/private/validargs.m octave-3.8.2/scripts/set/setdiff.m octave-3.8.2/scripts/set/intersect.m octave-3.8.2/scripts/set/union.m octave-3.8.2/scripts/specfun/isprime.m octave-3.8.2/scripts/specfun/ellipke.m octave-3.8.2/scripts/specfun/pow2.m octave-3.8.2/scripts/specfun/expint.m octave-3.8.2/scripts/specfun/realsqrt.m octave-3.8.2/scripts/specfun/factor.m octave-3.8.2/scripts/specfun/realpow.m octave-3.8.2/scripts/specfun/reallog.m octave-3.8.2/scripts/specfun/perms.m octave-3.8.2/scripts/specfun/bessel.m octave-3.8.2/scripts/specfun/factorial.m octave-3.8.2/scripts/specfun/betaln.m octave-3.8.2/scripts/specfun/lcm.m octave-3.8.2/scripts/specfun/beta.m octave-3.8.2/scripts/specfun/nthroot.m octave-3.8.2/scripts/specfun/legendre.m octave-3.8.2/scripts/specfun/primes.m octave-3.8.2/scripts/specfun/nchoosek.m octave-3.8.2/scripts/general/flipud.m octave-3.8.2/scripts/general/quadl.m octave-3.8.2/scripts/general/bitcmp.m octave-3.8.2/scripts/general/cart2pol.m octave-3.8.2/scripts/general/int2str.m octave-3.8.2/scripts/general/accumarray.m octave-3.8.2/scripts/general/narginchk.m octave-3.8.2/scripts/general/profile.m octave-3.8.2/scripts/general/flipdim.m octave-3.8.2/scripts/general/nargoutchk.m octave-3.8.2/scripts/general/chop.m octave-3.8.2/scripts/general/issquare.m octave-3.8.2/scripts/general/deal.m octave-3.8.2/scripts/general/isrow.m octave-3.8.2/scripts/general/fliplr.m octave-3.8.2/scripts/general/cplxpair.m octave-3.8.2/scripts/general/fieldnames.m octave-3.8.2/scripts/general/circshift.m octave-3.8.2/scripts/general/quadgk.m octave-3.8.2/scripts/general/trapz.m octave-3.8.2/scripts/general/rotdim.m octave-3.8.2/scripts/general/isequaln.m octave-3.8.2/scripts/general/sph2cart.m octave-3.8.2/scripts/general/profshow.m octave-3.8.2/scripts/general/quadv.m octave-3.8.2/scripts/general/num2str.m octave-3.8.2/scripts/general/blkdiag.m octave-3.8.2/scripts/general/del2.m octave-3.8.2/scripts/general/bincoeff.m octave-3.8.2/scripts/general/loadobj.m octave-3.8.2/scripts/general/rat.m octave-3.8.2/scripts/general/interp3.m octave-3.8.2/scripts/general/private/__isequal__.m octave-3.8.2/scripts/general/private/__splinen__.m octave-3.8.2/scripts/general/nextpow2.m octave-3.8.2/scripts/general/polyarea.m octave-3.8.2/scripts/general/logspace.m octave-3.8.2/scripts/general/interpft.m octave-3.8.2/scripts/general/isa.m octave-3.8.2/scripts/general/methods.m octave-3.8.2/scripts/general/pol2cart.m octave-3.8.2/scripts/general/isvector.m octave-3.8.2/scripts/general/interpn.m octave-3.8.2/scripts/general/bitset.m octave-3.8.2/scripts/general/saveobj.m octave-3.8.2/scripts/general/iscolumn.m octave-3.8.2/scripts/general/celldisp.m octave-3.8.2/scripts/general/common_size.m octave-3.8.2/scripts/general/shiftdim.m octave-3.8.2/scripts/general/postpad.m octave-3.8.2/scripts/general/idivide.m octave-3.8.2/scripts/general/nthargout.m octave-3.8.2/scripts/general/display.m octave-3.8.2/scripts/general/bicubic.m octave-3.8.2/scripts/general/dblquad.m octave-3.8.2/scripts/general/interp1.m octave-3.8.2/scripts/general/accumdim.m octave-3.8.2/scripts/general/cumtrapz.m octave-3.8.2/scripts/general/structfun.m octave-3.8.2/scripts/general/shift.m octave-3.8.2/scripts/general/sortrows.m octave-3.8.2/scripts/general/nargchk.m octave-3.8.2/scripts/general/curl.m octave-3.8.2/scripts/general/divergence.m octave-3.8.2/scripts/general/triplequad.m octave-3.8.2/scripts/general/subsindex.m octave-3.8.2/scripts/general/prepad.m octave-3.8.2/scripts/general/isdir.m octave-3.8.2/scripts/general/isequal.m octave-3.8.2/scripts/general/cart2sph.m octave-3.8.2/scripts/general/rot90.m octave-3.8.2/scripts/general/bitget.m octave-3.8.2/scripts/general/profexplore.m octave-3.8.2/scripts/general/cell2mat.m octave-3.8.2/scripts/general/isscalar.m octave-3.8.2/scripts/general/gradient.m octave-3.8.2/scripts/general/interp2.m octave-3.8.2/scripts/general/repmat.m octave-3.8.2/scripts/general/randi.m octave-3.8.2/scripts/audio/record.m octave-3.8.2/scripts/audio/wavwrite.m octave-3.8.2/scripts/audio/mu2lin.m octave-3.8.2/scripts/audio/loadaudio.m octave-3.8.2/scripts/audio/saveaudio.m octave-3.8.2/scripts/audio/wavread.m octave-3.8.2/scripts/audio/playaudio.m octave-3.8.2/scripts/audio/lin2mu.m octave-3.8.2/scripts/audio/setaudio.m octave-3.8.2/scripts/io/textread.m octave-3.8.2/scripts/io/importdata.m octave-3.8.2/scripts/io/csvread.m octave-3.8.2/scripts/io/csvwrite.m octave-3.8.2/scripts/io/strread.m octave-3.8.2/scripts/io/is_valid_file_id.m octave-3.8.2/scripts/io/fileread.m octave-3.8.2/scripts/io/beep.m octave-3.8.2/scripts/io/dlmwrite.m octave-3.8.2/scripts/io/textscan.m octave-3.8.2/scripts/plot/draw/ezcontourf.m octave-3.8.2/scripts/plot/draw/fill.m octave-3.8.2/scripts/plot/draw/surfnorm.m octave-3.8.2/scripts/plot/draw/scatter3.m octave-3.8.2/scripts/plot/draw/meshc.m octave-3.8.2/scripts/plot/draw/fplot.m octave-3.8.2/scripts/plot/draw/contour.m octave-3.8.2/scripts/plot/draw/semilogyerr.m octave-3.8.2/scripts/plot/draw/loglog.m octave-3.8.2/scripts/plot/draw/semilogy.m octave-3.8.2/scripts/plot/draw/loglogerr.m octave-3.8.2/scripts/plot/draw/slice.m octave-3.8.2/scripts/plot/draw/ezplot3.m octave-3.8.2/scripts/plot/draw/surface.m octave-3.8.2/scripts/plot/draw/scatter.m octave-3.8.2/scripts/plot/draw/pie.m octave-3.8.2/scripts/plot/draw/ezcontour.m octave-3.8.2/scripts/plot/draw/comet.m octave-3.8.2/scripts/plot/draw/surf.m octave-3.8.2/scripts/plot/draw/colorbar.m octave-3.8.2/scripts/plot/draw/stairs.m octave-3.8.2/scripts/plot/draw/semilogxerr.m octave-3.8.2/scripts/plot/draw/isonormals.m octave-3.8.2/scripts/plot/draw/ribbon.m octave-3.8.2/scripts/plot/draw/isosurface.m octave-3.8.2/scripts/plot/draw/ezmesh.m octave-3.8.2/scripts/plot/draw/patch.m octave-3.8.2/scripts/plot/draw/feather.m octave-3.8.2/scripts/plot/draw/surfc.m octave-3.8.2/scripts/plot/draw/pie3.m octave-3.8.2/scripts/plot/draw/private/__quiver__.m octave-3.8.2/scripts/plot/draw/private/__errcomm__.m octave-3.8.2/scripts/plot/draw/private/__errplot__.m octave-3.8.2/scripts/plot/draw/private/__add_datasource__.m octave-3.8.2/scripts/plot/draw/private/__ezplot__.m octave-3.8.2/scripts/plot/draw/private/__scatter__.m octave-3.8.2/scripts/plot/draw/private/__marching_cube__.m octave-3.8.2/scripts/plot/draw/private/__line__.m octave-3.8.2/scripts/plot/draw/private/__patch__.m octave-3.8.2/scripts/plot/draw/private/__contour__.m octave-3.8.2/scripts/plot/draw/private/__bar__.m octave-3.8.2/scripts/plot/draw/private/__plt__.m octave-3.8.2/scripts/plot/draw/private/__interp_cube__.m octave-3.8.2/scripts/plot/draw/private/__pie__.m octave-3.8.2/scripts/plot/draw/private/__stem__.m octave-3.8.2/scripts/plot/draw/stem.m octave-3.8.2/scripts/plot/draw/meshz.m octave-3.8.2/scripts/plot/draw/ezplot.m octave-3.8.2/scripts/plot/draw/sphere.m octave-3.8.2/scripts/plot/draw/plotyy.m octave-3.8.2/scripts/plot/draw/sombrero.m octave-3.8.2/scripts/plot/draw/peaks.m octave-3.8.2/scripts/plot/draw/surfl.m octave-3.8.2/scripts/plot/draw/pareto.m octave-3.8.2/scripts/plot/draw/pcolor.m octave-3.8.2/scripts/plot/draw/shrinkfaces.m octave-3.8.2/scripts/plot/draw/ezsurf.m octave-3.8.2/scripts/plot/draw/area.m octave-3.8.2/scripts/plot/draw/quiver3.m octave-3.8.2/scripts/plot/draw/comet3.m octave-3.8.2/scripts/plot/draw/triplot.m octave-3.8.2/scripts/plot/draw/ezsurfc.m octave-3.8.2/scripts/plot/draw/cylinder.m octave-3.8.2/scripts/plot/draw/barh.m octave-3.8.2/scripts/plot/draw/stem3.m octave-3.8.2/scripts/plot/draw/bar.m octave-3.8.2/scripts/plot/draw/ezmeshc.m octave-3.8.2/scripts/plot/draw/waterfall.m octave-3.8.2/scripts/plot/draw/rectangle.m octave-3.8.2/scripts/plot/draw/plot.m octave-3.8.2/scripts/plot/draw/tetramesh.m octave-3.8.2/scripts/plot/draw/plotmatrix.m octave-3.8.2/scripts/plot/draw/errorbar.m octave-3.8.2/scripts/plot/draw/isocolors.m octave-3.8.2/scripts/plot/draw/contourc.m octave-3.8.2/scripts/plot/draw/line.m octave-3.8.2/scripts/plot/draw/polar.m octave-3.8.2/scripts/plot/draw/trimesh.m octave-3.8.2/scripts/plot/draw/mesh.m octave-3.8.2/scripts/plot/draw/contourf.m octave-3.8.2/scripts/plot/draw/semilogx.m octave-3.8.2/scripts/plot/draw/plot3.m octave-3.8.2/scripts/plot/draw/hist.m octave-3.8.2/scripts/plot/draw/compass.m octave-3.8.2/scripts/plot/draw/ezpolar.m octave-3.8.2/scripts/plot/draw/ellipsoid.m octave-3.8.2/scripts/plot/draw/rose.m octave-3.8.2/scripts/plot/draw/quiver.m octave-3.8.2/scripts/plot/draw/trisurf.m octave-3.8.2/scripts/plot/draw/stemleaf.m octave-3.8.2/scripts/plot/draw/contour3.m octave-3.8.2/scripts/plot/util/subplot.m octave-3.8.2/scripts/plot/util/saveas.m octave-3.8.2/scripts/plot/util/gcbf.m octave-3.8.2/scripts/plot/util/__pltopt__.m octave-3.8.2/scripts/plot/util/allchild.m octave-3.8.2/scripts/plot/util/hggroup.m octave-3.8.2/scripts/plot/util/close.m octave-3.8.2/scripts/plot/util/ndgrid.m octave-3.8.2/scripts/plot/util/gca.m octave-3.8.2/scripts/plot/util/__next_line_color__.m octave-3.8.2/scripts/plot/util/graphics_toolkit.m octave-3.8.2/scripts/plot/util/struct2hdl.m octave-3.8.2/scripts/plot/util/refreshdata.m octave-3.8.2/scripts/plot/util/__plt_get_axis_arg__.m octave-3.8.2/scripts/plot/util/newplot.m octave-3.8.2/scripts/plot/util/ginput.m octave-3.8.2/scripts/plot/util/private/__go_draw_figure__.m octave-3.8.2/scripts/plot/util/private/__gnuplot_version__.m octave-3.8.2/scripts/plot/util/private/__gnuplot_has_terminal__.m octave-3.8.2/scripts/plot/util/private/__gnuplot_get_var__.m octave-3.8.2/scripts/plot/util/private/__print_parse_opts__.m octave-3.8.2/scripts/plot/util/private/__go_draw_axes__.m octave-3.8.2/scripts/plot/util/private/__gnuplot_open_stream__.m octave-3.8.2/scripts/plot/util/private/__ghostscript__.m octave-3.8.2/scripts/plot/util/private/__tight_eps_bbox__.m octave-3.8.2/scripts/plot/util/private/__add_default_menu__.m octave-3.8.2/scripts/plot/util/private/__fltk_print__.m octave-3.8.2/scripts/plot/util/private/__fltk_ginput__.m octave-3.8.2/scripts/plot/util/private/__gnuplot_print__.m octave-3.8.2/scripts/plot/util/private/__gnuplot_ginput__.m octave-3.8.2/scripts/plot/util/private/__gnuplot_has_feature__.m octave-3.8.2/scripts/plot/util/gnuplot_binary.m octave-3.8.2/scripts/plot/util/ancestor.m octave-3.8.2/scripts/plot/util/isprop.m octave-3.8.2/scripts/plot/util/ishold.m octave-3.8.2/scripts/plot/util/print.m octave-3.8.2/scripts/plot/util/colstyle.m octave-3.8.2/scripts/plot/util/__default_plot_options__.m octave-3.8.2/scripts/plot/util/isaxes.m octave-3.8.2/scripts/plot/util/printd.m octave-3.8.2/scripts/plot/util/shg.m octave-3.8.2/scripts/plot/util/hold.m octave-3.8.2/scripts/plot/util/gco.m octave-3.8.2/scripts/plot/util/findall.m octave-3.8.2/scripts/plot/util/closereq.m octave-3.8.2/scripts/plot/util/isfigure.m octave-3.8.2/scripts/plot/util/linkprop.m octave-3.8.2/scripts/plot/util/__gnuplot_drawnow__.m octave-3.8.2/scripts/plot/util/ishghandle.m octave-3.8.2/scripts/plot/util/axes.m octave-3.8.2/scripts/plot/util/clf.m octave-3.8.2/scripts/plot/util/refresh.m octave-3.8.2/scripts/plot/util/cla.m octave-3.8.2/scripts/plot/util/findobj.m octave-3.8.2/scripts/plot/util/copyobj.m octave-3.8.2/scripts/plot/util/meshgrid.m octave-3.8.2/scripts/plot/util/__next_line_style__.m octave-3.8.2/scripts/plot/util/figure.m octave-3.8.2/scripts/plot/util/hdl2struct.m octave-3.8.2/scripts/plot/util/findfigs.m octave-3.8.2/scripts/plot/util/__actual_axis_position__.m octave-3.8.2/scripts/plot/util/gcf.m octave-3.8.2/scripts/plot/util/gcbo.m octave-3.8.2/scripts/plot/appearance/pbaspect.m octave-3.8.2/scripts/plot/appearance/ylim.m octave-3.8.2/scripts/plot/appearance/box.m octave-3.8.2/scripts/plot/appearance/axis.m octave-3.8.2/scripts/plot/appearance/zlabel.m octave-3.8.2/scripts/plot/appearance/xlim.m octave-3.8.2/scripts/plot/appearance/view.m octave-3.8.2/scripts/plot/appearance/private/__axis_limits__.m octave-3.8.2/scripts/plot/appearance/private/__axis_label__.m octave-3.8.2/scripts/plot/appearance/shading.m octave-3.8.2/scripts/plot/appearance/caxis.m octave-3.8.2/scripts/plot/appearance/specular.m octave-3.8.2/scripts/plot/appearance/gtext.m octave-3.8.2/scripts/plot/appearance/grid.m octave-3.8.2/scripts/plot/appearance/orient.m octave-3.8.2/scripts/plot/appearance/datetick.m octave-3.8.2/scripts/plot/appearance/zlim.m octave-3.8.2/scripts/plot/appearance/__clabel__.m octave-3.8.2/scripts/plot/appearance/daspect.m octave-3.8.2/scripts/plot/appearance/__getlegenddata__.m octave-3.8.2/scripts/plot/appearance/diffuse.m octave-3.8.2/scripts/plot/appearance/ylabel.m octave-3.8.2/scripts/plot/appearance/xlabel.m octave-3.8.2/scripts/plot/appearance/hidden.m octave-3.8.2/scripts/plot/appearance/legend.m octave-3.8.2/scripts/plot/appearance/title.m octave-3.8.2/scripts/plot/appearance/text.m octave-3.8.2/scripts/plot/appearance/clabel.m octave-3.8.2/scripts/plot/appearance/whitebg.m octave-3.8.2/scripts/@ftp/close.m octave-3.8.2/scripts/@ftp/ftp.m octave-3.8.2/scripts/@ftp/dir.m octave-3.8.2/scripts/@ftp/loadobj.m octave-3.8.2/scripts/@ftp/delete.m octave-3.8.2/scripts/@ftp/mkdir.m octave-3.8.2/scripts/@ftp/saveobj.m octave-3.8.2/scripts/@ftp/ascii.m octave-3.8.2/scripts/@ftp/rmdir.m octave-3.8.2/scripts/@ftp/display.m octave-3.8.2/scripts/@ftp/mget.m octave-3.8.2/scripts/@ftp/binary.m octave-3.8.2/scripts/@ftp/cd.m octave-3.8.2/scripts/@ftp/rename.m octave-3.8.2/scripts/@ftp/mput.m octave-3.8.2/scripts/prefs/setpref.m octave-3.8.2/scripts/prefs/preferences.m octave-3.8.2/scripts/prefs/prefdir.m octave-3.8.2/scripts/prefs/private/loadprefs.m octave-3.8.2/scripts/prefs/private/saveprefs.m octave-3.8.2/scripts/prefs/private/prefsfile.m octave-3.8.2/scripts/prefs/addpref.m octave-3.8.2/scripts/prefs/ispref.m octave-3.8.2/scripts/prefs/rmpref.m octave-3.8.2/scripts/prefs/getpref.m octave-3.8.2/scripts/gui/guidata.m octave-3.8.2/scripts/gui/uiputfile.m octave-3.8.2/scripts/gui/errordlg.m octave-3.8.2/scripts/gui/questdlg.m octave-3.8.2/scripts/gui/uiresume.m octave-3.8.2/scripts/gui/listdlg.m octave-3.8.2/scripts/gui/uiwait.m octave-3.8.2/scripts/gui/waitforbuttonpress.m octave-3.8.2/scripts/gui/uipanel.m octave-3.8.2/scripts/gui/uigetfile.m octave-3.8.2/scripts/gui/private/__uiputfile_fltk__.m octave-3.8.2/scripts/gui/private/__uigetfile_fltk__.m octave-3.8.2/scripts/gui/private/__file_filter__.m octave-3.8.2/scripts/gui/private/message_dialog.m octave-3.8.2/scripts/gui/private/__uigetdir_fltk__.m octave-3.8.2/scripts/gui/private/__fltk_file_filter__.m octave-3.8.2/scripts/gui/private/__uiobject_split_args__.m octave-3.8.2/scripts/gui/private/__is_function__.m octave-3.8.2/scripts/gui/helpdlg.m octave-3.8.2/scripts/gui/uitoolbar.m octave-3.8.2/scripts/gui/uigetdir.m octave-3.8.2/scripts/gui/warndlg.m octave-3.8.2/scripts/gui/uitoggletool.m octave-3.8.2/scripts/gui/uicontextmenu.m octave-3.8.2/scripts/gui/waitbar.m octave-3.8.2/scripts/gui/uicontrol.m octave-3.8.2/scripts/gui/uimenu.m octave-3.8.2/scripts/gui/inputdlg.m octave-3.8.2/scripts/gui/guihandles.m octave-3.8.2/scripts/gui/msgbox.m octave-3.8.2/scripts/gui/uipushtool.m octave-3.8.2/scripts/strings/findstr.m octave-3.8.2/scripts/strings/deblank.m octave-3.8.2/scripts/strings/base2dec.m octave-3.8.2/scripts/strings/strcat.m octave-3.8.2/scripts/strings/dec2hex.m octave-3.8.2/scripts/strings/strtrunc.m octave-3.8.2/scripts/strings/strchr.m octave-3.8.2/scripts/strings/strjust.m octave-3.8.2/scripts/strings/strjoin.m octave-3.8.2/scripts/strings/dec2bin.m octave-3.8.2/scripts/strings/cstrcat.m octave-3.8.2/scripts/strings/regexptranslate.m octave-3.8.2/scripts/strings/strtok.m octave-3.8.2/scripts/strings/blanks.m octave-3.8.2/scripts/strings/validatestring.m octave-3.8.2/scripts/strings/bin2dec.m octave-3.8.2/scripts/strings/isstrprop.m octave-3.8.2/scripts/strings/dec2base.m octave-3.8.2/scripts/strings/untabify.m octave-3.8.2/scripts/strings/str2num.m octave-3.8.2/scripts/strings/substr.m octave-3.8.2/scripts/strings/strmatch.m octave-3.8.2/scripts/strings/strsplit.m octave-3.8.2/scripts/strings/rindex.m octave-3.8.2/scripts/strings/mat2str.m octave-3.8.2/scripts/strings/strtrim.m octave-3.8.2/scripts/strings/hex2dec.m octave-3.8.2/scripts/strings/ostrsplit.m octave-3.8.2/scripts/strings/isletter.m octave-3.8.2/scripts/strings/index.m octave-3.8.2/scripts/help/type.m octave-3.8.2/scripts/help/help.m octave-3.8.2/scripts/help/__makeinfo__.m octave-3.8.2/scripts/help/print_usage.m octave-3.8.2/scripts/help/lookfor.m octave-3.8.2/scripts/help/private/__additional_help_message__.m octave-3.8.2/scripts/help/private/__strip_html_tags__.m octave-3.8.2/scripts/help/doc_cache_create.m octave-3.8.2/scripts/help/doc.m octave-3.8.2/scripts/help/__gripe_missing_component__.m octave-3.8.2/scripts/help/which.m octave-3.8.2/scripts/help/get_first_help_sentence.m octave-3.8.2/scripts/help/__unimplemented__.m octave-3.8.2/scripts/linear-algebra/logm.m octave-3.8.2/scripts/linear-algebra/null.m octave-3.8.2/scripts/linear-algebra/subspace.m octave-3.8.2/scripts/linear-algebra/rank.m octave-3.8.2/scripts/linear-algebra/krylov.m octave-3.8.2/scripts/linear-algebra/trace.m octave-3.8.2/scripts/linear-algebra/onenormest.m octave-3.8.2/scripts/linear-algebra/condest.m octave-3.8.2/scripts/linear-algebra/vech.m octave-3.8.2/scripts/linear-algebra/normest.m octave-3.8.2/scripts/linear-algebra/isdefinite.m octave-3.8.2/scripts/linear-algebra/expm.m octave-3.8.2/scripts/linear-algebra/cond.m octave-3.8.2/scripts/linear-algebra/planerot.m octave-3.8.2/scripts/linear-algebra/commutation_matrix.m octave-3.8.2/scripts/linear-algebra/qzhess.m octave-3.8.2/scripts/linear-algebra/orth.m octave-3.8.2/scripts/linear-algebra/rref.m octave-3.8.2/scripts/linear-algebra/linsolve.m octave-3.8.2/scripts/linear-algebra/housh.m octave-3.8.2/scripts/linear-algebra/duplication_matrix.m octave-3.8.2/scripts/linear-algebra/issymmetric.m octave-3.8.2/scripts/linear-algebra/cross.m octave-3.8.2/scripts/linear-algebra/ishermitian.m octave-3.8.2/scripts/special-matrix/pascal.m octave-3.8.2/scripts/special-matrix/wilkinson.m octave-3.8.2/scripts/special-matrix/vander.m octave-3.8.2/scripts/special-matrix/magic.m octave-3.8.2/scripts/special-matrix/gallery.m octave-3.8.2/scripts/special-matrix/rosser.m octave-3.8.2/scripts/special-matrix/hilb.m octave-3.8.2/scripts/special-matrix/hankel.m octave-3.8.2/scripts/special-matrix/toeplitz.m octave-3.8.2/scripts/special-matrix/hadamard.m octave-3.8.2/scripts/special-matrix/invhilb.m octave-3.8.2/scripts/java/java_set.m octave-3.8.2/scripts/java/java_get.m octave-3.8.2/scripts/java/javaArray.m octave-3.8.2/scripts/java/javarmpath.m octave-3.8.2/scripts/java/javaclasspath.m octave-3.8.2/scripts/java/javamem.m octave-3.8.2/scripts/java/javaaddpath.m octave-3.8.2/scripts/java/usejava.m octave-3.8.2/scripts/geometry/griddata.m octave-3.8.2/scripts/geometry/delaunay3.m octave-3.8.2/scripts/geometry/convhull.m octave-3.8.2/scripts/geometry/delaunayn.m octave-3.8.2/scripts/geometry/voronoi.m octave-3.8.2/scripts/geometry/rectint.m octave-3.8.2/scripts/geometry/griddata3.m octave-3.8.2/scripts/geometry/dsearch.m octave-3.8.2/scripts/geometry/inpolygon.m octave-3.8.2/scripts/geometry/griddatan.m octave-3.8.2/scripts/geometry/voronoin.m octave-3.8.2/scripts/geometry/tsearchn.m octave-3.8.2/scripts/geometry/dsearchn.m octave-3.8.2/scripts/geometry/delaunay.m octave-3.8.2/scripts/time/ctime.m octave-3.8.2/scripts/time/is_leap_year.m octave-3.8.2/scripts/time/datenum.m octave-3.8.2/scripts/time/calendar.m octave-3.8.2/scripts/time/asctime.m octave-3.8.2/scripts/time/eomday.m octave-3.8.2/scripts/time/clock.m octave-3.8.2/scripts/time/date.m octave-3.8.2/scripts/time/datevec.m octave-3.8.2/scripts/time/addtodate.m octave-3.8.2/scripts/time/etime.m octave-3.8.2/scripts/time/now.m octave-3.8.2/scripts/time/weekday.m octave-3.8.2/scripts/time/datestr.m octave-3.8.2/scripts/miscellaneous/swapbytes.m octave-3.8.2/scripts/miscellaneous/perl.m octave-3.8.2/scripts/miscellaneous/cast.m octave-3.8.2/scripts/miscellaneous/paren.m octave-3.8.2/scripts/miscellaneous/dump_prefs.m octave-3.8.2/scripts/miscellaneous/ans.m octave-3.8.2/scripts/miscellaneous/copyfile.m octave-3.8.2/scripts/miscellaneous/substruct.m octave-3.8.2/scripts/miscellaneous/zip.m octave-3.8.2/scripts/miscellaneous/ver.m octave-3.8.2/scripts/miscellaneous/semicolon.m octave-3.8.2/scripts/miscellaneous/tar.m octave-3.8.2/scripts/miscellaneous/fileattrib.m octave-3.8.2/scripts/miscellaneous/setappdata.m octave-3.8.2/scripts/miscellaneous/fileparts.m octave-3.8.2/scripts/miscellaneous/dir.m octave-3.8.2/scripts/miscellaneous/unzip.m octave-3.8.2/scripts/miscellaneous/dos.m octave-3.8.2/scripts/miscellaneous/fact.m octave-3.8.2/scripts/miscellaneous/movefile.m octave-3.8.2/scripts/miscellaneous/orderfields.m octave-3.8.2/scripts/miscellaneous/license.m octave-3.8.2/scripts/miscellaneous/version.m octave-3.8.2/scripts/miscellaneous/gzip.m octave-3.8.2/scripts/miscellaneous/menu.m octave-3.8.2/scripts/miscellaneous/what.m octave-3.8.2/scripts/miscellaneous/run.m octave-3.8.2/scripts/miscellaneous/recycle.m octave-3.8.2/scripts/miscellaneous/mkoctfile.m octave-3.8.2/scripts/miscellaneous/gunzip.m octave-3.8.2/scripts/miscellaneous/private/display_info_file.m octave-3.8.2/scripts/miscellaneous/private/__xzip__.m octave-3.8.2/scripts/miscellaneous/tempdir.m octave-3.8.2/scripts/miscellaneous/citation.m octave-3.8.2/scripts/miscellaneous/isappdata.m octave-3.8.2/scripts/miscellaneous/fullfile.m octave-3.8.2/scripts/miscellaneous/info.m octave-3.8.2/scripts/miscellaneous/bug_report.m octave-3.8.2/scripts/miscellaneous/ls.m octave-3.8.2/scripts/miscellaneous/delete.m octave-3.8.2/scripts/miscellaneous/news.m octave-3.8.2/scripts/miscellaneous/desktop.m octave-3.8.2/scripts/miscellaneous/ispc.m octave-3.8.2/scripts/miscellaneous/tempname.m octave-3.8.2/scripts/miscellaneous/compare_versions.m octave-3.8.2/scripts/miscellaneous/rmappdata.m octave-3.8.2/scripts/miscellaneous/unpack.m octave-3.8.2/scripts/miscellaneous/isunix.m octave-3.8.2/scripts/miscellaneous/getfield.m octave-3.8.2/scripts/miscellaneous/mexext.m octave-3.8.2/scripts/miscellaneous/ismac.m octave-3.8.2/scripts/miscellaneous/warning_ids.m octave-3.8.2/scripts/miscellaneous/error_ids.m octave-3.8.2/scripts/miscellaneous/debug.m octave-3.8.2/scripts/miscellaneous/pack.m octave-3.8.2/scripts/miscellaneous/unix.m octave-3.8.2/scripts/miscellaneous/edit.m octave-3.8.2/scripts/miscellaneous/isdeployed.m octave-3.8.2/scripts/miscellaneous/colon.m octave-3.8.2/scripts/miscellaneous/getappdata.m octave-3.8.2/scripts/miscellaneous/bunzip2.m octave-3.8.2/scripts/miscellaneous/xor.m octave-3.8.2/scripts/miscellaneous/untar.m octave-3.8.2/scripts/miscellaneous/inputname.m octave-3.8.2/scripts/miscellaneous/genvarname.m octave-3.8.2/scripts/miscellaneous/python.m octave-3.8.2/scripts/miscellaneous/computer.m octave-3.8.2/scripts/miscellaneous/setfield.m octave-3.8.2/scripts/miscellaneous/comma.m octave-3.8.2/scripts/miscellaneous/list_primes.m octave-3.8.2/scripts/miscellaneous/bzip2.m octave-3.8.2/scripts/miscellaneous/symvar.m octave-3.8.2/scripts/miscellaneous/ls_command.m octave-3.8.2/scripts/miscellaneous/parseparams.m octave-3.8.2/scripts/miscellaneous/namelengthmax.m octave-3.8.2/scripts/miscellaneous/mex.m octave-3.8.2/scripts/path/matlabroot.m octave-3.8.2/scripts/path/pathdef.m octave-3.8.2/scripts/path/savepath.m octave-3.8.2/scripts/startup/__finish__.m octave-3.8.2/scripts/statistics/distributions/unifinv.m octave-3.8.2/scripts/statistics/distributions/norminv.m octave-3.8.2/scripts/statistics/distributions/nbincdf.m octave-3.8.2/scripts/statistics/distributions/finv.m octave-3.8.2/scripts/statistics/distributions/expcdf.m octave-3.8.2/scripts/statistics/distributions/stdnormal_inv.m octave-3.8.2/scripts/statistics/distributions/tcdf.m octave-3.8.2/scripts/statistics/distributions/binocdf.m octave-3.8.2/scripts/statistics/distributions/betarnd.m octave-3.8.2/scripts/statistics/distributions/discrete_pdf.m octave-3.8.2/scripts/statistics/distributions/logistic_inv.m octave-3.8.2/scripts/statistics/distributions/wblcdf.m octave-3.8.2/scripts/statistics/distributions/wblrnd.m octave-3.8.2/scripts/statistics/distributions/poissrnd.m octave-3.8.2/scripts/statistics/distributions/laplace_rnd.m octave-3.8.2/scripts/statistics/distributions/cauchy_inv.m octave-3.8.2/scripts/statistics/distributions/poisscdf.m octave-3.8.2/scripts/statistics/distributions/logistic_pdf.m octave-3.8.2/scripts/statistics/distributions/hygeinv.m octave-3.8.2/scripts/statistics/distributions/binoinv.m octave-3.8.2/scripts/statistics/distributions/laplace_cdf.m octave-3.8.2/scripts/statistics/distributions/expinv.m octave-3.8.2/scripts/statistics/distributions/stdnormal_rnd.m octave-3.8.2/scripts/statistics/distributions/cauchy_cdf.m octave-3.8.2/scripts/statistics/distributions/wienrnd.m octave-3.8.2/scripts/statistics/distributions/unidcdf.m octave-3.8.2/scripts/statistics/distributions/tinv.m octave-3.8.2/scripts/statistics/distributions/unidinv.m octave-3.8.2/scripts/statistics/distributions/lognpdf.m octave-3.8.2/scripts/statistics/distributions/unifpdf.m octave-3.8.2/scripts/statistics/distributions/betapdf.m octave-3.8.2/scripts/statistics/distributions/binornd.m octave-3.8.2/scripts/statistics/distributions/stdnormal_pdf.m octave-3.8.2/scripts/statistics/distributions/logninv.m octave-3.8.2/scripts/statistics/distributions/trnd.m octave-3.8.2/scripts/statistics/distributions/gampdf.m octave-3.8.2/scripts/statistics/distributions/logncdf.m octave-3.8.2/scripts/statistics/distributions/poissinv.m octave-3.8.2/scripts/statistics/distributions/chi2cdf.m octave-3.8.2/scripts/statistics/distributions/normrnd.m octave-3.8.2/scripts/statistics/distributions/gamrnd.m octave-3.8.2/scripts/statistics/distributions/normpdf.m octave-3.8.2/scripts/statistics/distributions/normcdf.m octave-3.8.2/scripts/statistics/distributions/fpdf.m octave-3.8.2/scripts/statistics/distributions/betacdf.m octave-3.8.2/scripts/statistics/distributions/lognrnd.m octave-3.8.2/scripts/statistics/distributions/logistic_rnd.m octave-3.8.2/scripts/statistics/distributions/empirical_cdf.m octave-3.8.2/scripts/statistics/distributions/exprnd.m octave-3.8.2/scripts/statistics/distributions/wblpdf.m octave-3.8.2/scripts/statistics/distributions/poisspdf.m octave-3.8.2/scripts/statistics/distributions/geopdf.m octave-3.8.2/scripts/statistics/distributions/hygecdf.m octave-3.8.2/scripts/statistics/distributions/chi2pdf.m octave-3.8.2/scripts/statistics/distributions/laplace_inv.m octave-3.8.2/scripts/statistics/distributions/nbinrnd.m octave-3.8.2/scripts/statistics/distributions/empirical_inv.m octave-3.8.2/scripts/statistics/distributions/tpdf.m octave-3.8.2/scripts/statistics/distributions/geoinv.m octave-3.8.2/scripts/statistics/distributions/gaminv.m octave-3.8.2/scripts/statistics/distributions/wblinv.m octave-3.8.2/scripts/statistics/distributions/cauchy_rnd.m octave-3.8.2/scripts/statistics/distributions/unidrnd.m octave-3.8.2/scripts/statistics/distributions/betainv.m octave-3.8.2/scripts/statistics/distributions/nbinpdf.m octave-3.8.2/scripts/statistics/distributions/unifrnd.m octave-3.8.2/scripts/statistics/distributions/frnd.m octave-3.8.2/scripts/statistics/distributions/chi2inv.m octave-3.8.2/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m octave-3.8.2/scripts/statistics/distributions/logistic_cdf.m octave-3.8.2/scripts/statistics/distributions/hygepdf.m octave-3.8.2/scripts/statistics/distributions/exppdf.m octave-3.8.2/scripts/statistics/distributions/geocdf.m octave-3.8.2/scripts/statistics/distributions/unifcdf.m octave-3.8.2/scripts/statistics/distributions/laplace_pdf.m octave-3.8.2/scripts/statistics/distributions/nbininv.m octave-3.8.2/scripts/statistics/distributions/empirical_rnd.m octave-3.8.2/scripts/statistics/distributions/empirical_pdf.m octave-3.8.2/scripts/statistics/distributions/binopdf.m octave-3.8.2/scripts/statistics/distributions/discrete_inv.m octave-3.8.2/scripts/statistics/distributions/cauchy_pdf.m octave-3.8.2/scripts/statistics/distributions/hygernd.m octave-3.8.2/scripts/statistics/distributions/geornd.m octave-3.8.2/scripts/statistics/distributions/unidpdf.m octave-3.8.2/scripts/statistics/distributions/stdnormal_cdf.m octave-3.8.2/scripts/statistics/distributions/gamcdf.m octave-3.8.2/scripts/statistics/distributions/discrete_rnd.m octave-3.8.2/scripts/statistics/distributions/chi2rnd.m octave-3.8.2/scripts/statistics/distributions/discrete_cdf.m octave-3.8.2/scripts/statistics/distributions/fcdf.m octave-3.8.2/scripts/statistics/models/private/logistic_regression_derivatives.m octave-3.8.2/scripts/statistics/models/private/logistic_regression_likelihood.m octave-3.8.2/scripts/statistics/models/logistic_regression.m octave-3.8.2/scripts/statistics/tests/manova.m octave-3.8.2/scripts/statistics/tests/prop_test_2.m octave-3.8.2/scripts/statistics/tests/wilcoxon_test.m octave-3.8.2/scripts/statistics/tests/cor_test.m octave-3.8.2/scripts/statistics/tests/chisquare_test_homogeneity.m octave-3.8.2/scripts/statistics/tests/z_test_2.m octave-3.8.2/scripts/statistics/tests/mcnemar_test.m octave-3.8.2/scripts/statistics/tests/z_test.m octave-3.8.2/scripts/statistics/tests/welch_test.m octave-3.8.2/scripts/statistics/tests/t_test_2.m octave-3.8.2/scripts/statistics/tests/anova.m octave-3.8.2/scripts/statistics/tests/var_test.m octave-3.8.2/scripts/statistics/tests/kolmogorov_smirnov_test_2.m octave-3.8.2/scripts/statistics/tests/u_test.m octave-3.8.2/scripts/statistics/tests/hotelling_test.m octave-3.8.2/scripts/statistics/tests/kolmogorov_smirnov_test.m octave-3.8.2/scripts/statistics/tests/t_test.m octave-3.8.2/scripts/statistics/tests/f_test_regression.m octave-3.8.2/scripts/statistics/tests/kruskal_wallis_test.m octave-3.8.2/scripts/statistics/tests/hotelling_test_2.m octave-3.8.2/scripts/statistics/tests/bartlett_test.m octave-3.8.2/scripts/statistics/tests/t_test_regression.m octave-3.8.2/scripts/statistics/tests/chisquare_test_independence.m octave-3.8.2/scripts/statistics/tests/sign_test.m octave-3.8.2/scripts/statistics/tests/run_test.m octave-3.8.2/scripts/statistics/base/zscore.m octave-3.8.2/scripts/statistics/base/corr.m octave-3.8.2/scripts/statistics/base/prctile.m octave-3.8.2/scripts/statistics/base/meansq.m octave-3.8.2/scripts/statistics/base/ranks.m octave-3.8.2/scripts/statistics/base/statistics.m octave-3.8.2/scripts/statistics/base/kendall.m octave-3.8.2/scripts/statistics/base/table.m octave-3.8.2/scripts/statistics/base/probit.m octave-3.8.2/scripts/statistics/base/median.m octave-3.8.2/scripts/statistics/base/iqr.m octave-3.8.2/scripts/statistics/base/qqplot.m octave-3.8.2/scripts/statistics/base/cloglog.m octave-3.8.2/scripts/statistics/base/kurtosis.m octave-3.8.2/scripts/statistics/base/skewness.m octave-3.8.2/scripts/statistics/base/ppplot.m octave-3.8.2/scripts/statistics/base/moment.m octave-3.8.2/scripts/statistics/base/ols.m octave-3.8.2/scripts/statistics/base/runlength.m octave-3.8.2/scripts/statistics/base/cov.m octave-3.8.2/scripts/statistics/base/mode.m octave-3.8.2/scripts/statistics/base/logit.m octave-3.8.2/scripts/statistics/base/spearman.m octave-3.8.2/scripts/statistics/base/range.m octave-3.8.2/scripts/statistics/base/center.m octave-3.8.2/scripts/statistics/base/gls.m octave-3.8.2/scripts/statistics/base/histc.m octave-3.8.2/scripts/statistics/base/var.m octave-3.8.2/scripts/statistics/base/run_count.m octave-3.8.2/scripts/statistics/base/quantile.m octave-3.8.2/scripts/statistics/base/mean.m octave-3.8.2/scripts/statistics/base/std.m octave-3.8.2/scripts/statistics/base/mahalanobis.m octave-3.8.2/scripts/deprecated/cut.m octave-3.8.2/scripts/deprecated/polyderiv.m octave-3.8.2/scripts/deprecated/java_debug.m octave-3.8.2/scripts/deprecated/gen_doc_cache.m octave-3.8.2/scripts/deprecated/interp1q.m octave-3.8.2/scripts/deprecated/java_unsigned_conversion.m octave-3.8.2/scripts/deprecated/__error_text__.m octave-3.8.2/scripts/deprecated/default_save_options.m octave-3.8.2/scripts/deprecated/java_invoke.m octave-3.8.2/scripts/deprecated/cor.m octave-3.8.2/scripts/deprecated/re_read_readline_init_file.m octave-3.8.2/scripts/deprecated/studentize.m octave-3.8.2/scripts/deprecated/java_convert_matrix.m octave-3.8.2/scripts/deprecated/isstr.m octave-3.8.2/scripts/deprecated/shell_cmd.m octave-3.8.2/scripts/deprecated/isequalwithequalnans.m octave-3.8.2/scripts/deprecated/corrcoef.m octave-3.8.2/scripts/deprecated/read_readline_init_file.m octave-3.8.2/scripts/deprecated/sylvester_matrix.m octave-3.8.2/scripts/deprecated/error_text.m octave-3.8.2/scripts/deprecated/saving_history.m octave-3.8.2/scripts/deprecated/javamethods.m octave-3.8.2/scripts/deprecated/java_new.m octave-3.8.2/scripts/deprecated/javafields.m octave-3.8.2/scripts/testfun/fail.m octave-3.8.2/scripts/testfun/test.m octave-3.8.2/scripts/testfun/demo.m octave-3.8.2/scripts/testfun/__run_test_suite__.m octave-3.8.2/scripts/testfun/example.m octave-3.8.2/scripts/testfun/rundemos.m octave-3.8.2/scripts/testfun/assert.m octave-3.8.2/scripts/testfun/__prog_output_assert__.m octave-3.8.2/scripts/testfun/speed.m octave-3.8.2/scripts/testfun/__printf_assert__.m octave-3.8.2/scripts/testfun/__have_feature__.m octave-3.8.2/scripts/testfun/runtests.m

from __future__ import division
try:
    from runtime import *
except ImportError:
    from smop.runtime import *

def roots_(v=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[v].count(None)+len(args)

    if (nargin != 1 or (not isvector_(v) and not isempty_(v))):
        print_usage_()
    else:
        if (any_(not isfinite_(v))):
            error_(char('roots: inputs must not contain Inf or NaN'))
    v=v[:]
    n=numel_(v)
    v_max=max_(abs_(v))
    if (isempty_(v) or v_max == 0):
        r=matlabarray([])
        return r
    f=find_(v / v_max)
    m=numel_(f)
    v=v[f[1]:f[m]]
    l=numel_(v)
    if (l > 1):
        A=diag_(ones_(1,l - 2),- 1)
        A[1,:]=- v[2:l] / v[1]
        r=eig_(A)
        if (f[m] < n):
            r=matlabarray([[r],[zeros_(n - f[m],1)]])
    else:
        r=zeros_(n - f[m],1)
    return r
def ppint_(pp=None,c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[pp,c].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (not (isstruct_(pp) and strcmp_(pp.form,char('pp')))):
        error_(char('ppint: PP must be a structure'))
    x,p,n,k,d=unmkpp_(pp,nargout=5)
    p=reshape_(p,[],k)
    pi=p / diag_(arange_(k,1,- 1))
    k += 1
    if (nargin == 1):
        pi[:,k]=0
    else:
        pi[:,k]=repmat_(c[:],n,1)
    ppi=mkpp_(x,pi,d)
    tmp=- cumsum_(ppjumps_(ppi),length_(d) + 1)
    ppi.coefs[prod_(d) + 1:end(),k]=tmp[:]
    return ppi
def polyder_(p=None,a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[p,a].count(None)+len(args)

    if (nargin == 1 or nargin == 2):
        if (not isvector_(p)):
            error_(char('polyder: argument must be a vector'))
        if (nargin == 2):
            if (not isvector_(a)):
                error_(char('polyder: argument must be a vector'))
            if (nargout == 1):
                q=polyder_(conv_(p,a))
            else:
                d=conv_(a,a)
                if (numel_(p) == 1):
                    q=- p * polyder_(a)
                else:
                    if (numel_(a) == 1):
                        q=a * polyder_(p)
                    else:
                        q=conv_(polyder_(p),a) - conv_(p,polyder_(a))
                        q=polyreduce_(q)
                x=polygcd_(q,d)
                if (length_(x) != 1):
                    q=deconv_(q,x)
                    d=deconv_(d,x)
                q=q / d[1]
                d=d / d[1]
        else:
            lp=numel_(p)
            if (lp == 1):
                q=0
                return q,d
            else:
                if (lp == 0):
                    q=matlabarray([])
                    return q,d
            p=p[:].T
            q=p[1:(lp - 1)].dot([arange_((lp - 1),1,- 1)])
    else:
        print_usage_()
    return q,d
def spline_(x=None,y=None,xi=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,xi].count(None)+len(args)

    x=x[:]
    n=length_(x)
    if (n < 2):
        error_(char('spline: requires at least 2 points'))
    ndy=ndims_(y)
    szy=size_(y)
    if (ndy == 2 and (any_(szy == n) or any_(szy == n + 2))):
        if (szy[2] == n or szy[2] == n + 2):
            a=y.T
        else:
            a=copy_(y)
            szy=szy[[2,1]]
    else:
        a=shiftdim_(reshape_(y,[prod_(szy[1:end() - 1]),szy[end()]]),1)
    for k in (arange_(1,columns_(a)))(any_(isnan_(a))).reshape(-1):
        ok=not isnan_(a[:,k])
        a[not ok,k]=spline_(x[ok],a[ok,k],x[not ok])
    complete=copy_(false)
    if (rows_(a) == n + 2):
        complete=copy_(true)
        dfs=a[1,:]
        dfe=a[end(),:]
        a=a[2:end() - 1,:]
    if (not issorted_(x)):
        x,idx=sort_(x,nargout=2)
        a=a[idx,:]
    b=c=zeros_(size_(a))
    h=diff_(x)
    idx=ones_(columns_(a),1)
    if (complete):
        if (n == 2):
            d=(dfs + dfe) / (x[2] - x[1]) ** 2 + 2 * (a[1,:] - a[2,:]) / (x[2] - x[1]) ** 3
            c=(- 2 * dfs - dfe) / (x[2] - x[1]) - 3 * (a[1,:] - a[2,:]) / (x[2] - x[1]) ** 2
            b=copy_(dfs)
            a=a[1,:]
            d=d[1:n - 1,:]
            c=c[1:n - 1,:]
            b=b[1:n - 1,:]
            a=a[1:n - 1,:]
        else:
            g[1,:]=(a[2,:] - a[1,:]) / h[1] - dfs
            g[2:n - 1,:]=(a[3:n,:] - a[2:n - 1,:]) / h[2:n - 1] - (a[2:n - 1,:] - a[1:n - 2,:]) / h[1:n - 2]
            g[n,:]=dfe - (a[n,:] - a[n - 1,:]) / h[n - 1]
            c=numpy.linalg.solve(spdiags_([[[h / 6],[0]],[[h[1] / 3],[(h[1:n - 2] + h[2:n - 1]) / 3],[h[n - 1] / 3]],[[0],[h / 6]]],[- 1,0,1],n,n),(g / 2))
            b[1:n - 1,:]=diff_(a) / h[1:n - 1,idx] - h[1:n - 1,idx] / 3.dot((c[2:n,:] + 2 * c[1:n - 1,:]))
            d=diff_(c) / (3 * h[1:n - 1,idx])
            d=d[1:n - 1,:]
            c=c[1:n - 1,:]
            b=b[1:n - 1,:]
            a=a[1:n - 1,:]
    else:
        if (n == 2):
            b=(a[2,:] - a[1,:]) / (x[2] - x[1])
            a=a[1,:]
            d=matlabarray([])
            c=matlabarray([])
            b=b[1:n - 1,:]
            a=a[1:n - 1,:]
        else:
            if (n == 3):
                n=2
                c=(a[1,:] - a[3,:]) / ((x[3] - x[1]) * (x[2] - x[3])) + (a[2,:] - a[1,:]) / ((x[2] - x[1]) * (x[2] - x[3]))
                b=(a[2,:] - a[1,:]) * (x[3] - x[1]) / ((x[2] - x[1]) * (x[3] - x[2])) + (a[1,:] - a[3,:]) * (x[2] - x[1]) / ((x[3] - x[1]) * (x[3] - x[2]))
                a=a[1,:]
                d=matlabarray([])
                x=matlabarray([min_(x),max_(x)])
                c=c[1:n - 1,:]
                b=b[1:n - 1,:]
                a=a[1:n - 1,:]
            else:
                g=zeros_(n - 2,columns_(a))
                g[1,:]=3 / (h[1] + h[2]) * (a[3,:] - a[2,:] - h[2] / h[1] * (a[2,:] - a[1,:]))
                g[n - 2,:]=3 / (h[n - 1] + h[n - 2]) * (h[n - 2] / h[n - 1] * (a[n,:] - a[n - 1,:]) - (a[n - 1,:] - a[n - 2,:]))
                if (n > 4):
                    g[2:n - 3,:]=3 * diff_(a[3:n - 1,:]) / h[3:n - 2,idx] - 3 * diff_(a[2:n - 2,:]) / h[2:n - 3,idx]
                    dg=2 * (h[1:n - 2]+ h[2:n - 1])
                    dg[1]=dg[1] - h[1]
                    dg[n - 2]=dg[n - 2] - h[n - 1]
                    ldg=udg=h[2:n - 2]
                    udg[1]=udg[1] - h[1]
                    ldg[n - 3]=ldg[n - 3] - h[n - 1]
                    c[2:n - 1,:]=numpy.linalg.solve(spdiags_([[[ldg[:]],[0]],dg,[[0],[udg[:]]]],[- 1,0,1],n - 2,n - 2),g)
                else:
                    if (n == 4):
                        dg=matlabarray([[h[1] + 2 * h[2]],[2 * h[2] + h[3]]])
                        ldg=h[2] - h[3]
                        udg=h[2] - h[1]
                        c[2:n - 1,:]=numpy.linalg.solve(spdiags_([[[ldg[:]],[0]],dg,[[0],[udg[:]]]],[- 1,0,1],n - 2,n - 2),g)
                c[1,:]=c[2,:] + h[1] / h[2] * (c[2,:] - c[3,:])
                c[n,:]=c[n - 1,:] + h[n - 1] / h[n - 2] * (c[n - 1,:] - c[n - 2,:])
                b=diff_(a) / h[1:n - 1,idx] - h[1:n - 1,idx] / 3.dot((c[2:n,:] + 2 * c[1:n - 1,:]))
                d=diff_(c) / (3 * h[1:n - 1,idx])
                d=d[1:n - 1,:]
                d=d.T(arange_())
                c=c[1:n - 1,:]
                c=c.T(arange_())
                b=b[1:n - 1,:]
                b=b.T(arange_())
                a=a[1:n - 1,:]
                a=a.T(arange_())
    ret=mkpp_(x,cat_(2,d,c,b,a),szy[1:end() - 1])
    if (nargin == 3):
        ret=ppval_(ret,xi)
    return ret
def pchip_(x=None,y=None,xi=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,xi].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    x=x[:].T
    n=length_(x)
    if (isvector_(y)):
        y=y[:].T
        szy=size_(y)
        if (not size_equal_(x,y)):
            error_(char('pchip: length of X and Y must match'))
    else:
        szy=size_(y)
        if (n != szy[end()]):
            error_(char('pchip: length of X and last dimension of Y must match'))
        y=reshape_(y,[prod_(szy[1:end() - 1]),szy[end()]])
    h=diff_(x)
    if (all_(h < 0)):
        x=fliplr_(x)
        h=diff_(x)
        y=fliplr_(y)
    else:
        if (any_(h <= 0)):
            error_(char('pchip: X must be strictly monotonic'))
    f1=y[:,1:n - 1]
    d=__pchip_deriv___(x,y,2)
    d1=d[:,1:n - 1]
    d2=d[:,2:n]
    h=diag_(h)
    delta=diff_(y,1,2) / h
    del1=(d1 - delta) / h
    del2=(d2 - delta) / h
    c3=del1 + del2
    c2=- c3 - del1
    c3=c3 / h
    coeffs=cat_(3,c3,c2,d1,f1)
    ret=mkpp_(x,coeffs,szy[1:end() - 1])
    if (nargin == 3):
        ret=ppval_(ret,xi)
    return ret
def polygcd_(b=None,a=None,tol=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[b,a,tol].count(None)+len(args)

    if (nargin == 2 or nargin == 3):
        if (nargin == 2):
            if (isa_(a,char('single')) or isa_(b,char('single'))):
                tol=sqrt_(eps_(char('single')))
            else:
                tol=sqrt_(eps)
        if (length_(a) == 1 or length_(b) == 1):
            if (a == 0):
                x=copy_(b)
            else:
                if (b == 0):
                    x=copy_(a)
                else:
                    x=1
        else:
            a /= a[1]
            while (1):

                d,r=deconv_(b,a,nargout=2)
                nz=find_(abs_(r) > tol)
                if (isempty_(nz)):
                    x=copy_(a)
                    break
                else:
                    r=r[nz[1]:length_(r)]
                b=copy_(a)
                a=r / r[1]

    else:
        print_usage_()
    return x
def polyvalm_(c=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[c,x].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not (isvector_(c) or isempty_(c))):
        error_(char('polyvalm: first argument must be a vector'))
    if (not issquare_(x)):
        error_(char('polyvalm: second argument must be a square matrix'))
    n=length_(c)
    if (n == 0):
        y=zeros_(rows_(x),class_(x))
    else:
        _id=eye_(rows_(x),class_(x))
        y=c[1] * _id
        for i in arange_(2,n).reshape(-1):
            y=y * x + c[i] * _id
    return y
def unmkpp_(pp=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[pp].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (isstruct_(pp) and isfield_(pp,char('form')) and strcmp_(pp.form,char('pp')))):
        error_(char('unmkpp: PP must be a piecewise polynomial structure'))
    x=pp.breaks
    P=pp.coefs
    n=pp.pieces
    k=pp.order
    d=pp.dim
    return x,P,n,k,d
def polyint_(p=None,k=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[p,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin == 1):
        k=0
    else:
        if (not isscalar_(k)):
            error_(char('polyint: the constant of integration must be a scalar'))
    if (not (isvector_(p) or isempty_(p))):
        error_(char('polyint: argument must be a vector'))
    lp=length_(p)
    if (lp == 0):
        retval=matlabarray([])
        return retval
    if (rows_(p) > 1):
        p=p.T
    retval=matlabarray([(p / [arange_(lp,1,- 1)]),k])
    return retval
def compan_(c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[c].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not isvector_(c)):
        error_(char('compan: expecting a vector argument'))
    n=length_(c)
    if (n == 1):
        A=matlabarray([])
    else:
        A=diag_(ones_(n - 2,1),- 1)
        A[1,:]=- c[2:n] / c[1]
    return A
def ppval_(pp=None,xi=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[pp,xi].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not (isstruct_(pp) and isfield_(pp,char('form')) and strcmp_(pp.form,char('pp')))):
        error_(char('ppval: first argument must be a pp-form structure'))
    x,P,n,k,d=unmkpp_(pp,nargout=5)
    sxi=size_(xi)
    if (isvector_(xi)):
        xi=xi[:].T
    nd=length_(d)
    xn=numel_(xi)
    idx=lookup_(x,xi,char('lr'))
    P=reshape_(P,[d,n * k])
    P=shiftdim_(P,nd)
    P=reshape_(P,[n,k,d])
    Pidx=P[idx[:],:]
    if (isvector_(xi)):
        Pidx=reshape_(Pidx,[xn,k,d])
        Pidx=shiftdim_(Pidx,1)
        dimvec=matlabarray([d,xn])
    else:
        Pidx=reshape_(Pidx,[sxi,k,d])
        Pidx=shiftdim_(Pidx,length_(sxi))
        dimvec=matlabarray([d,sxi])
    ndv=length_(dimvec)
    dx=(xi - x[idx])(arange_()).T
    dx=repmat_(dx,[prod_(d),1])
    dx=reshape_(dx,dimvec)
    dx=shiftdim_(dx,ndv - 1)
    if (k > 1):
        yi=shiftdim_(reshape_(Pidx[1,:],dimvec),ndv - 1)
    else:
        yi=shiftdim_(reshape_(Pidx,dimvec),ndv - 1)
    for i in arange_(2,k).reshape(-1):
        yi .*= dx
        yi += shiftdim_(reshape_(Pidx[i,:],dimvec),ndv - 1)
    if ((numel_(xi) > 1) or (length_(d) == 1)):
        yi=reshape_(shiftdim_(yi,1),dimvec)
    if (isvector_(xi) and (d == 1)):
        yi=reshape_(yi,sxi)
    else:
        if (isfield_(pp,char('orient')) and strcmp_(pp.orient,char('first'))):
            yi=shiftdim_(yi,nd)
    if (d == 1):
        yi=reshape_(yi,sxi)
    return yi
def __splinefit___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    error_(nargchk_(3,7,nargin))
    x,y,dim,breaks,n,periodic,beta,constr=arguments_(varargin[:],nargout=8)
    base=splinebase_(breaks,n)
    pieces=base.pieces
    A=ppval_(base,x)
    junk,ibin=histc_(x,[- inf,breaks[2:end() - 1],inf],nargout=2)
    mx=numel_(x)
    ii=matlabarray([[ibin],[ones_(n - 1,mx)]])
    ii=cumsum_(ii,1)
    jj=repmat_(arange_(1,mx),n,1)
    if periodic:
        ii=mod_(ii - 1,pieces) + 1
        A=sparse_(ii,jj,A,pieces,mx)
    else:
        A=sparse_(ii,jj,A,pieces + n - 1,mx)
    if pieces < 20 * n / log_(1.7 * n):
        A=full_(A)
    if isempty_(constr):
        u=lsqsolve_(A,y,beta)
    else:
        B=evalcon_(base,constr,periodic)
        Z,u0=solvecon_(B,constr,nargout=2)
        y=y - u0 * A
        A=Z * A
        v=lsqsolve_(A,y,beta)
        u=u0 + v * Z
    if periodic:
        jj=mod_(arange_(0,pieces + n - 2),pieces) + 1
        u=u[:,jj]
    ii=matlabarray([[repmat_(arange_(1,pieces),1,n)],[ones_(n - 1,n * pieces)]])
    ii=cumsum_(ii,1)
    jj=repmat_(arange_(1,n * pieces),n,1)
    C=sparse_(ii,jj,base.coefs,pieces + n - 1,n * pieces)
    coefs=u * C
    coefs=reshape_(coefs,[],n)
    pp=mkpp_(breaks,coefs,dim)
    return pp
def arguments_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    x=varargin[1]
    mx=numel_(x)
    x=reshape_(x,1,mx)
    y=varargin[2]
    dim=size_(y)
    while numel_(dim) > 1 and dim[end()] == 1:

        dim[end()]=[]

    my=dim[end()]
    if numel_(dim) > 1:
        dim[end()]=[]
    else:
        dim=1
    pdim=prod_(dim)
    y=reshape_(y,pdim,my)
    if mx != my:
        mess=char('Last dimension of array y must equal length of vector x.')
        error_(char('arguments:datasize'),mess)
    inan=find_(isnan_(x))
    if not isempty_(inan):
        x[inan]=[]
        y[:,inan]=[]
        mess=char('All data points with NaN as x-location will be ignored.')
        warning_(char('arguments:nanx'),mess)
    inan=find_(any_(isnan_(y),1))
    if not isempty_(inan):
        x[inan]=[]
        y[:,inan]=[]
        mess=char('All data points with NaN in their y-value will be ignored.')
        warning_(char('arguments:nany'),mess)
    mx=numel_(x)
    if mx == 0:
        error_(char('arguments:nodata'),char('There must be at least one data point.'))
    if any_(diff_(x) < 0):
        x,isort=sort_(x,nargout=2)
        y=y[:,isort]
    if isscalar_(varargin[3]):
        p=varargin[3]
        if not isreal_(p) or not isfinite_(p) or p < 1 or fix_(p) < p:
            mess=char('Argument #3 must be a vector or a positive integer.')
            error_(char('arguments:breaks1'),mess)
        if x[1] < x[end()]:
            dx=diff_(x)
            ibreaks=linspace_(1,mx,p + 1)
            junk,ibin=histc_(ibreaks,[0,arange_(2,mx - 1),mx + 1],nargout=2)
            breaks=x[ibin] + dx[ibin].dot((ibreaks - ibin))
        else:
            breaks=x[1] + linspace_(0,1,p + 1)
    else:
        breaks=reshape_(varargin[3],1,[])
        if isempty_(breaks) or min_(breaks) == max_(breaks):
            mess=char('At least two unique breaks are required.')
            error_(char('arguments:breaks2'),mess)
    if any_(diff_(breaks) <= 0):
        breaks=unique_(breaks)
    n=4
    periodic=copy_(false)
    robust=copy_(false)
    beta=0.5
    constr=matlabarray([])
    for k in arange_(4,nargin).reshape(-1):
        a=varargin[k]
        if ischar_(a) and isscalar_(a) and lower_(a) == char('p'):
            periodic=copy_(true)
        else:
            if ischar_(a) and isscalar_(a) and lower_(a) == char('r'):
                robust=copy_(true)
            else:
                if isreal_(a) and isscalar_(a) and isfinite_(a) and a > 0 and a < 1:
                    beta=copy_(a)
                    robust=copy_(true)
                else:
                    if isreal_(a) and isscalar_(a) and isfinite_(a) and a > 0 and fix_(a) == a:
                        n=copy_(a)
                    else:
                        if isstruct_(a) and isscalar_(a):
                            constr=copy_(a)
                        else:
                            error_(char('arguments:nonsense'),char('Failed to interpret argument #%d.'),k)
    if not robust:
        beta=0
    h=diff_(breaks)
    xlim1=breaks[1] - 0.01 * h[1]
    xlim2=breaks[end()] + 0.01 * h[end()]
    if x[1] < xlim1 or x[end()] > xlim2:
        if periodic:
            P=breaks[end()] - breaks[1]
            x=mod_(x - breaks[1],P) + breaks[1]
            x,isort=sort_(x,nargout=2)
            y=y[:,isort]
        else:
            mess=char('Some data points are outside the spline domain.')
            warning_(char('arguments:exteriordata'),mess)
    if isempty_(constr):
        return x,y,dim,breaks,n,periodic,beta,constr
    xc=matlabarray([])
    yc=matlabarray([])
    cc=matlabarray([])
    names=fieldnames_(constr)
    for k in arange_(1,numel_(names)).reshape(-1):
        if [char('xc')] == names[k]:
            xc=constr.xc
        else:
            if [char('yc')] == names[k]:
                yc=constr.yc
            else:
                if [char('cc')] == names[k]:
                    cc=constr.cc
                else:
                    mess=char("Unknown field '%s' in constraint structure.")
                    warning_(char('arguments:unknownfield'),mess,names[k])
    if isempty_(xc):
        mess=char('Constraints contains no x-locations.')
        error_(char('arguments:emptyxc'),mess)
    else:
        nx=numel_(xc)
        xc=reshape_(xc,1,nx)
    if isempty_(yc):
        yc=zeros_(pdim,nx)
    else:
        if numel_(yc) == 1:
            yc=zeros_(pdim,nx) + yc
        else:
            if numel_(yc) != pdim * nx:
                error_(char('arguments:ycsize'),char('Cannot reshape yc to size %dx%d.'),pdim,nx)
            else:
                yc=reshape_(yc,pdim,nx)
    if isempty_(cc):
        cc=ones_(size_(xc))
    else:
        if numel_(size_(cc)) != 2:
            error_(char('arguments:ccsize1'),char('Constraint coefficients cc must be 2-D.'))
        else:
            if size_(cc,2) != nx:
                mess=char('Last dimension of cc must equal length of xc.')
                error_(char('arguments:ccsize2'),mess)
    if size_(cc,1) >= n:
        if any_(any_(cc[n:end(),:])):
            mess=char('Constraints involve derivatives of order %d or larger.')
            error_(char('arguments:difforder'),mess,n - 1)
        cc=cc[1:n - 1,:]
    if min_(xc) < xlim1 or max_(xc) > xlim2:
        if periodic:
            P=breaks[end()] - breaks[1]
            xc=mod_(xc - breaks[1],P) + breaks[1]
        else:
            mess=char('Some constraints are outside the spline domain.')
            warning_(char('arguments:exteriorconstr'),mess)
    constr=struct_(char('xc'),xc,char('yc'),yc,char('cc'),cc)
    return x,y,dim,breaks,n,periodic,beta,constr
def splinebase_(breaks=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[breaks,n].count(None)+len(args)

    breaks=breaks[:]
    breaks0=breaks.T
    h=diff_(breaks)
    pieces=numel_(h)
    deg=n - 1
    if deg > 0:
        if deg <= pieces:
            hcopy=copy_(h)
        else:
            hcopy=repmat_(h,ceil_(deg / pieces),1)
        hl=hcopy[end():- 1:end() - deg + 1]
        bl=breaks[1] - cumsum_(hl)
        hr=hcopy[1:deg]
        br=breaks[end()] + cumsum_(hr)
        breaks=matlabarray([[bl[deg:- 1:1]],[breaks],[br]])
        h=diff_(breaks)
        pieces=numel_(h)
    coefs=zeros_(n * pieces,n)
    coefs[1:n:end(),1]=1
    ii=matlabarray([[arange_(1,pieces)],[ones_(deg,pieces)]])
    ii=cumsum_(ii,1)
    ii=min_(ii,pieces)
    H=h[ii[:]]
    for k in arange_(2,n).reshape(-1):
        for j in arange_(1,k - 1).reshape(-1):
            coefs[:,j]=coefs[:,j].dot(H) / (k - j)
        Q=sum_(coefs,2)
        Q=reshape_(Q,n,pieces)
        Q=cumsum_(Q,1)
        c0=matlabarray([[zeros_(1,pieces)],[Q[1:deg,:]]])
        coefs[:,k]=c0[:]
        fmax=repmat_(Q[n,:],n,1)
        fmax=fmax[:]
        for j in arange_(1,k).reshape(-1):
            coefs[:,j]=coefs[:,j] / fmax
        coefs[1:end() - deg,1:k]=coefs[1:end() - deg,1:k] - coefs[n:end(),1:k]
        coefs[1:n:end(),k]=0
    scale=ones_(size_(H))
    for k in arange_(1,n - 1).reshape(-1):
        scale=scale / H
        coefs[:,n - k]=scale.dot(coefs[:,n - k])
    pieces=pieces - 2 * deg
    ii=matlabarray([[n * (arange_(1,pieces))],[deg * ones_(deg,pieces)]])
    ii=cumsum_(ii,1)
    coefs=coefs[ii[:],:]
    pp=mkpp_(breaks0,coefs,n)
    return pp
def evalcon_(base=None,constr=None,periodic=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[base,constr,periodic].count(None)+len(args)

    breaks=base.breaks
    pieces=base.pieces
    n=base.order
    xc=constr.xc
    cc=constr.cc
    junk,ibin=histc_(xc,[- inf,breaks[2:end() - 1],inf],nargout=2)
    nx=numel_(xc)
    B0=zeros_(n,nx)
    for k in arange_(1,size_(cc,1)).reshape(-1):
        if any_(cc[k,:]):
            B0=B0 + repmat_(cc[k,:],n,1).dot(ppval_(base,xc))
        coefs=base.coefs(arange_(),arange_(1,n - k))
        for j in arange_(1,n - k - 1).reshape(-1):
            coefs[:,j]=(n - k - j + 1) * coefs[:,j]
        base.coefs=coefs
        base.order=n - k
    ii=matlabarray([[ibin],[ones_(n - 1,nx)]])
    ii=cumsum_(ii,1)
    jj=repmat_(arange_(1,nx),n,1)
    if periodic:
        ii=mod_(ii - 1,pieces) + 1
        B=sparse_(ii,jj,B0,pieces,nx)
    else:
        B=sparse_(ii,jj,B0,pieces + n - 1,nx)
    return B
def solvecon_(B=None,constr=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[B,constr].count(None)+len(args)

    yc=constr.yc
    tol=1000 * eps
    ii=any_(B,2)
    B2=full_(B[ii,:])
    if isempty_(B2):
        Z2=matlabarray([])
    else:
        Q,R,dummy=qr_(B2,nargout=3)
        R=abs_(R)
        jj=all_(R < R[1] * tol,2)
        Z2=Q[:,jj].T
    m,ncon=size_(B,nargout=2)
    m2=size_(B2,1)
    nz=size_(Z2,1)
    Z=sparse_(arange_(nz + 1,nz + m - m2),find_(not ii),1,nz + m - m2,m)
    Z[1:nz,ii]=Z2
    if nz + ncon > m2:
        mess=char('Rank deficient constraints, rank = %d.')
        warning_(char('solvecon:deficient'),mess,m2 - nz)
    u0=zeros_(size_(yc,1),m)
    if any_(yc[:]):
        u0[:,ii]=yc / B2
        if norm_(u0 * B - yc,char('fro')) > norm_(yc,char('fro')) * tol:
            mess=char('Inconsistent constraints. No solution within tolerance.')
            error_(char('solvecon:inconsistent'),mess)
    return Z,u0
def lsqsolve_(A=None,y=None,beta=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[A,y,beta].count(None)+len(args)

    if issparse_(A) and not isreal_(y):
        A=full_(A)
    u=y / A
    if beta > 0:
        m,n=size_(y,nargout=2)
        alpha=0.5 * beta / (1 - beta) / m
        for k in arange_(1,3).reshape(-1):
            r=u * A - y
            rr=r.dot(conj_(r))
            rrmean=sum_(rr,2) / n
            rrmean[not rrmean]=1
            rrhat=(alpha / rrmean).T * rr
            w=exp_(- rrhat)
            spw=spdiags_(w.T,0,n,n)
            u=(y * spw) / (A * spw)
    return u
def polyreduce_(c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[c].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    else:
        if (not isvector_(c) or isempty_(c)):
            error_(char('polyreduce: C must be a non-empty vector'))
    idx=find_(c != 0,1)
    if (isempty_(idx)):
        p=0
    else:
        p=c[idx:end()]
    return p
def residue_(b=None,a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[b,a].count(None)+len(args)

    if (nargin < 2 or nargin > 4):
        print_usage_()
    toler=0.001
    if (nargin >= 3):
        if (nargin >= 4):
            e=varargin[2]
        else:
            e=matlabarray([])
        r,p=rresidue_(b,a,varargin[1],toler,e,nargout=2)
        return r,p,k,e
    a=polyreduce_(a)
    b=polyreduce_(b)
    b=b / a[1]
    a=a / a[1]
    la=length_(a)
    lb=length_(b)
    if (la == 0 or lb == 0):
        k=r=p=e=matlabarray([])
        return r,p,k,e
    else:
        if (la == 1):
            k=b / a
            r=p=e=matlabarray([])
            return r,p,k,e
    p=roots_(a)
    lp=length_(p)
    e,indx=mpoles_(p,toler,1,nargout=2)
    p=p[indx]
    p_group=cumsum_(e == 1)
    for ng in arange_(1,p_group[end()]).reshape(-1):
        m=find_(p_group == ng)
        p[m]=mean_(p[m])
    if (lb >= la):
        k,b=deconv_(b,a,nargout=2)
        lb=length_(b)
    else:
        k=matlabarray([])
    small=max_(abs_(p))
    if (isa_(a,char('single')) or isa_(b,char('single'))):
        small=max_([small,1]) * eps_(char('single')) * 10000.0 * (1 + numel_(p)) ** 2
    else:
        small=max_([small,1]) * eps * 10000.0 * (1 + numel_(p)) ** 2
    p[abs_(p) < small]=0
    index=(abs_(imag_(p)) < small)
    p[index]=real_(p[index])
    index=(abs_(real_(p)) < small)
    p[index]=1j * imag_(p[index])
    if (lp == 1):
        r=polyval_(b,p)
        return r,p,k,e
    aorder=numel_(a) - 1
    border=aorder - 1
    A=zeros_(border + 1,border + 1)
    B=prepad_(reshape_(b,[numel_(b),1]),border + 1,0)
    for ip in arange_(1,numel_(p)).reshape(-1):
        ri=zeros_(size_(p))
        ri[ip]=1
        A[:,ip]=prepad_(rresidue_(ri,p,[],toler),border + 1,0).T
    r=numpy.linalg.solve(A,B)
    return r,p,k,e
def rresidue_(r=None,p=None,k=None,toler=None,e=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[r,p,k,toler,e].count(None)+len(args)

    if (nargin < 2 or nargin > 5):
        print_usage_()
    if (nargin < 5):
        e=matlabarray([])
    if (nargin < 4):
        toler=matlabarray([])
    if (nargin < 3):
        k=matlabarray([])
    if (numel_(e)):
        indx=arange_(1,numel_(p))
    else:
        e,indx=mpoles_(p,toler,0,nargout=2)
        p=p[indx]
        r=r[indx]
    indx=arange_(1,numel_(p))
    for n in indx.reshape(-1):
        pn=matlabarray([1,- p[n]])
        if (n == 1):
            pden=copy_(pn)
        else:
            pden=conv_(pden,pn)
    D=numel_(pden) - 1
    K=numel_(k) - 1
    N=K + D
    pnum=zeros_(1,N + 1)
    for n in indx[abs_(r) > 0].reshape(-1):
        p1=matlabarray([1,- p[n]])
        for m in arange_(1,e[n]).reshape(-1):
            if (m == 1):
                pm=copy_(p1)
            else:
                pm=conv_(pm,p1)
        pn=deconv_(pden,pm)
        pn=r[n] * pn
        pnum=pnum + prepad_(pn,N + 1,0,2)
    if (numel_(k)):
        pnum=pnum + conv_(pden,k)
    if (isa_(r,char('single')) or isa_(p,char('single')) or isa_(k,char('single'))):
        small=max_([max_(abs_(pden)),max_(abs_(pnum)),1]) * eps_(char('single'))
    else:
        small=max_([max_(abs_(pden)),max_(abs_(pnum)),1]) * eps
    pnum[abs_(pnum) < small]=0
    pden[abs_(pden) < small]=0
    pnum=polyreduce_(pnum)
    pden=polyreduce_(pden)
    return pnum,pden,e
def ppder_(pp=None,m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[pp,m].count(None)+len(args)

    if ((nargin < 1) or (nargin > 2)):
        print_usage_()
    else:
        if (nargin == 1):
            m=1
    if (not (isstruct_(pp) and strcmp_(pp.form,char('pp')))):
        error_(char('ppder: PP must be a structure'))
    x,p,n,k,d=unmkpp_(pp,nargout=5)
    if (k - m <= 0):
        x=matlabarray([x[1],x[end()]])
        pd=zeros_(prod_(d),1)
    else:
        f=arange_(k,1,- 1)
        ff=bincoeff_(f,m + 1).dot(factorial_(m + 1)) / f
        k -= m
        pd=p[:,1:k] * diag_(ff[1:k])
    ppd=mkpp_(x,pd,d)
    return ppd
def polyval_(p=None,x=None,mu=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[p,x,s,mu].count(None)+len(args)

    if (nargin < 2 or nargin > 4 or (nargout == 2 and nargin < 3)):
        print_usage_()
    if (isempty_(x)):
        y=matlabarray([])
        return y,dy
    else:
        if (isempty_(p)):
            y=zeros_(size_(x))
            return y,dy
        else:
            if (not isvector_(p)):
                error_(char('polyval: first argument must be a vector'))
    if (nargin > 3):
        x=(x - mu[1]) / mu[2]
    n=length_(p) - 1
    y=p[1] * ones_(size_(x))
    for i in arange_(2,n + 1).reshape(-1):
        y=y.dot(x) + p[i]
    if (nargout == 2):
        try:
            k=numel_(x)
            A=(x[:] * ones_(1,n + 1)) ** (ones_(k,1) * (arange_(n,0,- 1)))
            dy=sqrt_(1 + sumsq_(A / s.R,2)) * s.normr / sqrt_(s.df)
            dy=reshape_(dy,size_(x))
        finally:
            pass
    return y,dy
def polyeig_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargout > 2):
        print_usage_()
    nin=numel_(varargin)
    n=zeros_(1,nin)
    for cnt in arange_(1,nin).reshape(-1):
        if (not issquare_(varargin[cnt])):
            error_(char('polyeig: coefficients must be square matrices'))
        n[cnt]=size_(varargin[cnt],1)
    if (numel_(unique_(n)) > 1):
        error_(char('polyeig: coefficients must have the same dimensions'))
    n=unique_(n)
    l=nin - 1
    C=matlabarray([[zeros_(n * (l - 1),n),eye_(n * (l - 1))],[- cell2mat_(varargin[1:end() - 1])]])
    D=matlabarray([[eye_(n * (l - 1)),zeros_(n * (l - 1),n)],[zeros_(n,n * (l - 1)),varargin[end()]]])
    if (isequal_(nargout,1)):
        z=eig_(C,D)
    else:
        z,v=eig_(C,D,nargout=2)
        varargout[1]=v
        z=z[1:n,:]
        t=max_(z)
        z /= diag_(t)
    return z,varargout
def deconv_(y=None,a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[y,a].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not (isvector_(y) and isvector_(a))):
        error_(char('deconv: both arguments must be vectors'))
    la=length_(a)
    ly=length_(y)
    lb=ly - la + 1
    if (diff_(size_(y)(arange_(1,2))) * diff_(size_(a)(arange_(1,2))) < 0):
        a=permute_(a,[2,1])
    if (ly > la):
        x=zeros_(size_(y) - size_(a) + 1)
        x[1]=1
        b=filter_(y,a,x)
    else:
        if (ly == la):
            b=filter_(y,a,1)
        else:
            b=0
    lc=la + length_(b) - 1
    if (ly == lc):
        r=y - conv_(a,b)
    else:
        if (rows_(y) <= columns_(y)):
            r=[(zeros_(1,lc - ly)),y] - conv_(a,b)
        else:
            r=[[(zeros_(lc - ly,1))],[y]] - conv_(a,b)
        if (ly < la):
            r=r[end() - (length_(y) - 1):end()]
    return b,r
def splinefit_(x=None,y=None,breaks=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,breaks].count(None)+len(args)

    if (nargin > 3):
        n=cellfun_(char('isclass'),varargin,char('char'))
        varargin[n]=lower_(varargin[n])
        try:
            props=struct_(varargin[:])
        finally:
            pass
    else:
        props=struct_()
    fields=fieldnames_(props)
    for f in arange_(1,numel_(fields)).reshape(-1):
        if (not any_(strcmp_(fields[f],[char('periodic'),char('robust'),char('beta'),char('order'),char('constraints')]))):
            error_(char('splinefit:invalidproperty'),char("unrecognized property '%s'"),fields[f])
    args=[]
    if (isfield_(props,char('periodic')) and props.periodic):
        args[end() + 1]=char('p')
    if (isfield_(props,char('robust')) and props.robust):
        args[end() + 1]=char('r')
    if (isfield_(props,char('beta'))):
        if (0 < props.beta and props.beta < 1):
            args[end() + 1]=props.beta
        else:
            error_(char('splinefit:invalidbeta'),char('invalid beta parameter (0 < beta < 1)'))
    if (isfield_(props,char('order'))):
        if (props.order >= 0):
            args[end() + 1]=props.order + 1
        else:
            error_(char('splinefit:invalidorder'),char('invalid order'))
    if (isfield_(props,char('constraints'))):
        args[end() + 1]=props.constraints
    if (nargin < 3):
        print_usage_()
    else:
        if (not isnumeric_(breaks) or not isvector_(breaks)):
            print_usage_()
    pp=__splinefit___(x,y,breaks,args[:])
    return pp
def polyfit_(x=None,y=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,n].count(None)+len(args)

    if (nargin < 3 or nargin > 4):
        print_usage_()
    if (nargout > 2):
        mu=matlabarray([mean_(x),std_(x)])
        x=(x - mu[1]) / mu[2]
    if (not size_equal_(x,y)):
        error_(char('polyfit: X and Y must be vectors of the same size'))
    if (islogical_(n)):
        polymask=copy_(n)
        n=length_(polymask) - 1
        m=sum_(polymask) - 1
    else:
        if (not (isscalar_(n) and n >= 0 and not isinf_(n) and n == fix_(n))):
            error_(char('polyfit: N must be a non-negative integer'))
        polymask=logical_(ones_(1,n + 1))
        m=copy_(n)
    y_is_row_vector=(rows_(y) == 1)
    l=numel_(x)
    x=x[:]
    y=y[:]
    v=vander_(x,n + 1)
    q,r,k=qr_(v[:,polymask],0,nargout=3)
    p=numpy.linalg.solve(r,(q.T * y))
    p[k]=p
    if (n != m):
        q=copy_(p)
        p=zeros_(n + 1,1)
        p[polymask]=q
    if (nargout > 1):
        yf=v * p
        if (y_is_row_vector):
            s.yf=yf.T
        else:
            s.yf=yf
        s.X=v
        try:
            C=cholinv_(r.T * r)(k,k)
        finally:
            pass
        if (n != m):
            s.X[:,not polymask]=0
            s.R=zeros_(n + 1,n + 1)
            s.R[polymask,polymask]=r
            s.C=zeros_(n + 1,n + 1)
            s.C[polymask,polymask]=C
        else:
            s.R=r
            s.C=C
        s.df=l - m - 1
        s.normr=norm_(yf - y)
    p=p.T
    return p,s,mu
def conv_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[a,b,shape].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not (isvector_(a) and isvector_(b))):
        error_(char('conv: both arguments A and B must be vectors'))
    else:
        if (nargin == 3 and not any_(strcmpi_(shape,[char('full'),char('same'),char('valid')]))):
            error_(char('conv: SHAPE argument must be "full", "same", or "valid"'))
    la=la_orig=length_(a)
    lb=lb_orig=length_(b)
    ly=la + lb - 1
    if (ly == 0):
        y=zeros_(1,0)
        return y
    if (la > lb):
        a,b=deal_(b,a,nargout=2)
        lb=copy_(la)
    x=copy_(b)
    if (ly > lb):
        x[end() + 1:end() + ly - lb]=0
    y=filter_(a,1,x)
    if (strcmpi_(shape,char('same'))):
        idx=ceil_((ly - la) / 2)
        y=y[idx + 1:idx + la]
    else:
        if (strcmpi_(shape,char('valid'))):
            _len=la_orig - lb_orig
            y=y[lb_orig:lb_orig + _len]
    return y
def polyaffine_(f=None,mu=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,mu].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isvector_(f)):
        error_(char('polyaffine: F must be a vector'))
    if (not isvector_(mu) or length_(mu) != 2):
        error_(char('polyaffine: MU must be a two-element vector'))
    lf=length_(f)
    if (rows_(f) > 1):
        f=f.T
    g=copy_(f)
    if (mu[2] != 1):
        g=g / (mu[2] ** (arange_(lf - 1,0,- 1)))
    if (mu[1] != 0):
        w=(- mu[1]) ** (arange_(0,lf - 1))
        ii=arange_(lf,1,- 1)
        g=g[ii] * (toeplitz_(w).dot(pascal_(lf,- 1)))
        g=g[ii]
    return g
def mkpp_(x=None,P=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,P,d].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (length_(x) < 2):
        error_(char('mkpp: at least one interval is needed'))
    if (not isvector_(x)):
        error_(char('mkpp: x must be a vector'))
    _len=length_(x) - 1
    dP=length_(size_(P))
    pp=struct_(char('form'),char('pp'),char('breaks'),x[:].T,char('coefs'),[],char('pieces'),_len,char('order'),prod_(size_(P)) / _len,char('dim'),1)
    if (nargin == 3):
        pp.dim=d
        pp.order /= prod_(d)
    dim_vec=matlabarray([pp.pieces * prod_(pp.dim),pp.order])
    pp.coefs=reshape_(P,dim_vec)
    return pp
def ppjumps_(pp=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[pp].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (isstruct_(pp) and strcmp_(pp.form,char('pp')))):
        error_(char('ppjumps: PP must be a structure'))
    x,P,n,k,d=unmkpp_(pp,nargout=5)
    nd=length_(d) + 1
    dx=diff_(x[1:n])
    dx=repmat_(dx,[prod_(d),1])
    dx=reshape_(dx,[d,n - 1])
    dx=shiftdim_(dx,nd - 1)
    if (k > 1):
        llim=shiftdim_(reshape_(P[1:(n - 1) * prod_(d),1],[d,n - 1]),nd - 1)
    for i in arange_(2,k).reshape(-1):
        llim .*= dx
        llim += shiftdim_(reshape_(P[1:(n - 1) * prod_(d),i],[d,n - 1]),nd - 1)
    rlim=shiftdim_(ppval_(pp,x[2:end() - 1]),nd - 1)
    jumps=shiftdim_(rlim - llim,1)
    return jumps
def mpoles_(p=None,tol=None,reorder=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[p,tol,reorder].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (nargin < 2 or isempty_(tol)):
        tol=0.001
    if (nargin < 3 or isempty_(reorder)):
        reorder=copy_(true)
    Np=numel_(p)
    p=p[:]
    if (reorder):
        p,ordr=sort_(p,nargout=2)
        n=arange_(Np,1,- 1)
        p=p[n]
        ordr=ordr[n]
    else:
        ordr=arange_(1,Np)
    multp=zeros_(Np,1)
    indx=matlabarray([])
    n=find_(multp == 0,1)
    while (n):

        dp=abs_(p - p[n])
        if (p[n] == 0.0):
            if (any_(abs_(p) > 0 and isfinite_(p))):
                p0=mean_(abs_(p[abs_(p) > 0 and isfinite_(p)]))
            else:
                p0=1
        else:
            p0=abs_(p[n])
        k=find_(dp < tol * p0)
        if (numel_(indx)):
            k=k[not ismember_(k,indx)]
        m=arange_(1,numel_(k))
        multp[k]=m
        indx=matlabarray([[indx],[k]])
        n=find_(multp == 0,1)

    multp=multp[indx]
    indx=ordr[indx]
    return multp,indx
def polyout_(c=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[c,x].count(None)+len(args)

    if (nargin < 1) or (nargin > 2) or (nargout < 0) or (nargout > 1):
        print_usage_()
    if (not isvector_(c)):
        error_(char('polyout: first argument must be a vector'))
    if (nargin == 1):
        x=char('s')
    else:
        if (not ischar_(x)):
            error_(char('polyout: second argument must be a string'))
    n=length_(c)
    if (n > 0):
        n1=n + 1
        tmp=coeff_(c[1])
        for ii in arange_(2,n).reshape(-1):
            if (real_(c[ii]) < 0):
                ns=char(' - ')
                c[ii]=- c[ii]
            else:
                ns=char(' + ')
            tmp=sprintf_(char('%s*%s^%d%s%s'),tmp,x,n1 - ii,ns,coeff_(c[ii]))
    else:
        tmp=char(' ')
    if (nargout == 0):
        disp_(tmp)
    else:
        y=copy_(tmp)
    return y
def coeff_(c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[c].count(None)+len(args)

    if (imag_(c)):
        if (real_(c)):
            _str=sprintf_(char('(%s)'),num2str_(c,5))
        else:
            _str=num2str_(c,5)
    else:
        _str=num2str_(c,5)
    return _str
def poly_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    m=min_(size_(x))
    n=max_(size_(x))
    if (m == 0):
        y=1
        return y
    else:
        if (m == 1):
            v=copy_(x)
        else:
            if (m == n):
                v=eig_(x)
            else:
                print_usage_()
    y=zeros_(1,n + 1)
    y[1]=1
    for j in arange_(1,n).reshape(-1):
        y[2:(j + 1)]=y[2:(j + 1)] - v[j].dot(y[1:j])
    if (all_(all_(imag_(x) == 0))):
        y=real_(y)
    return y
def tand_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    I0=x / 180
    I90=(x - 90) / 180
    y=tan_(I0.dot(pi))
    y[I0 == fix_(I0) and finite_(I0)]=0
    y[I90 == fix_(I90) and finite_(I90)]=Inf
    return y
def sech_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=1 / cosh_(x)
    return y
def cscd_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=1 / sind_(x)
    return y
def cosd_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    I=x / 180
    y=cos_(I.dot(pi))
    I=I + 0.5
    y[I == fix_(I) and finite_(I)]=0
    return y
def secd_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=1 / cosd_(x)
    return y
def asind_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=asin_(x).dot(180) / pi
    return y
def acotd_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=atand_(1 / x)
    return y
def atan2d_(y=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[y,x].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    retval=180 / pi.dot(atan2_(y,x))
    return retval
def sind_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    I=x / 180
    y=sin_(I.dot(pi))
    y[I == fix_(I) and finite_(I)]=0
    return y
def asecd_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=asec_(x).dot(180) / pi
    return y
def acsch_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=asinh_(1 / x)
    return y
def acosd_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=acos_(x).dot(180) / pi
    return y
def sec_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=1 / cos_(x)
    return y
def acscd_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=acsc_(x).dot(180) / pi
    return y
def asech_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=acosh_(1 / x)
    return y
def acsc_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=asin_(1 / x)
    return y
def asec_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=acos_(1 / x)
    return y
def csch_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=1 / sinh_(x)
    return y
def acoth_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=atanh_(1 / x)
    return y
def cot_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=1 / tan_(x)
    return y
def coth_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=1 / tanh_(x)
    return y
def cotd_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=1 / tand_(x)
    return y
def atand_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=180 / pi.dot(atan_(x))
    return y
def acot_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=atan_(1 / x)
    return y
def csc_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=1 / sin_(x)
    return y
def pkg_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    user_prefix=copy_(false)
    prefix=copy_(false)
    archprefix=- 1
    local_list=tilde_expand_(fullfile_(char('~'),char('.octave_packages')))
    global_list=fullfile_(OCTAVE_HOME_(),char('share'),char('octave'),char('octave_packages'))
    confirm_recursive_rmdir_(false,char('local'))
    mlock_()
    global_install=((ispc_() and not isunix_()) or (geteuid_() == 0))
    if (isbool_(prefix)):
        if (global_install):
            prefix=fullfile_(OCTAVE_HOME_(),char('share'),char('octave'),char('packages'))
            archprefix=fullfile_(octave_config_info_(char('libdir')),char('octave'),char('packages'))
        else:
            prefix=fullfile_(char('~'),char('octave'))
            archprefix=copy_(prefix)
        prefix=tilde_expand_(prefix)
        archprefix=tilde_expand_(archprefix)
    available_actions=[char('list'),char('install'),char('uninstall'),char('load'),char('unload'),char('prefix'),char('local_list'),char('global_list'),char('rebuild'),char('build'),char('describe'),char('update')]
    if (length_(varargin) == 0 or not iscellstr_(varargin)):
        print_usage_()
    files=[]
    deps=copy_(true)
    auto=0
    action=char('none')
    verbose=copy_(false)
    octave_forge=copy_(false)
    for i in arange_(1,length_(varargin)).reshape(-1):
        if char('-nodeps') == (varargin[i]):
            deps=copy_(false)
        else:
            if char('-noauto') == (varargin[i]):
                auto=- 1
            else:
                if char('-auto') == (varargin[i]):
                    auto=1
                else:
                    if char('-verbose') == (varargin[i]):
                        verbose=copy_(true)
                        page_output_immediately_(true,char('local'))
                    else:
                        if char('-forge') == (varargin[i]):
                            if (not octave_config_info_(char('CURL_LIBS'))):
                                error_(char("pkg: can't download from forge without the cURL library"))
                            octave_forge=copy_(true)
                        else:
                            if char('-local') == (varargin[i]):
                                global_install=copy_(false)
                                if (not user_prefix):
                                    prefix=tilde_expand_(fullfile_(char('~'),char('octave')))
                                    archprefix=copy_(prefix)
                            else:
                                if char('-global') == (varargin[i]):
                                    global_install=copy_(true)
                                    if (not user_prefix):
                                        prefix=fullfile_(OCTAVE_HOME_(),char('share'),char('octave'),char('packages'))
                                        archprefix=fullfile_(octave_config_info_(char('libdir')),char('octave'),char('packages'))
                                else:
                                    if available_actions == (varargin[i]):
                                        if (strcmp_(action,char('none'))):
                                            action=varargin[i]
                                        else:
                                            error_(char('more than one action specified'))
                                    else:
                                        files[end() + 1]=varargin[i]
    if (octave_forge and not any_(strcmp_(action,[char('install'),char('list')]))):
        error_(char('-forge can only be used with install or list'))
    if char('list') == (action):
        if (octave_forge):
            if (nargout > 0):
                local_packages=list_forge_packages_()
            else:
                list_forge_packages_()
        else:
            if (nargout == 0):
                installed_packages_(local_list,global_list)
            else:
                if (nargout == 1):
                    local_packages=installed_packages_(local_list,global_list)
                else:
                    if (nargout == 2):
                        local_packages,global_packages=installed_packages_(local_list,global_list,nargout=2)
                    else:
                        error_(char('too many output arguments requested'))
    else:
        if char('install') == (action):
            if (length_(files) == 0):
                error_(char("you must specify at least one filename when calling 'pkg install'"))
            local_files=[]
            try:
                if (octave_forge):
                    urls,local_files=cellfun_(char('get_forge_download'),files,char('uniformoutput'),false,nargout=2)
                    files,succ=cellfun_(char('urlwrite'),urls,local_files,char('uniformoutput'),false,nargout=2)
                    succ=matlabarray([succ[:]])
                    if (not all_(succ)):
                        i=find_(not succ,1)
                        error_(char('could not download file %s from url %s'),local_files[i],urls[i])
                install_(files,deps,auto,prefix,archprefix,verbose,local_list,global_list,global_install)
            finally:
                cellfun_(char('unlink'),local_files)
        else:
            if char('uninstall') == (action):
                if (length_(files) == 0):
                    error_(char("you must specify at least one package when calling 'pkg uninstall'"))
                uninstall_(files,deps,verbose,local_list,global_list,global_install)
            else:
                if char('load') == (action):
                    if (length_(files) == 0):
                        error_(char("you must specify at least one package, 'all' or 'auto' when calling 'pkg load'"))
                    load_packages_(files,deps,local_list,global_list)
                else:
                    if char('unload') == (action):
                        if (length_(files) == 0):
                            error_(char("you must specify at least one package or 'all' when calling 'pkg unload'"))
                        unload_packages_(files,deps,local_list,global_list)
                    else:
                        if char('prefix') == (action):
                            if (length_(files) == 0 and nargout == 0):
                                printf_(char('Installation prefix:             %s\n'),prefix)
                                printf_(char('Architecture dependent prefix:   %s\n'),archprefix)
                            else:
                                if (length_(files) == 0 and nargout >= 1):
                                    local_packages=copy_(prefix)
                                    global_packages=copy_(archprefix)
                                else:
                                    if (length_(files) >= 1 and nargout <= 2 and ischar_(files[1])):
                                        prefix=tilde_expand_(files[1])
                                        if (not exist_(prefix,char('dir'))):
                                            status,msg,msgid=mkdir_(prefix,nargout=3)
                                            if (status == 0):
                                                error_(char('cannot create prefix %s: %s'),prefix,msg)
                                            warning_(char('creating the directory %s\n'),prefix)
                                        local_packages=prefix=canonicalize_file_name_(prefix)
                                        user_prefix=copy_(true)
                                        if (length_(files) >= 2 and ischar_(files[2])):
                                            archprefix=tilde_expand_(files[2])
                                            if (not exist_(archprefix,char('dir'))):
                                                status,msg,msgid=mkdir_(archprefix,nargout=3)
                                                if (status == 0):
                                                    error_(char('cannot create archprefix %s: %s'),archprefix,msg)
                                                warning_(char('creating the directory %s\n'),archprefix)
                                                global_packages=archprefix=canonicalize_file_name_(archprefix)
                                    else:
                                        error_(char('you must specify a prefix directory, or request an output argument'))
                        else:
                            if char('local_list') == (action):
                                if (length_(files) == 0 and nargout == 0):
                                    disp_(local_list)
                                else:
                                    if (length_(files) == 0 and nargout == 1):
                                        local_packages=copy_(local_list)
                                    else:
                                        if (length_(files) == 1 and nargout == 0 and ischar_(files[1])):
                                            local_list=files[1]
                                            if (not exist_(local_list,char('file'))):
                                                try:
                                                    fclose_(fopen_(local_list,char('wt')))
                                                finally:
                                                    pass
                                            local_list=canonicalize_file_name_(local_list)
                                        else:
                                            error_(char('you must specify a local_list file, or request an output argument'))
                            else:
                                if char('global_list') == (action):
                                    if (length_(files) == 0 and nargout == 0):
                                        disp_(global_list)
                                    else:
                                        if (length_(files) == 0 and nargout == 1):
                                            local_packages=copy_(global_list)
                                        else:
                                            if (length_(files) == 1 and nargout == 0 and ischar_(files[1])):
                                                global_list=files[1]
                                                if (not exist_(global_list,char('file'))):
                                                    try:
                                                        fclose_(fopen_(files[1],char('wt')))
                                                    finally:
                                                        pass
                                                global_list=canonicalize_file_name_(global_list)
                                            else:
                                                error_(char('you must specify a global_list file, or request an output argument'))
                                else:
                                    if char('rebuild') == (action):
                                        if (global_install):
                                            global_packages=rebuild_(prefix,archprefix,global_list,files,auto,verbose)
                                            global_packages=save_order_(global_packages)
                                            save_(global_list,char('global_packages'))
                                            if (nargout > 0):
                                                local_packages=copy_(global_packages)
                                        else:
                                            local_packages=rebuild_(prefix,archprefix,local_list,files,auto,verbose)
                                            local_packages=save_order_(local_packages)
                                            save_(local_list,char('local_packages'))
                                            if (nargout == 0):
                                                clear_(char('local_packages'))
                                    else:
                                        if char('build') == (action):
                                            if (length_(files) < 2):
                                                error_(char("you must specify at least the build directory and one filename\nwhen calling 'pkg build'"))
                                            build_(files,deps,auto,verbose)
                                        else:
                                            if char('describe') == (action):
                                                if (length_(files) == 0):
                                                    error_(char("you must specify at least one package or 'all' when calling 'pkg describe'"))
                                                if 0 == (nargout):
                                                    describe_(files,verbose,local_list,global_list)
                                                else:
                                                    if 1 == (nargout):
                                                        pkg_desc_list=describe_(files,verbose,local_list,global_list)
                                                        local_packages=copy_(pkg_desc_list)
                                                    else:
                                                        if 2 == (nargout):
                                                            pkg_desc_list,flag=describe_(files,verbose,local_list,global_list,nargout=2)
                                                            local_packages=copy_(pkg_desc_list)
                                                            global_packages=copy_(flag)
                                                        else:
                                                            error_(char("you can request at most two outputs when calling 'pkg describe'"))
                                            else:
                                                if char('update') == (action):
                                                    if (nargout == 0):
                                                        installed_pkgs_lst=installed_packages_(local_list,global_list)
                                                        for i in arange_(1,length_(installed_pkgs_lst)).reshape(-1):
                                                            installed_pkg_name=installed_pkgs_lst[i].name
                                                            installed_pkg_version=installed_pkgs_lst[i].version
                                                            forge_pkg_version=get_forge_pkg_(installed_pkg_name)
                                                            if (compare_versions_(forge_pkg_version,installed_pkg_version,char('>'))):
                                                                feval_(pkg,char('install'),char('-forge'),installed_pkg_name)
                                                    else:
                                                        error_(char('no output arguments available'))
                                                else:
                                                    error_(char("you must specify a valid action for 'pkg'. See 'help pkg' for details"))
    return local_packages,global_packages
def load_packages_and_dependencies_(idx=None,handle_deps=None,installed_pkgs_lst=None,global_install=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[idx,handle_deps,installed_pkgs_lst,global_install].count(None)+len(args)

    idx=load_package_dirs_(idx,[],handle_deps,installed_pkgs_lst)
    dirs=[]
    execpath=EXEC_PATH_()
    for i in idx.reshape(-1):
        ndir=installed_pkgs_lst[i].dir
        dirs[end() + 1]=ndir
        if (exist_(fullfile_(dirs[end()],char('bin')),char('dir'))):
            execpath=matlabarray([execpath,pathsep_(),fullfile_(dirs[end()],char('bin'))])
        tmpdir=getarchdir_(installed_pkgs_lst[i])
        if (exist_(tmpdir,char('dir'))):
            dirs[end() + 1]=tmpdir
            if (exist_(fullfile_(dirs[end()],char('bin')),char('dir'))):
                execpath=matlabarray([execpath,pathsep_(),fullfile_(dirs[end()],char('bin'))])
    if (length_(dirs) > 0):
        addpath_(dirs[:])
    if (not strcmp_(EXEC_PATH,execpath)):
        EXEC_PATH_(execpath)
    return
def packinfo_copy_file_(filename=None,requirement=None,packdir=None,packinfo=None,desc=None,octfiledir=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[filename,requirement,packdir,packinfo,desc,octfiledir].count(None)+len(args)

    filepath=fullfile_(packdir,filename)
    if (not exist_(filepath,char('file')) and strcmpi_(requirement,char('optional'))):
        pass
    else:
        status,output=copyfile_(filepath,packinfo,nargout=2)
        if (status != 1):
            rmdir_(desc.dir,char('s'))
            rmdir_(octfiledir,char('s'))
            error_(char("Couldn't copy %s file: %s"),filename,output)
    return
def save_order_(desc=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[desc].count(None)+len(args)

    newdesc=[]
    for i in arange_(1,length_(desc)).reshape(-1):
        deps=desc[i].depends
        if (isempty_(deps) or (length_(deps) == 1 and strcmp_(deps[1].package,char('octave')))):
            newdesc[end() + 1]=desc[i]
        else:
            tmpdesc=[]
            for k in arange_(1,length_(deps)).reshape(-1):
                for j in arange_(1,length_(desc)).reshape(-1):
                    if (strcmp_(desc[j].name,deps[k].package)):
                        tmpdesc[end() + 1]=desc[j]
                        break
            if (not isempty_(tmpdesc)):
                newdesc=[newdesc[:],save_order_(tmpdesc)[:],desc[i]]
            else:
                newdesc[end() + 1]=desc[i]
    idx=matlabarray([])
    for i in arange_(1,length_(newdesc)).reshape(-1):
        for j in arange_((i + 1),length_(newdesc)).reshape(-1):
            if (strcmp_(newdesc[i].name,newdesc[j].name)):
                idx[end() + 1]=j
    newdesc[idx]=[]
    return newdesc
def getarch_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    _arch=matlabarray([octave_config_info_(char('canonical_host_type')),char('-'),octave_config_info_(char('api_version'))])
    arch=copy_(_arch)
    return arch
def create_pkgadddel_(desc=None,packdir=None,nm=None,global_install=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[desc,packdir,nm,global_install].count(None)+len(args)

    instpkg=fullfile_(desc.dir,nm)
    instfid=fopen_(instpkg,char('wt'))
    archdir=fullfile_(getarchprefix_(desc,global_install),[desc.name,char('-'),desc.version],getarch_())
    if (exist_(getarchdir_(desc,global_install),char('dir'))):
        archpkg=fullfile_(getarchdir_(desc,global_install),nm)
        archfid=fopen_(archpkg,char('at'))
    else:
        archpkg=copy_(instpkg)
        archfid=copy_(instfid)
    if (archfid >= 0 and instfid >= 0):
        lst=dir_(fullfile_(packdir,char('inst'),char('*.m')))
        for i in arange_(1,length_(lst)).reshape(-1):
            nam=fullfile_(packdir,char('inst'),lst[i].name)
            fwrite_(instfid,extract_pkg_(nam,[char('^[#%][#%]* *'),nm,char(': *(.*)$')]))
        lst=dir_(fullfile_(packdir,char('src'),char('*.cc')))
        for i in arange_(1,length_(lst)).reshape(-1):
            nam=fullfile_(packdir,char('src'),lst[i].name)
            fwrite_(archfid,extract_pkg_(nam,[char('^//* *'),nm,char(': *(.*)$')]))
            fwrite_(archfid,extract_pkg_(nam,[char('^/\\** *'),nm,char(': *(.*) *\\*/$')]))
        packdirnm=fullfile_(packdir,nm)
        if (exist_(packdirnm,char('file'))):
            fid=fopen_(packdirnm,char('rt'))
            if (fid >= 0):
                while (not feof_(fid)):

                    ln=fgets_(fid)
                    if (ln > 0):
                        fwrite_(archfid,ln)

                fclose_(fid)
        fclose_(instfid)
        t=dir_(instpkg)
        if (t.bytes <= 0):
            unlink_(instpkg)
        if (instfid != archfid):
            fclose_(archfid)
            t=dir_(archpkg)
            if (t.bytes <= 0):
                unlink_(archpkg)
    return
def generate_lookfor_cache_(desc=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[desc].count(None)+len(args)

    dirs=strtrim_(ostrsplit_(genpath_(desc.dir),pathsep_()))
    for i in arange_(1,length_(dirs)).reshape(-1):
        doc_cache_create_(fullfile_(dirs[i],char('doc-cache')),dirs[i])
    return
def print_package_description_(pkg_name=None,pkg_ver=None,pkg_idx_struct=None,pkg_desc=None,status=None,verbose=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[pkg_name,pkg_ver,pkg_idx_struct,pkg_desc,status,verbose].count(None)+len(args)

    printf_(char('---\nPackage name:\n\t%s\n'),pkg_name)
    printf_(char('Version:\n\t%s\n'),pkg_ver)
    printf_(char('Short description:\n\t%s\n'),pkg_desc)
    printf_(char('Status:\n\t%s\n'),status)
    if (verbose):
        printf_(char('---\nProvides:\n'))
        for i in arange_(1,length_(pkg_idx_struct)).reshape(-1):
            if (not isempty_(pkg_idx_struct[i].functions)):
                printf_(char('%s\n'),pkg_idx_struct[i].category)
                for j in arange_(1,length_(pkg_idx_struct[i].functions)).reshape(-1):
                    printf_(char('\t%s\n'),pkg_idx_struct[i].functions[j])
    return
def fix_version_(v=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[v].count(None)+len(args)

    if (regexp_(v,char('^\\d+(\\.\\d+){1,2}$')) == 1):
        parts=ostrsplit_(v,char('.'),true)
        if (numel_(parts) == 2):
            out=strcat_(v,char('.0'))
        else:
            out=copy_(v)
    else:
        error_(char('bad version string: %s'),v)
    return out
def build_(files=None,handle_deps=None,autoload=None,verbose=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[files,handle_deps,autoload,verbose].count(None)+len(args)

    if (length_(files) < 1):
        error_(char('insufficient number of files'))
    builddir=files[1]
    if (not exist_(builddir,char('dir'))):
        warning_(char('creating build directory %s'),builddir)
        status,msg=mkdir_(builddir,nargout=2)
        if (status != 1):
            error_(char('could not create installation directory: %s'),msg)
    builddir,status=canonicalize_file_name_(builddir,nargout=2)
    if (status != 0):
        error_(char('cannot find directory %s'),builddir)
    installdir=fullfile_(builddir,char('install'))
    if (not exist_(installdir,char('dir'))):
        status,msg=mkdir_(installdir,nargout=2)
        if (status != 1):
            error_(char('could not create installation directory: %s'),msg)
    files[1]=[]
    buildlist=fullfile_(builddir,char('octave_packages'))
    install_(files,handle_deps,autoload,installdir,installdir,verbose,buildlist,char(''),false)
    try:
        repackage_(builddir,buildlist)
    finally:
        unload_packages_([char('all')],handle_deps,buildlist,char(''))
        if (exist_(installdir,char('dir'))):
            rmdir_(installdir,char('s'))
        if (exist_(buildlist,char('file'))):
            unlink_(buildlist)
    return
def get_forge_download_(name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[name].count(None)+len(args)

    ver,url=get_forge_pkg_(name,nargout=2)
    local_file=matlabarray([name,char('-'),ver,char('.tar.gz')])
    return url,local_file
def repackage_(builddir=None,buildlist=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[builddir,buildlist].count(None)+len(args)

    packages=installed_packages_(buildlist,buildlist)
    wd=pwd_()
    for i in arange_(1,length_(packages)).reshape(-1):
        pack=packages[i]
        try:
            cd_(builddir)
            mkdir_(pack.name)
            mkdir_(fullfile_(pack.name,char('inst')))
            copyfile_(fullfile_(pack.dir,char('*')),fullfile_(pack.name,char('inst')))
            movefile_(fullfile_(pack.name,char('inst'),char('packinfo'),char('*')),pack.name)
            if (exist_(fullfile_(pack.name,char('inst'),char('packinfo'),char('.autoload')),char('file'))):
                unlink_(fullfile_(pack.name,char('inst'),char('packinfo'),char('.autoload')))
            rmdir_(fullfile_(pack.name,char('inst'),char('packinfo')))
            if (exist_(fullfile_(pack.name,char('inst'),char('doc')),char('dir'))):
                movefile_(fullfile_(pack.name,char('inst'),char('doc')),pack.name)
            if (exist_(fullfile_(pack.name,char('inst'),char('bin')),char('dir'))):
                movefile_(fullfile_(pack.name,char('inst'),char('bin')),pack.name)
            archdir=fullfile_(pack.archprefix,[pack.name,char('-'),pack.version],getarch_())
            if (exist_(archdir,char('dir'))):
                if (exist_(fullfile_(pack.name,char('inst'),char('PKG_ADD')),char('file'))):
                    unlink_(fullfile_(pack.name,char('inst'),char('PKG_ADD')))
                if (exist_(fullfile_(pack.name,char('inst'),char('PKG_DEL')),char('file'))):
                    unlink_(fullfile_(pack.name,char('inst'),char('PKG_DEL')))
                if (exist_(fullfile_(archdir,char('PKG_ADD')),char('file'))):
                    movefile_(fullfile_(archdir,char('PKG_ADD')),fullfile_(pack.name,char('PKG_ADD')))
                if (exist_(fullfile_(archdir,char('PKG_DEL')),char('file'))):
                    movefile_(fullfile_(archdir,char('PKG_DEL')),fullfile_(pack.name,char('PKG_DEL')))
            else:
                if (exist_(fullfile_(pack.name,char('inst'),char('PKG_ADD')),char('file'))):
                    movefile_(fullfile_(pack.name,char('inst'),char('PKG_ADD')),fullfile_(pack.name,char('PKG_ADD')))
                if (exist_(fullfile_(pack.name,char('inst'),char('PKG_DEL')),char('file'))):
                    movefile_(fullfile_(pack.name,char('inst'),char('PKG_DEL')),fullfile_(pack.name,char('PKG_DEL')))
            tfile=matlabarray([pack.name,char('-'),pack.version,char('.tar')])
            tar_(tfile,pack.name)
            try:
                gzip_(tfile)
                unlink_(tfile)
            finally:
                pass
        finally:
            if (exist_(pack.name,char('dir'))):
                rmdir_(pack.name,char('s'))
            cd_(wd)
    return
def getarchprefix_(desc=None,global_install=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[desc,global_install].count(None)+len(args)

    if (global_install):
        archprefix=fullfile_(octave_config_info_(char('libdir')),char('octave'),char('packages'),[desc.name,char('-'),desc.version])
    else:
        archprefix=desc.dir
    return archprefix
def shell_(cmd=None,verbose=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[cmd,verbose].count(None)+len(args)

    have_sh
    cmd=strrep_(cmd,char('\\'),char('/'))
    if (ispc_() and not isunix_()):
        if (isempty_(have_sh)):
            if (system_(char('sh.exe -c "exit"'))):
                have_sh=copy_(false)
            else:
                have_sh=copy_(true)
        if (have_sh):
            cmd=matlabarray([char('sh.exe -c "'),cmd,char('"')])
        else:
            error_(char('pkg: unable to find the command shell.'))
    output=char('')
    if (verbose):
        status=system_(cmd)
    else:
        status,output=system_(cmd,nargout=2)
    return status,output
def rebuild_(prefix=None,archprefix=None,list=None,files=None,auto=None,verbose=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[prefix,archprefix,_list,files,auto,verbose].count(None)+len(args)

    if (isempty_(files)):
        dirlist,err,msg=readdir_(prefix,nargout=3)
        if (err):
            error_(char("couldn't read directory %s: %s"),prefix,msg)
        dirlist[[1,2]]=[]
    else:
        old_descriptions=installed_packages_(_list,_list)
        wd=pwd_()
        try:
            cd_(prefix)
            dirlist=glob_(strcat_(files,char('-*')))
        finally:
            cd_(wd)
    descriptions=[]
    for k in arange_(1,length_(dirlist)).reshape(-1):
        descfile=fullfile_(prefix,dirlist[k],char('packinfo'),char('DESCRIPTION'))
        if (verbose):
            printf_(char('recreating package description from %s\n'),dirlist[k])
        if (exist_(descfile,char('file'))):
            desc=get_description_(descfile)
            desc.dir=fullfile_(prefix,dirlist[k])
            desc.archprefix=fullfile_(archprefix,[desc.name,char('-'),desc.version])
            if (auto != 0):
                if (exist_(fullfile_(desc.dir,char('packinfo'),char('.autoload')),char('file'))):
                    unlink_(fullfile_(desc.dir,char('packinfo'),char('.autoload')))
                if (auto < 0):
                    desc.autoload=0
                else:
                    if (auto > 0):
                        desc.autoload=1
                        fclose_(fopen_(fullfile_(desc.dir,char('packinfo'),char('.autoload')),char('wt')))
            else:
                if (exist_(fullfile_(desc.dir,char('packinfo'),char('.autoload')),char('file'))):
                    desc.autoload=1
                else:
                    desc.autoload=0
            descriptions[end() + 1]=desc
        else:
            if (verbose):
                warning_(char('directory %s is not a valid package'),dirlist[k])
    if (not isempty_(files)):
        descriptions=[descriptions[:],old_descriptions[:]]
        dup=matlabarray([])
        for i in arange_(1,length_(descriptions)).reshape(-1):
            if (any_(dup == i)):
                continue
            for j in arange_((i + 1),length_(descriptions)).reshape(-1):
                if (any_(dup == j)):
                    continue
                if (strcmp_(descriptions[i].name,descriptions[j].name)):
                    dup=matlabarray([dup,j])
        if (not isempty_(dup)):
            descriptions[dup]=[]
    return descriptions
def fix_depends_(depends=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[depends].count(None)+len(args)

    deps=strtrim_(ostrsplit_(tolower_(depends),char(',')))
    deps_cell=cell_(1,length_(deps))
    dep_pat=char('\\s*(?<name>[-\\w]+)\\s*(\\(\\s*(?<op>[<>=]+)\\s*(?<ver>\\d+\\.\\d+(\\.\\d+)*)\\s*\\))*\\s*')
    for i in arange_(1,length_(deps)).reshape(-1):
        dep=deps[i]
        start,nm=regexp_(dep,dep_pat,char('start'),char('names'),nargout=2)
        if (not isempty_(start)):
            package=tolower_(strtrim_(nm.name))
            if (not isempty_(nm.ver)):
                operator=nm.op
                if (not any_(strcmp_(operator,[char('>'),char('>='),char('<='),char('<'),char('==')]))):
                    error_(char('unsupported operator: %s'),operator)
                version=fix_version_(nm.ver)
            else:
                package=tolower_(strtrim_(dep))
                operator=char('>=')
                version=char('0.0.0')
            deps_cell[i]=struct_(char('package'),package,char('operator'),operator,char('version'),version)
        else:
            error_(char("incorrect syntax for dependency '%s' in the DESCRIPTION file\n"),dep)
    return deps_cell
def write_index_(desc=None,dir=None,index_file=None,global_install=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[desc,_dir,index_file,global_install].count(None)+len(args)

    files,err,msg=readdir_(_dir,nargout=3)
    if (err):
        error_(char("couldn't read directory %s: %s"),_dir,msg)
    class_idx=find_(strncmp_(files,char('@'),1))
    for k in arange_(1,length_(class_idx)).reshape(-1):
        class_name=files[class_idx[k]]
        class_dir=fullfile_(_dir,class_name)
        if (exist_(class_dir,char('dir'))):
            files2,err,msg=readdir_(class_dir,nargout=3)
            if (err):
                error_(char("couldn't read directory %s: %s"),class_dir,msg)
            files2=strcat_(class_name,filesep_(),files2)
            files=matlabarray([[files],[files2]])
    tmpdir=getarchdir_(desc)
    if (exist_(tmpdir,char('dir'))):
        files2,err,msg=readdir_(tmpdir,nargout=3)
        if (err):
            error_(char("couldn't read directory %s: %s"),tmpdir,msg)
        files=matlabarray([[files],[files2]])
    functions=[]
    for i in arange_(1,length_(files)).reshape(-1):
        _file=files[i]
        lf=length_(_file)
        if (lf > 2 and strcmp_(_file[end() - 1:end()],char('.m'))):
            functions[end() + 1]=_file[1:end() - 2]
        else:
            if (lf > 4 and strcmp_(_file[end() - 3:end()],char('.oct'))):
                functions[end() + 1]=_file[1:end() - 4]
    if (not isfield_(desc,char('categories'))):
        error_(char('the DESCRIPTION file must have a Categories field, when no INDEX file is given'))
    categories=strtrim_(strsplit_(desc.categories,char(',')))
    if (length_(categories) < 1):
        error_(char('the Category field is empty'))
    fid=fopen_(index_file,char('w'))
    if (fid == - 1):
        error_(char("couldn't open %s for writing"),index_file)
    fprintf_(fid,char('%s >> %s\n'),desc.name,desc.title)
    fprintf_(fid,char('%s\n'),categories[1])
    fprintf_(fid,char('  %s\n'),functions[:])
    fclose_(fid)
    return
def uninstall_(pkgnames=None,handle_deps=None,verbose=None,local_list=None,global_list=None,global_install=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[pkgnames,handle_deps,verbose,local_list,global_list,global_install].count(None)+len(args)

    local_packages,global_packages=installed_packages_(local_list,global_list,nargout=2)
    if (global_install):
        installed_pkgs_lst=[local_packages[:],global_packages[:]]
    else:
        installed_pkgs_lst=copy_(local_packages)
    num_packages=length_(installed_pkgs_lst)
    delete_idx=matlabarray([])
    for i in arange_(1,num_packages).reshape(-1):
        cur_name=installed_pkgs_lst[i].name
        if (any_(strcmp_(cur_name,pkgnames))):
            delete_idx[end() + 1]=i
    if (length_(delete_idx) != length_(pkgnames)):
        if (global_install):
            installed_pkgs_lst=copy_(local_packages)
            num_packages=length_(installed_pkgs_lst)
            delete_idx=matlabarray([])
            for i in arange_(1,num_packages).reshape(-1):
                cur_name=installed_pkgs_lst[i].name
                if (any_(strcmp_(cur_name,pkgnames))):
                    delete_idx[end() + 1]=i
            if (length_(delete_idx) != length_(pkgnames)):
                warning_(char('some of the packages you want to uninstall are not installed'))
        else:
            warning_(char('some of the packages you want to uninstall are not installed'))
    idx=setdiff_(arange_(1,num_packages),delete_idx)
    remaining_packages=[installed_pkgs_lst[idx]]
    if (handle_deps):
        error_text=char('')
        for i in arange_(1,length_(remaining_packages)).reshape(-1):
            desc=remaining_packages[i]
            bad_deps=get_unsatisfied_deps_(desc,remaining_packages)
            if (not isempty_(bad_deps)):
                for i in arange_(1,length_(bad_deps)).reshape(-1):
                    dep=bad_deps[i]
                    error_text=matlabarray([error_text,char(' '),desc.name,char(' needs '),dep.package,char(' '),dep.operator,char(' '),dep.version,char('\n')])
        if (not isempty_(error_text)):
            error_(char('the following dependencies where unsatisfied:\n  %s'),error_text)
    for i in delete_idx.reshape(-1):
        desc=installed_pkgs_lst[i]
        if (exist_(fullfile_(desc.dir,char('packinfo'),char('on_uninstall.m')),char('file'))):
            wd=pwd_()
            cd_(fullfile_(desc.dir,char('packinfo')))
            on_uninstall_(desc)
            cd_(wd)
        if (desc.loaded):
            rmpath_(desc.dir)
            if (exist_(getarchdir_(desc))):
                rmpath_(getarchdir_(desc))
        if (exist_(desc.dir,char('dir'))):
            status,msg=rmdir_(desc.dir,char('s'),nargout=2)
            if (status != 1 and exist_(desc.dir,char('dir'))):
                error_(char("couldn't delete directory %s: %s"),desc.dir,msg)
            status,msg=rmdir_(getarchdir_(desc),char('s'),nargout=2)
            if (status != 1 and exist_(getarchdir_(desc),char('dir'))):
                error_(char("couldn't delete directory %s: %s"),getarchdir_(desc),msg)
            if (dirempty_(desc.archprefix)):
                rmdir_(desc.archprefix,char('s'))
        else:
            warning_(char('directory %s previously lost'),desc.dir)
    if (global_install):
        if (length_(remaining_packages) == 0):
            unlink_(global_list)
        else:
            global_packages=save_order_(remaining_packages)
            save_(global_list,char('global_packages'))
    else:
        if (length_(remaining_packages) == 0):
            unlink_(local_list)
        else:
            local_packages=save_order_(remaining_packages)
            save_(local_list,char('local_packages'))
    return
def load_package_dirs_(lidx=None,idx=None,handle_deps=None,installed_pkgs_lst=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[lidx,idx,handle_deps,installed_pkgs_lst].count(None)+len(args)

    for i in lidx.reshape(-1):
        if (isfield_(installed_pkgs_lst[i],char('loaded')) and installed_pkgs_lst[i].loaded):
            continue
        else:
            if (not any_(idx == i)):
                idx=matlabarray([i,idx])
            if (handle_deps):
                deps=installed_pkgs_lst[i].depends
                if ((length_(deps) > 1) or (length_(deps) == 1 and not strcmp_(deps[1].package,char('octave')))):
                    tmplidx=matlabarray([])
                    for k in arange_(1,length_(deps)).reshape(-1):
                        for j in arange_(1,length_(installed_pkgs_lst)).reshape(-1):
                            if (strcmp_(installed_pkgs_lst[j].name,deps[k].package)):
                                if (not any_(idx == j)):
                                    tmplidx[end() + 1]=j
                                    break
                    idx=load_package_dirs_(tmplidx,idx,handle_deps,installed_pkgs_lst)
    return idx
def install_(files=None,handle_deps=None,autoload=None,prefix=None,archprefix=None,verbose=None,local_list=None,global_list=None,global_install=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 9-[files,handle_deps,autoload,prefix,archprefix,verbose,local_list,global_list,global_install].count(None)+len(args)

    if (not exist_(prefix,char('dir'))):
        warning_(char('creating installation directory %s'),prefix)
        status,msg=mkdir_(prefix,nargout=2)
        if (status != 1):
            error_(char('could not create installation directory: %s'),msg)
    local_packages,global_packages=installed_packages_(local_list,global_list,nargout=2)
    installed_pkgs_lst=[local_packages[:],global_packages[:]]
    if (global_install):
        packages=copy_(global_packages)
    else:
        packages=copy_(local_packages)
    tmpdirs=packdirs=descriptions=[]
    try:
        for i in arange_(1,length_(files)).reshape(-1):
            if (isempty_(glob_(files[i]))):
                warning_(char('file %s does not exist'),files[i])
        files=glob_(files)
        packages_to_uninstall=matlabarray([])
        for i in arange_(1,length_(files)).reshape(-1):
            tgz=files[i]
            if (exist_(tgz,char('file'))):
                tmpdir=tmpnam_()
                tmpdirs[end() + 1]=tmpdir
                if (verbose):
                    printf_(char('mkdir (%s)\n'),tmpdir)
                status,msg=mkdir_(tmpdir,nargout=2)
                if (status != 1):
                    error_(char("couldn't create temporary directory: %s"),msg)
                if (verbose):
                    printf_(char('untar (%s, %s)\n'),tgz,tmpdir)
                untar_(tgz,tmpdir)
                dirlist,err,msg=readdir_(tmpdir,nargout=3)
                if (err):
                    error_(char("couldn't read directory produced by tar: %s"),msg)
                if (length_(dirlist) > 3):
                    error_(char('bundles of packages are not allowed'))
            if (exist_(tgz,char('dir'))):
                dirlist=[char('.'),char('..'),tgz]
            if (exist_(tgz,char('file')) or exist_(tgz,char('dir'))):
                if (exist_(tgz,char('file'))):
                    packdir=fullfile_(tmpdir,dirlist[3])
                else:
                    packdir=fullfile_(pwd_(),dirlist[3])
                packdirs[end() + 1]=packdir
                verify_directory_(packdir)
                filename=fullfile_(packdir,char('DESCRIPTION'))
                desc=get_description_(filename)
                dummy,nm=fileparts_(tgz,nargout=2)
                if ((length_(nm) >= length_(desc.name)) and not strcmp_(desc.name,nm[1:length_(desc.name)])):
                    error_(char("package name '%s' doesn't correspond to its filename '%s'"),desc.name,nm)
                desc.dir=fullfile_(prefix,[desc.name,char('-'),desc.version])
                desc.archprefix=fullfile_(archprefix,[desc.name,char('-'),desc.version])
                descriptions[end() + 1]=desc
                for j in arange_(1,length_(packages)).reshape(-1):
                    if (strcmp_(packages[j].name,desc.name)):
                        packages_to_uninstall[end() + 1]=j
    finally:
        pass
    if (handle_deps):
        ok=copy_(true)
        error_text=char('')
        for i in arange_(1,length_(descriptions)).reshape(-1):
            desc=descriptions[i]
            idx2=setdiff_(arange_(1,length_(descriptions)),i)
            if (global_install):
                idx1=setdiff_(arange_(1,length_(global_packages)),packages_to_uninstall)
                pseudo_installed_packages=[global_packages[idx1],descriptions[idx2]]
            else:
                idx1=setdiff_(arange_(1,length_(local_packages)),packages_to_uninstall)
                pseudo_installed_packages=[local_packages[idx1],global_packages[:],descriptions[idx2]]
            bad_deps=get_unsatisfied_deps_(desc,pseudo_installed_packages)
            if (not isempty_(bad_deps)):
                ok=copy_(false)
                for i in arange_(1,length_(bad_deps)).reshape(-1):
                    dep=bad_deps[i]
                    error_text=matlabarray([error_text,char(' '),desc.name,char(' needs '),dep.package,char(' '),dep.operator,char(' '),dep.version,char('\n')])
        if (not ok):
            error_(char('the following dependencies were unsatisfied:\n  %s'),error_text)
    try:
        for i in arange_(1,length_(descriptions)).reshape(-1):
            desc=descriptions[i]
            pdir=packdirs[i]
            prepare_installation_(desc,pdir)
            configure_make_(desc,pdir,verbose)
    finally:
        pass
    try:
        for i in packages_to_uninstall.reshape(-1):
            if (global_install):
                uninstall_([global_packages[i].name],false,verbose,local_list,global_list,global_install)
            else:
                uninstall_([local_packages[i].name],false,verbose,local_list,global_list,global_install)
    finally:
        pass
    try:
        for i in arange_(1,length_(descriptions)).reshape(-1):
            desc=descriptions[i]
            pdir=packdirs[i]
            copy_files_(desc,pdir,global_install)
            create_pkgadddel_(desc,pdir,char('PKG_ADD'),global_install)
            create_pkgadddel_(desc,pdir,char('PKG_DEL'),global_install)
            finish_installation_(desc,pdir,global_install)
            generate_lookfor_cache_(desc)
    finally:
        pass
    for i in arange_(length_(descriptions),1,- 1).reshape(-1):
        if (dirempty_(descriptions[i].dir,[char('packinfo'),char('doc')]) and dirempty_(getarchdir_(descriptions[i]))):
            warning_(char('package %s is empty\n'),descriptions[i].name)
            rmdir_(descriptions[i].dir,char('s'))
            rmdir_(getarchdir_(descriptions[i]),char('s'))
            descriptions[i]=[]
    str_true=[char('true'),char('on'),char('yes'),char('1')]
    for i in arange_(length_(descriptions),1,- 1).reshape(-1):
        desc_autoload=copy_(false)
        if (isfield_(descriptions[i],char('autoload'))):
            a=descriptions[i].autoload
            desc_autoload=((isnumeric_(a) and a > 0) or (ischar_(a) and any_(strcmpi_(a,str_true))))
        if (autoload > 0 or (autoload == 0 and desc_autoload)):
            fclose_(fopen_(fullfile_(descriptions[i].dir,char('packinfo'),char('.autoload')),char('wt')))
            descriptions[i].autoload=1
        else:
            descriptions[i].autoload=0
    try:
        if (global_install):
            idx=setdiff_(arange_(1,length_(global_packages)),packages_to_uninstall)
            global_packages=save_order_([global_packages[idx],descriptions[:]])
            save_(global_list,char('global_packages'))
            installed_pkgs_lst=[local_packages[:],global_packages[:]]
        else:
            idx=setdiff_(arange_(1,length_(local_packages)),packages_to_uninstall)
            local_packages=save_order_([local_packages[idx],descriptions[:]])
            save_(local_list,char('local_packages'))
            installed_pkgs_lst=[local_packages[:],global_packages[:]]
    finally:
        pass
    for i in arange_(1,length_(tmpdirs)).reshape(-1):
        status,msg=rmdir_(tmpdirs[i],char('s'),nargout=2)
        if (status != 1 and exist_(tmpdirs[i],char('dir'))):
            warning_(char("couldn't clean up after my self: %s\n"),msg)
    if (length_(descriptions) > 0):
        idx=matlabarray([])
        for i in arange_(1,length_(descriptions)).reshape(-1):
            if (descriptions[i].autoload > 0):
                nm=descriptions[i].name
                for j in arange_(1,length_(installed_pkgs_lst)).reshape(-1):
                    if (strcmp_(nm,installed_pkgs_lst[j].name)):
                        idx[end() + 1]=j
                        break
        load_packages_and_dependencies_(idx,handle_deps,installed_pkgs_lst,global_install)
    if (exist_(char('desc'),char('var')) and exist_(fullfile_(desc.dir,char('packinfo'),char('NEWS')),char('file'))):
        printf_(char("For information about changes from previous versions of the %s package, run 'news %s'.\n"),desc.name,desc.name)
    return
def finish_installation_(desc=None,packdir=None,global_install=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[desc,packdir,global_install].count(None)+len(args)

    if (exist_(fullfile_(packdir,char('post_install.m')),char('file'))):
        wd=pwd_()
        try:
            cd_(packdir)
            post_install_(desc)
            cd_(wd)
        finally:
            pass
    return
def list_forge_packages_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    _list,succ=urlread_(char('http://packages.octave.org/list_packages.php'),nargout=2)
    if (succ):
        _list=ostrsplit_(_list,char(' \n\t'),true)
    else:
        error_(char('pkg: could not read URL, please verify internet connection'))
    if (nargout == 0):
        page_screen_output_(false,char('local'))
        puts_(char('OctaveForge provides these packages:\n'))
        for i in arange_(1,length_(_list)).reshape(-1):
            try:
                ver=get_forge_pkg_(_list[i])
            finally:
                pass
            printf_(char('  %s %s\n'),_list[i],ver)
    return _list
def prepare_installation_(desc=None,packdir=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[desc,packdir].count(None)+len(args)

    if (exist_(fullfile_(packdir,char('pre_install.m')),char('file'))):
        wd=pwd_()
        try:
            cd_(packdir)
            pre_install_(desc)
            cd_(wd)
        finally:
            pass
    inst_dir=fullfile_(packdir,char('inst'))
    if (not exist_(inst_dir,char('dir'))):
        status,msg=mkdir_(inst_dir,nargout=2)
        if (status != 1):
            rmdir_(desc.dir,char('s'))
            error_(char("the 'inst' directory did not exist and could not be created: %s"),msg)
    return
def get_unsatisfied_deps_(desc=None,installed_pkgs_lst=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[desc,installed_pkgs_lst].count(None)+len(args)

    bad_deps=[]
    for i in arange_(1,length_(desc.depends)).reshape(-1):
        dep=desc.depends[i]
        if (strcmp_(dep.package,char('octave'))):
            if (not compare_versions_(OCTAVE_VERSION,dep.version,dep.operator)):
                bad_deps[end() + 1]=dep
        else:
            ok=copy_(false)
            for i in arange_(1,length_(installed_pkgs_lst)).reshape(-1):
                cur_name=installed_pkgs_lst[i].name
                cur_version=installed_pkgs_lst[i].version
                if (strcmp_(dep.package,cur_name) and compare_versions_(cur_version,dep.version,dep.operator)):
                    ok=copy_(true)
                    break
            if (not ok):
                bad_deps[end() + 1]=dep
    return bad_deps
def extract_pkg_(nm=None,pat=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[nm,pat].count(None)+len(args)

    fid=fopen_(nm,char('rt'))
    pkg=char('')
    if (fid >= 0):
        while (not feof_(fid)):

            ln=fgetl_(fid)
            if (ln > 0):
                t=regexp_(ln,pat,char('tokens'))
                if (not isempty_(t)):
                    pkg=matlabarray([pkg,char('\n'),t[1][1]])

        if (not isempty_(pkg)):
            pkg=matlabarray([pkg,char('\n')])
        fclose_(fid)
    return pkg
def describe_(pkgnames=None,verbose=None,local_list=None,global_list=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[pkgnames,verbose,local_list,global_list].count(None)+len(args)

    installed_pkgs_lst=installed_packages_(local_list,global_list)
    num_packages=length_(installed_pkgs_lst)
    describe_all=copy_(false)
    if (any_(strcmp_(char('all'),pkgnames))):
        describe_all=copy_(true)
        flag[1:num_packages]=[char('Not Loaded')]
        num_pkgnames=copy_(num_packages)
    else:
        num_pkgnames=length_(pkgnames)
        flag[1:num_pkgnames]=[char('Not installed')]
    for i in arange_(1,num_packages).reshape(-1):
        curr_name=installed_pkgs_lst[i].name
        if (describe_all):
            name_pos=copy_(i)
        else:
            name_pos=find_(strcmp_(curr_name,pkgnames))
        if (not isempty_(name_pos)):
            if (installed_pkgs_lst[i].loaded):
                flag[name_pos]=char('Loaded')
            else:
                flag[name_pos]=char('Not loaded')
            pkg_desc_list[name_pos].name=installed_pkgs_lst[i].name
            pkg_desc_list[name_pos].version=installed_pkgs_lst[i].version
            pkg_desc_list[name_pos].description=installed_pkgs_lst[i].description
            pkg_desc_list[name_pos].provides=parse_pkg_idx_(installed_pkgs_lst[i].dir)
    non_inst=find_(strcmp_(flag,char('Not installed')))
    if (not isempty_(non_inst)):
        if (nargout < 2):
            non_inst_str=sprintf_(char(' %s '),pkgnames[non_inst])
            error_(char('some packages are not installed: %s'),non_inst_str)
        else:
            pkg_desc_list[non_inst]=struct_(char('name'),[],char('description'),[],char('provides'),[])
    if (nargout == 0):
        for i in arange_(1,num_pkgnames).reshape(-1):
            print_package_description_(pkg_desc_list[i].name,pkg_desc_list[i].version,pkg_desc_list[i].provides,pkg_desc_list[i].description,flag[i],verbose)
    return pkg_desc_list,flag
def installed_packages_(local_list=None,global_list=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[local_list,global_list].count(None)+len(args)

    try:
        local_packages=load_(local_list).local_packages
    finally:
        pass
    try:
        global_packages=load_(global_list).global_packages
    finally:
        pass
    installed_pkgs_lst=[local_packages[:],global_packages[:]]
    dup=matlabarray([])
    for i in arange_(1,length_(installed_pkgs_lst)).reshape(-1):
        if (any_(dup == i)):
            continue
        for j in arange_((i + 1),length_(installed_pkgs_lst)).reshape(-1):
            if (any_(dup == j)):
                continue
            if (strcmp_(installed_pkgs_lst[i].name,installed_pkgs_lst[j].name)):
                dup=matlabarray([dup,j])
    if (not isempty_(dup)):
        installed_pkgs_lst[dup]=[]
    tmppath=strrep_(path_(),char('\\'),char('/'))
    for i in arange_(1,length_(installed_pkgs_lst)).reshape(-1):
        if (strfind_(tmppath,strrep_(installed_pkgs_lst[i].dir,char('\\'),char('/')))):
            installed_pkgs_lst[i].loaded=true
        else:
            installed_pkgs_lst[i].loaded=false
    for i in arange_(1,length_(local_packages)).reshape(-1):
        if (strfind_(tmppath,strrep_(local_packages[i].dir,char('\\'),char('/')))):
            local_packages[i].loaded=true
        else:
            local_packages[i].loaded=false
    for i in arange_(1,length_(global_packages)).reshape(-1):
        if (strfind_(tmppath,strrep_(global_packages[i].dir,char('\\'),char('/')))):
            global_packages[i].loaded=true
        else:
            global_packages[i].loaded=false
    if (nargout == 2):
        out1=copy_(local_packages)
        out2=copy_(global_packages)
        return out1,out2
    else:
        if (nargout == 1):
            out1=copy_(installed_pkgs_lst)
            return out1,out2
    num_packages=length_(installed_pkgs_lst)
    if (num_packages == 0):
        printf_(char('no packages installed.\n'))
        return out1,out2
    h1=char('Package Name')
    h2=char('Version')
    h3=char('Installation directory')
    max_name_length=length_(h1)
    max_version_length=length_(h2)
    names=cell_(num_packages,1)
    for i in arange_(1,num_packages).reshape(-1):
        max_name_length=max_(max_name_length,length_(installed_pkgs_lst[i].name))
        max_version_length=max_(max_version_length,length_(installed_pkgs_lst[i].version))
        names[i]=installed_pkgs_lst[i].name
    max_dir_length=terminal_size_()(2) - max_name_length - max_version_length - 7
    if (max_dir_length < 20):
        max_dir_length=copy_(Inf)
    h1=postpad_(h1,max_name_length + 1,char(' '))
    h2=postpad_(h2,max_version_length,char(' '))
    header=sprintf_(char('%s | %s | %s\n'),h1,h2,h3)
    printf_(header)
    tmp=sprintf_(repmat_(char('-'),1,length_(header) - 1))
    tmp[length_(h1) + 2]=char('+')
    tmp[length_(h1) + length_(h2) + 5]=char('+')
    printf_(char('%s\n'),tmp)
    _format=sprintf_(char('%%%ds %%1s| %%%ds | %%s\n'),max_name_length,max_version_length)
    dummy,idx=sort_(names,nargout=2)
    for i in arange_(1,num_packages).reshape(-1):
        cur_name=installed_pkgs_lst[idx[i]].name
        cur_version=installed_pkgs_lst[idx[i]].version
        cur_dir=installed_pkgs_lst[idx[i]].dir
        if (length_(cur_dir) > max_dir_length):
            first_char=length_(cur_dir) - max_dir_length + 4
            first_filesep=strfind_(cur_dir[first_char:end()],filesep_())
            if (not isempty_(first_filesep)):
                cur_dir=matlabarray([char('...'),cur_dir[(first_char + first_filesep[1] - 1):end()]])
            else:
                cur_dir=matlabarray([char('...'),cur_dir[first_char:end()]])
        if (installed_pkgs_lst[idx[i]].loaded):
            cur_loaded=char('*')
        else:
            cur_loaded=char(' ')
        printf_(_format,cur_name,cur_loaded,cur_version,cur_dir)
    return out1,out2
def load_packages_(files=None,handle_deps=None,local_list=None,global_list=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[files,handle_deps,local_list,global_list].count(None)+len(args)

    installed_pkgs_lst=installed_packages_(local_list,global_list)
    num_packages=length_(installed_pkgs_lst)
    pnames=pdirs=cell_(1,num_packages)
    for i in arange_(1,num_packages).reshape(-1):
        pnames[i]=installed_pkgs_lst[i].name
        pdirs[i]=installed_pkgs_lst[i].dir
    if (length_(files) == 1 and strcmp_(files[1],char('all'))):
        idx=matlabarray([arange_(1,length_(installed_pkgs_lst))])
    else:
        if (length_(files) == 1 and strcmp_(files[1],char('auto'))):
            idx=matlabarray([])
            for i in arange_(1,length_(installed_pkgs_lst)).reshape(-1):
                if (exist_(fullfile_(pdirs[i],char('packinfo'),char('.autoload')),char('file'))):
                    idx[end() + 1]=i
        else:
            idx=matlabarray([])
            for i in arange_(1,length_(files)).reshape(-1):
                idx2=find_(strcmp_(pnames,files[i]))
                if (not any_(idx2)):
                    error_(char('package %s is not installed'),files[i])
                idx[end() + 1]=idx2
    load_packages_and_dependencies_(idx,handle_deps,installed_pkgs_lst,true)
    return
def parse_pkg_idx_(packdir=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[packdir].count(None)+len(args)

    index_file=fullfile_(packdir,char('packinfo'),char('INDEX'))
    if (not exist_(index_file,char('file'))):
        error_(char("could not find any INDEX file in directory %s, try 'pkg rebuild all' to generate missing INDEX files"),packdir)
    fid,msg=fopen_(index_file,char('r'),nargout=2)
    if (fid == - 1):
        error_(char('the INDEX file %s could not be read: %s'),index_file,msg)
    cat_num=1
    pkg_idx_struct[1].category=char('Uncategorized')
    pkg_idx_struct[1].functions=[]
    line=fgetl_(fid)
    while (isempty_(strfind_(line,char('>>'))) and not feof_(fid)):

        line=fgetl_(fid)

    while (not feof_(fid) or line != - 1):

        if (not any_(not isspace_(line)) or line[1] == char('#') or any_(line == char('='))):
            pass
        else:
            if (not isempty_(strfind_(line,char('>>')))):
                pass
            else:
                if (not isspace_(line[1])):
                    if (not isempty_(pkg_idx_struct[cat_num].functions)):
                        pkg_idx_struct[++ cat_num].functions=[]
                    pkg_idx_struct[cat_num].category=deblank_(line)
                else:
                    while (any_(not isspace_(line))):

                        fun_name,line=strtok_(line,nargout=2)
                        pkg_idx_struct[cat_num].functions[end() + 1]=deblank_(fun_name)

        line=fgetl_(fid)

    fclose_(fid)
    return pkg_idx_struct
def is_architecture_dependent_(nm=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[nm].count(None)+len(args)

    archdepsuffix=[char('.oct'),char('.mex'),char('.a'),char('.lib'),char('.so'),char('.so.*'),char('.dll'),char('dylib')]
    dep=copy_(false)
    for i in arange_(1,length_(archdepsuffix)).reshape(-1):
        ext=archdepsuffix[i]
        if (ext[end()] == char('*')):
            isglob=copy_(true)
            ext[end()]=[]
        else:
            isglob=copy_(false)
        pos=strfind_(nm,ext)
        if (pos):
            if (not isglob and (length_(nm) - pos[end()] != length_(ext) - 1)):
                continue
            dep=copy_(true)
            break
    return dep
def unload_packages_(files=None,handle_deps=None,local_list=None,global_list=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[files,handle_deps,local_list,global_list].count(None)+len(args)

    installed_pkgs_lst=installed_packages_(local_list,global_list)
    num_packages=length_(installed_pkgs_lst)
    pnames=pdirs=cell_(1,num_packages)
    for i in arange_(1,num_packages).reshape(-1):
        pnames[i]=installed_pkgs_lst[i].name
        pdirs[i]=installed_pkgs_lst[i].dir
        pdeps[i]=installed_pkgs_lst[i].depends
    p=strtrim_(ostrsplit_(path_(),pathsep_()))
    if (length_(files) == 1 and strcmp_(files[1],char('all'))):
        dirs=copy_(pdirs)
        desc=copy_(installed_pkgs_lst)
    else:
        dirs=[]
        desc=[]
        for i in arange_(1,length_(files)).reshape(-1):
            idx=strcmp_(pnames,files[i])
            if (not any_(idx)):
                error_(char('package %s is not installed'),files[i])
            dirs[end() + 1]=pdirs[idx]
            desc[end() + 1]=installed_pkgs_lst[idx]
    archdirs=[]
    for i in arange_(1,length_(dirs)).reshape(-1):
        tmpdir=getarchdir_(desc[i])
        if (exist_(tmpdir,char('dir'))):
            archdirs[end() + 1]=dirs[i]
            archdirs[end() + 1]=tmpdir
        else:
            archdirs[end() + 1]=dirs[i]
    for i in arange_(1,length_(archdirs)).reshape(-1):
        d=archdirs[i]
        idx=strcmp_(p,d)
        if (any_(idx)):
            rmpath_(d)
    return
def getarchdir_(desc=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[desc].count(None)+len(args)

    archdir=fullfile_(desc.archprefix,getarch_())
    return archdir
def verify_directory_(dir=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[_dir].count(None)+len(args)

    needed_files=[char('COPYING'),char('DESCRIPTION')]
    for f in needed_files.reshape(-1):
        if (not exist_(fullfile_(_dir,f[1]),char('file'))):
            error_(char('package is missing file: %s'),f[1])
    return
def dirempty_(nm=None,ign=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[nm,ign].count(None)+len(args)

    if (exist_(nm,char('dir'))):
        if (nargin < 2):
            ign=[char('.'),char('..')]
        else:
            ign=matlabarray([[char('.'),char('..')],ign])
        l=dir_(nm)
        for i in arange_(1,length_(l)).reshape(-1):
            found=copy_(false)
            for j in arange_(1,length_(ign)).reshape(-1):
                if (strcmp_(l[i].name,ign[j])):
                    found=copy_(true)
                    break
            if (not found):
                emp=copy_(false)
                return emp
        emp=copy_(true)
    else:
        emp=copy_(true)
    return emp
def copy_files_(desc=None,packdir=None,global_install=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[desc,packdir,global_install].count(None)+len(args)

    if (not exist_(desc.dir,char('dir'))):
        status,output=mkdir_(desc.dir,nargout=2)
        if (status != 1):
            error_(char("couldn't create installation directory %s : %s"),desc.dir,output)
    octfiledir=getarchdir_(desc)
    instdir=fullfile_(packdir,char('inst'))
    if (not dirempty_(instdir)):
        status,output=copyfile_(fullfile_(instdir,char('*')),desc.dir,nargout=2)
        if (status != 1):
            rmdir_(desc.dir,char('s'))
            error_(char("couldn't copy files to the installation directory"))
        if (exist_(fullfile_(desc.dir,getarch_()),char('dir')) and not strcmp_(fullfile_(desc.dir,getarch_()),octfiledir)):
            if (not exist_(octfiledir,char('dir'))):
                octm1=fileparts_(octfiledir)
                if (not exist_(octm1,char('dir'))):
                    octm2=fileparts_(octm1)
                    if (not exist_(octm2,char('dir'))):
                        octm3=fileparts_(octm2)
                        if (not exist_(octm3,char('dir'))):
                            status,output=mkdir_(octm3,nargout=2)
                            if (status != 1):
                                rmdir_(desc.dir,char('s'))
                                error_(char("couldn't create installation directory %s : %s"),octm3,output)
                        status,output=mkdir_(octm2,nargout=2)
                        if (status != 1):
                            rmdir_(desc.dir,char('s'))
                            error_(char("couldn't create installation directory %s : %s"),octm2,output)
                    status,output=mkdir_(octm1,nargout=2)
                    if (status != 1):
                        rmdir_(desc.dir,char('s'))
                        error_(char("couldn't create installation directory %s : %s"),octm1,output)
                status,output=mkdir_(octfiledir,nargout=2)
                if (status != 1):
                    rmdir_(desc.dir,char('s'))
                    error_(char("couldn't create installation directory %s : %s"),octfiledir,output)
            status,output=movefile_(fullfile_(desc.dir,getarch_(),char('*')),octfiledir,nargout=2)
            rmdir_(fullfile_(desc.dir,getarch_()),char('s'))
            if (status != 1):
                rmdir_(desc.dir,char('s'))
                rmdir_(octfiledir,char('s'))
                error_(char("couldn't copy files to the installation directory"))
    packinfo=fullfile_(desc.dir,char('packinfo'))
    status,msg=mkdir_(packinfo,nargout=2)
    if (status != 1):
        rmdir_(desc.dir,char('s'))
        rmdir_(octfiledir,char('s'))
        error_(char("couldn't create packinfo directory: %s"),msg)
    packinfo_copy_file_(char('DESCRIPTION'),char('required'),packdir,packinfo,desc,octfiledir)
    packinfo_copy_file_(char('COPYING'),char('required'),packdir,packinfo,desc,octfiledir)
    packinfo_copy_file_(char('CITATION'),char('optional'),packdir,packinfo,desc,octfiledir)
    packinfo_copy_file_(char('NEWS'),char('optional'),packdir,packinfo,desc,octfiledir)
    packinfo_copy_file_(char('ONEWS'),char('optional'),packdir,packinfo,desc,octfiledir)
    packinfo_copy_file_(char('ChangeLog'),char('optional'),packdir,packinfo,desc,octfiledir)
    index_file=fullfile_(packdir,char('INDEX'))
    if (exist_(index_file,char('file'))):
        packinfo_copy_file_(char('INDEX'),char('required'),packdir,packinfo,desc,octfiledir)
    else:
        try:
            write_index_(desc,fullfile_(packdir,char('inst')),fullfile_(packinfo,char('INDEX')),global_install)
        finally:
            pass
    packinfo_copy_file_(char('on_uninstall.m'),char('optional'),packdir,packinfo,desc,octfiledir)
    docdir=fullfile_(packdir,char('doc'))
    if (exist_(docdir,char('dir')) and not dirempty_(docdir)):
        status,output=copyfile_(docdir,desc.dir,nargout=2)
    bindir=fullfile_(packdir,char('bin'))
    if (exist_(bindir,char('dir')) and not dirempty_(bindir)):
        status,output=copyfile_(bindir,desc.dir,nargout=2)
    return
def blackman_(m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[m].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (isscalar_(m) and (m == fix_(m)) and (m > 0))):
        error_(char('blackman: M has to be an integer > 0'))
    if (m == 1):
        c=1
    else:
        m=m - 1
        k=(arange_(0,m)).T / m
        c=0.42 - 0.5 * cos_(2 * pi * k) + 0.08 * cos_(4 * pi * k)
    return c
def arma_rnd_(a=None,b=None,v=None,t=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[a,b,v,t,n].count(None)+len(args)

    if (nargin == 4):
        n=100
    else:
        if (nargin == 5):
            if (not isscalar_(n)):
                error_(char('arma_rnd: N must be a scalar'))
        else:
            print_usage_()
    if ((min_(size_(a)) > 1) or (min_(size_(b)) > 1)):
        error_(char('arma_rnd: A and B must not be matrices'))
    if (not isscalar_(t)):
        error_(char('arma_rnd: T must be a scalar'))
    ar=length_(a)
    br=length_(b)
    a=reshape_(a,ar,1)
    b=reshape_(b,br,1)
    a=matlabarray([[1],[- a]])
    b=matlabarray([[1],[b]])
    n=min_(n,ar + br)
    e=sqrt_(v) * randn_(t + n,1)
    x=filter_(b,a,e)
    x=x[n + 1:t + n]
    return x
def spencer_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    xr,xc=size_(x,nargout=2)
    n=copy_(xr)
    c=copy_(xc)
    if (isvector_(x)):
        n=length_(x)
        c=1
        x=reshape_(x,n,1)
    w=[- 3,- 6,- 5,3,21,46,67,74,67,46,21,3,- 5,- 6,- 3] / 320
    retval=fftfilt_(w,x)
    retval=matlabarray([[zeros_(7,c)],[retval[15:n,:]],[zeros_(7,c)]])
    retval=reshape_(retval,xr,xc)
    return retval
def fftshift_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (nargin == 2):
        if (not (isscalar_(dim) and dim > 0 and dim == fix_(dim))):
            error_(char('fftshift: dimension DIM must be a positive integer'))
        nd=ndims_(x)
        sz=size_(x)
        sz2=ceil_(sz[dim] / 2)
        idx=cell_()
        idx=repmat_([char(':')],nd,1)
        idx[dim]=[arange_(sz2 + 1,sz[dim]),arange_(1,sz2)]
        retval=x[idx[:]]
    else:
        if (isvector_(x)):
            xl=length_(x)
            xx=ceil_(xl / 2)
            retval=x[[arange_(xx + 1,xl),arange_(1,xx)]]
        else:
            if (ismatrix_(x)):
                nd=ndims_(x)
                sz=size_(x)
                sz2=ceil_(sz / 2)
                idx=cell_()
                for i in arange_(1,nd).reshape(-1):
                    idx[i]=[arange_(sz2[i] + 1,sz[i]),arange_(1,sz2[i])]
                retval=x[idx[:]]
            else:
                error_(char('fftshift: expecting vector or matrix argument'))
    return retval
def arch_fit_(y=None,x=None,p=None,iter=None,gamma=None,a0=None,b0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[y,x,p,_iter,gamma,a0,b0].count(None)+len(args)

    if ((nargin < 3) or (nargin == 6) or (nargin > 7)):
        print_usage_()
    if (not (isvector_(y))):
        error_(char('arch_fit: Y must be a vector'))
    T=length_(y)
    y=reshape_(y,T,1)
    rx,cx=size_(x,nargout=2)
    if ((rx == 1) and (cx == 1)):
        x=autoreg_matrix_(y,x)
    else:
        if (not (rx == T)):
            error_(char('arch_fit: either rows (X) == length (Y), or X is a scalar'))
    T,k=size_(x,nargout=2)
    if (nargin == 7):
        a=copy_(a0)
        b=copy_(b0)
        e=y - x * b
    else:
        b,v_b,e=ols_(y,x,nargout=3)
        a=[v_b,(zeros_(1,p))].T
        if (nargin < 5):
            gamma=0.1
            if (nargin < 4):
                _iter=50
    esq=e ** 2
    Z=autoreg_matrix_(esq,p)
    for i in arange_(1,_iter).reshape(-1):
        h=Z * a
        tmp=esq / h ** 2 - 1 / h
        s=1 / h[1:T - p]
        for j in arange_(1,p).reshape(-1):
            s=s - a[j + 1] * tmp[j + 1:T - p + j]
        r=1 / h[1:T - p]
        for j in arange_(1,p).reshape(-1):
            r=r + 2 * h[j + 1:T - p + j] ** 2.dot(esq[1:T - p])
        r=sqrt_(r)
        X_tilde=x[1:T - p,:].dot((r * ones_(1,k)))
        e_tilde=e[1:T - p].dot(s) / r
        delta_b=inv_(X_tilde.T * X_tilde) * X_tilde.T * e_tilde
        b=b + gamma * delta_b
        e=y - x * b
        esq=e ** 2
        Z=autoreg_matrix_(esq,p)
        h=Z * a
        f=esq / h - ones_(T,1)
        Z_tilde=Z / (h * ones_(1,p + 1))
        delta_a=inv_(Z_tilde.T * Z_tilde) * Z_tilde.T * f
        a=a + gamma * delta_a
    return a,b
def sinc_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    result=ones_(size_(x))
    i=(x != 0)
    if (any_(i[:])):
        t=pi * x[i]
        result[i]=sin_(t) / t
    return result
def arch_test_(y=None,x=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[y,x,p].count(None)+len(args)

    if (nargin != 3):
        error_(char('arch_test: 3 input arguments required'))
    if (not (isvector_(y))):
        error_(char('arch_test: Y must be a vector'))
    T=length_(y)
    y=reshape_(y,T,1)
    rx,cx=size_(x,nargout=2)
    if ((rx == 1) and (cx == 1)):
        x=autoreg_matrix_(y,x)
    else:
        if (not (rx == T)):
            error_(char('arch_test: either rows (X) == length (Y), or X is a scalar'))
    if (not (isscalar_(p) and (rem_(p,1) == 0) and (p > 0))):
        error_(char('arch_test: P must be a positive integer'))
    b,v_b,e=ols_(y,x,nargout=3)
    Z=autoreg_matrix_(e ** 2,p)
    f=e ** 2 / v_b - ones_(T,1)
    f=Z.T * f
    lm=f.T * inv_(Z.T * Z) * f / 2
    pval=1 - chi2cdf_(lm,p)
    return pval,lm
def sinewave_(m=None,n=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[m,n,d].count(None)+len(args)

    if (nargin > 0 and nargin < 4):
        if (nargin < 3):
            d=0
        if (nargin < 2):
            n=copy_(m)
        x=sin_(((arange_(1,m)) + d - 1) * 2 * pi / n)
    else:
        print_usage_()
    return x
def bartlett_(m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[m].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (isscalar_(m) and (m == fix_(m)) and (m > 0))):
        error_(char('bartlett: M has to be an integer > 0'))
    if (m == 1):
        c=1
    else:
        m=m - 1
        n=fix_(m / 2)
        c=[2 * (arange_(0,n)) / m,2 - 2 * (arange_(n + 1,m)) / m].T
    return c
def freqz_plot_(w=None,h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[w,h,freq_norm].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    n=length_(w)
    mag=20 * log10_(abs_(h))
    phase=unwrap_(arg_(h))
    if (freq_norm):
        x_label=char('Normalized Frequency (\\times\\pi rad/sample)')
    else:
        x_label=char('Frequency (Hz)')
    subplot_(2,1,1)
    plot_(w,mag)
    grid_(char('on'))
    axis_([w[1],w[n]],char('autoy'))
    xlabel_(x_label)
    ylabel_(char('Magnitude (dB)'))
    subplot_(2,1,2)
    plot_(w,phase * 360 / (2 * pi))
    grid_(char('on'))
    axis_([w[1],w[n]],char('autoy'))
    xlabel_(x_label)
    ylabel_(char('Phase (degrees)'))
    return
def fftconv_(x=None,y=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,n].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not (isvector_(x) and isvector_(y))):
        error_(char('fftconv: both A and B must be vectors'))
    la=length_(x)
    lb=length_(y)
    if ((la == 1) or (lb == 1)):
        c=x * y
    else:
        lc=la + lb - 1
        x[lc]=0
        y[lc]=0
        if (nargin == 2):
            c=fftfilt_(x,y)
        else:
            if (not isscalar_(n)):
                error_(char('fftconv: N must be a scalar'))
            c=fftfilt_(x,y,n)
    return c
def fftfilt_(b=None,x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[b,x,n].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    transpose=(rows_(x) == 1)
    if (transpose):
        x=x.T
    r_x,c_x=size_(x,nargout=2)
    r_b,c_b=size_(b,nargout=2)
    if (not isvector_(b)):
        error_(char('fftfilt: B must be a vector'))
    if (ndims_(x) != 2):
        error_(char('fftfilt: X must be a 1-D or 2-D array'))
    l_b=r_b * c_b
    b=reshape_(b,l_b,1)
    if (nargin == 2):
        n=2 ** nextpow2_(r_x + l_b - 1)
        B=fft_(b,n)
        y=ifft_(fft_(x,n).dot(B[:,ones_(1,c_x)]))
    else:
        if (not (isscalar_(n))):
            error_(char('fftfilt: N has to be a scalar'))
        n=2 ** nextpow2_(max_([n,l_b]))
        L=n - l_b + 1
        B=fft_(b,n)
        B=B[:,ones_(c_x,1)]
        R=ceil_(r_x / L)
        y=zeros_(r_x,c_x)
        for r in arange_(1,R).reshape(-1):
            lo=(r - 1) * L + 1
            hi=min_(r * L,r_x)
            tmp=zeros_(n,c_x)
            tmp[1:(hi - lo + 1),:]=x[lo:hi,:]
            tmp=ifft_(fft_(tmp).dot(B))
            hi=min_(lo + n - 1,r_x)
            y[lo:hi,:]=y[lo:hi,:] + tmp[1:(hi - lo + 1),:]
    y=y[1:r_x,:]
    xisreal=all_(imag_(x) == 0)
    xisimag=all_(real_(x) == 0)
    if (all_(imag_(b) == 0)):
        y[:,xisreal]=real_(y[:,xisreal])
        y[:,xisimag]=complex_(real_(y[:,xisimag]) * 0,imag_(y[:,xisimag]))
    else:
        if (all_(real_(b) == 0)):
            y[:,xisreal]=complex_(real_(y[:,xisreal]) * 0,imag_(y[:,xisreal]))
            y[:,xisimag]=real_(y[:,xisimag])
    if (not any_(b - fix_(b))):
        idx=find_(not any_(x - fix_(x)))
        y[:,idx]=round_(y[:,idx])
    if (transpose):
        y=y.T
    return y
def rectangle_lw_(n=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,b].count(None)+len(args)

    retval=zeros_(n,1)
    t=floor_(1 / b)
    retval[1:t,1]=ones_(t,1)
    return retval
def triangle_lw_(n=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,b].count(None)+len(args)

    retval=1 - (arange_(0,n - 1)).T * b
    retval=max_([[retval.T],[(zeros_(1,n))]]).T
    return retval
def rectangle_sw_(n=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,b].count(None)+len(args)

    retval=zeros_(n,1)
    retval[1]=2 / b + 1
    l=(arange_(2,n)).T - 1
    l=2 * pi * l / n
    retval[2:n]=sin_((2 / b + 1) * l / 2) / sin_(l / 2)
    return retval
def triangle_sw_(n=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,b].count(None)+len(args)

    retval=zeros_(n,1)
    retval[1]=1 / b
    l=(arange_(2,n)).T - 1
    l=2 * pi * l / n
    retval[2:n]=b * (sin_(l / (2 * b)) / sin_(l / 2)) ** 2
    return retval
def diffpara_(x=None,a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    if ((nargin < 1) or (nargin > 3)):
        print_usage_()
    else:
        if (isvector_(x)):
            n=length_(x)
            k=1
            x=reshape_(x,n,1)
        else:
            n,k=size_(x,nargout=2)
        if (nargin == 1):
            a=0.5 * sqrt_(n)
            b=1.5 * sqrt_(n)
        else:
            if (nargin == 2):
                b=copy_(a)
                a=1
    if (not (isscalar_(a) and isscalar_(b))):
        error_(char('diffpara: A and B must be scalars'))
    dd=zeros_(b - a + 1,k)
    for l in arange_(1,k).reshape(-1):
        w=2 * pi * (arange_(1,n - 1)) / n
        x=2 * log_(abs_(1 - exp_(- i * w)))
        y=log_(periodogram_(x[2:n,l]))
        x=center_(x)
        y=center_(y)
        for m in arange_(a,b).reshape(-1):
            dd[m - a + 1]=- x[1:m] * y[1:m] / sumsq_(x[1:m])
    d=mean_(dd)
    return d,dd
def arch_rnd_(a=None,b=None,t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[a,b,t].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not ((min_(size_(a)) == 1) and (min_(size_(b)) == 1))):
        error_(char('arch_rnd: A and B must both be scalars or vectors'))
    if (not (isscalar_(t) and (t > 0) and (rem_(t,1) == 0))):
        error_(char('arch_rnd: T must be a positive integer'))
    if (not (a[1] > 0)):
        error_(char('arch_rnd: A(1) must be positive'))
    la=length_(a)
    a=reshape_(a,1,la)
    if (la == 1):
        a=matlabarray([a,0])
        la=la + 1
    lb=length_(b)
    b=reshape_(b,1,lb)
    if (lb == 1):
        b=matlabarray([b,0])
        lb=lb + 1
    m=max_([la,lb])
    e=zeros_(t,1)
    h=zeros_(t,1)
    y=zeros_(t,1)
    h[1]=a[1]
    e[1]=sqrt_(h[1]) * randn
    y[1]=b[1] + e[1]
    for t in arange_(2,m).reshape(-1):
        ta=min_([t,la])
        h[t]=a[1] + a[2:ta] * e[t - ta + 1:t - 1] ** 2
        e[t]=sqrt_(h[t]) * randn
        tb=min_([t,lb])
        y[t]=b[1] + b[2:tb] * y[t - tb + 1:t - 1] + e[t]
    if (t > m):
        for t in arange_(m + 1,t).reshape(-1):
            h[t]=a[1] + a[2:la] * e[t - la + 1:t - 1] ** 2
            e[t]=sqrt_(h[t]) * randn
            y[t]=b[1] + b[2:lb] * y[t - tb + 1:t - 1] + e[t]
    y=y[1:t]
    return y
def autoreg_matrix_(y=None,k=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[y,k].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not (isvector_(y))):
        error_(char('autoreg_matrix: Y must be a vector'))
    T=length_(y)
    y=reshape_(y,T,1)
    X=ones_(T,k + 1)
    for j in arange_(1,k).reshape(-1):
        X[:,j + 1]=[[(zeros_(j,1))],[y[1:T - j]]]
    return X
def unwrap_(x=None,tol=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,tol,dim].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not isnumeric_(x)):
        error_(char('unwrap: X must be a numeric matrix or vector'))
    if (nargin < 2 or isempty_(tol)):
        tol=copy_(pi)
    tol=abs_(tol)
    nd=ndims_(x)
    sz=size_(x)
    if (nargin == 3):
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('unwrap: DIM must be an integer and a valid dimension'))
    else:
        dim=find_(sz > 1,1) or 1
    rng=2 * pi
    m=sz[dim]
    if (m == 1):
        retval=copy_(x)
        return retval
    idx=repmat_([char(':')],nd,1)
    idx[dim]=[1,arange_(1,m - 1)]
    d=x[idx[:]] - x
    p=ceil_(abs_(d) / rng).dot(rng).dot((((d > tol) > 0) - ((d < - tol) > 0)))
    r=cumsum_(p,dim)
    retval=x + r
    return retval
def hurst_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (isscalar_(x)):
        error_(char('hurst: X must not be a scalar'))
    else:
        if (isvector_(x)):
            x=reshape_(x,length_(x),1)
    xr,xc=size_(x,nargout=2)
    s=std_(x)
    w=cumsum_(x - mean_(x))
    RS=(max_(w) - min_(w)) / s
    H=log_(RS) / log_(xr)
    return H
def yulewalker_(c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[c].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    p=length_(c) - 1
    if (columns_(c) > 1):
        c=c.T
    cp=c[2:p + 1]
    CP=zeros_(p,p)
    for i in arange_(1,p).reshape(-1):
        for j in arange_(1,p).reshape(-1):
            CP[i,j]=c[abs_(i - j) + 1]
    a=inv_(CP) * cp
    v=c[1] - a.T * cp
    return a,v
def freqz_(b=None,a=None,n=None,region=None,Fs=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[b,a,n,region,Fs].count(None)+len(args)

    if (nargin < 1 or nargin > 5):
        print_usage_()
    else:
        if (nargin == 1):
            a=n=region=Fs=matlabarray([])
        else:
            if (nargin == 2):
                n=region=Fs=matlabarray([])
            else:
                if (nargin == 3):
                    region=Fs=matlabarray([])
                else:
                    if (nargin == 4):
                        Fs=matlabarray([])
                        if (not ischar_(region) and not isempty_(region)):
                            Fs=copy_(region)
                            region=matlabarray([])
    if (isempty_(b)):
        b=1
    if (isempty_(a)):
        a=1
    if (isempty_(n)):
        n=512
    if (isempty_(region)):
        if (isreal_(b) and isreal_(a)):
            region=char('half')
        else:
            region=char('whole')
    if (isempty_(Fs)):
        freq_norm=copy_(true)
        if (nargout == 0):
            Fs=2
        else:
            Fs=2 * pi
    else:
        freq_norm=copy_(false)
    a=a[:]
    b=b[:]
    if (not isscalar_(n)):
        w=f=copy_(n)
        if (nargin == 4):
            w=2 * pi * f / Fs
        k=max_(length_(b),length_(a))
        hb=polyval_(postpad_(b,k),exp_(j * w))
        ha=polyval_(postpad_(a,k),exp_(j * w))
    else:
        k=max_(length_(b),length_(a))
        if (k > n / 2 and nargout == 0):
            n=n * 2 ** ceil_(log2_(2 * k / n))
        if (strcmp_(region,char('whole'))):
            N=copy_(n)
        else:
            N=2 * n
        f=Fs * (arange_(0,n - 1)).T / N
        pad_sz=N * ceil_(k / N)
        b=postpad_(b,pad_sz)
        a=postpad_(a,pad_sz)
        hb=zeros_(n,1)
        ha=zeros_(n,1)
        for i in arange_(1,pad_sz,N).reshape(-1):
            hb=hb + fft_(postpad_(b[i:i + N - 1],N))(arange_(1,n))
            ha=ha + fft_(postpad_(a[i:i + N - 1],N))(arange_(1,n))
    h=hb / ha
    if (nargout != 0):
        h_r=copy_(h)
        f_r=copy_(f)
    else:
        freqz_plot_(f,h,freq_norm)
    return h_r,f_r
def durbinlevinson_(c=None,oldphi=None,oldv=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[c,oldphi,oldv].count(None)+len(args)

    if (not ((nargin == 1) or (nargin == 3))):
        print_usage_()
    if (columns_(c) > 1):
        c=c.T
    newphi=0
    newv=0
    if (nargin == 3):
        t=length_(oldphi) + 1
        if (length_(c) < t + 1):
            error_(char('durbinlevinson: C too small'))
        if (oldv == 0):
            error_(char('durbinlevinson: OLDV = 0'))
        if (rows_(oldphi) > 1):
            oldphi=oldphi.T
        newphi=zeros_(1,t)
        newphi[1]=(c[t + 1] - oldphi * c[2:t]) / oldv
        for i in arange_(2,t).reshape(-1):
            newphi[i]=oldphi[i - 1] - newphi[1] * oldphi[t - i + 1]
        newv=(1 - newphi[1] ** 2) * oldv
    else:
        if (nargin == 1):
            tt=length_(c) - 1
            oldphi=c[2] / c[1]
            oldv=(1 - oldphi ** 2) * c[1]
            for t in arange_(2,tt).reshape(-1):
                newphi=zeros_(1,t)
                newphi[1]=(c[t + 1] - oldphi * c[2:t]) / oldv
                for i in arange_(2,t).reshape(-1):
                    newphi[i]=oldphi[i - 1] - newphi[1] * oldphi[t - i + 1]
                newv=(1 - newphi[1] ** 2) * oldv
                oldv=copy_(newv)
                oldphi=copy_(newphi)
    return newphi,newv
def spectral_adf_(c=None,win=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[c,win,b].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    cr=length_(c)
    if (columns_(c) > 1):
        c=c.T
    if (nargin < 3):
        b=1 / ceil_(sqrt_(cr))
    if (nargin == 1):
        w=triangle_lw_(cr,b)
    else:
        if (not ischar_(win)):
            error_(char('spectral_adf: WIN must be a string'))
        else:
            win=str2func_([win,char('_lw')])
            w=feval_(win,cr,b)
    c=c.dot(w)
    retval=2 * real_(fft_(c)) - c[1]
    retval=matlabarray([(zeros_(cr,1)),retval])
    retval[:,1]=(arange_(0,cr - 1)).T / cr
    return retval
def hamming_(m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[m].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (isscalar_(m) and (m == fix_(m)) and (m > 0))):
        error_(char('hamming: M has to be an integer > 0'))
    if (m == 1):
        c=1
    else:
        m=m - 1
        c=0.54 - 0.46 * cos_(2 * pi * (arange_(0,m)).T / m)
    return c
def ifftshift_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    retval=0
    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (nargin == 2):
        if (not isscalar_(dim)):
            error_(char('ifftshift: dimension must be an integer scalar'))
        nd=ndims_(x)
        sz=size_(x)
        sz2=floor_(sz[dim] / 2)
        idx=repmat_([char(':')],nd,1)
        idx[dim]=[arange_(sz2 + 1,sz[dim]),arange_(1,sz2)]
        retval=x[idx[:]]
    else:
        if (isvector_(x)):
            xl=length_(x)
            xx=floor_(xl / 2)
            retval=x[[arange_(xx + 1,xl),arange_(1,xx)]]
        else:
            if (ismatrix_(x)):
                nd=ndims_(x)
                sz=size_(x)
                sz2=floor_(sz / 2)
                idx=cell_()
                for i in arange_(1,nd).reshape(-1):
                    idx[i]=[arange_(sz2[i] + 1,sz[i]),arange_(1,sz2[i])]
                retval=x[idx[:]]
            else:
                error_(char('ifftshift: expecting vector or matrix argument'))
    return retval
def sinetone_(freq=None,rate=None,sec=None,ampl=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[freq,rate,sec,ampl].count(None)+len(args)

    if (nargin == 1):
        rate=8000
        sec=1
        ampl=64
    else:
        if (nargin == 2):
            sec=1
            ampl=64
        else:
            if (nargin == 3):
                ampl=64
            else:
                if ((nargin < 1) or (nargin > 4)):
                    print_usage_()
    err,freq,ampl=common_size_(freq,ampl,nargout=3)
    if (err or not isvector_(freq)):
        error_(char('sinetone: FREQ and AMPL must be vectors of common size'))
    if (not (isscalar_(rate) and isscalar_(sec))):
        error_(char('sinetone: RATE and SEC must be scalars'))
    n=length_(freq)
    ns=round_(rate * sec)
    retval=zeros_(ns,n)
    for k in arange_(1,n).reshape(-1):
        retval[:,k]=ampl[k] * sin_(2 * pi * (arange_(1,ns)) / rate * freq[k]).T
    return retval
def hanning_(m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[m].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (isscalar_(m) and (m == fix_(m)) and (m > 0))):
        error_(char('hanning: M has to be an integer > 0'))
    if (m == 1):
        c=1
    else:
        m=m - 1
        c=0.5 - 0.5 * cos_(2 * pi * (arange_(0,m)).T / m)
    return c
def periodogram_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin < 1 or nargin > 5):
        print_usage_()
    nfft=matlabarray([])
    fs=matlabarray([])
    _range=matlabarray([])
    window=matlabarray([])
    j=1
    for k in arange_(1,length_(varargin)).reshape(-1):
        if (ischar_(varargin[k])):
            _range=varargin[k]
        else:
            if 1 == (j):
                window=varargin[k]
            else:
                if 2 == (j):
                    nfft=varargin[k]
                else:
                    if 3 == (j):
                        fs=varargin[k]
                    else:
                        if 4 == (j):
                            _range=varargin[k]
            j
    r,c=size_(x,nargout=2)
    if (r == 1):
        r=copy_(c)
    if (ischar_(window)):
        _range=copy_(window)
        window=matlabarray([])
    if (ischar_(nfft)):
        _range=copy_(nfft)
        nfft=matlabarray([])
    if (ischar_(fs)):
        _range=copy_(fs)
        fs=matlabarray([])
    if (not isempty_(window)):
        if (all_(size_(x) == size_(window))):
            x .*= window
        else:
            if (rows_(x) == rows_(window) and columns_(window) == 1):
                x .*= window[:,ones_(1,c)]
    if (numel_(nfft) > 1):
        error_(char('nfft must be scalar'))
    if (isempty_(nfft)):
        nfft=max_(256,2.0 ** ceil_(log2_(r)))
    if (strcmp_(_range,char('onesided'))):
        _range=1
    else:
        if (strcmp_(_range,char('twosided'))):
            _range=2
        else:
            _range=2 - isreal_(x)
    if (r > nfft):
        Pxx=0
        rr=rem_(length_(x),nfft)
        if (rr):
            x=matlabarray([[x[:]],[(zeros_(nfft - rr,1))]])
        x=sum_(reshape_(x,nfft,[]),2)
    if (isempty_(window)):
        n=copy_(r)
    else:
        n=sumsq_(window)
    Pxx=(abs_(fft_(x,nfft))) ** 2 / n
    if (nargin < 4):
        Pxx /= 2 * pi
    else:
        if (not isempty_(fs)):
            Pxx /= fs
    if (_range == 1):
        Pxx=Pxx[1:nfft / 2 + 1] + [[0],[Pxx[end():- 1:(nfft / 2 + 2)]],[0]]
    if (nargout != 1):
        if (_range == 1):
            f=(arange_(0,nfft / 2)).T / nfft
        else:
            if (_range == 2):
                f=(arange_(0,nfft - 1)).T / nfft
        if (nargin < 4):
            f *= 2 * pi
        else:
            if (not isempty_(fs)):
                f *= fs
    if (nargout == 0):
        if (nargin < 4):
            plot_(f / (2 * pi),10 * log10_(Pxx))
            xlabel_(char('normalized frequency [x pi rad]'))
            ylabel_(char('Power density [dB/rad/sample]'))
        else:
            plot_(f,10 * log10_(Pxx))
            xlabel_(char('frequency [Hz]'))
            ylabel_(char('Power density [dB/Hz]'))
        grid_(char('on'))
        title_(char('Periodogram Power Spectral Density Estimate'))
    else:
        pxx=copy_(Pxx)
    return pxx,f
def fractdiff_(x=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,d].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    N=100
    if (not isvector_(x)):
        error_(char('fractdiff: X must be a vector'))
    if (not isscalar_(d)):
        error_(char('fractdiff: D must be a scalar'))
    if (d >= 1):
        for k in arange_(1,d).reshape(-1):
            x=x[2:length_(x)] - x[1:length_(x) - 1]
    if (d > - 1):
        d=rem_(d,1)
        if (d != 0):
            n=(arange_(0,N)).T
            w=real_(gamma_(- d + n) / gamma_(- d) / gamma_(n + 1))
            retval=fftfilt_(w,x)
            retval=retval[1:length_(x)]
        else:
            retval=copy_(x)
    else:
        error_(char('fractdiff: D must be > -1'))
    return retval
def filter2_(b=None,x=None,shape=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[b,x,shape].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (nargin < 3):
        shape=char('same')
    nr,nc=size_(b,nargout=2)
    y=conv2_(x,b[nr:- 1:1,nc:- 1:1],shape)
    return y
def detrend_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,p].count(None)+len(args)

    if (nargin > 0 and isreal_(x) and ndims_(x) <= 2):
        if (ischar_(p) and strcmpi_(p,char('constant'))):
            p=0
        else:
            if (ischar_(p) and strcmpi_(p,char('linear'))):
                p=1
            else:
                if (not isscalar_(p) or p < 0 or p != fix_(p)):
                    error_(char("detrend: second input argument must be 'constant', 'linear' or a positive integer"))
    else:
        error_(char('detrend: first input argument must be a real vector or matrix'))
    m,n=size_(x,nargout=2)
    if (m == 1):
        x=x.T
    r=rows_(x)
    b=((arange_(1,r)).T * ones_(1,p + 1)) ** (ones_(r,1) * (arange_(0,p)))
    y=x - b * (numpy.linalg.solve(b,x))
    if (m == 1):
        y=y.T
    return y
def spectral_xdf_(x=None,win=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,win,b].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    xr=length_(x)
    if (columns_(x) > 1):
        x=x.T
    if (nargin < 3):
        b=1 / ceil_(sqrt_(xr))
    if (nargin == 1):
        w=triangle_sw_(xr,b)
    else:
        if (not ischar_(win)):
            error_(char('spectral_xdf: WIN must be a string'))
        else:
            win=str2func_([win,char('_sw')])
            w=feval_(win,xr,b)
    x=x - sum_(x) / xr
    retval=(abs_(fft_(x)) / xr) ** 2
    retval=real_(ifft_(fft_(retval).dot(fft_(w))))
    retval=matlabarray([(zeros_(xr,1)),retval])
    retval[:,1]=(arange_(0,xr - 1)).T / xr
    return retval
def pqpnonneg_(c=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[c,d,x,options].count(None)+len(args)

    if (nargin == 1 and ischar_(c) and strcmp_(c,char('defaults'))):
        x=optimset_(char('MaxIter'),100000.0)
        return x,minval,exitflag,output,_lambda
    if (not (nargin >= 2 and nargin <= 4 and ismatrix_(c) and ismatrix_(d) and isstruct_(options))):
        print_usage_()
    m=rows_(c)
    n=columns_(c)
    if (m != n):
        error_(char('pqpnonneg: matrix must be square'))
    if (isempty_(x)):
        x=zeros_(n,1)
    else:
        x=max_(x,0)
    max_iter=optimget_(options,char('MaxIter'),100000.0)
    p=find_(x > 0).T
    r=chol_(c[p,p])
    usechol=copy_(true)
    _iter=0
    while (_iter < max_iter):

        while (_iter < max_iter):

            _iter
            if (usechol):
                xtmp=- (numpy.linalg.solve(r,(numpy.linalg.solve(r.T,d[p]))))
            else:
                xtmp=- (numpy.linalg.solve(c[p,p],d[p]))
            idx=find_(xtmp < 0)
            if (isempty_(idx)):
                x[:]=0
                x[p]=xtmp
                break
            else:
                pidx=p[idx]
                sf=x[pidx] / (x[pidx] - xtmp[idx])
                alpha=min_(sf)
                xx=zeros_(n,1)
                xx[p]=xtmp
                x += alpha * (xx - x)
                idx=idx[sf == alpha]
                p[idx]=[]
                if (usechol):
                    r=choldelete_(r,idx)

        w=- (d + c * x)
        w[p]=[]
        if (not any_(w > 0)):
            if (usechol):
                usechol=copy_(false)
                continue
            else:
                break
        idx=find_(w == max_(w))
        if (numel_(idx) > 1):
            warning_(char('pqpnonneg:nonunique'),char('a non-unique solution may be returned due to equal gradients'))
            idx=idx[1]
        z=matlabarray([arange_(1,n)])
        z[p]=[]
        zidx=z[idx]
        jdx=1 + lookup_(p,zidx)
        p=matlabarray([p[1:jdx - 1],zidx,p[jdx:end()]])
        if (usechol):
            r,bad=cholinsert_(r,jdx,c[p,zidx],nargout=2)
            if (bad):
                usechol=copy_(false)

    if (nargout > 1):
        minval=1 / 2 * (x.T * c * x) + d.T * x
    exitflag=copy_(_iter)
    if (nargout > 2 and _iter >= max_iter):
        exitflag=0
    if (nargout > 3):
        output=struct_(char('algorithm'),char('nnls-pqp'),char('iterations'),_iter)
    if (nargout > 4):
        _lambda=zeros_(size_(x))
        _lambda[p]=w
    return x,minval,exitflag,output,_lambda
def qp_(x0=None,H=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x0,H].count(None)+len(args)

    nargs=copy_(nargin)
    if (nargin == 1 and ischar_(x0) and strcmp_(x0,char('defaults'))):
        x=optimset_(char('MaxIter'),200)
        return x,obj,INFO,_lambda
    if (nargs > 2 and isstruct_(varargin[end()])):
        options=varargin[end()]
        nargs
    else:
        options=struct_()
    if (nargs >= 3):
        q=varargin[1]
    else:
        q=matlabarray([])
    if (nargs >= 5):
        A=varargin[2]
        b=varargin[3]
    else:
        A=matlabarray([])
        b=matlabarray([])
    if (nargs >= 7):
        lb=varargin[4]
        ub=varargin[5]
    else:
        lb=matlabarray([])
        ub=matlabarray([])
    if (nargs == 10):
        A_lb=varargin[6]
        A_in=varargin[7]
        A_ub=varargin[8]
    else:
        A_lb=matlabarray([])
        A_in=matlabarray([])
        A_ub=matlabarray([])
    if (nargs == 2 or nargs == 3 or nargs == 5 or nargs == 7 or nargs == 10):
        maxit=optimget_(options,char('MaxIter'),200)
        if (not issquare_(H)):
            error_(char('qp: quadratic penalty matrix not square'))
        else:
            if (not ishermitian_(H)):
                H=(H + H.T) / 2
        n=rows_(H)
        if (isempty_(x0)):
            x0=zeros_(n,1)
        else:
            if (numel_(x0) != n):
                error_(char('qp: the initial guess has incorrect length'))
        if (isempty_(q)):
            q=zeros_(n,1)
        else:
            if (numel_(q) != n):
                error_(char('qp: the linear term has incorrect length'))
        if (isempty_(A) or isempty_(b)):
            A=zeros_(0,n)
            b=zeros_(0,1)
            n_eq=0
        else:
            n_eq,n1=size_(A,nargout=2)
            if (n1 != n):
                error_(char('qp: equality constraint matrix has incorrect column dimension'))
            if (numel_(b) != n_eq):
                error_(char('qp: equality constraint matrix and vector have inconsistent dimension'))
        Ain=zeros_(0,n)
        _bin=zeros_(0,1)
        n_in=0
        if (nargs > 5):
            if (not isempty_(lb)):
                if (numel_(lb) != n):
                    error_(char('qp: lower bound has incorrect length'))
                else:
                    if (isempty_(ub)):
                        Ain=matlabarray([[Ain],[eye_(n)]])
                        _bin=matlabarray([[_bin],[lb]])
            if (not isempty_(ub)):
                if (numel_(ub) != n):
                    error_(char('qp: upper bound has incorrect length'))
                else:
                    if (isempty_(lb)):
                        Ain=matlabarray([[Ain],[- eye_(n)]])
                        _bin=matlabarray([[_bin],[- ub]])
            if (not isempty_(lb) and not isempty_(ub)):
                rtol=sqrt_(eps)
                for i in arange_(1,n).reshape(-1):
                    if (abs_(lb[i] - ub[i]) < rtol * (1 + max_(abs_(lb[i] + ub[i])))):
                        tmprow=zeros_(1,n)
                        tmprow[i]=1
                        A=matlabarray([[A],[tmprow]])
                        b=matlabarray([[b],[0.5 * (lb[i] + ub[i])]])
                        n_eq=n_eq + 1
                    else:
                        tmprow=zeros_(1,n)
                        tmprow[i]=1
                        Ain=matlabarray([[Ain],[tmprow],[- tmprow]])
                        _bin=matlabarray([[_bin],[lb[i]],[- ub[i]]])
                        n_in=n_in + 2
        if (nargs > 7):
            dimA_in,n1=size_(A_in,nargout=2)
            if (n1 != n):
                error_(char('qp: inequality constraint matrix has incorrect column dimension'))
            else:
                if (not isempty_(A_lb)):
                    if (numel_(A_lb) != dimA_in):
                        error_(char('qp: inequality constraint matrix and lower bound vector inconsistent'))
                    else:
                        if (isempty_(A_ub)):
                            Ain=matlabarray([[Ain],[A_in]])
                            _bin=matlabarray([[_bin],[A_lb]])
                if (not isempty_(A_ub)):
                    if (numel_(A_ub) != dimA_in):
                        error_(char('qp: inequality constraint matrix and upper bound vector inconsistent'))
                    else:
                        if (isempty_(A_lb)):
                            Ain=matlabarray([[Ain],[- A_in]])
                            _bin=matlabarray([[_bin],[- A_ub]])
                if (not isempty_(A_lb) and not isempty_(A_ub)):
                    rtol=sqrt_(eps)
                    for i in arange_(1,dimA_in).reshape(-1):
                        if (abs_(A_lb[i] - A_ub[i]) < rtol * (1 + max_(abs_(A_lb[i] + A_ub[i])))):
                            tmprow=A_in[i,:]
                            A=matlabarray([[A],[tmprow]])
                            b=matlabarray([[b],[0.5 * (A_lb[i] + A_ub[i])]])
                            n_eq=n_eq + 1
                        else:
                            tmprow=A_in[i,:]
                            Ain=matlabarray([[Ain],[tmprow],[- tmprow]])
                            _bin=matlabarray([[_bin],[A_lb[i]],[- A_ub[i]]])
                            n_in=n_in + 2
        idx=isinf_(_bin) and _bin < 0
        _bin[idx]=[]
        Ain[idx,:]=[]
        n_in=numel_(_bin)
        if (isa_(x0,char('single')) or isa_(H,char('single')) or isa_(q,char('single')) or isa_(A,char('single')) or isa_(b,char('single'))):
            rtol=sqrt_(eps_(char('single')))
        else:
            rtol=sqrt_(eps)
        eq_infeasible=(n_eq > 0 and norm_(A * x0 - b) > rtol * (1 + abs_(b)))
        in_infeasible=(n_in > 0 and any_(Ain * x0 - _bin < - rtol * (1 + abs_(_bin))))
        info=0
        if (eq_infeasible or in_infeasible):
            if (eq_infeasible):
                if (rank_(A) < n_eq):
                    error_(char('qp: equality constraint matrix must be full row rank'))
                xbar=pinv_(A) * b
            else:
                xbar=copy_(x0)
            if (n_in > 0):
                res=Ain * xbar - _bin
                if (any_(res < - rtol * (1 + abs_(_bin)))):
                    if (n_eq > 0):
                        Z=null_(A)
                        if (isempty_(Z)):
                            info=6
                    if (info != 6):
                        gamma=eye_(n_in)
                        if (n_eq > 0):
                            Atmp=matlabarray([Ain * Z,gamma])
                            btmp=- res
                        else:
                            Atmp=matlabarray([Ain,gamma])
                            btmp=copy_(_bin)
                        ctmp=matlabarray([[zeros_(n - n_eq,1)],[ones_(n_in,1)]])
                        lb=matlabarray([[- Inf_(n - n_eq,1)],[zeros_(n_in,1)]])
                        ub=matlabarray([])
                        ctype=repmat_(char('L'),n_in,1)
                        P,dummy,status=glpk_(ctmp,Atmp,btmp,lb,ub,ctype,nargout=3)
                        if ((status == 0) and all_(abs_(P[n - n_eq + 1:end()]) < rtol * (1 + norm_(btmp)))):
                            if (n_eq > 0):
                                x0=xbar + Z * P[1:n - n_eq]
                            else:
                                x0=P[1:n]
                        else:
                            info=6
                else:
                    x0=copy_(xbar)
            else:
                x0=copy_(xbar)
        if (info == 0):
            x,_lambda,info,_iter=__qp___(x0,H,q,A,b,Ain,_bin,maxit,nargout=4)
        else:
            _iter=0
            x=copy_(x0)
            _lambda=matlabarray([])
        obj=0.5 * x.T * H * x + q.T * x
        INFO.solveiter=_iter
        INFO.info=info
    else:
        print_usage_()
    return x,obj,INFO,_lambda
def glpk_(c=None,A=None,b=None,lb=None,ub=None,ctype=None,vartype=None,sense=None,param=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 9-[c,A,b,lb,ub,ctype,vartype,sense,param].count(None)+len(args)

    if (nargin < 3 or nargin > 9):
        print_usage_()
        return xopt,fmin,errnum,extra
    if (all_(size_(c) > 1) or iscomplex_(c) or ischar_(c)):
        error_(char('glpk:C must be a real vector'))
        return xopt,fmin,errnum,extra
    nx=length_(c)
    c=c[:]
    if (isempty_(A)):
        error_(char('glpk: A cannot be an empty matrix'))
        return xopt,fmin,errnum,extra
    nc,nxa=size_(A,nargout=2)
    if (not isreal_(A) or nxa != nx):
        error_(char('glpk: A must be a real valued %d by %d matrix'),nc,nx)
        return xopt,fmin,errnum,extra
    if (isempty_(b)):
        error_(char('glpk: B cannot be an empty vector'))
        return xopt,fmin,errnum,extra
    if (not isreal_(b) or length_(b) != nc):
        error_(char('glpk: B must be a real valued %d by 1 vector'),nc)
        return xopt,fmin,errnum,extra
    if (nargin > 3):
        if (isempty_(lb)):
            lb=zeros_(nx,1)
        else:
            if (not isreal_(lb) or all_(size_(lb) > 1) or length_(lb) != nx):
                error_(char('glpk: LB must be a real valued %d by 1 column vector'),nx)
                return xopt,fmin,errnum,extra
    else:
        lb=zeros_(nx,1)
    if (nargin > 4):
        if (isempty_(ub)):
            ub=Inf_(nx,1)
        else:
            if (not isreal_(ub) or all_(size_(ub) > 1) or length_(ub) != nx):
                error_(char('glpk: UB must be a real valued %d by 1 column vector'),nx)
                return xopt,fmin,errnum,extra
    else:
        ub=Inf_(nx,1)
    if (nargin > 5):
        if (isempty_(ctype)):
            ctype=repmat_(char('S'),nc,1)
        else:
            if (not ischar_(ctype) or all_(size_(ctype) > 1) or length_(ctype) != nc):
                error_(char('glpk: CTYPE must be a char valued vector of length %d'),nc)
                return xopt,fmin,errnum,extra
            else:
                if (not all_(ctype == char('F') or ctype == char('U') or ctype == char('S') or ctype == char('L') or ctype == char('D'))):
                    error_(char('glpk: CTYPE must contain only F, U, S, L, or D'))
                    return xopt,fmin,errnum,extra
    else:
        ctype=repmat_(char('S'),nc,1)
    if (nargin > 6):
        if (isempty_(vartype)):
            vartype=repmat_(char('C'),nx,1)
        else:
            if (not ischar_(vartype) or all_(size_(vartype) > 1) or length_(vartype) != nx):
                error_(char('glpk: VARTYPE must be a char valued vector of length %d'),nx)
                return xopt,fmin,errnum,extra
            else:
                if (not all_(vartype == char('C') or vartype == char('I'))):
                    error_(char('glpk: VARTYPE must contain only C or I'))
                    return xopt,fmin,errnum,extra
    else:
        vartype=repmat_(char('C'),nx,1)
    if (nargin > 7):
        if (isempty_(sense)):
            sense=1
        else:
            if (ischar_(sense) or all_(size_(sense) > 1) or not isreal_(sense)):
                error_(char('glpk: SENSE must be an integer value'))
            else:
                if (sense >= 0):
                    sense=1
                else:
                    sense=- 1
    else:
        sense=1
    if (nargin > 8):
        if (not isstruct_(param)):
            error_(char('glpk: PARAM must be a structure'))
            return xopt,fmin,errnum,extra
    else:
        param=struct_()
    xopt,fmin,errnum,extra=__glpk___(c,A,b,lb,ub,ctype,vartype,sense,param,nargout=4)
    return xopt,fmin,errnum,extra
def __all_opts___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    saved_names=[]
    mlock_()
    recursive=copy_(false)
    if (recursive):
        names=[]
    else:
        if (nargin == 0):
            names=copy_(saved_names)
        else:
            recursive=copy_(true)
            names=copy_(saved_names)
            for i in arange_(1,nargin).reshape(-1):
                try:
                    opts=optimset_(varargin[i])
                    fn=fieldnames_(opts).T
                    names=matlabarray([names,fn])
                finally:
                    pass
            names=unique_(names)
            lnames,idx=unique_(tolower_(names),nargout=2)
            if (length_(lnames) < length_(names)):
                error_(char('__all_opts__: duplicate options with inconsistent case'))
            else:
                names=names[idx]
            saved_names=copy_(names)
            recursive=copy_(false)
    return names
def __fdjac___(fcn=None,x=None,fvec=None,typicalx=None,cdif=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[fcn,x,fvec,typicalx,cdif,err].count(None)+len(args)

    if (cdif):
        err=(max_(eps,err)) ** (1 / 3)
        h=typicalx * err
        fjac=zeros_(length_(fvec),numel_(x))
        for i in arange_(1,numel_(x)).reshape(-1):
            x1=x2=copy_(x)
            x1[i] += h[i]
            x2[i] -= h[i]
            fjac[:,i]=(fcn[x1](arange_()) - fcn[x2](arange_())) / (x1[i] - x2[i])
    else:
        err=sqrt_(max_(eps,err))
        h=typicalx * err
        fjac=zeros_(length_(fvec),numel_(x))
        for i in arange_(1,numel_(x)).reshape(-1):
            x1=copy_(x)
            x1[i] += h[i]
            fjac[:,i]=(fcn[x1](arange_()) - fvec) / (x1[i] - x[i])
    return fjac
def fzero_(fun=None,x0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[fun,x0,options].count(None)+len(args)

    if (nargin == 1 and ischar_(fun) and strcmp_(fun,char('defaults'))):
        x=optimset_(char('MaxIter'),Inf,char('MaxFunEvals'),Inf,char('TolX'),1e-08,char('OutputFcn'),[],char('FunValCheck'),char('off'))
        return x,fval,info,output
    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (ischar_(fun)):
        fun=str2func_(fun,char('global'))
    funvalchk=strcmpi_(optimget_(options,char('FunValCheck'),char('off')),char('on'))
    outfcn=optimget_(options,char('OutputFcn'))
    tolx=optimget_(options,char('TolX'),1e-08)
    maxiter=optimget_(options,char('MaxIter'),Inf)
    maxfev=optimget_(options,char('MaxFunEvals'),Inf)
    mu=0.5
    if (funvalchk):
        fun=lambda x: guarded_eval_(fun,x)
    info=0
    niter=0
    nfev=0
    x=fval=a=fa=b=fb=copy_(NaN)
    eps=eps_(class_(x0))
    a=x0[1]
    fa=fun[a]
    nfev=1
    if (length_(x0) > 1):
        b=x0[2]
        fb=fun[b]
        nfev += 1
    else:
        if (a == 0):
            aa=1
        else:
            aa=copy_(a)
        for b in [0.9 * aa,1.1 * aa,aa - 1,aa + 1,0.5 * aa,1.5 * aa,- aa,2 * aa,- 10 * aa,10 * aa].reshape(-1):
            fb=fun[b]
            nfev += 1
            if (sign_(fa) * sign_(fb) <= 0):
                break
    if (b < a):
        u=copy_(a)
        a=copy_(b)
        b=copy_(u)
        fu=copy_(fa)
        fa=copy_(fb)
        fb=copy_(fu)
    if (not (sign_(fa) * sign_(fb) <= 0)):
        error_(char('fzero:bracket'),char('fzero: not a valid initial bracketing'))
    slope0=(fb - fa) / (b - a)
    if (fa == 0):
        b=copy_(a)
        fb=copy_(fa)
    else:
        if (fb == 0):
            a=copy_(b)
            fa=copy_(fb)
    itype=1
    if (abs_(fa) < abs_(fb)):
        u=copy_(a)
        fu=copy_(fa)
    else:
        u=copy_(b)
        fu=copy_(fb)
    d=e=copy_(u)
    fd=fe=copy_(fu)
    mba=mu * (b - a)
    while (niter < maxiter and nfev < maxfev):

        if 1 == (itype):
            if (b - a <= 2 * (2 * abs_(u) * eps + tolx)):
                x=copy_(u)
                fval=copy_(fu)
                info=1
                break
            if (abs_(fa) <= 1000.0 * abs_(fb) and abs_(fb) <= 1000.0 * abs_(fa)):
                c=u - (a - b) / (fa - fb) * fu
            else:
                c=0.5 * (a + b)
            d=copy_(u)
            fd=copy_(fu)
            itype=5
        else:
            if [2,3] == (itype):
                l=length_(unique_([fa,fb,fd,fe]))
                if (l == 4):
                    q11=(d - e) * fd / (fe - fd)
                    q21=(b - d) * fb / (fd - fb)
                    q31=(a - b) * fa / (fb - fa)
                    d21=(b - d) * fd / (fd - fb)
                    d31=(a - b) * fb / (fb - fa)
                    q22=(d21 - q11) * fb / (fe - fb)
                    q32=(d31 - q21) * fa / (fd - fa)
                    d32=(d31 - q21) * fd / (fd - fa)
                    q33=(d32 - q22) * fa / (fe - fa)
                    c=a + q31 + q32 + q33
                if (l < 4 or sign_(c - a) * sign_(c - b) > 0):
                    a0=copy_(fa)
                    a1=(fb - fa) / (b - a)
                    a2=((fd - fb) / (d - b) - a1) / (d - a)
                    c=a - a0 / a1
                    if (a2 != 0):
                        c=a - a0 / a1
                        for i in arange_(1,itype).reshape(-1):
                            pc=a0 + (a1 + a2 * (c - b)) * (c - a)
                            pdc=a1 + a2 * (2 * c - a - b)
                            if (pdc == 0):
                                c=a - a0 / a1
                                break
                            c -= pc / pdc
                itype += 1
            else:
                if 4 == (itype):
                    c=u - 2 * (b - a) / (fb - fa) * fu
                    if (abs_(c - u) > 0.5 * (b - a)):
                        c=0.5 * (b + a)
                    itype=5
                else:
                    if 5 == (itype):
                        c=0.5 * (b + a)
                        itype=2
        delta=2 * 0.7 * (2 * abs_(u) * eps + tolx)
        if ((b - a) <= 2 * delta):
            c=(a + b) / 2
        else:
            c=max_(a + delta,min_(b - delta,c))
        x=copy_(c)
        fval=fc=fun[c]
        niter
        nfev
        if (sign_(fc - fa) * sign_(fc - fb) >= 0):
            fe=copy_(fc)
        else:
            e=copy_(d)
            fe=copy_(fd)
        if (sign_(fa) * sign_(fc) < 0):
            d=copy_(b)
            fd=copy_(fb)
            b=copy_(c)
            fb=copy_(fc)
        else:
            if (sign_(fb) * sign_(fc) < 0):
                d=copy_(a)
                fd=copy_(fa)
                a=copy_(c)
                fa=copy_(fc)
            else:
                if (fc == 0):
                    a=b=copy_(c)
                    fa=fb=copy_(fc)
                    info=1
                    break
                else:
                    error_(char('fzero:bracket'),char('fzero: zero point is not bracketed'))
        if (outfcn):
            optv.funccount=nfev
            optv.fval=fval
            optv.iteration=niter
            if (outfcn[x,optv,char('iter')]):
                info=- 1
                break
        if (abs_(fa) < abs_(fb)):
            u=copy_(a)
            fu=copy_(fa)
        else:
            u=copy_(b)
            fu=copy_(fb)
        if (b - a <= 2 * (2 * abs_(u) * eps + tolx)):
            info=1
            break
        if (itype == 5 and (b - a) <= mba):
            itype=2
        if (itype == 2):
            mba=mu * (b - a)

    if (info == 1):
        if ((b - a) != 0 and abs_((fb - fa) / (b - a) / slope0) > max_(1000000.0,0.5 / (eps + tolx))):
            info=- 5
    output.iterations=niter
    output.funcCount=nfev
    output.bracketx=[a,b]
    output.brackety=[fa,fb]
    return x,fval,info,output
def guarded_eval_(fun=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[fun,x].count(None)+len(args)

    fx=fun[x]
    fx=fx[1]
    if (not isreal_(fx)):
        error_(char('fzero:notreal'),char('fzero: non-real value encountered'))
    else:
        if (isnan_(fx)):
            error_(char('fzero:isnan'),char('fzero: NaN value encountered'))
    return fx
def fminsearch_(fun=None,x0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[fun,x0,options].count(None)+len(args)

    if (nargin == 1 and ischar_(fun) and strcmp_(fun,char('defaults'))):
        x=optimset_(char('Display'),char('notify'),char('FunValCheck'),char('off'),char('MaxFunEvals'),400,char('MaxIter'),400,char('OutputFcn'),[],char('TolFun'),1e-07,char('TolX'),0.0001)
        return x,fval
    if (nargin < 2 or nargin > 3):
        print_usage_()
    x=nmsmax_(fun,x0,options)
    if (isargout_(2)):
        fval=feval_(fun,x)
    return x,fval
def parse_options_(options=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[options,x].count(None)+len(args)

    stopit[1]=tol=optimget_(options,char('TolX'),0.0001)
    stopit[2]=optimget_(options,char('MaxFunEvals'),length_(x) * 200)
    maxiter=optimget_(options,char('MaxIter'),length_(x) * 200)
    stopit[3]=Inf
    stopit[4]=0
    display=optimget_(options,char('Display'),char('notify'))
    if (strcmp_(display,char('iter'))):
        stopit[5]=1
    else:
        stopit[5]=0
    trace=stopit[5]
    stopit[6]=dirn=- 1
    savit=matlabarray([])
    return stopit,savit,dirn,trace,tol,maxiter
def nmsmax_(fun=None,x=None,options=None,savit=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[fun,x,options,savit].count(None)+len(args)

    stopit,savit,dirn,trace,tol,maxiter=parse_options_(options,x,nargout=6)
    if (strcmpi_(optimget_(options,char('FunValCheck'),char('off')),char('on'))):
        fun=lambda x: guarded_eval_(fun,x)
    x0=x[:]
    n=length_(x0)
    V=matlabarray([zeros_(n,1),eye_(n)])
    f=zeros_(n + 1,1)
    V[:,1]=x0
    f[1]=dirn * feval_(fun,x,varargin[:])
    fmax_old=f[1]
    if (trace):
        fprintf_(char('f(x0) = %9.4e\n'),f[1])
    k=0
    m=0
    scale=max_(norm_(x0,Inf),1)
    if (stopit[4] == 0):
        alpha=scale / (n * sqrt_(2)) * [sqrt_(n + 1) - 1 + n,sqrt_(n + 1) - 1]
        V[:,2:n + 1]=(x0 + alpha[2] * ones_(n,1)) * ones_(1,n)
        for j in arange_(2,n + 1).reshape(-1):
            V[j - 1,j]=x0[j - 1] + alpha[1]
            x[:]=V[:,j]
            f[j]=dirn * feval_(fun,x,varargin[:])
    else:
        alpha=scale * ones_(n + 1,1)
        for j in arange_(2,n + 1).reshape(-1):
            V[:,j]=x0 + alpha[j] * V[:,j]
            x[:]=V[:,j]
            f[j]=dirn * feval_(fun,x,varargin[:])
    nf=n + 1
    how=char('initial  ')
    __,j=sort_(f,nargout=2)
    j=j[n + 1:- 1:1]
    f=f[j]
    V=V[:,j]
    alpha=1
    beta=1 / 2
    gamma=2
    while (1):

        k
        if (k > maxiter):
            msg=char('Exceeded maximum iterations...quitting\n')
            break
        fmax=f[1]
        if (fmax > fmax_old):
            if (not isempty_(savit)):
                x[:]=V[:,1]
                eval_([char('save '),savit,char(' x fmax nf')])
        if (trace):
            fprintf_(char('Iter. %2.0f,'),k)
            fprintf_([char('  how = '),how,char('  ')])
            fprintf_(char('nf = %3.0f,  f = %9.4e  (%2.1f%%)\n'),nf,fmax,100 * (fmax - fmax_old) / (abs_(fmax_old) + eps))
        fmax_old=copy_(fmax)
        if (fmax >= stopit[3]):
            msg=char('Exceeded target...quitting\n')
            break
        if (nf >= stopit[2]):
            msg=char('Max no. of function evaluations exceeded...quitting\n')
            break
        v1=V[:,1]
        size_simplex=norm_(V[:,2:n + 1] - v1[:,ones_(1,n)],1) / max_(1,norm_(v1,1))
        if (size_simplex <= tol):
            msg=sprintf_(char('Simplex size %9.4e <= %9.4e...quitting\n'),size_simplex,tol)
            break
        vbar=(sum_(V[:,1:n].T) / n).T
        vr=(1 + alpha) * vbar - alpha * V[:,n + 1]
        x[:]=vr
        fr=dirn * feval_(fun,x,varargin[:])
        nf=nf + 1
        vk=copy_(vr)
        fk=copy_(fr)
        how=char('reflect, ')
        if (fr > f[n]):
            if (fr > f[1]):
                ve=gamma * vr + (1 - gamma) * vbar
                x[:]=ve
                fe=dirn * feval_(fun,x,varargin[:])
                nf=nf + 1
                if (fe > f[1]):
                    vk=copy_(ve)
                    fk=copy_(fe)
                    how=char('expand,  ')
        else:
            vt=V[:,n + 1]
            ft=f[n + 1]
            if (fr > ft):
                vt=copy_(vr)
                ft=copy_(fr)
            vc=beta * vt + (1 - beta) * vbar
            x[:]=vc
            fc=dirn * feval_(fun,x,varargin[:])
            nf=nf + 1
            if (fc > f[n]):
                vk=copy_(vc)
                fk=copy_(fc)
                how=char('contract,')
            else:
                for j in arange_(2,n).reshape(-1):
                    V[:,j]=(V[:,1] + V[:,j]) / 2
                    x[:]=V[:,j]
                    f[j]=dirn * feval_(fun,x,varargin[:])
                nf=nf + n - 1
                vk=(V[:,1] + V[:,n + 1]) / 2
                x[:]=vk
                fk=dirn * feval_(fun,x,varargin[:])
                nf=nf + 1
                how=char('shrink,  ')
        V[:,n + 1]=vk
        f[n + 1]=fk
        __,j=sort_(f,nargout=2)
        j=j[n + 1:- 1:1]
        f=f[j]
        V=V[:,j]

    if (trace):
        fprintf_(msg)
    x[:]=V[:,1]
    return x,fmax,nf
def guarded_eval_(fun=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[fun,x].count(None)+len(args)

    y=fun[x]
    if (not (isreal_(f))):
        error_(char('fminsearch:notreal'),char('fminsearch: non-real value encountered'))
    else:
        if (any_(isnan_(f_(arange_())))):
            error_(char('fminsearch:isnan'),char('fminsearch: NaN value encountered'))
        else:
            if (any_(isinf_(f_(arange_())))):
                error_(char('fminsearch:isinf'),char('fminsearch: Inf value encountered'))
    return y
def fminbnd_(fun=None,xmin=None,xmax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[fun,xmin,xmax,options].count(None)+len(args)

    if (nargin == 1 and ischar_(fun) and strcmp_(fun,char('defaults'))):
        x=optimset_(char('MaxIter'),Inf,char('MaxFunEvals'),Inf,char('TolX'),1e-08,char('OutputFcn'),[],char('FunValCheck'),char('off'))
        return x,fval,info,output
    if (nargin < 2 or nargin > 4):
        print_usage_()
    if (ischar_(fun)):
        fun=str2func_(fun,char('global'))
    displ=optimget_(options,char('Display'),char('notify'))
    funvalchk=strcmpi_(optimget_(options,char('FunValCheck'),char('off')),char('on'))
    outfcn=optimget_(options,char('OutputFcn'))
    tolx=optimget_(options,char('TolX'),1e-08)
    maxiter=optimget_(options,char('MaxIter'),Inf)
    maxfev=optimget_(options,char('MaxFunEvals'),Inf)
    if (funvalchk):
        fun=lambda x: guarded_eval_(fun,x)
    info=0
    niter=0
    nfev=0
    sqrteps=eps_(class_(xmin + xmax))
    c=0.5 * (3 - sqrt_(5))
    a=copy_(xmin)
    b=copy_(xmax)
    v=a + c * (b - a)
    w=x=copy_(v)
    e=0
    fv=fw=fval=fun[x]
    nfev
    iter_(1).funccount=nfev
    _iter[1].x=x
    _iter[1].fx=fval
    while (niter < maxiter and nfev < maxfev):

        xm=0.5 * (a + b)
        tol=2 * sqrteps * abs_(x) + tolx / 3
        if (abs_(x - xm) <= (2 * tol - 0.5 * (b - a))):
            info=1
            break
        if (abs_(e) > tol):
            dogs=copy_(false)
            _iter[niter + 1].procedure=char('parabolic')
            r=(x - w) * (fval - fv)
            q=(x - v) * (fval - fw)
            p=(x - v) * q - (x - w) * r
            q=2 * (q - r)
            p *= - sign_(q)
            q=abs_(q)
            r=copy_(e)
            e=copy_(d)
            if (abs_(p) < abs_(0.5 * q * r) and p > q * (a - x) and p < q * (b - x)):
                d=p / q
                u=x + d
                if (min_(u - a,b - u) < 2 * tol):
                    d=tol * (sign_(xm - x) + (xm == x))
            else:
                dogs=copy_(true)
        else:
            dogs=copy_(true)
        if (dogs):
            _iter[niter + 1].procedure=char('golden')
            e=ifelse_(x >= xm,a - x,b - x)
            d=c * e
        u=x + max_(abs_(d),tol) * (sign_(d) + (d == 0))
        fu=fun[u]
        niter
        _iter[niter].funccount=nfev
        _iter[niter].x=u
        _iter[niter].fx=fu
        if (fu <= fval):
            if (u < x):
                b=copy_(x)
            else:
                a=copy_(x)
            v=copy_(w)
            fv=copy_(fw)
            w=copy_(x)
            fw=copy_(fval)
            x=copy_(u)
            fval=copy_(fu)
        else:
            if (u < x):
                a=copy_(u)
            else:
                b=copy_(u)
            if (fu <= fw or w == x):
                v=copy_(w)
                fv=copy_(fw)
                w=copy_(u)
                fw=copy_(fu)
            else:
                if (fu <= fv or v == x or v == w):
                    v=copy_(u)
                    fv=copy_(fu)
        if (outfcn):
            optv.funccount=nfev
            optv.fval=fval
            optv.iteration=niter
            if (outfcn[x,optv,char('iter')]):
                info=- 1
                break

    _iter[1].procedure=char('initial')
    if char('iter') == (displ):
        print_formatted_table_(_iter)
        print_exit_msg_(info,struct_(char('TolX'),tolx,char('fx'),fval))
    else:
        if char('notify') == (displ):
            if (info == 0):
                print_exit_msg_(info,struct_(char('fx'),fval))
        else:
            if char('final') == (displ):
                print_exit_msg_(info,struct_(char('TolX'),tolx,char('fx'),fval))
            else:
                if char('off') == (displ):
                    char('skip')
                else:
                    warning_(char("unknown option for Display: '%s'"),displ)
    output.iterations=niter
    output.funcCount=nfev
    output.bracket=[a,b]
    return x,fval,info,output
def guarded_eval_(fun=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[fun,x].count(None)+len(args)

    fx=fun[x]
    fx=fx[1]
    if (not isreal_(fx)):
        error_(char('fminbnd:notreal'),char('fminbnd: non-real value encountered'))
    else:
        if (isnan_(fx)):
            error_(char('fminbnd:isnan'),char('fminbnd: NaN value encountered'))
    return fx
def print_formatted_table_(table=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[table].count(None)+len(args)

    printf_(char('\n Func-count     x          f(x)         Procedure\n'))
    for row in table.reshape(-1):
        printf_(char('%5.5s        %7.7s    %8.8s\t%s\n'),int2str_(row.funccount),num2str_(row.x,char('%.5f')),num2str_(row.fx,char('%.6f')),row.procedure)
    printf_(char('\n'))
    return
def print_exit_msg_(info=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[info,opt].count(None)+len(args)

    printf_(char(''))
    if 1 == (info):
        printf_(char('Optimization terminated:\n'))
        printf_(char(' the current x satisfies the termination criteria using OPTIONS.TolX of %e\n'),opt.TolX)
    else:
        if 0 == (info):
            printf_(char('Exiting: Maximum number of iterations has been exceeded\n'))
            printf_(char('         - increase MaxIter option.\n'))
            printf_(char('         Current function value: %.6f\n'),opt.fx)
        else:
            if - 1 == (info):
                char('FIXME')
            else:
                error_(char('internal error - fminbnd() is bug, sorry!'))
    printf_(char('\n'))
    return
def lsqnonneg_(c=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[c,d,x,options].count(None)+len(args)

    if (nargin == 1 and ischar_(c) and strcmp_(c,char('defaults'))):
        x=optimset_(char('MaxIter'),100000.0)
        return x,resnorm,residual,exitflag,output,_lambda
    if (not (nargin >= 2 and nargin <= 4 and ismatrix_(c) and ismatrix_(d) and isstruct_(options))):
        print_usage_()
    m=rows_(c)
    n=columns_(c)
    if (isempty_(x)):
        x=zeros_(n,1)
    else:
        x=max_(x,0)
    useqr=m >= n
    max_iter=optimget_(options,char('MaxIter'),100000.0)
    p=find_(x > 0).T
    if (useqr):
        q,r=qr_(c[:,p],0,nargout=2)
    _iter=0
    while (_iter < max_iter):

        while (_iter < max_iter):

            _iter
            if (useqr):
                xtmp=numpy.linalg.solve(r,q.T) * d
            else:
                xtmp=numpy.linalg.solve(c[:,p],d)
            idx=find_(xtmp < 0)
            if (isempty_(idx)):
                x[:]=0
                x[p]=xtmp
                break
            else:
                pidx=p[idx]
                sf=x[pidx] / (x[pidx] - xtmp[idx])
                alpha=min_(sf)
                xx=zeros_(n,1)
                xx[p]=xtmp
                x += alpha * (xx - x)
                idx=idx[sf == alpha]
                p[idx]=[]
                if (useqr):
                    q,r=qrdelete_(q,r,idx,nargout=2)

        w=c.T * (d - c * x)
        w[p]=[]
        tolx=optimget_(options,char('TolX'),10 * eps * norm_(c,1) * length_(c))
        if (not any_(w > tolx)):
            if (useqr):
                useqr=copy_(false)
                continue
            else:
                break
        idx=find_(w == max_(w))
        if (numel_(idx) > 1):
            warning_(char('lsqnonneg:nonunique'),char('a non-unique solution may be returned due to equal gradients'))
            idx=idx[1]
        z=matlabarray([arange_(1,n)])
        z[p]=[]
        zidx=z[idx]
        jdx=1 + lookup_(p,zidx)
        p=matlabarray([p[1:jdx - 1],zidx,p[jdx:end()]])
        if (useqr):
            q,r=qrinsert_(q,r,jdx,c[:,zidx],nargout=2)

    if (nargout > 1):
        resnorm=norm_(c * x - d) ** 2
    if (nargout > 2):
        residual=d - c * x
    exitflag=copy_(_iter)
    if (nargout > 3 and _iter >= max_iter):
        exitflag=0
    if (nargout > 4):
        output=struct_(char('algorithm'),char('nnls'),char('iterations'),_iter)
    if (nargout > 5):
        _lambda=zeros_(size_(x))
        _lambda[p]=w
    return x,resnorm,residual,exitflag,output,_lambda
def iscolormap_(cmap=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[cmap].count(None)+len(args)

    if (nargin != 1):
        print_usage
    retval=(isnumeric_(cmap) and isreal_(cmap) and ndims_(cmap) == 2 and columns_(cmap) == 3 and isa_(cmap,char('double')) and min_(cmap[:]) >= 0 and max_(cmap[:]) <= 1)
    return retval
def rainbow_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('rainbow: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([1,0,0])
    else:
        if (n > 1):
            x=[arange_(0,(n - 1))].T / (n - 1)
            r=((x < 2 / 5) + (x >= 2 / 5 and x < 3 / 5).dot((- 5 * x + 3)) + (x >= 4 / 5).dot((10 / 3 * x - 8 / 3)))
            g=((x < 2 / 5).dot((5 / 2 * x)) + (x >= 2 / 5 and x < 3 / 5) + (x >= 3 / 5 and x < 4 / 5).dot((- 5 * x + 4)))
            b=((x >= 3 / 5 and x < 4 / 5).dot((5 * x - 3)) + (x >= 4 / 5))
            _map=matlabarray([r,g,b])
        else:
            _map=zeros_(0,3)
    return _map
def cmpermute_(X=None,map=None,index=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[X,_map,index].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    cls=class_(X)
    if (not any_(strcmp_(cls,[char('uint8'),char('uint16'),char('single'),char('double')]))):
        error_(char("cmpermute: invalid data type '%s'"),cls)
    if (not isreal_(X) or issparse_(X) or (isfloat_(X) and (any_(X[:] < 1 or any_(X[:] != fix_(X[:])))))):
        error_(char('cmpermute: X must be an indexed image'))
    if (not iscolormap_(_map)):
        error_(char('cmpermute: MAP must be a valid colormap'))
    if (nargin < 3):
        index=randperm_(rows_(_map))
    else:
        if (not isvector_(index) or length_(index) != rows_(_map)):
            error_(char('cmpermute: invalid parameter INDEX'))
    newmap=_map[index,:]
    rindex=zeros_(size_(index))
    rindex[index]=arange_(1,length_(index))
    if (strcmp_(cls,char('double'))):
        Y=rindex[X]
    else:
        if (strcmp_(cls,char('single'))):
            rindex=single_(rindex)
            Y=rindex[X]
        else:
            rindex=feval_(cls,rindex - 1)
            Y=rindex[single_(X) + 1]
    return Y,newmap
def hsv2rgb_(hsv_map=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[hsv_map].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    cls=class_(hsv_map)
    if (not any_(strcmp_(cls,[char('uint8'),char('uint16'),char('single'),char('double')]))):
        error_(char("hsv2rgb: invalid data type '%s'"),cls)
    else:
        if (isfloat_(hsv_map) and (any_(hsv_map[:] < 0) or any_(hsv_map[:] > 1))):
            error_(char('hsv2rgb: floating point images may only contain values between 0 and 1'))
    if (isreal_(hsv_map) and ndims_(hsv_map) == 3):
        is_image=copy_(true)
        sz=size_(hsv_map)
        hsv_map=matlabarray([hsv_map[:,:,1](arange_()),hsv_map[:,:,2](arange_()),hsv_map[:,:,3](arange_())])
        if (isinteger_(hsv_map)):
            low=double_(intmin_(cls))
            high=double_(intmax_(cls))
            hsv_map=(double_(hsv_map) - low) / (high - low)
    else:
        is_image=copy_(false)
    if (not isreal_(hsv_map) or columns_(hsv_map) != 3 or issparse_(hsv_map)):
        error_(char('hsv2rgb: input must be a matrix of size Nx3 or MxNx3'))
    h=hsv_map[:,1]
    s=hsv_map[:,2]
    v=hsv_map[:,3]
    rgb_map=repmat_(v.dot((1 - s)),1,3)
    hue=matlabarray([mod_(h - 2 / 3,1),h,mod_(h - 1 / 3,1)])
    f=repmat_(s.dot(v),1,3)
    rgb_map += f.dot((6 * (hue < 1 / 6).dot(hue) + (hue >= 1 / 6 and hue < 1 / 2) + (hue >= 1 / 2 and hue < 2 / 3).dot((4 - 6 * hue))))
    if (is_image):
        rgb_map=reshape_(rgb_map,sz)
    return rgb_map
def brighten_(arg1=None,beta=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[arg1,beta].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    h=- 1
    if (nargin == 1):
        beta=copy_(arg1)
        m=colormap_()
        h=gcf_()
    else:
        if (ishandle_(arg1)):
            h=copy_(arg1)
            m=get_(h,char('colormap'))
        else:
            if (iscolormap_(arg1)):
                m=copy_(arg1)
            else:
                error_(char('brighten: first argument must be a colormap or a graphics handle'))
    if (not isscalar_(beta) or beta <= - 1 or beta >= 1):
        error_(char('brighten: BETA must be a scalar in the range (-1,1)'))
    if (beta > 0):
        gamma=1 - beta
    else:
        gamma=1 / (1 + beta)
    if (nargout == 0):
        if (ishandle_(h)):
            set_(h,char('colormap'),m ** gamma)
        else:
            colormap_(m ** gamma)
    else:
        rmap=m ** gamma
    return rmap
def colorcube_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('colorcube: N must be a scalar'))
        else:
            print_usage_()
    if (n < 9):
        _map=gray_(n)
        return _map
    cubelen=fix_(cbrt_(n))
    reserve=n - cubelen ** 3
    if (reserve == 0):
        r,g,b=meshgrid_(linspace_(0,1,cubelen),linspace_(0,1,cubelen),linspace_(0,1,cubelen - 1),nargout=3)
    else:
        r,g,b=meshgrid_(linspace_(0,1,cubelen),linspace_(0,1,cubelen),linspace_(0,1,cubelen),nargout=3)
    _map=matlabarray([r[:],g[:],b[:]])
    idx=any_(bsxfun_(ne,_map[:,1],_map[:,2:3]),2)
    _map=_map[idx,:]
    idx=sum_(_map == 0,2)
    _map=_map[idx != 2,:]
    reserve=n - rows_(_map) - 1
    csteps=fix_(reserve / 4)
    cstepsz=1 / csteps
    cgrad=(arange_(cstepsz,1,cstepsz)).T
    gsteps=reserve - 3 * csteps
    gstepsz=1 / gsteps
    ggrad=(arange_(gstepsz,1,gstepsz)).T
    _map=matlabarray([_map,cgrad,zeros_(csteps,1),zeros_(csteps,1),zeros_(csteps,1),cgrad,zeros_(csteps,1),zeros_(csteps,1),zeros_(csteps,1),cgrad,0,0,0,ggrad,ggrad,ggrad])
    return _map
def imagesc_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('imagesc'),varargin[:],nargout=3)
    chararg=find_(cellfun_(char('isclass'),varargin,char('char')),1,char('first'))
    do_new=copy_(true)
    if (nargin == 0):
        print_usage_()
    else:
        if (chararg == 1):
            do_new=copy_(false)
            img=x=y=climits=matlabarray([])
        else:
            if (nargin == 1 or chararg == 2):
                img=varargin[1]
                x=y=climits=matlabarray([])
            else:
                if (nargin == 2 or chararg == 3):
                    img=varargin[1]
                    climits=varargin[2]
                    x=y=matlabarray([])
                else:
                    if (nargin == 3 or chararg == 4):
                        x=varargin[1]
                        y=varargin[2]
                        img=varargin[3]
                        climits=matlabarray([])
                    else:
                        if (nargin == 4 or chararg == 5):
                            x=varargin[1]
                            y=varargin[2]
                            img=varargin[3]
                            climits=varargin[4]
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        if (do_new):
            hax=newplot_(hax)
        else:
            if (isempty_(hax)):
                hax=gca_()
        if (do_new):
            htmp=image_(x,y,img,char('cdatamapping'),char('scaled'),varargin[chararg:end()])
        else:
            htmp=image_(char('cdatamapping'),char('scaled'),varargin[:])
        if (do_new and not ishold_(hax)):
            if (numel_(climits) == 2 and climits[1] <= climits[2]):
                set_(hax,char('clim'),climits)
            else:
                if (not isempty_(climits)):
                    error_(char('imagesc: CLIMITS must be in form [lo, hi]'))
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def gray_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('gray: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([0,0,0])
    else:
        if (n > 1):
            gr=[arange_(0,(n - 1))].T / (n - 1)
            _map=matlabarray([gr,gr,gr])
        else:
            _map=zeros_(0,3)
    return _map
def colormap_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    map_list=cell_()
    hax,varargin,nargin=__plt_get_axis_arg___(char('colormap'),varargin[:],nargout=3)
    if (nargin > 2):
        print_usage_()
    if (not isempty_(hax)):
        cf=ancestor_(hax,char('figure'))
    else:
        cf=get_(0,char('currentfigure'))
    if (nargin == 1):
        _map=varargin[1]
        if (ischar_(_map)):
            if (strcmp_(_map,char('default'))):
                _map=jet_(64)
            else:
                if (strcmp_(_map,char('list'))):
                    cmap=copy_(map_list)
                    return cmap
                else:
                    _map=feval_(_map)
        if (not isempty_(_map)):
            if (not (isnumeric_(_map) and isreal_(_map) and ndims_(_map) == 2 and columns_(_map) == 3)):
                error_(char('colormap: MAP must be a real-valued N x 3 ([R,G,B]) matrix'))
            if (any_(_map[:] < 0) or any_(_map[:] > 1)):
                error_(char('colormap: all MAP values must be in the range [0,1]'))
            if (isempty_(cf)):
                cf=gcf_()
            set_(cf,char('colormap'),_map)
    else:
        if (nargin == 2):
            opt=varargin[1]
            name=varargin[2]
            if (not ischar_(opt) or not any_(strcmp_(opt,[char('register'),char('unregister')]))):
                print_usage_()
            else:
                if (not ischar_(name)):
                    error_(char('colormap: to register/unregister a colormap, NAME must be a string'))
                else:
                    if (strcmp_(opt,char('register'))):
                        map_list[end() + 1]=name
                    else:
                        if (strcmp_(opt,char('unregister'))):
                            map_list[strcmp_(name,map_list)]=[]
    if (nargout > 0 or (nargout == 0 and nargin == 0)):
        if (isempty_(cf)):
            cf=gcf_()
        cmap=get_(cf,char('colormap'))
    return cmap
def cool_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('cool: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([0,1,1])
    else:
        if (n > 1):
            r=[arange_(0,(n - 1))].T / (n - 1)
            g=1 - r
            b=ones_(n,1)
            _map=matlabarray([r,g,b])
        else:
            _map=zeros_(0,3)
    return _map
def ind2rgb_(x=None,map=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,_map].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    x,_map=ind2x_(char('ind2rgb'),x,_map,nargout=2)
    sz=size_(x)
    R=reshape_(_map[x[:],1],sz)
    G=reshape_(_map[x[:],2],sz)
    B=reshape_(_map[x[:],3],sz)
    if (nargout <= 1):
        if (ndims_(x) == 2):
            R=reshape_([[R[:]],[G[:]],[B[:]]],[sz,3])
        else:
            if (ndims_(x) == 4):
                R=permute_(reshape_([[R[:]],[G[:]],[B[:]]],[sz[1],sz[2],sz[4],3]),[1,2,4,3])
            else:
                error_(char('ind2rgb: an indexed image must have 2 or 4 dimensions.'))
    return R,G,B
def spring_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('spring: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([1,0,1])
    else:
        if (n > 1):
            r=ones_(n,1)
            g=[arange_(0,(n - 1))].T / (n - 1)
            b=1 - g
            _map=matlabarray([r,g,b])
        else:
            _map=zeros_(0,3)
    return _map
def gmap40_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=6
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('gmap40: N must be a scalar'))
        else:
            print_usage_()
    if (n > 1):
        C=matlabarray([[1,0,0],[0,1,0],[0,0,1],[1,1,0],[1,0,1],[0,1,1]])
        _map=C[rem_(arange_(0,(n - 1)),6) + 1,:]
    else:
        _map=zeros_(0,3)
    return _map
def copper_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('copper: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([0,0,0])
    else:
        if (n > 1):
            x=[arange_(0,(n - 1))].T / (n - 1)
            r=(x < 4 / 5).dot((5 / 4 * x)) + (x >= 4 / 5)
            g=0.7812 * x
            b=0.4975 * x
            _map=matlabarray([r,g,b])
        else:
            _map=zeros_(0,3)
    return _map
def imwrite_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    filename,ext=imwrite_filename_(varargin[2:end()],nargout=2)
    fmt=imformats_(ext)
    if (isempty_(fieldnames_(fmt))):
        if (isempty_(ext)):
            error_(char('imwrite: no extension found for %s to identify the image format'),filename)
        warning_(char('imwrite: unlisted image format %s (see imformats). Trying to save anyway.'),ext)
        __imwrite___(varargin[:])
    else:
        fmt.write(varargin[:])
    return
def imread_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    else:
        if (not ischar_(varargin[1])):
            error_(char('imread: FILENAME must be a string'))
    filename=[varargin[1]]
    if (nargin > 1 and ischar_(varargin[2])):
        filename[2]=varargin[2]
    img,varargout[1:nargout - 1]=imageIO_(__imread__,char('read'),filename,varargin[:],nargout=2)
    return img,varargout
def gray2ind_(I=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[I,n].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    else:
        if (not isreal_(I) or issparse_(I)):
            error_(char('gray2ind: I must be a grayscale or binary image'))
        else:
            if (not isscalar_(n) or n < 1 or n > 65536):
                error_(char('gray2ind: N must be a positive integer in the range [1, 65536]'))
            else:
                if (not ismatrix_(I) or ndims_(I) < 2):
                    error_(char('gray2ind: I must be a grayscale or binary image'))
    if (nargin == 1 and islogical_(I)):
        n=2
    cls=class_(I)
    if (not any_(strcmp_(cls,[char('logical'),char('uint8'),char('uint16'),char('int16'),char('single'),char('double')]))):
        error_(char("gray2ind: invalid data type '%s'"),cls)
    else:
        if (isfloat_(I) and (min_(I[:] < 0) or max_(I[:] > 1))):
            error_(char('gray2ind: floating point images may only contain values between 0 and 1'))
    _map=gray_(n)
    if (isinteger_(I)):
        low=double_(intmin_(cls))
        scale=double_(intmax_(cls)) - low
        I=double_(I) - low
    else:
        scale=1
    I *= (n - 1) / scale
    if (n < 256):
        I=uint8_(I)
    else:
        I=uint16_(I)
    return I,_map
def imwrite_filename_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    cmap=matlabarray([])
    if (ischar_(varargin[1])):
        filename_idx=1
    else:
        if (numel_(varargin) >= 2 and iscolormap_(varargin[1]) and ischar_(varargin[2])):
            filename_idx=2
            cmap=varargin[1]
        else:
            error_(char('imwrite: no FILENAME specified'))
    filename=tilde_expand_(varargin[filename_idx])
    options_idx=filename_idx + 1
    if (numel_(varargin) > filename_idx and rem_(length_(varargin) - filename_idx,2) != 0 and ischar_(varargin[filename_idx + 1])):
        ext=varargin[filename_idx + 1]
        options_idx
    else:
        __,__,ext=fileparts_(filename,nargout=3)
        if (not isempty_(ext)):
            ext=ext[2:end()]
    options=varargin[options_idx:end()]
    return filename,ext,cmap,options
def __imfinfo___(filename=None,ext=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[filename,ext].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_(char('imfinfo'))
    if (not ischar_(filename)):
        error_(char('imfinfo: FILENAME must be a string'))
    else:
        if (nargin >= 2 and not ischar_(ext)):
            error_(char('imfinfo: EXT must be a string'))
    filename=tilde_expand_(filename)
    delete_file=copy_(false)
    try:
        fn=file_in_path_(IMAGE_PATH,filename)
        if (isempty_(fn)):
            if (nargin >= 2):
                filename=matlabarray([filename,char('.'),ext])
                fn=file_in_path_(IMAGE_PATH,filename)
                if (isempty_(fn)):
                    error_(char('imfinfo: cannot find file %s'),filename)
            else:
                fn,status,msg=urlwrite_(filename,tmpnam_(),nargout=3)
                if (not status):
                    error_(char('imfinfo: cannot find or download %s: %s'),filename,msg)
                delete_file=copy_(true)
        info=__magick_finfo___(fn)
    finally:
        if (delete_file):
            unlink_(fn)
    return info
def ind2x_(caller=None,x=None,map=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[caller,x,_map].count(None)+len(args)

    if (all_(ndims_(x) != [2,4]) or size_(x,3) != 1 or issparse_(x) or (isfloat_(x) and not isindex_(x)) or not any_(strcmp_(class_(x),[char('uint8'),char('uint16'),char('single'),char('double')]))):
        error_(char('%s: X must be an indexed image'),caller)
    if (not iscolormap_(_map)):
        error_(char('%s: MAP must be a valid colormap'),caller)
    maxidx=max_(x[:])
    if (isinteger_(x)):
        if (maxidx == intmax_(class_(x))):
            x=single_(x)
        x += 1
        maxidx += 1
    num_colors=rows_(_map)
    if (num_colors < maxidx):
        pad=repmat_(_map[end(),:],maxidx - num_colors,1)
        _map[end() + 1:maxidx,:]=pad
    return x,_map
def __imread___(filename=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[filename].count(None)+len(args)

    if (nargin < 1):
        print_usage_(char('imread'))
    else:
        if (not ischar_(filename)):
            error_(char('imread: FILENAME must be a string'))
    offset=1
    filename=tilde_expand_(filename)
    fn=file_in_path_(IMAGE_PATH,filename)
    if (isempty_(fn) and nargin >= offset + 1 and ischar_(varargin[offset])):
        filename=matlabarray([filename,char('.'),varargin[offset]])
        fn=file_in_path_(IMAGE_PATH,filename)
        offset
    if (isempty_(fn)):
        error_(char('imread: cannot find %s'),filename)
    options=struct_(char('index'),1)
    if (nargin >= offset + 1 and not ischar_(varargin[offset])):
        if (not is_valid_index_option_(options.index)):
            error_(char('imread: IDX must be a numeric vector'))
        options.index=varargin[offset]
        offset
    if (rem_(numel_(varargin) - offset + 1,2) != 0):
        error_(char('imread: no pair for all arguments (odd number left over)'))
    indexes=cellfun_(char('isclass'),varargin,char('char'))
    indexes[indexes] &= ismember_(tolower_(varargin[indexes]),[char('frames'),char('index')])
    indexes=find_(indexes)
    if (indexes):
        options.index=varargin[indexes + 1]
        if (not (is_valid_index_option_(options.index)) and not (ischar_(options.index) and strcmpi_(options.index,char('all')))):
            error_(char("imread: value for %s must be a vector or the string `all'"))
    try:
        if (ischar_(options.index) and strcmpi_(options.index,char('all'))):
            info=__magick_ping___(fn,1)
        else:
            info=__magick_ping___(fn,options.index(1))
        options.region=[arange_(1,info.rows,1),arange_(1,info.columns,1)]
        for idx in arange_(offset,(numel_(varargin) - offset + 1),2).reshape(-1):
            if [char('frames'),char('index')] == (tolower___(varargin[idx])):
                pass
            else:
                if char('pixelregion') == (tolower___(varargin[idx])):
                    options.region=varargin[idx + 1]
                    if (not iscell_(options.region) or numel_(options.region) != 2):
                        error_(char('imread: value for %s must be a 2 element cell array'),varargin[idx])
                    for reg_idx in arange_(1,2).reshape(-1):
                        if (numel_(options.region[reg_idx]) == 3):
                            pass
                        else:
                            if (numel_(options.region[reg_idx]) == 2):
                                options.region[reg_idx][3]=options.region[reg_idx](2)
                                options.region[reg_idx][2]=1
                            else:
                                error_(char('imread: range for %s must be a 2 or 3 element vector'),varargin[idx])
                        options.region[reg_idx]=arange_(floor_(options.region[reg_idx](1)),floor_(options.region[reg_idx](3)),floor_(options.region[reg_idx](2)))
                    if (options.region[1](end()) > info.rows):
                        error_(char('imread: end ROWS for PixelRegions option is larger than image height'))
                    else:
                        if (options.region[2](end()) > info.columns):
                            error_(char('imread: end COLS for PixelRegions option is larger than image width'))
                else:
                    if char('info') == (tolower___(varargin[idx])):
                        pass
                    else:
                        error_(char("imread: invalid PARAMETER `%s'"),varargin[idx])
        varargout[1:nargout]=__magick_read___(fn,options)
    finally:
        pass
    return varargout
def is_valid_index_option_(arg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[arg].count(None)+len(args)

    _bool=copy_(false)
    if (isvector_(arg) and isnumeric_(arg) and isreal_(arg)):
        _bool=copy_(true)
    return _bool
def image_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('image'),varargin[:],nargout=3)
    chararg=find_(cellfun_(char('isclass'),varargin,char('char')),1,char('first'))
    do_new=copy_(true)
    if (nargin == 0):
        img=imread_(char('default.img'))
        x=y=matlabarray([])
    else:
        if (chararg == 1):
            do_new=copy_(false)
            x=y=img=matlabarray([])
            idx=find_(strcmpi_(varargin,char('cdata')),1)
            if (idx):
                img=varargin[idx + 1]
                varargin[idx:idx + 1]=[]
            idx=find_(strcmpi_(varargin,char('xdata')),1)
            if (idx):
                x=varargin[idx + 1]
                varargin[idx:idx + 1]=[]
            idx=find_(strcmpi_(varargin,char('ydata')),1)
            if (idx):
                y=varargin[idx + 1]
                varargin[idx:idx + 1]=[]
        else:
            if (nargin == 1 or chararg == 2):
                img=varargin[1]
                x=y=matlabarray([])
            else:
                if (nargin == 2 or chararg == 3):
                    print_usage_()
                else:
                    x=varargin[1]
                    y=varargin[2]
                    img=varargin[3]
                    chararg=4
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        if (do_new):
            hax=newplot_(hax)
        else:
            if (isempty_(hax)):
                hax=gca_()
        htmp=__img___(hax,do_new,x,y,img,varargin[chararg:end()])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def __img___(hax=None,do_new=None,x=None,y=None,img=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[hax,do_new,x,y,img].count(None)+len(args)

    if (ndims_(img) == 2 and (isinteger_(img) or islogical_(img))):
        img=single_(img) + 1
    if (not isempty_(img)):
        if (isempty_(x)):
            x=matlabarray([1,columns_(img)])
        if (isempty_(y)):
            y=matlabarray([1,rows_(img)])
        xdata=x[[1,end()]](arange_()).T
        ydata=y[[1,end()]](arange_()).T
        if (numel_(x) > 2 and numel_(y) > 2):
            tol=0.01
            dx=diff_(x)
            dxmean=(max_(x) - min_(x)) / (numel_(x) - 1)
            dx=abs_((abs_(dx) - dxmean) / dxmean)
            dy=diff_(y)
            dymean=(max_(y) - min_(y)) / (numel_(y) - 1)
            dy=abs_((abs_(dy) - dymean) / dymean)
            if (any_(dx > tol) or any_(dy > tol)):
                warning_([char('image: non-linear X, Y data is ignored.  '),char('IMG will be shown with linear mapping')])
    h=__go_image___(hax,char('cdata'),img,char('xdata'),xdata,char('ydata'),ydata,char('cdatamapping'),char('direct'),varargin[:])
    if (do_new and not ishold_(hax)):
        if (not isempty_(img)):
            if (isscalar_(get_(hax,char('children')))):
                axis_(hax,char('tight'))
            if (ndims_(img) == 3):
                if (isinteger_(img)):
                    cls=class_(img)
                    mn=intmin_(cls)
                    mx=intmax_(cls)
                    set_(hax,char('clim'),double_([mn,mx]))
        set_(hax,char('view'),[0,90],char('ydir'),char('reverse'),char('layer'),char('bottom'))
    return h
def imfinfo_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    else:
        if (not ischar_(varargin[1])):
            error_(char('imfinfo: FILENAME must be a string'))
        else:
            if (nargin > 1 and not ischar_(varargin[2])):
                error_(char('imfinfo: EXT must be a string'))
    info=imageIO_(__imfinfo__,char('info'),varargin,varargin[:])
    return info
def winter_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('winter: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([0,0,1])
    else:
        if (n > 1):
            r=zeros_(n,1)
            g=[arange_(0,(n - 1))].T / (n - 1)
            b=1 - g / 2
            _map=matlabarray([r,g,b])
        else:
            _map=zeros_(0,3)
    return _map
def cmunique_(X=None,map=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[X,_map].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    cls=class_(X)
    if (not any_(strcmp_(cls,[char('uint8'),char('uint16'),char('single'),char('double')]))):
        error_(char("cmunique: X is of invalid data type '%s'"),cls)
    if (nargin == 2):
        if (not iscolormap_(_map)):
            error_(char('cmunique: MAP must be a valid colormap'))
        newmap,i,j=unique_(_map,char('rows'),nargout=3)
        if (isfloat_(X)):
            Y=j[X]
        else:
            Y=j[double_(X) + 1]
    else:
        if 1 == (size__(X,3)):
            newmap,i,j=unique_(X,nargout=3)
            newmap=repmat_(newmap,1,3)
            Y=reshape_(j,rows_(X),columns_(X))
        else:
            if 3 == (size__(X,3)):
                _map=matlabarray([X[:,:,1](arange_()),X[:,:,2](arange_()),X[:,:,3](arange_())])
                newmap,i,j=unique_(_map,char('rows'),nargout=3)
                Y=reshape_(j,rows_(X),columns_(X))
            else:
                error_(char('cmunique: X is not a valid image'))
        if (isinteger_(X)):
            newmap=double_(newmap) / double_(intmax_(cls))
    if (rows_(newmap) <= 256):
        Y=uint8_(Y - 1)
    return Y,newmap
def rgb2ind_(R=None,G=None,B=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[R,G,B].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (nargin == 1):
        rgb=copy_(R)
        if (ndims_(rgb) > 4 or size_(rgb,3) != 3):
            error_(char('rgb2ind: argument is not an RGB image'))
        else:
            R=rgb[:,:,1,:]
            G=rgb[:,:,2,:]
            B=rgb[:,:,3,:]
    else:
        if (not size_equal_(R,G,B)):
            error_(char('rgb2ind: R, G, and B must have the same size'))
    x=reshape_(arange_(1,numel_(R)),size_(R))
    _map=unique_([R[:],G[:],B[:]],char('rows'))
    __,x=ismember_([R[:],G[:],B[:]],_map,char('rows'),nargout=2)
    x=reshape_(x,size_(R))
    if [char('single'),char('double'),char('logical')] == (class___(R)):
        pass
    else:
        if [char('uint8'),char('uint16')] == (class___(R)):
            _map=double_(_map) / double_(intmax_(class_(R)))
        else:
            if char('int16') == (class___(R)):
                _map=(double_(im) + 32768) / 65535
            else:
                error_(char('unsupported image class %s'),im_class)
    if (rows_(_map) < 256):
        x=uint8_(x - 1)
    else:
        if (rows_(_map) < 65536):
            x=uint16_(x - 1)
    return x,_map
def rgb2ntsc_(rgb=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[rgb].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    cls=class_(rgb)
    if (not any_(strcmp_(cls,[char('uint8'),char('uint16'),char('single'),char('double')]))):
        error_(char("rgb2ntsc: invalid data type '%s'"),cls)
    else:
        if (isfloat_(rgb) and (any_(rgb[:] < 0) or any_(rgb[:] > 1))):
            error_(char('rgb2ntsc: floating point images may only contain values between 0 and 1'))
    if (isreal_(rgb) and ndims_(rgb) == 3):
        is_image=copy_(true)
        sz=size_(rgb)
        rgb=matlabarray([rgb[:,:,1](arange_()),rgb[:,:,2](arange_()),rgb[:,:,3](arange_())])
        if (isinteger_(rgb)):
            low=double_(intmin_(cls))
            high=double_(intmax_(cls))
            rgb=(double_(rgb) - low) / (high - low)
        else:
            if (isa_(rgb,char('single'))):
                rgb=double_(rgb)
    else:
        is_image=copy_(false)
    if (not isreal_(rgb) or columns_(rgb) != 3 or issparse_(rgb)):
        error_(char('rgb2ntsc: input must be a matrix of size Nx3 or NxMx3'))
    trans=matlabarray([[0.299,0.596,0.211],[0.587,- 0.274,- 0.523],[0.114,- 0.322,0.312]])
    yiq=rgb * trans
    if (is_image):
        yiq=reshape_(yiq,sz)
    return yiq
def jet_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('jet: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([0,1,1])
    else:
        if (n == 2):
            _map=matlabarray([0,0,1,0,1,1])
        else:
            if (n > 2):
                nel=ceil_(n / 4)
                idx1=ceil_(3 / 8 * n) + 1
                if (mod_(n,8) == 2):
                    idx1
                idx2=idx1 + nel - 1
                idx3=min_(idx2 + nel,n)
                r=zeros_(n,1)
                r[idx1:idx2,1]=[arange_(1,nel)] / nel
                r[idx2:idx3,1]=1
                nel2=n - idx3
                r[idx3:(idx3 + nel2),1]=[arange_(nel,(nel - nel2),- 1)] / nel
                idx1=idx1 - nel
                idx2=idx1 + nel - 1
                idx3=min_(idx2 + nel,n)
                g=zeros_(n,1)
                g[idx1:idx2,1]=[arange_(1,nel)] / nel
                g[idx2:idx3,1]=1
                nel2=min_(nel,n - idx3)
                g[idx3:(idx3 + nel2),1]=[arange_(nel,(nel - nel2),- 1)] / nel
                idx1=max_(idx2 - nel,1)
                idx2=copy_(idx2)
                idx3=copy_(idx3)
                b=zeros_(n,1)
                nel2=min_(nel,idx1 - 1)
                b[1:idx1,1]=[arange_((nel - nel2),nel)] / nel
                b[idx1:idx2,1]=1
                nel2=min_(nel,n - idx3)
                b[idx2:(idx2 + nel2),1]=[arange_(nel,(nel - nel2),- 1)] / nel
                _map=matlabarray([r,g,b])
            else:
                _map=zeros_(0,3)
    return _map
def rgb2hsv_(rgb=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[rgb].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    cls=class_(rgb)
    if (not any_(strcmp_(cls,[char('uint8'),char('uint16'),char('single'),char('double')]))):
        error_(char("rgb2hsv: invalid data type '%s'"),cls)
    else:
        if (isfloat_(rgb) and (any_(rgb[:] < 0) or any_(rgb[:] > 1))):
            error_(char('rgb2hsv: floating point images may only contain values between 0 and 1'))
    if (isreal_(rgb) and ndims_(rgb) == 3):
        is_image=copy_(true)
        sz=size_(rgb)
        rgb=matlabarray([rgb[:,:,1](arange_()),rgb[:,:,2](arange_()),rgb[:,:,3](arange_())])
        if (isinteger_(rgb)):
            low=double_(intmin_(cls))
            high=double_(intmax_(cls))
            rgb=(double_(rgb) - low) / (high - low)
    else:
        is_image=copy_(false)
    if (not ismatrix_(rgb) or columns_(rgb) != 3 or issparse_(rgb)):
        error_(char('rgb2hsv: input must be a matrix of size Nx3 or MxNx3'))
    s=min_(rgb,[],2)
    v=max_(rgb,[],2)
    h=zeros_(rows_(rgb),1)
    notgray=(s != v)
    idx=(v == rgb[:,3] and notgray)
    if (any_(idx)):
        h[idx]=2 / 3 + 1 / 6 * (rgb[idx,1] - rgb[idx,2]) / (v[idx] - s[idx])
    idx=(v == rgb[:,2] and notgray)
    if (any_(idx)):
        h[idx]=1 / 3 + 1 / 6 * (rgb[idx,3] - rgb[idx,1]) / (v[idx] - s[idx])
    idx=(v == rgb[:,1] and notgray)
    if (any_(idx)):
        h[idx]=1 / 6 * (rgb[idx,2] - rgb[idx,3]) / (v[idx] - s[idx])
    h[h < 0] += 1
    s[not notgray]=0
    s[notgray]=1 - s[notgray] / v[notgray]
    hsv_map=matlabarray([h,s,v])
    if (is_image):
        hsv_map=reshape_(hsv_map,sz)
    return hsv_map
def flag_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('flag: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([1,0,0])
    else:
        if (n > 1):
            C=matlabarray([[1,0,0],[1,1,1],[0,0,1],[0,0,0]])
            _map=C[rem_(arange_(0,(n - 1)),4) + 1,:]
        else:
            _map=zeros_(0,3)
    return _map
def ntsc2rgb_(yiq=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[yiq].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not isa_(yiq,char('double'))):
        error_(char('ntsc2rgb: YIQ must be of type double'))
    if (ismatrix_(yiq) and ndims_(yiq) == 3):
        is_image=copy_(true)
        sz=size_(yiq)
        yiq=matlabarray([yiq[:,:,1](arange_()),yiq[:,:,2](arange_()),yiq[:,:,3](arange_())])
    else:
        is_image=copy_(false)
    if (not isreal_(yiq) or columns_(yiq) != 3 or issparse_(yiq)):
        error_(char('ntsc2rgb: input must be a matrix of size Nx3 or NxMx3'))
    trans=matlabarray([[1.0,1.0,1.0],[0.95617,- 0.27269,- 1.10374],[0.62143,- 0.64681,1.70062]])
    rgb=yiq * trans
    if (is_image):
        rgb=reshape_(rgb,sz)
    return rgb
def ind2gray_(x=None,map=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,_map].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    x,_map=ind2x_(char('ind2gray'),x,_map,nargout=2)
    _map *= [[0.29894],[0.58704],[0.11402]]
    cls=class_(x)
    if (isinteger_(x)):
        _map *= intmax_(cls)
    else:
        if (strcmp_(cls,char('single'))):
            _map=single_(_map)
    I=reshape_(_map[x[:]],size_(x))
    return I
def rgbplot_(cmap=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[cmap,style].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (not iscolormap_(cmap)):
        error_(char('rgbplot: CMAP must be a valid colormap'))
    else:
        if (not ischar_(style)):
            error_(char('rgbplot: STYLE must be a string'))
    if char('profile') == (tolower__(style)):
        htmp=plot_(cmap[:,1],char('r'),cmap[:,2],char('g'),cmap[:,3],char('b'))
        set_(gca,char('ytick'),arange_(0,1,0.1))
    else:
        if char('composite') == (tolower__(style)):
            htmp=image_(arange_(1,rows_(cmap)))
            set_(gca,char('ytick'),[])
            colormap_(cmap)
        else:
            error_(char("rgbplot: unknown style '%s'"),style)
    xlabel_(char('color index'))
    if (nargout > 0):
        h=copy_(htmp)
    return h
def hot_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('hot: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([1,1,1])
    else:
        if (n == 2):
            _map=matlabarray([1,1,1 / 2,1,1,1])
        else:
            if (n > 2):
                idx=floor_(3 / 8 * n)
                nel=copy_(idx)
                r=ones_(n,1)
                r[1:idx,1]=[arange_(1,nel)].T / nel
                g=zeros_(n,1)
                g[idx + 1:2 * idx,1]=r[1:idx]
                g[2 * idx + 1:end(),1]=1
                idx=2 * idx + 1
                nel=n - idx + 1
                b=zeros_(n,1)
                b[idx:end(),1]=[arange_(1,nel)].T / nel
                _map=matlabarray([r,g,b])
            else:
                _map=zeros_(0,3)
    return _map
def prism_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('prism: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([1,0,0])
    else:
        if (n > 1):
            C=matlabarray([[1,0,0],[1,1 / 2,0],[1,1,0],[0,1,0],[0,0,1],[2 / 3,0,1]])
            _map=C[rem_(arange_(0,(n - 1)),6) + 1,:]
        else:
            _map=zeros_(0,3)
    return _map
def hsv_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('hsv: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([1,0,0])
    else:
        if (n > 1):
            hue=[arange_(0,n - 1)].T / n
            _map=hsv2rgb_([hue,ones_(n,1),ones_(n,1)])
        else:
            _map=zeros_(0,3)
    return _map
def pink_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('pink: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=sqrt_([1 / 3,1 / 3,1 / 3])
    else:
        if (n == 2):
            _map=sqrt_([1 / 3,1 / 3,1 / 6,1,1,1])
        else:
            if (n > 2):
                x=[arange_(0,(n - 1))].T / (n - 1)
                idx=floor_(3 / 8 * n)
                base=1 / (3 * idx)
                nel=copy_(idx)
                r[1:idx,1]=linspace_(base,2 / 3 * x[idx] + 1 / 3,nel)
                r[idx + 1:n,1]=2 / 3 * x[idx + 1:n] + 1 / 3
                g[1:idx,1]=2 / 3 * x[1:idx]
                g[idx:2 * idx,1]=linspace_(2 / 3 * x[idx],2 / 3 * x[2 * idx] + 1 / 3,nel + 1)
                g[2 * idx + 1:n,1]=2 / 3 * x[2 * idx + 1:n] + 1 / 3
                nel=n - 2 * idx + 1
                b[1:2 * idx,1]=2 / 3 * x[1:2 * idx]
                b[2 * idx:n,1]=linspace_(2 / 3 * x[2 * idx],1,nel)
                _map=sqrt_([r,g,b])
            else:
                _map=zeros_(0,3)
    return _map
def bone_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('bone: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([1 / 8,1 / 8,1 / 8])
    else:
        if (n == 2):
            _map=matlabarray([1 / 16,1 / 8,1 / 8,1,1,1])
        else:
            if (n > 2):
                x=[arange_(0,n - 1)].T / (n - 1)
                idx=floor_(3 / 4 * n)
                nel=n - idx + 1
                rem=mod_(n,8)
                if [2,4] == (rem):
                    base=1 / (16 + 2 * (n - rem))
                else:
                    if [5,7] == (rem):
                        base=1 / (24 + 2 * (n - rem))
                    else:
                        base=0
                r[1:idx,1]=7 / 8 * x[1:idx]
                r[idx:n,1]=linspace_(7 / 8 * x[idx] + base,1,nel)
                idx=floor_(3 / 8 * n)
                nel=idx + 1
                g[1:idx,1]=7 / 8 * x[1:idx]
                g[idx:2 * idx,1]=linspace_(7 / 8 * x[idx],7 / 8 * x[2 * idx] + 1 / 8,nel)
                g[2 * idx + 1:n,1]=7 / 8 * x[2 * idx + 1:n] + 1 / 8
                base=1 / (8 * idx)
                nel=copy_(idx)
                b[1:idx,1]=linspace_(base,7 / 8 * x[idx] + 1 / 8,nel)
                b[idx:n,1]=7 / 8 * x[idx:n] + 1 / 8
                _map=matlabarray([r,g,b])
            else:
                _map=zeros_(0,3)
    return _map
def ocean_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('ocean: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([0,0,0])
    else:
        if (n > 1):
            cutin=fix_(n / 3)
            dr=(n - 1) / cutin
            r=prepad_([arange_(0,(n - 1),dr)],n).T
            dg=(n - 1) / (2 * cutin)
            g=prepad_([arange_(0,(n - 1),dg)],n).T
            b=[arange_(0,(n - 1))].T
            _map=[r,g,b] / (n - 1)
        else:
            _map=zeros_(0,3)
    return _map
def summer_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('summer: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([0,0.5,0.4])
    else:
        if (n > 1):
            r=[arange_(0,(n - 1))].T / (n - 1)
            g=0.5 + r / 2
            b=0.4 * ones_(n,1)
            _map=matlabarray([r,g,b])
        else:
            _map=zeros_(0,3)
    return _map
def contrast_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin == 1):
        n=rows_(colormap_())
    else:
        if (nargin == 2):
            if (not isscalar_(n)):
                error_(char('contrast: N must be a scalar'))
        else:
            print_usage_()
    x=x[:]
    minx=min_(x)
    cmap=find_(diff_(sort_([[round_(n * ((x - minx) / (max_(x) - minx)))],[[arange_(0,n)].T]])))
    minm=min_(cmap)
    cmap=(cmap - minm) / (max_(cmap) - minm)
    cmap=matlabarray([cmap,cmap,cmap])
    return cmap
def spinmap_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[t,inc].count(None)+len(args)

    if (nargin > 2):
        print_usage_()
    else:
        if (ischar_(t)):
            if (strcmpi_(t,char('inf'))):
                t=copy_(Inf)
            else:
                error_(char('spinmap: time T must be a real scalar or "inf"'))
        else:
            if (not isscalar_(t) or not isreal_(t)):
                error_(char('spinmap: time T must be a real scalar'))
    cmap=cmap_orig=get_(gcf_(),char('colormap'))
    t0=copy_(clock)
    while (etime_(clock,t0) < t):

        cmap=shift_(cmap,inc,1)
        set_(gcf_(),char('colormap'),cmap)
        drawnow_()

    set_(gcf_(),char('colormap'),cmap_orig)
    return
def white_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('white: N must be a scalar'))
        else:
            print_usage_()
    _map=ones_(n,3)
    return _map
def autumn_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('autumn: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([1,0,0])
    else:
        if (n > 1):
            r=ones_(n,1)
            g=[arange_(0,(n - 1))].T / (n - 1)
            b=zeros_(n,1)
            _map=matlabarray([r,g,b])
        else:
            _map=zeros_(0,3)
    return _map
def lines_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 0):
        n=rows_(colormap)
    else:
        if (nargin == 1):
            if (not isscalar_(n)):
                error_(char('lines: N must be a scalar'))
        else:
            print_usage_()
    if (n == 1):
        _map=matlabarray([0,0,1])
    else:
        if (n > 1):
            C=get_(gca,char('colororder'))
            nr=rows_(C)
            _map=C[rem_(arange_(0,(n - 1)),nr) + 1,:]
        else:
            _map=zeros_(0,3)
    return _map
def imshow_(im=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[im].count(None)+len(args)

    if (nargin == 0):
        print_usage_()
    display_range=copy_(NA)
    true_color=copy_(false)
    indexed=copy_(false)
    xdata=ydata=matlabarray([])
    if (ischar_(im)):
        im,_map=imread_(im,nargout=2)
        indexed=copy_(true)
        colormap_(_map)
    nd=ndims_(im)
    if (not ((isnumeric_(im) or islogical_(im)) and (nd == 2 or nd == 3))):
        error_(char('imshow: IM must be an image or the filename of an image'))
    if (nd == 2):
        if (not indexed):
            colormap_(gray_())
    else:
        if (size_(im,3) == 3):
            if (ismember_(class_(im),[char('uint8'),char('uint16'),char('double'),char('single')])):
                true_color=copy_(true)
            else:
                error_(char('imshow: color image must be uint8, uint16, double, or single'))
        else:
            error_(char('imshow: expecting MxN or MxNx3 matrix for image'))
    narg=1
    while (narg <= numel_(varargin)):

        arg=varargin[narg]
        if (isnumeric_(arg)):
            if (numel_(arg) == 2 or isempty_(arg)):
                display_range=copy_(arg)
            else:
                if (columns_(arg) == 3):
                    indexed=copy_(true)
                    colormap_(arg)
                else:
                    if (not isempty_(arg)):
                        error_(char('imshow: argument number %d is invalid'),narg + 1)
        else:
            if (ischar_(arg)):
                if char('displayrange') == (tolower____(arg)):
                    display_range=varargin[narg]
                else:
                    if char('xdata') == (tolower____(arg)):
                        xdata=varargin[narg]
                        if (not isvector_(xdata)):
                            error_(char('imshow: xdata must be a vector'))
                        xdata=matlabarray([xdata[1],xdata[end()]])
                    else:
                        if char('ydata') == (tolower____(arg)):
                            ydata=varargin[narg]
                            if (not isvector_(ydata)):
                                error_(char('imshow: expect a vector for ydata'))
                            ydata=matlabarray([ydata[1],ydata[end()]])
                        else:
                            if [char('truesize'),char('initialmagnification')] == (tolower____(arg)):
                                warning_(char('image: zoom argument ignored -- use GUI features'))
                            else:
                                warning_(char('imshow: unrecognized property %s'),arg)
                                narg
            else:
                error_(char('imshow: argument number %d is invalid'),narg + 1)

    if (iscomplex_(im)):
        warning_(char('imshow: only showing real part of complex image'))
        im=real_(im)
    if (isempty_(display_range)):
        display_range=matlabarray([min_(im[:]),max_(im[:])])
    else:
        if (isna_(display_range)):
            t=class_(im)
            if [char('double'),char('single'),char('logical')] == (t):
                display_range=matlabarray([0,1])
            else:
                if [char('int8'),char('int16'),char('int32'),char('uint8'),char('uint16'),char('uint32')] == (t):
                    display_range=matlabarray([intmin_(t),intmax_(t)])
                else:
                    error_(char('imshow: invalid data type for image'))
    nans=isnan_(im[:])
    if (any_(nans)):
        warning_(char('Octave:imshow-NaN'),char('imshow: pixels with NaN or NA values are set to minimum pixel value'))
        im[nans]=display_range[1]
    if (not (indexed or (true_color and isinteger_(im))) or islogical_(im)):
        im=double_(im)
    if (not (true_color or indexed or islogical_(im))):
        low=display_range[1]
        high=display_range[2]
        im[im < low]=low
        im[im > high]=high
    if (true_color or indexed):
        tmp=image_(xdata,ydata,im)
    else:
        tmp=image_(xdata,ydata,im)
        set_(tmp,char('cdatamapping'),char('scaled'))
        set_(gca_(),char('clim'),display_range)
    set_(gca_(),char('visible'),char('off'),char('ydir'),char('reverse'))
    axis_(char('image'))
    if (nargout > 0):
        h=copy_(tmp)
    return h
def spconvert_(m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[m].count(None)+len(args)

    if (issparse_(m)):
        s=copy_(m)
    else:
        sz=size_(m)
        if (nargin != 1 or not ismatrix_(m) or not isreal_(m) or length_(sz) != 2 or (sz[2] != 3 and sz[2] != 4)):
            error_(char('spconvert: argument must be sparse or real matrix with 3 or 4 columns'))
        else:
            if (sz[2] == 3):
                s=sparse_(m[:,1],m[:,2],m[:,3])
            else:
                s=sparse_(m[:,1],m[:,2],m[:,3] + 1j * m[:,4])
    return s
def sprandn_(m=None,n=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[m,n,d].count(None)+len(args)

    if (nargin == 1):
        S=__sprand_impl___(m,randn)
    else:
        if (nargin == 3):
            S=__sprand_impl___(m,n,d,char('sprandn'),randn)
        else:
            print_usage_()
    return S
def bicg_(A=None,b=None,tol=None,maxit=None,M1=None,M2=None,x0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[A,b,tol,maxit,M1,M2,x0].count(None)+len(args)

    if (nargin >= 2 and isvector_(full_(b))):
        if (ischar_(A)):
            fun=str2func_(A)
            Ax=lambda x: feval_(fun,x,char('notransp'))
            Atx=lambda x: feval_(fun,x,char('transp'))
        else:
            if (ismatrix_(A)):
                Ax=lambda x: A * x
                Atx=lambda x: A.T * x
            else:
                if (isa_(A,char('function_handle'))):
                    Ax=lambda x: feval_(A,x,char('notransp'))
                    Atx=lambda x: feval_(A,x,char('transp'))
                else:
                    error_([char('bicg: first argument is expected to '),char('be a function or a square matrix')])
        if (nargin < 3 or isempty_(tol)):
            tol=1e-06
        if (nargin < 4 or isempty_(maxit)):
            maxit=min_(rows_(b),20)
        if (nargin < 5 or isempty_(M1)):
            M1m1x=lambda x,ignore: x
            M1tm1x=copy_(M1m1x)
        else:
            if (ischar_(M1)):
                fun=str2func_(M1)
                M1m1x=lambda x: feval_(fun,x,char('notransp'))
                M1tm1x=lambda x: feval_(fun,x,char('transp'))
            else:
                if (ismatrix_(M1)):
                    M1m1x=lambda x: numpy.linalg.solve(M1,x)
                    M1tm1x=lambda x: numpy.linalg.solve(M1.T,x)
                else:
                    if (isa_(M1,char('function_handle'))):
                        M1m1x=lambda x: feval_(M1,x,char('notransp'))
                        M1tm1x=lambda x: feval_(M1,x,char('transp'))
                    else:
                        error_([char('bicg: preconditioner is expected to '),char('be a function or matrix')])
        if (nargin < 6 or isempty_(M2)):
            M2m1x=lambda x,ignore: x
            M2tm1x=copy_(M2m1x)
        else:
            if (ischar_(M2)):
                fun=str2func_(M2)
                M2m1x=lambda x: feval_(fun,x,char('notransp'))
                M2tm1x=lambda x: feval_(fun,x,char('transp'))
            else:
                if (ismatrix_(M2)):
                    M2m1x=lambda x: numpy.linalg.solve(M2,x)
                    M2tm1x=lambda x: numpy.linalg.solve(M2.T,x)
                else:
                    if (isa_(M2,char('function_handle'))):
                        M2m1x=lambda x: feval_(M2,x,char('notransp'))
                        M2tm1x=lambda x: feval_(M2,x,char('transp'))
                    else:
                        error_([char('bicg: preconditioner is expected to '),char('be a function or matrix')])
        Pm1x=lambda x: M2m1x[M1m1x[x]]
        Ptm1x=lambda x: M1tm1x[M2tm1x[x]]
        if (nargin < 7 or isempty_(x0)):
            x0=zeros_(size_(b))
        y=x=copy_(x0)
        c=copy_(b)
        r0=b - Ax[x]
        s0=c - Atx[y]
        d=Pm1x[r0]
        f=Ptm1x[s0]
        bnorm=norm_(b)
        res0=copy_(Inf)
        if (any_(r0 != 0)):
            for k in arange_(1,maxit).reshape(-1):
                a=(s0.T * Pm1x[r0]) / (f.T * Ax[d])
                x += a * d
                y += conj_(a) * f
                r1=r0 - a * Ax[d]
                s1=s0 - conj_(a) * Atx[f]
                beta=(s1.T * Pm1x[r1]) / (s0.T * Pm1x[r0])
                d=Pm1x[r1] + beta * d
                f=Ptm1x[s1] + conj_(beta) * f
                r0=copy_(r1)
                s0=copy_(s1)
                res1=norm_(b - Ax[x]) / bnorm
                if (res1 < tol):
                    flag=0
                    if (nargout < 2):
                        printf_(char('bicg converged at iteration %i '),k)
                        printf_(char('to a solution with relative residual %e\n'),res1)
                    break
                if (res0 <= res1):
                    flag=3
                    printf_(char('bicg stopped at iteration %i '),k)
                    printf_(char('without converging to the desired tolerance %e\n'),tol)
                    printf_(char('because the method stagnated.\n'))
                    printf_(char('The iterate returned (number %i) '),k - 1)
                    printf_(char('has relative residual %e\n'),res0)
                    break
                res0=copy_(res1)
                if (nargout > 4):
                    resvec[k]=res0
            if (k == maxit):
                flag=1
                printf_(char('bicg stopped at iteration %i '),maxit)
                printf_(char('without converging to the desired tolerance %e\n'),tol)
                printf_(char('because the maximum number of iterations was reached. '))
                printf_(char('The iterate returned (number %i) has '),maxit)
                printf_(char('relative residual %e\n'),res1)
        else:
            flag=0
            if (nargout < 2):
                printf_(char('bicg converged after 0 interations\n'))
    else:
        print_usage_()
    return x,flag,res1,k,resvec
def bicgstab_(A=None,b=None,tol=None,maxit=None,M1=None,M2=None,x0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[A,b,tol,maxit,M1,M2,x0].count(None)+len(args)

    if (nargin >= 2 and nargin <= 7 and isvector_(full_(b))):
        if (ischar_(A)):
            A=str2func_(A)
        else:
            if (ismatrix_(A)):
                Ax=lambda x: A * x
            else:
                if (isa_(A,char('function_handle'))):
                    Ax=lambda x: feval_(A,x)
                else:
                    error_([char('bicgstab: first argument is expected '),char('to be a function or a square matrix')])
        if (nargin < 3 or isempty_(tol)):
            tol=1e-06
        if (nargin < 4 or isempty_(maxit)):
            maxit=min_(rows_(b),20)
        if (nargin < 5 or isempty_(M1)):
            M1m1x=lambda x: x
        else:
            if (ischar_(M1)):
                M1m1x=str2func_(M1)
            else:
                if (ismatrix_(M1)):
                    M1m1x=lambda x: numpy.linalg.solve(M1,x)
                else:
                    if (isa_(M1,char('function_handle'))):
                        M1m1x=lambda x: feval_(M1,x)
                    else:
                        error_([char('bicgstab: preconditioner is '),char('expected to be a function or matrix')])
        if (nargin < 6 or isempty_(M2)):
            M2m1x=lambda x: x
        else:
            if (ischar_(M2)):
                M2m1x=str2func_(M2)
            else:
                if (ismatrix_(M2)):
                    M2m1x=lambda x: numpy.linalg.solve(M2,x)
                else:
                    if (isa_(M2,char('function_handle'))):
                        M2m1x=lambda x: feval_(M2,x)
                    else:
                        error_([char('bicgstab: preconditioner is '),char('expected to be a function or matrix')])
        precon=lambda x: M2m1x[M1m1x[x]]
        if (nargin < 7 or isempty_(x0)):
            x0=zeros_(size_(b))
        if (nargin < 7):
            x=zeros_(rows_(b),1)
        else:
            x=copy_(x0)
        norm_b=norm_(b)
        res=b - Ax[x]
        rr=copy_(res)
        resvec=norm_(res) / norm_b
        flag=1
        for _iter in arange_(1,maxit).reshape(-1):
            rho_1=rr.T * res
            if (_iter == 1):
                p=copy_(res)
            else:
                beta=(rho_1 / rho_2) * (alpha / omega)
                p=res + beta * (p - omega * v)
            phat=precon[p]
            v=Ax[phat]
            alpha=rho_1 / (rr.T * v)
            s=res - alpha * v
            shat=precon[s]
            t=Ax[shat]
            omega=(s.T * t) / (t.T * t)
            x=x + alpha * phat + omega * shat
            res=s - omega * t
            rho_2=copy_(rho_1)
            relres=norm_(res) / norm_b
            resvec=matlabarray([[resvec],[relres]])
            if (relres <= tol):
                flag=0
                break
            else:
                if (resvec[end()] == resvec[end() - 1]):
                    flag=3
                    break
        if (nargout < 2):
            if (flag == 0):
                printf_(char('bicgstab converged at iteration %i '),_iter)
                printf_(char('to a solution with relative residual %e\n'),relres)
            else:
                if (flag == 3):
                    printf_(char('bicgstab stopped at iteration %i '),_iter)
                    printf_(char('without converging to the desired tolerance %e\n'),tol)
                    printf_(char('because the method stagnated.\n'))
                    printf_(char('The iterate returned (number %i) '),_iter)
                    printf_(char('has relative residual %e\n'),relres)
                else:
                    printf_(char('bicgstab stopped at iteration %i '),_iter)
                    printf_(char('without converging to the desired toleranc %e\n'),tol)
                    printf_(char('because the maximum number of iterations was reached.\n'))
                    printf_(char('The iterate returned (number %i) '),_iter)
                    printf_(char('has relative residual %e\n'),relres)
    else:
        print_usage_()
    return x,flag,relres,_iter,resvec
def nonzeros_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    __,__,t=find_(s,nargout=3)
    t=t[:]
    return t
def speye_(m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[m,n].count(None)+len(args)

    if (nargin == 1):
        if (isvector_(m) and length_(m) == 2):
            n=m[2]
            m=m[1]
        else:
            if (isscalar_(m)):
                n=copy_(m)
            else:
                error_(char('speye: invalid matrix dimension'))
    else:
        if (not isscalar_(m) or not isscalar_(n)):
            error_(char('speye: invalid matrix dimension'))
    lo=min_([m,n])
    s=sparse_(arange_(1,lo),arange_(1,lo),1,m,n)
    return s
def treelayout_(tree=None,permutation=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[tree,permutation].count(None)+len(args)

    if (nargin < 1 or nargin > 2 or nargout > 4):
        print_usage_()
    else:
        if (not isvector_(tree) or rows_(tree) != 1 or not isnumeric_(tree) or any_(tree > length_(tree)) or any_(tree < 0)):
            error_(char('treelayout: the first input argument must be a vector of predecessors'))
        else:
            tree=tree[:].T
            num_nodes=length_(tree)
            num_children=zeros_(1,num_nodes + 1)
            for i in arange_(1,num_nodes).reshape(-1):
                if (tree[i] < i):
                    continue
                tortoise=tree[i]
                hare=tree[tortoise]
                while (tortoise != hare):

                    if (hare < i):
                        break
                    tortoise=tree[tortoise]
                    hare=tree[tree[hare]]

                if (tortoise == hare):
                    error_(char('treelayout: vector of predecessors has bad format'))
            for i in arange_(1,num_nodes).reshape(-1):
                num_children[tree[i] + 1]=num_children[tree[i] + 1] + 1
            pos=1
            start=zeros_(1,num_nodes + 1)
            xhelp=zeros_(1,num_nodes + 1)
            stop=zeros_(1,num_nodes + 1)
            for i in arange_(1,num_nodes + 1).reshape(-1):
                start[i]=pos
                xhelp[i]=pos
                pos += num_children[i]
                stop[i]=pos
            if (nargin == 1):
                for i in arange_(1,num_nodes).reshape(-1):
                    vec_of_child[xhelp[tree[i] + 1]]=i
                    xhelp[tree[i] + 1]=xhelp[tree[i] + 1] + 1
            else:
                vec_of_child=copy_(permutation)
            par_number=0
            left_most=0
            level=copy_(num_nodes)
            max_ht=copy_(num_nodes)
            stk=matlabarray([- 1,0])
            s=0
            top_level=1
            while (par_number != - 1):

                if (start[par_number + 1] < stop[par_number + 1]):
                    idx=vec_of_child[start[par_number + 1]:stop[par_number + 1] - 1]
                else:
                    idx=zeros_(1,0)
                stk=matlabarray([[stk],[[idx.T,ones_(fliplr_(size_(idx))) * par_number]]])
                if (columns_(idx) == 1 and top_level == 1):
                    s
                else:
                    top_level=0
                if (stk[end(),2] != par_number):
                    left_most
                    x_coordinate_r[par_number]=left_most
                    max_ht=min_(max_ht,level)
                    if (length_(stk) > 1 and find_((shift_(stk,1) - stk) == 0) > 1 and stk[end(),2] != stk[end() - 1,2]):
                        position=(find_((shift_(stk[:,2],1) - stk[:,2]) == 0))(end()) + 1
                        par_number_vec=stk[position:end(),2]
                        level += length_(par_number_vec)
                        x_coordinate_r[par_number_vec]=left_most
                        stk[position:end(),:]=[]
                    stk[end(),:]=[]
                    par_number=stk[end(),1]
                    if (par_number != - 1):
                        y_coordinate[par_number]=level
                        x_coordinate_l[par_number]=left_most + 1
                else:
                    level
                    par_number=stk[end(),1]
                    y_coordinate[par_number]=level
                    x_coordinate_l[par_number]=left_most + 1

            x_coordinate=(x_coordinate_l + x_coordinate_r) / 2
            height=num_nodes - max_ht - 1
    return x_coordinate,y_coordinate,height,s
def svds_(A=None,k=None,sigma=None,opts=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[A,k,sigma,opts].count(None)+len(args)

    root2=sqrt_(2)
    if (nargin < 1 or nargin > 4):
        print_usage_()
    if (ndims_(A) > 2):
        error_(char('svds: A must be a 2-D matrix'))
    if (nargin < 4):
        opts.tol=0
        opts.disp=0
        opts.maxit=300
    else:
        if (not isstruct_(opts)):
            error_(char('svds: OPTS must be a structure'))
        if (not isfield_(opts,char('tol'))):
            opts.tol=0
        else:
            opts.tol=opts.tol / root2
        if (isfield_(opts,char('v0'))):
            if (not isvector_(opts.v0) or (length_(opts.v0) != sum_(size_(A)))):
                error_(char('svds: OPTS.v0 must be a vector with rows(A)+columns(A) entries'))
    if (nargin < 3 or strcmp_(sigma,char('L'))):
        if (isreal_(A)):
            sigma=char('LA')
        else:
            sigma=char('LR')
    else:
        if (isscalar_(sigma) and isnumeric_(sigma) and isreal_(sigma)):
            if (sigma < 0):
                error_(char('svds: SIGMA must be a positive real value'))
        else:
            error_(char("svds: SIGMA must be a positive real value or the string 'L'"))
    m,n=size_(A,nargout=2)
    max_a=max_(abs_(nonzeros_(A)))
    if (isempty_(max_a)):
        max_a=0
    flag=0
    if (max_a == 0):
        s=zeros_(k,1)
    else:
        if (nargin < 2):
            k=min_([6,m,n])
        else:
            k=min_([k,m,n])
        b=A / max_a
        b_opts=copy_(opts)
        b_opts.issym=true
        b_sigma=copy_(sigma)
        if (not ischar_(b_sigma)):
            b_sigma=b_sigma / max_a
        if (b_sigma == 0):
            b_k=2 * k
        else:
            b_k=copy_(k)
        if (nargout > 1):
            V,s,flag=eigs_([[sparse_(m,m),b],[b.T,sparse_(n,n)]],b_k,b_sigma,b_opts,nargout=3)
            s=diag_(s)
        else:
            s=eigs_([[sparse_(m,m),b],[b.T,sparse_(n,n)]],b_k,b_sigma,b_opts)
        if (ischar_(sigma)):
            norma=max_(s)
        else:
            norma=normest_(A)
        tol=norma * opts.tol
        ind=find_(s > tol)
        if (length_(ind) < k):
            zind=find_(abs_(s) <= tol)
            p=min_(length_(zind),k - length_(ind))
            ind=matlabarray([[ind],[zind[1:p]]])
        else:
            if (length_(ind) > k):
                if (b_sigma == 0):
                    ind=ind[end() + 1 - k:end()]
                else:
                    ind=ind[1:k]
        s=s[ind]
        if (length_(s) < k):
            warning_(char('returning fewer singular values than requested'))
            if (not ischar_(sigma)):
                warning_(char('try increasing the value of sigma'))
        s=s * max_a
    if (nargout < 2):
        u=copy_(s)
    else:
        if (max_a == 0):
            u=eye_(m,k)
            s=diag_(s)
            v=eye_(n,k)
        else:
            u=root2 * V[1:m,ind]
            s=diag_(s)
            v=root2 * V[m + 1:end(),ind]
        if (nargout > 3):
            flag=(flag != 0)
    return u,s,v,flag
def spstats_(S=None,j=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[S,j].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin == 1):
        i,j,v=find_(S,nargout=3)
    else:
        v=copy_(S)
        i=arange_(1,length_(v))
        S=sparse_(i,j,v)
    n,m=size_(S,nargout=2)
    count=sum_(sparse_(i,j,1,n,m))
    if (nargout > 1):
        mean=sum_(S) / count
    if (nargout > 2):
        diff=S - sparse_(i,j,mean[j],n,m)
        var=sum_(diff.dot(diff)) / (count - 1)
    return count,mean,var
def __sprand_impl___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 2):
        m=varargin[1]
        randfun=varargin[2]
        i,j=find_(m,nargout=2)
        nr,nc=size_(m,nargout=2)
        S=sparse_(i,j,randfun[size_(i)],nr,nc)
        return S
    m,n,d,funname,randfun=deal_(varargin[:],nargout=5)
    if (not (isscalar_(m) and m == fix_(m) and m > 0)):
        error_(char('%s: M must be an integer greater than 0'),funname)
    if (not (isscalar_(n) and n == fix_(n) and n > 0)):
        error_(char('%s: N must be an integer greater than 0'),funname)
    if (d < 0 or d > 1):
        error_(char('%s: density D must be between 0 and 1'),funname)
    mn=m * n
    k=round_(d * mn)
    if (mn > sizemax_()):
        idx=unique_(fix_(rand_(min_(k * 1.01,k + 10),1) * mn)) + 1
        k=min_(length_(idx),k)
        j=floor_((idx[1:k] - 1) / m)
        i=idx[1:k] - j * m
        j
    else:
        idx=randperm_(mn,k)
        i,j=ind2sub_([m,n],idx,nargout=2)
    S=sparse_(i,j,randfun[k,1],m,n)
    return S
def pcr_(A=None,b=None,tol=None,maxit=None,m=None,x0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[A,b,tol,maxit,m,x0].count(None)+len(args)

    breakdown=copy_(false)
    if (nargin < 6 or isempty_(x0)):
        x=zeros_(size_(b))
    else:
        x=copy_(x0)
    if (nargin < 5):
        m=matlabarray([])
    if (nargin < 4 or isempty_(maxit)):
        maxit=20
    maxit += 2
    if (nargin < 3 or isempty_(tol)):
        tol=1e-06
    if (nargin < 2):
        print_usage_()
    if (isnumeric_(A)):
        r=b - A * x
    else:
        r=b - feval_(A,x,varargin[:])
    if (isnumeric_(m)):
        if (isempty_(m)):
            p=copy_(r)
        else:
            p=numpy.linalg.solve(m,r)
    else:
        p=feval_(m,r,varargin[:])
    _iter=2
    b_bot_old=1
    q_old=p_old=s_old=zeros_(size_(x))
    if (isnumeric_(A)):
        q=A * p
    else:
        q=feval_(A,p,varargin[:])
    resvec[1]=abs_(norm_(r))
    while (resvec[_iter - 1] > tol * resvec[1] and _iter < maxit):

        if (isnumeric_(m)):
            if (isempty_(m)):
                s=copy_(q)
            else:
                s=numpy.linalg.solve(m,q)
        else:
            s=feval_(m,q,varargin[:])
        b_top=r.T * s
        b_bot=q.T * s
        if (b_bot == 0.0):
            breakdown=copy_(true)
            break
        _lambda=b_top / b_bot
        x += _lambda * p
        r -= _lambda * q
        if (isnumeric_(A)):
            t=A * s
        else:
            t=feval_(A,s,varargin[:])
        alpha0=(t.T * s) / b_bot
        alpha1=(t.T * s_old) / b_bot_old
        p_temp=copy_(p)
        q_temp=copy_(q)
        p=s - alpha0 * p - alpha1 * p_old
        q=t - alpha0 * q - alpha1 * q_old
        s_old=copy_(s)
        p_old=copy_(p_temp)
        q_old=copy_(q_temp)
        b_bot_old=copy_(b_bot)
        resvec[_iter]=abs_(norm_(r))
        _iter

    flag=0
    relres=resvec[_iter - 1] / resvec[1]
    _iter -= 2
    if (_iter >= maxit - 2):
        flag=1
        if (nargout < 2):
            warning_(char('pcr: maximum number of iterations (%d) reached\n'),_iter)
            warning_(char('the initial residual norm was reduced %g times.\n'),1.0 / relres)
    else:
        if (nargout < 2 and not breakdown):
            fprintf_(stderr,char('pcr: converged in %d iterations. \n'),_iter)
            fprintf_(stderr,char('the initial residual norm was reduced %g times.\n'),1.0 / relres)
    if (breakdown):
        flag=3
        if (nargout < 2):
            warning_(char('pcr: breakdown occurred:\n'))
            warning_(char('system matrix singular or preconditioner indefinite?\n'))
    return x,flag,relres,_iter,resvec
def spy_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    markersize=copy_(NaN)
    if (nnz_(x) < 1000):
        line_spec=char('*')
    else:
        line_spec=char('.')
    for i in arange_(1,length_(varargin)).reshape(-1):
        if (ischar_(varargin[i])):
            if (length_(varargin[i]) == 1):
                line_spec=matlabarray([line_spec,varargin[i]])
            else:
                line_spec=varargin[i]
        else:
            if (isscalar_(varargin[i])):
                markersize=varargin[i]
            else:
                error_(char('spy: expected markersize or linespec'))
    i,j,s=find_(x,nargout=3)
    m,n=size_(x,nargout=2)
    if (isnan_(markersize)):
        plot_(j,i,line_spec)
    else:
        plot_(j,i,line_spec,char('markersize'),markersize)
    axis_([0,n + 1,0,m + 1],char('ij'))
    return
def spones_(S=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[S].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    i,j,v=find_(S,nargout=3)
    m,n=size_(S,nargout=2)
    r=sparse_(i,j,1,m,n)
    return r
def gmres_(A=None,b=None,restart=None,rtol=None,maxit=None,M1=None,M2=None,x0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 8-[A,b,restart,rtol,maxit,M1,M2,x0].count(None)+len(args)

    if (nargin < 2 or nargin > 8):
        print_usage_()
    if (ischar_(A)):
        Ax=str2func_(A)
    else:
        if (ismatrix_(A)):
            Ax=lambda x: A * x
        else:
            if (isa_(A,char('function_handle'))):
                Ax=copy_(A)
            else:
                error_(char('gmres: A must be a function or matrix'))
    if (nargin < 3 or isempty_(restart)):
        restart=rows_(b)
    if (nargin < 4 or isempty_(rtol)):
        rtol=1e-06
    if (nargin < 5 or isempty_(maxit)):
        maxit=min_(rows_(b) / restart,10)
    if (nargin < 6 or isempty_(M1)):
        M1m1x=lambda x: x
    else:
        if (ischar_(M1)):
            M1m1x=str2func_(M1)
        else:
            if (ismatrix_(M1)):
                M1m1x=lambda x: numpy.linalg.solve(M1,x)
            else:
                if (isa_(M1,char('function_handle'))):
                    M1m1x=copy_(M1)
                else:
                    error_(char('gmres: preconditioner M1 must be a function or matrix'))
    if (nargin < 7 or isempty_(M2)):
        M2m1x=lambda x: x
    else:
        if (ischar_(M2)):
            M2m1x=str2func_(M2)
        else:
            if (ismatrix_(M2)):
                M2m1x=lambda x: numpy.linalg.solve(M2,x)
            else:
                if (isa_(M2,char('function_handle'))):
                    M2m1x=copy_(M2)
                else:
                    error_(char('gmres: preconditioner M2 must be a function or matrix'))
    Pm1x=lambda x: M2m1x[M1m1x[x]]
    if (nargin < 8 or isempty_(x0)):
        x0=zeros_(size_(b))
    x_old=copy_(x0)
    x=copy_(x_old)
    prec_res=Pm1x[b - Ax[x_old]]
    presn=norm_(prec_res,2)
    B=zeros_(restart + 1,1)
    V=zeros_(rows_(x),restart)
    H=zeros_(restart + 1,restart)
    _iter=1
    restart_it=restart + 1
    resvec=zeros_(maxit,1)
    resvec[1]=presn
    prec_b_norm=norm_(Pm1x[b],2)
    flag=1
    while (_iter <= maxit * restart and presn > rtol * prec_b_norm):

        if (restart_it > restart):
            restart_it=1
            x_old=copy_(x)
            prec_res=Pm1x[b - Ax[x_old]]
            presn=norm_(prec_res,2)
            B[1]=presn
            H[:]=0
            V[:,1]=prec_res / presn
        tmp=Pm1x[Ax[V[:,restart_it]]]
        V[:,restart_it + 1],H[1:restart_it + 1,restart_it]=mgorth_(tmp,V[:,1:restart_it],nargout=2)
        Y=(numpy.linalg.solve(H[1:restart_it + 1,1:restart_it],B[1:restart_it + 1]))
        little_res=B[1:restart_it + 1] - H[1:restart_it + 1,1:restart_it] * Y[1:restart_it]
        presn=norm_(little_res,2)
        x=x_old + V[:,1:restart_it] * Y[1:restart_it]
        resvec[_iter + 1]=presn
        if (norm_(x - x_old,inf) <= eps):
            flag=3
            break
        restart_it
        _iter

    if (nargout > 1):
        relres=presn / prec_b_norm
        if (relres <= rtol):
            flag=0
        it=matlabarray([floor_(_iter / restart),restart_it - 1])
    return x,flag,relres,it,resvec
def pcg_(A=None,b=None,tol=None,maxit=None,m1=None,m2=None,x0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[A,b,tol,maxit,m1,m2,x0].count(None)+len(args)

    if (nargin < 7 or isempty_(x0)):
        x=zeros_(size_(b))
    else:
        x=copy_(x0)
    if (nargin < 5 or isempty_(m1)):
        exist_m1=0
    else:
        exist_m1=1
    if (nargin < 6 or isempty_(m2)):
        exist_m2=0
    else:
        exist_m2=1
    if (nargin < 4 or isempty_(maxit)):
        maxit=min_(rows_(b),20)
    maxit += 2
    if (nargin < 3 or isempty_(tol)):
        tol=1e-06
    preconditioned_residual_out=copy_(false)
    if (nargout > 5):
        T=zeros_(maxit,maxit)
        preconditioned_residual_out=copy_(true)
    matrix_positive_definite=copy_(true)
    p=zeros_(size_(b))
    oldtau=1
    if (isnumeric_(A)):
        r=b - A * x
    else:
        r=b - feval_(A,x,varargin[:])
    b_norm=norm_(b)
    resvec[1,1]=norm_(r)
    alpha=1
    _iter=2
    while (resvec[_iter - 1,1] > tol * b_norm and _iter < maxit):

        if (exist_m1):
            if (isnumeric_(m1)):
                y=numpy.linalg.solve(m1,r)
            else:
                y=feval_(m1,r,varargin[:])
        else:
            y=copy_(r)
        if (exist_m2):
            if (isnumeric_(m2)):
                z=numpy.linalg.solve(m2,y)
            else:
                z=feval_(m2,y,varargin[:])
        else:
            z=copy_(y)
        tau=z.T * r
        resvec[_iter - 1,2]=sqrt_(tau)
        beta=tau / oldtau
        oldtau=copy_(tau)
        p=z + beta * p
        if (isnumeric_(A)):
            w=A * p
        else:
            w=feval_(A,p,varargin[:])
        oldalpha=copy_(alpha)
        alpha=tau / (p.T * w)
        if (alpha <= 0.0):
            matrix_positive_definite=copy_(false)
        x += alpha * p
        r -= alpha * w
        if (nargout > 5 and _iter > 2):
            T[_iter - 1:_iter,_iter - 1:_iter]=T[_iter - 1:_iter,_iter - 1:_iter] + [[1,sqrt_(beta)],[sqrt_(beta),beta]] / oldalpha
        resvec[_iter,1]=norm_(r)
        _iter

    if (nargout > 5):
        if (matrix_positive_definite):
            if (_iter > 3):
                T=T[2:_iter - 2,2:_iter - 2]
                l=eig_(T)
                eigest=matlabarray([min_(l),max_(l)])
            else:
                eigest=matlabarray([NaN,NaN])
                warning_(char('pcg: eigenvalue estimate failed: iteration converged too fast'))
        else:
            eigest=matlabarray([NaN,NaN])
        if (exist_m1):
            if (isnumeric_(m1)):
                y=numpy.linalg.solve(m1,r)
            else:
                y=feval_(m1,r,varargin[:])
        else:
            y=copy_(r)
        if (exist_m2):
            if (isnumeric_(m2)):
                z=numpy.linalg.solve(m2,y)
            else:
                z=feval_(m2,y,varargin[:])
        else:
            z=copy_(y)
        resvec[_iter - 1,2]=sqrt_(r.T * z)
    else:
        resvec=resvec[:,1]
    flag=0
    relres=resvec[_iter - 1,1] / resvec[1,1]
    _iter -= 2
    if (_iter >= maxit - 2):
        flag=1
        if (nargout < 2):
            warning_(char('pcg: maximum number of iterations (%d) reached\n'),_iter)
            warning_(char('the initial residual norm was reduced %g times.\n'),1.0 / relres)
    else:
        if (nargout < 2):
            fprintf_(stderr,char('pcg: converged in %d iterations. '),_iter)
            fprintf_(stderr,char('the initial residual norm was reduced %g times.\n'),1.0 / relres)
    if (not matrix_positive_definite):
        flag=3
        if (nargout < 2):
            warning_(char('pcg: matrix not positive definite?\n'))
    return x,flag,relres,_iter,resvec,eigest
def sprand_(m=None,n=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[m,n,d].count(None)+len(args)

    if (nargin == 1):
        S=__sprand_impl___(m,rand)
    else:
        if (nargin == 3):
            S=__sprand_impl___(m,n,d,char('sprand'),rand)
        else:
            print_usage_()
    return S
def spaugment_(A=None,c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,c].count(None)+len(args)

    if (nargin < 2):
        if (issparse_(A)):
            c=max_(max_(abs_(A))) / 1000
        else:
            if (ndims_(A) != 2):
                error_(char('spaugment: expecting 2-dimenisional matrix'))
            else:
                c=max_(abs_(A[:])) / 1000
    else:
        if (not isscalar_(c)):
            error_(char('spaugment: C must be a scalar'))
    m,n=size_(A,nargout=2)
    s=matlabarray([[c * speye_(m,m),A],[A.T,sparse_(n,n)]])
    return s
def spfun_(f=None,S=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,S].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    i,j,v=find_(S,nargout=3)
    m,n=size_(S,nargout=2)
    if (isa_(f,char('function_handle')) or isa_(f,char('inline function'))):
        y=sparse_(i,j,f[v],m,n)
    else:
        y=sparse_(i,j,feval_(f,v),m,n)
    return y
def gplot_(A=None,xy=None,line_style=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[A,xy,line_style].count(None)+len(args)

    if (nargin < 2 or nargin > 3 or nargout > 2):
        print_usage_()
    if (nargin == 2):
        line_style=char('-')
    i,j=find_(A,nargout=2)
    xcoord=[xy[i,1],xy[j,1],NaN_(length_(i),1)].T(arange_())
    ycoord=[xy[i,2],xy[j,2],NaN_(length_(i),1)].T(arange_())
    if (nargout == 0):
        plot_(xcoord,ycoord,line_style)
    else:
        x=copy_(xcoord)
        y=copy_(ycoord)
    return x,y
def colperm_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    i,j=find_(s,nargout=2)
    idx=find_(diff_([[j],[Inf]]) != 0)
    dummy,p=sort_(idx - [[0],[idx[1:(end() - 1)]]],nargout=2)
    return p
def cgs_(A=None,b=None,tol=None,maxit=None,M1=None,M2=None,x0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[A,b,tol,maxit,M1,M2,x0].count(None)+len(args)

    if (nargin >= 2 and nargin <= 7 and isvector_(full_(b))):
        if (ischar_(A)):
            A=str2func_(A)
        else:
            if (ismatrix_(A)):
                Ax=lambda x: A * x
            else:
                if (isa_(A,char('function_handle'))):
                    Ax=lambda x: feval_(A,x)
                else:
                    error_([char('cgs: first argument is expected to '),char('be a function or a square matrix')])
        if (nargin < 3 or isempty_(tol)):
            tol=1e-06
        if (nargin < 4 or isempty_(maxit)):
            maxit=min_(rows_(b),20)
        if (nargin < 5 or isempty_(M1)):
            M1m1x=lambda x: x
        else:
            if (ischar_(M1)):
                M1m1x=str2func_(M1)
            else:
                if (ismatrix_(M1)):
                    M1m1x=lambda x: numpy.linalg.solve(M1,x)
                else:
                    if (isa_(M1,char('function_handle'))):
                        M1m1x=lambda x: feval_(M1,x)
                    else:
                        error_(char('cgs: preconditioner is expected to be a function or matrix'))
        if (nargin < 6 or isempty_(M2)):
            M2m1x=lambda x: x
        else:
            if (ischar_(M2)):
                M2m1x=str2func_(M2)
            else:
                if (ismatrix_(M2)):
                    M2m1x=lambda x: numpy.linalg.solve(M2,x)
                else:
                    if (isa_(M2,char('function_handle'))):
                        M2m1x=lambda x: feval_(M2,x)
                    else:
                        error_(char('cgs: preconditioner is expected to be a function or matrix'))
        precon=lambda x: M2m1x[M1m1x[x]]
        if (nargin < 7 or isempty_(x0)):
            x0=zeros_(size_(b))
        x=copy_(x0)
        res=b - Ax[x]
        norm_b=norm_(b)
        resvec=norm_(res) / norm_b
        ro=0
        flag=1
        for _iter in arange_(1,maxit).reshape(-1):
            z=precon[res]
            ro_old=copy_(ro)
            ro=res.T * z
            if (_iter == 1):
                p=copy_(z)
            else:
                beta=ro / ro_old
                p=z + beta * p
            q=Ax[p]
            alpha=ro / (p.T * q)
            x=x + alpha * p
            res=res - alpha * q
            relres=norm_(res) / norm_b
            resvec=matlabarray([[resvec],[relres]])
            if (relres <= tol):
                flag=0
                break
            else:
                if (resvec[end()] == resvec[end() - 1]):
                    flag=3
                    break
        if (nargout < 1):
            if (flag == 0):
                printf_(char('cgs converged at iteration %i to a solution with relative residual %e\n'),_iter,relres)
            else:
                if (flag == 3):
                    printf_([char('cgs stopped at iteration %i without converging to the desired tolerance %e\n'),char('because the method stagnated.\n'),char('The iterate returned (number %i) has relative residual %e\n')],_iter,tol,_iter,relres)
                else:
                    printf_([char('cgs stopped at iteration %i without converging to the desired tolerance %e\n'),char('because the maximum number of iterations was reached.\n'),char('The iterate returned (number %i) has relative residual %e\n')],_iter,tol,_iter,relres)
    else:
        print_usage_()
    return x,flag,relres,_iter,resvec
def etreeplot_(A=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[A].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    treeplot_(etree_(A + A.T),varargin[:])
    return
def sprandsym_(n=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,d].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (nargin == 1):
        i,j=find_(tril_(n),nargout=2)
        nr,nc=size_(n,nargout=2)
        S=sparse_(i,j,randn_(size_(i)),nr,nc)
        S=S + tril_(S,- 1).T
        return S
    if (not (isscalar_(n) and n == fix_(n) and n > 0)):
        error_(char('sprandsym: N must be an integer greater than 0'))
    if (d < 0 or d > 1):
        error_(char('sprandsym: density D must be between 0 and 1'))
    k=round_(n ** 2 * d)
    r=pick_rand_diag_(n,k)
    m=(k - r) / 2
    ondiag=randperm_(n,r)
    offdiag=randperm_(n * (n - 1) / 2,m)
    i=lookup_(cumsum_(arange_(0,n)),offdiag - 1) + 1
    j=offdiag - (i - 1).dot((i - 2)) / 2
    diagvals=randn_(1,r)
    offdiagvals=randn_(1,m)
    S=sparse_([ondiag,i,j],[ondiag,j,i],[diagvals,offdiagvals,offdiagvals],n,n)
    return S
def pick_rand_diag_(n=None,k=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (k == 1):
        r=1
        return r
    a=n * (n - 1) / 2
    d=matlabarray([arange_(mod_(k,2),min_(n,k) - 2,2)])
    m=(k - d) / 2
    q=(n - d).dot((n - d - 1)).dot(m) / (d + 2) / (d + 1) / (a - m + 1)
    __,midx=max_(cumsum_(log_(q)),nargout=2)
    midx
    lc=fliplr_(cumprod_(1.0 / q[midx - 1:- 1:1]))
    rc=cumprod_(q[midx:end()])
    c=matlabarray([lc,1,rc])
    s=sum_(c)
    p=c / s
    d[end() + 1]=d[end()] + 2
    r=d[sum_(cumsum_(p) < rand) + 1]
    return r
def treeplot_(tree=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[tree,node_style,edge_style].count(None)+len(args)

    if (nargin < 1 or nargin > 3 or nargout > 0):
        print_usage_()
    if (not ismatrix_(tree) or rows_(tree) != 1 or not isnumeric_(tree) or not isvector_(tree) or any_(tree > length_(tree))):
        error_(char('treeplot: TREE must be a vector of predecessors'))
    if (nargin > 1):
        if (isempty_(regexp_(node_style,char('[ox+*]'),char('once')))):
            node_style=matlabarray([node_style,char('o')])
    tree=tree[:].T
    num_nodes=length_(tree)
    num_children=zeros_(1,num_nodes + 1)
    for i in arange_(1,num_nodes).reshape(-1):
        num_children[tree[i] + 1]=num_children[tree[i] + 1] + 1
    pos=1
    start=zeros_(1,num_nodes + 1)
    xhelp=zeros_(1,num_nodes + 1)
    stop=zeros_(1,num_nodes + 1)
    for i in arange_(1,num_nodes + 1).reshape(-1):
        start[i]=pos
        xhelp[i]=pos
        pos += num_children[i]
        stop[i]=pos
    for i in arange_(1,num_nodes).reshape(-1):
        vec_of_child[xhelp[tree[i] + 1]]=i
        xhelp[tree[i] + 1]=xhelp[tree[i] + 1] + 1
    par_number=0
    left_most=0
    level=copy_(num_nodes)
    max_ht=copy_(num_nodes)
    stk=matlabarray([- 1,0])
    skelet=0
    while (par_number != - 1):

        if (start[par_number + 1] < stop[par_number + 1]):
            idx=vec_of_child[start[par_number + 1]:stop[par_number + 1] - 1]
        else:
            idx=zeros_(1,0)
        stk=matlabarray([[stk],[[idx.T,ones_(fliplr_(size_(idx))) * par_number]]])
        if (par_number != 0):
            skelet=matlabarray([[skelet],[([[ones_(size_(idx)) * par_number],[idx]])(arange_())]])
        if (stk[end(),2] != par_number):
            left_most
            x_coordinate_r[par_number]=left_most
            max_ht=min_(max_ht,level)
            if (length_(stk) > 1 and find_((shift_(stk,1) - stk) == 0) > 1 and stk[end(),2] != stk[end() - 1,2]):
                position=(find_((shift_(stk[:,2],1) - stk[:,2]) == 0))(end()) + 1
                par_number_vec=stk[position:end(),2]
                skelet=matlabarray([[skelet],[flipud_(par_number_vec)]])
                level += length_(par_number_vec)
                x_coordinate_r[par_number_vec]=left_most
                stk[position:end(),:]=[]
            stk[end(),:]=[]
            par_number=stk[end(),1]
            if (par_number != - 1):
                skelet=matlabarray([[skelet],[stk[end(),2]],[par_number]])
                y_coordinate[par_number]=level
                x_coordinate_l[par_number]=left_most + 1
        else:
            level
            par_number=stk[end(),1]
            y_coordinate[par_number]=level
            x_coordinate_l[par_number]=left_most + 1

    x_coordinate=(x_coordinate_l + x_coordinate_r) / 2
    hold_is_on=ishold_()
    try:
        plot_(x_coordinate,y_coordinate,node_style)
        skelet=matlabarray([[skelet],[0]])
        idx=find_(skelet == 0)
        hold_(char('on'))
        for i in arange_(2,length_(idx)).reshape(-1):
            istart=idx[i - 1] + 1
            istop=idx[i] - 1
            if (istop - istart < 1):
                continue
            plot_(x_coordinate[skelet[istart:istop]],y_coordinate[skelet[istart:istop]],edge_style)
        axis_([0.5,left_most + 0.5,max_ht - 0.5,num_nodes - 0.5],char('nolabel'))
    finally:
        if (not hold_is_on):
            hold_(char('off'))
    return
def eigs_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0):
        print_usage_()
    call_eig=copy_(false)
    offset=0
    k=6
    sigma=char('lm')
    if (isnumeric_(varargin[1]) and issquare_(varargin[1])):
        a=varargin[1]
        if (nargin > 1 and isnumeric_(varargin[2]) and issquare_(varargin[2]) and size_equal_(a,varargin[2])):
            b=varargin[2]
            offset=1
        if (rows_(a) < 9):
            call_eig=copy_(true)
        if (nargin > 1 + offset):
            tmp=varargin[2 + offset]
            if (isnumeric_(tmp) and isscalar_(tmp) and isreal_(tmp) and round_(tmp) == tmp):
                k=copy_(tmp)
                if (rows_(a) - k < 3):
                    call_eig=copy_(true)
            else:
                call_eig=copy_(false)
            if (nargin > 2 + offset):
                tmp=varargin[3 + offset]
                if (ischar_(tmp) or (isnumeric_(tmp) and isscalar_(tmp))):
                    sigma=copy_(tmp)
                else:
                    call_eig=copy_(false)
    if (call_eig):
        varargout=cell_(1,min_(2,max_(1,nargout)))
        if (offset):
            real_valued=isreal_(a) and isreal_(b)
            symmetric=issymmetric_(a) and issymmetric_(b)
            varargout[:]=eig_(a,b)
        else:
            real_valued=isreal_(a)
            symmetric=issymmetric_(a)
            varargout[:]=eig_(a)
        varargout=select_(varargout,k,sigma,real_valued,symmetric)
        if (nargout == 3):
            varargout[3]=0
    else:
        varargout=cell_(1,max_(1,nargout))
        varargout[:]=__eigs___(varargin[:])
    return varargout
def select_(args=None,k=None,sigma=None,real_valued=None,symmetric=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[args,k,sigma,real_valued,symmetric].count(None)+len(args)

    if (numel_(args) == 1):
        d=args[1]
    else:
        d=diag_(args[2])
    if (ischar_(sigma)):
        if char('lm') == (sigma):
            __,idx=sort_(abs_(d),char('descend'),nargout=2)
        else:
            if char('sm') == (sigma):
                __,idx=sort_(abs_(d),char('ascend'),nargout=2)
            else:
                if char('la') == (sigma):
                    if (real_valued and symmetric):
                        __,idx=sort_(real_(d),char('descend'),nargout=2)
                    else:
                        error_(char('sigma = "la" requires real symmetric problem'))
                else:
                    if char('sa') == (sigma):
                        if (real_valued and symmetric):
                            __,idx=sort_(real_(d),char('ascend'),nargout=2)
                        else:
                            error_(char('sigma = "sa" requires real symmetric problem'))
                    else:
                        if char('be') == (sigma):
                            if (real_valued and symmetric):
                                __,idx=sort_(real_(d),char('ascend'),nargout=2)
                            else:
                                error_(char('sigma = "be" requires real symmetric problem'))
                        else:
                            if char('lr') == (sigma):
                                if (not (real_valued or symmetric)):
                                    __,idx=sort_(real_(d),char('descend'),nargout=2)
                                else:
                                    error_(char('sigma = "lr" requires complex or unsymmetric problem'))
                            else:
                                if char('sr') == (sigma):
                                    if (not (real_valued or symmetric)):
                                        __,idx=sort_(real_(d),char('ascend'),nargout=2)
                                    else:
                                        error_(char('sigma = "sr" requires complex or unsymmetric problem'))
                                else:
                                    if char('li') == (sigma):
                                        if (not (real_valued or symmetric)):
                                            __,idx=sort_(imag_(d),char('descend'),nargout=2)
                                        else:
                                            error_(char('sigma = "li" requires complex or unsymmetric problem'))
                                    else:
                                        if char('si') == (sigma):
                                            if (not (real_valued or symmetric)):
                                                __,idx=sort_(imag_(d),char('ascend'),nargout=2)
                                            else:
                                                error_(char('sigma = "si" requires complex or unsymmetric problem'))
                                        else:
                                            error_(char('unrecognized value for sigma: %s'),sigma)
    else:
        __,idx=sort_(abs_(d - sigma),nargout=2)
    d=d[idx]
    n=numel_(d)
    k=min_(k,n)
    if (strcmp_(sigma,char('be'))):
        tmp=k / 2
        n1=floor_(tmp)
        n2=n - ceil_(tmp) + 1
        selection=matlabarray([arange_(1,floor_(k / 2)),arange_(n2,n)])
    else:
        selection=arange_(1,k)
    d=d[selection]
    if (numel_(args) == 1):
        out[1]=d
    else:
        out[2]=diag_(d)
        v=args[1]
        v=v[:,idx]
        out[1]=v[:,selection]
    return out
def spdiags_(v=None,c=None,m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[v,c,m,n].count(None)+len(args)

    if (nargin == 1 or nargin == 2):
        nr,nc=size_(v,nargout=2)
        i,j,v=find_(v,nargout=3)
        if (nargin == 1):
            c=unique_(j - i)
        offset=max_(min_(c,nc - nr),0)
        A=zeros_(min_(nr,nc),length_(c))
        for k in arange_(1,length_(c)).reshape(-1):
            idx=find_(j - i == c[k])
            A[j[idx] - offset[k],k]=v[idx]
    else:
        if (nargin == 3):
            nr,nc=size_(m,nargout=2)
            B=spdiags_(m,c)
            A=m - spdiags_(B,c,nr,nc) + spdiags_(v,c,nr,nc)
        else:
            j,i,v=find_(v,nargout=3)
            offset=max_(min_(c[:],n - m),0)
            j=j[:] + offset[i[:]]
            i=j - c[:](i[:])
            idx=i > 0 and i <= m and j > 0 and j <= n
            A=sparse_(i[idx],j[idx],v[idx],m,n)
    return A,c
def setxor_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    a,b=validargs_(char('setxor'),a,b,varargin[:],nargout=2)
    if (nargout > 1):
        a,ia=unique_(a,varargin[:],nargout=2)
        b,ib=unique_(b,varargin[:],nargout=2)
    else:
        a=unique_(a,varargin[:])
        b=unique_(b,varargin[:])
    if (isempty_(a)):
        c=copy_(b)
    else:
        if (isempty_(b)):
            c=copy_(a)
        else:
            if (nargin > 2):
                na=rows_(a)
                nb=rows_(b)
                c,i=sortrows_([[a],[b]],nargout=2)
                n=rows_(c)
                idx=find_(all_(c[1:n - 1,:] == c[2:n,:],2))
                if (not isempty_(idx)):
                    c[[idx,idx + 1],:]=[]
                    i[[idx,idx + 1],:]=[]
            else:
                na=numel_(a)
                nb=numel_(b)
                c,i=sort_([[a[:]],[b[:]]],nargout=2)
                n=length_(c)
                if (iscell_(c)):
                    idx=find_(strcmp_(c[1:n - 1],c[2:n]))
                else:
                    idx=find_(c[1:n - 1] == c[2:n])
                if (not isempty_(idx)):
                    c[[idx,idx + 1]]=[]
                    i[[idx,idx + 1]]=[]
                if (rows_(a) == 1 or rows_(b) == 1):
                    c=c.T
    if (nargout > 1):
        ia=ia[i[i <= na]]
        ib=ib[i[i > na] - na]
    return c,ia,ib
def ismember_(A=None,s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,s].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (islogical_(A)):
        A=uint8_(A)
    if (islogical_(s)):
        s=uint8_(s)
    A,s=validargs_(char('ismember'),A,s,varargin[:],nargout=2)
    if (nargin == 2):
        s=s[:]
        if (issorted_(s)):
            _is=matlabarray([])
        else:
            s,_is=sort_(s,nargout=2)
        if (isreal_(s) and not isempty_(s) and isnan_(s[end()])):
            s=s[1:end() - sum_(isnan_(s))]
        if (nargout > 1):
            a_idx=lookup_(s,A,char('m'))
            tf=logical_(a_idx)
            if (not isempty_(_is)):
                a_idx[tf]=_is[a_idx[tf]]
        else:
            tf=lookup_(s,A,char('b'))
    else:
        if (isempty_(A) or isempty_(s)):
            tf=false_(rows_(A),1)
            a_idx=zeros_(rows_(A),1)
        else:
            xx,ii,jj=unique_([[A],[s]],char('rows'),char('last'),nargout=3)
            na=rows_(A)
            jj=ii[jj[1:na]]
            tf=jj > na
            if (nargout > 1):
                a_idx=max_(0,jj - na)
    return tf,a_idx
def powerset_(a=None,byrows_arg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,byrows_arg].count(None)+len(args)

    byrows=copy_(false)
    if (nargin == 2):
        if (not strcmpi_(byrows_arg,char('rows'))):
            error_(char('powerset: expecting second argument to be "rows"'))
        else:
            if (iscell_(a)):
                warning_(char('powerset: "rows" not valid for cell arrays'))
            else:
                byrows=copy_(true)
    else:
        if (nargin != 1):
            print_usage_()
    if (iscell_(a) and not iscellstr_(a)):
        error_(char('powerset: cell arrays can only used for character strings'))
    if (byrows):
        a=unique_(a,byrows_arg)
        n=rows_(a)
    else:
        a=unique_(a)
        n=numel_(a)
    if (n == 0):
        p=[]
    else:
        if (n > 32):
            error_(char('powerset: not implemented for more than 32 elements'))
        b=reshape_(bitunpack_(uint32_(arange_(0,2 ** n - 1))),32,2 ** n)(arange_(1,n),arange_())
        i,k=find_(b,nargout=2)
        k=sum_(b,1)
        if (byrows):
            p=mat2cell_(a[i,:],k,columns_(a))
        else:
            if (rows_(a) == 1):
                p=mat2cell_(a[i],1,k)
            else:
                p=mat2cell_(a[i],k,1)
    return p
def unique_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (nargin > 1):
        if (iscellstr_(varargin)):
            optfirst=strcmp_(char('first'),varargin)
            optlast=strcmp_(char('last'),varargin)
            optrows=strcmp_(char('rows'),varargin)
            if (not all_(optfirst or optlast or optrows)):
                error_(char('unique: invalid option'))
            optfirst=any_(optfirst)
            optlast=any_(optlast)
            optrows=any_(optrows)
            if (optfirst and optlast):
                error_(char('unique: cannot specify both "last" and "first"'))
        else:
            error_(char('unique: options must be strings'))
        if (optrows and iscell_(x)):
            warning_(char('unique: "rows" is ignored for cell arrays'))
            optrows=copy_(false)
    else:
        optfirst=copy_(false)
        optrows=copy_(false)
    if (issparse_(x) and not optrows and nargout <= 1):
        if (nnz_(x) < numel_(x)):
            y=unique_([[0],[(full_(nonzeros_(x)))]],varargin[:])
        else:
            y=unique_(full_(x),varargin[:])
        return y,i,j
    if (optrows):
        n=rows_(x)
        dim=1
    else:
        n=numel_(x)
        dim=(rows_(x) == 1) + 1
    y=copy_(x)
    if (n == 0):
        if (not optrows and isempty_(x) and any_(size_(x))):
            if (iscell_(y)):
                y=cell_(0,1)
            else:
                y=zeros_(0,1,class_(y))
        i=j=matlabarray([])
        return y,i,j
    else:
        if (n == 1):
            i=j=1
            return y,i,j
    if (optrows):
        if (nargout > 1):
            y,i=sortrows_(y,nargout=2)
        else:
            y=sortrows_(y)
        match=all_(y[1:n - 1,:] == y[2:n,:],2)
        idx=find_(match)
        y[idx,:]=[]
    else:
        if (not isvector_(y)):
            y=y[:]
        if (nargout > 1):
            y,i=sort_(y,nargout=2)
        else:
            y=sort_(y)
        if (iscell_(y)):
            match=strcmp_(y[1:n - 1],y[2:n])
        else:
            match=(y[1:n - 1] == y[2:n])
        idx=find_(match)
        y[idx]=[]
    if (isargout_(3)):
        j=copy_(i)
        if (dim == 1):
            j[i]=cumsum_([[1],[not match]])
        else:
            j[i]=cumsum_([1,not match])
    if (isargout_(2)):
        if (optfirst):
            i[idx + 1]=[]
        else:
            i[idx]=[]
    return y,i,j
def validargs_(caller=None,x=None,y=None,byrows_arg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[caller,x,y,byrows_arg].count(None)+len(args)

    if (nargin == 3):
        icx=iscellstr_(x)
        icy=iscellstr_(y)
        if (icx or icy):
            if (icx and ischar_(y)):
                y=cellstr_(y)
            else:
                if (icy and ischar_(x)):
                    x=cellstr_(x)
                else:
                    if (not (icx and icy)):
                        error_(char('%s: cell array of strings cannot be combined with a nonstring value'),caller)
        else:
            if (not (ismatrix_(x) and ismatrix_(y))):
                error_(char('%s: input arguments must be arrays or cell arrays of strings'),caller)
    else:
        if (nargin == 4):
            if (strcmpi_(byrows_arg,char('rows'))):
                if (iscell_(x) or iscell_(y)):
                    error_(char('%s: cells not supported with "rows"'),caller)
                else:
                    if (not (ismatrix_(x) and ismatrix_(y))):
                        error_(char('%s: input arguments must be arrays or cell arrays of strings'),caller)
                    else:
                        if (ndims_(x) > 2 or ndims_(y) > 2):
                            error_(char('%s: need 2-dimensional matrices for "rows"'),caller)
                        else:
                            if (columns_(x) != columns_(y) and not (isempty_(x) or isempty_(y))):
                                error_(char('%s: number of columns must match'),caller)
            else:
                error_(char('%s: invalid option: %s'),caller,byrows_arg)
        else:
            print_usage_(caller)
    return x,y
def setdiff_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    a,b=validargs_(char('setdiff'),a,b,varargin[:],nargout=2)
    if (nargin > 2):
        if (nargout > 1):
            c,i=unique_(a,char('rows'),nargout=2)
        else:
            c=unique_(a,char('rows'))
        if (not isempty_(c) and not isempty_(b)):
            b=unique_(b,char('rows'))
            dummy,idx=sortrows_([[c],[b]],nargout=2)
            dups=find_(all_(dummy[1:end() - 1,:] == dummy[2:end(),:],2))
            c[idx[dups],:]=[]
            if (nargout > 1):
                i[idx[dups],:]=[]
    else:
        if (nargout > 1):
            c,i=unique_(a,nargout=2)
        else:
            c=unique_(a)
        if (not isempty_(c) and not isempty_(b)):
            b=unique_(b)
            dummy,idx=sort_([[c[:]],[b[:]]],nargout=2)
            if (iscellstr_(dummy)):
                dups=find_(strcmp_(dummy[1:end() - 1],dummy[2:end()]))
            else:
                dups=find_(dummy[1:end() - 1] == dummy[2:end()])
            c[idx[dups]]=[]
            if (nargout > 1):
                i[idx[dups]]=[]
            if (rows_(c) != 1 and rows_(b) == 1):
                c=c.T
    return c,i
def intersect_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    a,b=validargs_(char('intersect'),a,b,varargin[:],nargout=2)
    if (isempty_(a) or isempty_(b)):
        c=ia=ib=matlabarray([])
    else:
        if (nargout > 1):
            a,ja=unique_(a,varargin[:],nargout=2)
            b,jb=unique_(b,varargin[:],nargout=2)
        else:
            a=unique_(a,varargin[:])
            b=unique_(b,varargin[:])
        if (nargin > 2):
            c=matlabarray([[a],[b]])
            c,ic=sortrows_(c,nargout=2)
            ii=find_(all_(c[1:end() - 1,:] == c[2:end(),:],2))
            c=c[ii,:]
            len_a=rows_(a)
        else:
            c=matlabarray([[a[:]],[b[:]]])
            c,ic=sort_(c,nargout=2)
            if (iscellstr_(c)):
                ii=find_(strcmp_(c[1:end() - 1],c[2:end()]))
            else:
                ii=find_(c[1:end() - 1] == c[2:end()])
            c=c[ii]
            len_a=length_(a)
        if (nargout > 1):
            ia=ja[ic[ii]]
            ib=jb[ic[ii + 1] - len_a]
        if (nargin == 2 and (rows_(b) == 1 or rows_(a) == 1)):
            c=c.T
    return c,ia,ib
def union_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    a,b=validargs_(char('union'),a,b,varargin[:],nargout=2)
    if (nargin == 2):
        y=matlabarray([[a[:]],[b[:]]])
        na=numel_(a)
        nb=numel_(b)
        if (rows_(a) == 1 or rows_(b) == 1):
            y=y.T
    else:
        y=matlabarray([[a],[b]])
        na=rows_(a)
        nb=rows_(b)
    if (nargout == 1):
        y=unique_(y,varargin[:])
    else:
        y,i=unique_(y,varargin[:],nargout=2)
        ia=i[i <= na]
        ib=i[i > na] - na
    return y,ia,ib
def isprime_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin == 1):
        if (any_((x != floor_(x) or x < 0)(arange_()))):
            error_(char('isprime: needs positive integers'))
        maxn=max_(x[:])
        maxp=min_(maxn,max_(sqrt_(maxn),10000000.0))
        pr=primes_(maxp)
        t=lookup_(pr,x,char('b'))
        m=x[x > maxp]
        if (not isempty_(m)):
            if (maxn <= intmax_(char('uint32'))):
                m=uint32_(m)
            else:
                if (maxn <= intmax_(char('uint64'))):
                    m=uint64_(m)
                else:
                    warning_(char('isprime: too large integers being tested'))
            pr=cast_(pr[pr <= sqrt_(maxn)],class_(m))
            for p in pr.reshape(-1):
                m=m[rem_(m,p) != 0]
                if (length_(m) < length_(pr) / 10):
                    break
            pr=pr[pr > p]
            mm=arrayfun_(lambda x: all_(rem_(x,pr)),m)
            m=m[mm]
            if (not isempty_(m)):
                m=cast_(sort_(m),class_(x))
                t |= lookup_(m,x,char('b'))
    else:
        print_usage_()
    return t
def ellipke_(m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[m].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    m=m[:]
    if (not isreal_(m)):
        error_(char('ellipke: M must be real'))
    else:
        if (any_(m > 1)):
            error_(char('ellipke: M must be <= 1'))
    k=e=zeros_(size_(m))
    idx_1=(m == 1)
    k[idx_1]=Inf
    e[idx_1]=1
    idx_neginf=(m == - Inf)
    k[idx_neginf]=0
    e[idx_neginf]=Inf
    Nmax=16
    idx=not idx_1 and not idx_neginf
    if (any_(idx)):
        idx_neg=find_(m < 0 and not idx_neginf)
        mult_k=1.0 / sqrt_(1 - m[idx_neg])
        mult_e=sqrt_(1 - m[idx_neg])
        m[idx_neg]=- m[idx_neg] / (1 - m[idx_neg])
        a=ones_(sum_(idx),1)
        b=sqrt_(1 - m[idx])
        c=sqrt_(m[idx])
        f=0.5
        _sum=f * c ** 2
        n=2
        do
        t=(a + b) / 2
        c=(a - b) / 2
        b=sqrt_(a.dot(b))
        a=copy_(t)
        f *= 2
        _sum += f * c ** 2
        until_(all_(c / a < eps) or (++ n > Nmax))
        if (n >= Nmax):
            error_(char('ellipke: algorithm did not converge in %d iterations'),Nmax)
        k[idx]=0.5 * pi / a
        e[idx]=0.5 * pi * (1 - _sum) / a
        k[idx_neg]=mult_k.dot(k[idx_neg])
        e[idx_neg]=mult_e.dot(e[idx_neg])
    return k,e
def pow2_(f=None,e=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,e].count(None)+len(args)

    if (nargin == 1):
        y=2 ** f
    else:
        if (nargin == 2):
            y=f.dot((2 ** e))
        else:
            print_usage_()
    return y
def expint_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=copy_(x)
    if (isreal_(x)):
        idx=(x >= 0)
        y[idx]=- expint_Ei_(- x[idx])
        idx=(x < 0)
        y[idx]=- expint_Ei_(- x[idx]) - i * pi
    else:
        idx=(imag_(x) > 0)
        y[idx]=- expint_Ei_(- x[idx]) - i * pi
        idx=(imag_(x) < 0)
        y[idx]=- expint_Ei_(- x[idx]) + i * pi
        isreal_idx=(imag_(x) == 0)
        idx=(isreal_idx and real_(x) >= 0)
        y[idx]=- expint_Ei_(- x[idx])
        idx=(isreal_idx and real_(x) < 0)
        y[idx]=- expint_Ei_(- x[idx]) - i * pi
    return y
def expint_Ei_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    y=zeros_(size_(x))
    F=lambda x: exp_(- x) / x
    for t in arange_(1,numel_(x)).reshape(-1):
        xt=x[t]
        if (xt < 0 and imag_(xt) == 0):
            y[t]=- quad_(F,- xt,Inf,[0,1e-10])
        else:
            if (xt > 2 and imag_(xt) == 0):
                Ei_2=4.954234356
                y[t]=Ei_2 - quad_(F,- xt,- 2)
            else:
                if (abs_(xt) < 10):
                    k=1
                    do
                    term=xt ** k / (k * factorial_(k))
                    y[t] += term
                    until_(abs_(term) < eps_(abs_(y[t])) / 2 or k >= 100)
                    y[t]=0.577215664902 + log_(xt) + y[t]
                else:
                    if (imag_(xt) <= 0):
                        a1=4.0364
                        a2=1.15198
                        b1=5.03637
                        b2=4.1916
                        y[t]=- (xt ** 2 - a1 * xt + a2) / ((xt ** 2 - b1 * xt + b2) * (- xt) * exp_(- xt)) - i * pi
                    else:
                        y[t]=conj_(expint_Ei_(conj_(xt)))
    return y
def realsqrt_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    else:
        if (iscomplex_(x) or any_(x[:] < 0)):
            error_(char('realsqrt: produced complex result'))
        else:
            y=sqrt_(x)
    return y
def factor_(q=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[q].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (not isscalar_(q) or q != fix_(q)):
        error_(char('factor: Q must be a scalar integer'))
    if (q < 4):
        x=copy_(q)
        n=1
        return x,n
    q=double_(q)
    qorig=copy_(q)
    x=matlabarray([])
    p=primes_(sqrt_(q))
    while (q > 1):

        p=p[rem_(q,p) == 0]
        if (isempty_(p)):
            p=copy_(q)
        x=matlabarray([x,p])
        q /= prod_(p)

    x=sort_(x)
    q=prod_(x)
    if (q != qorig):
        error_(char('factor: Input Q too large to factor'))
    else:
        if (q > bitmax):
            warning_(char('factor: Input Q too large.  Answer is unreliable'))
    if (nargout > 1):
        idx=find_([0,x] != [x,0])
        x=x[idx[1:length_(idx) - 1]]
        n=diff_(idx)
    return x,n
def realpow_(x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    else:
        z=x ** y
        if (iscomplex_(z)):
            error_(char('realpow: produced complex result'))
    return z
def reallog_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    else:
        if (iscomplex_(x) or any_(x[:] < 0)):
            error_(char('reallog: produced complex result'))
        else:
            y=log_(x)
    return y
def perms_(v=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[v].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    vidx=uint8_([arange_(1,length_(v))].T)
    n=length_(vidx)
    if (n == 0):
        p=matlabarray([])
    else:
        p=vidx[1]
        for j in arange_(2,n).reshape(-1):
            B=copy_(p)
            p=zeros_(prod_(arange_(2,j)),n,char('uint8'))
            k=rows_(B)
            idx=arange_(1,k)
            for i in arange_(j,1,- 1).reshape(-1):
                p[idx,1:i - 1]=B[:,1:i - 1]
                p[idx,i]=vidx[j]
                p[idx,i + 1:j]=B[:,i:j - 1]
                idx += k
    A=v[p]
    return A
def bessel_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    error_(char('bessel: you must use besselj, bessely, besseli, or besselk'))
    return
def factorial_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    else:
        if (any_(n[:] < 0 or n[:] != fix_(n[:]))):
            error_(char('factorial: N must all be non-negative integers'))
    x=round_(gamma_(n + 1))
    return x
def betaln_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    retval=gammaln_(a) + gammaln_(b) - gammaln_(a + b)
    return retval
def lcm_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin > 1):
        if (common_size_(varargin[:]) != 0):
            error_(char('lcm: all args must be of the same size or scalar'))
        else:
            if (not all_(cellfun_(char('isnumeric'),varargin))):
                error_(char('lcm: all arguments must be numeric'))
        l=varargin[1]
        for i in arange_(2,nargin).reshape(-1):
            x=varargin[i]
            msk=l == 0 and x == 0
            l .*= x / gcd_(l,x)
            l[msk]=0
    else:
        print_usage_()
    return l
def beta_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (any_(size_(a) != size_(b)) and numel_(a) != 1 and numel_(b) != 1):
        error_(char('beta: inputs A and B have inconsistent sizes'))
    if (not isreal_(a) or not isreal_(b)):
        error_(char('beta: inputs A and B must be real'))
    retval=real_(exp_(gammaln_(a) + gammaln_(b) - gammaln_(a + b)))
    return retval
def nthroot_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (any_(iscomplex_(x[:]))):
        error_(char('nthroot: X must not contain complex values'))
    if (not isscalar_(n) or n == 0):
        error_(char('nthroot: N must be a nonzero scalar'))
    if (n == 3):
        y=cbrt_(x)
    else:
        if (n == - 3):
            y=1 / cbrt_(x)
        else:
            if (n < 0):
                y=1 / nthroot_(x,- n)
            else:
                if (n == fix_(n) and mod_(n,2) == 1):
                    y=abs_(x) ** (1 / n).dot(sign_(x))
                else:
                    if (any_(x[:] < 0)):
                        error_(char('nthroot: if X contains negative values, N must be an odd integer'))
                    else:
                        y=x ** (1 / n)
                if (finite_(n) and n > 0 and n == fix_(n)):
                    y=((n - 1) * y + x / (y ** (n - 1))) / n
                    y=merge_(finite_(y),y,x)
    return y
def legendre_(n=None,x=None,normalization=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[n,x,normalization].count(None)+len(args)

    warned_overflow=copy_(false)
    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not isscalar_(n) or n < 0 or n != fix_(n)):
        error_(char('legendre: N must be a non-negative scalar integer'))
    if (not isreal_(x) or any_(x[:] < - 1 or x[:] > 1)):
        error_(char('legendre: X must be real-valued vector in the range -1 <= X <= 1'))
    if (nargin == 3):
        normalization=lower_(normalization)
    else:
        normalization=char('unnorm')
    if char('norm') == (normalization):
        scale=sqrt_(n + 0.5)
    else:
        if char('sch') == (normalization):
            scale=sqrt_(2)
        else:
            if char('unnorm') == (normalization):
                scale=1
            else:
                error_(char('legendre: expecting NORMALIZATION option to be "norm", "sch", or "unnorm"'))
    scale=scale * ones_(size_(x))
    overflow=copy_(false)
    retval=zeros_([n + 1,size_(x)])
    for m in arange_(1,n).reshape(-1):
        lpm1=copy_(scale)
        lpm2=(2 * m - 1).dot(x).dot(scale)
        lpm3=copy_(lpm2)
        for k in arange_(m + 1,n).reshape(-1):
            lpm3a=(2 * k - 1).dot(x).dot(lpm2)
            lpm3b=(k + m - 2).dot(lpm1)
            lpm3=(lpm3a - lpm3b) / (k - m + 1)
            lpm1=copy_(lpm2)
            lpm2=copy_(lpm3)
            if (not warned_overflow):
                if (any_(abs_(lpm3a) > realmax) or any_(abs_(lpm3b) > realmax) or any_(abs_(lpm3) > realmax)):
                    overflow=copy_(true)
        retval[m,:]=lpm3[:]
        if (strcmp_(normalization,char('unnorm'))):
            scale=- scale * (2 * m - 1)
        else:
            scale=scale / sqrt_((n - m + 1) * (n + m)) * (2 * m - 1)
        scale=scale.dot(sqrt_(1 - x ** 2))
    retval[n + 1,:]=scale[:]
    if (isvector_(x)):
        retval=reshape_(retval,n + 1,length_(x))
    if (strcmp_(normalization,char('sch'))):
        retval[1,:]=retval[1,:] / sqrt_(2)
    if (overflow and not warned_overflow):
        warning_(char('legendre: overflow - results may be unstable for high orders'))
        warned_overflow=copy_(true)
    return retval
def primes_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not isscalar_(n)):
        error_(char('primes: N must be a scalar'))
    if (n > 100000):
        lenm=floor_((n + 1) / 6)
        lenp=floor_((n - 1) / 6)
        sievem=true_(1,lenm)
        sievep=true_(1,lenp)
        for i in arange_(1,(sqrt_(n) + 1) / 6).reshape(-1):
            if (sievem[i]):
                sievem[7 * i - 1:6 * i - 1:lenm]=false
                sievep[5 * i - 1:6 * i - 1:lenp]=false
            if (sievep[i]):
                sievep[7 * i + 1:6 * i + 1:lenp]=false
                sievem[5 * i + 1:6 * i + 1:lenm]=false
        x=sort_([2,3,6 * find_(sievem) - 1,6 * find_(sievep) + 1])
    else:
        if (n > 352):
            _len=floor_((n - 1) / 2)
            sieve=true_(1,_len)
            for i in arange_(1,(sqrt_(n) - 1) / 2).reshape(-1):
                if (sieve[i]):
                    sieve[3 * i + 1:2 * i + 1:_len]=false
            x=matlabarray([2,1 + 2 * find_(sieve)])
        else:
            a=matlabarray([2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349])
            x=a[a <= n]
    return x
def nchoosek_(v=None,k=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[v,k].count(None)+len(args)

    if (nargin != 2 or not isnumeric_(k) or not isnumeric_(v) or not isscalar_(k) or not (isscalar_(v) or isvector_(v))):
        print_usage_()
    if (k < 0 or k != fix_(k) or (isscalar_(v) and (v < k or v < 0 or v != fix_(v)))):
        error_(char('nchoosek: args are non-negative integers with V not less than K'))
    n=length_(v)
    if (n == 1):
        k=min_(k,v - k)
        A=round_(prod_((arange_(v - k + 1,v)) / (arange_(1,k))))
        if (A * 2 * k * eps >= 0.5):
            warning_(char('nchoosek'),char('nchoosek: possible loss of precision'))
    else:
        if (k == 0):
            A=matlabarray([])
        else:
            if (k == 1):
                A=v[:]
            else:
                if (k == n):
                    A=v[:].T
                else:
                    if (k > n):
                        A=zeros_(0,k,class_(v))
                    else:
                        if (k == 2):
                            x=repelems_(v[1:n - 1],[[arange_(1,n - 1)],[arange_(n - 1,1,- 1)]]).T
                            y=cat_(1,cellslices_(v[:],arange_(2,n),n * ones_(1,n - 1))[:])
                            A=matlabarray([x,y])
                        else:
                            if (k < n):
                                v=v[:].T
                                A=v[k:n]
                                l=arange_(1,n - k + 1)
                                for j in arange_(2,k).reshape(-1):
                                    c=columns_(A)
                                    cA=cellslices_(A,l,c * ones_(1,n - k + 1),2)
                                    l=c - l + 1
                                    b=repelems_(v[k - j + 1:n - j + 1],[[arange_(1,n - k + 1)],[l]])
                                    A=matlabarray([[b],[cA[:]]])
                                    l=cumsum_(l)
                                    l=matlabarray([1,1 + l[1:n - k]])
                                clear_(char('cA'),char('b'))
                                A=A.T
    return A
def flipud_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (ndims_(x) > 2):
        error_(char('flipud: Only works with 2-d arrays'))
    nr=rows_(x)
    y=x[nr:- 1:1,:]
    return y
def quadl_(f=None,a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[f,a,b,tol,trace].count(None)+len(args)

    if (nargin < 3):
        print_usage_()
    if (isa_(a,char('single')) or isa_(b,char('single'))):
        myeps=eps_(char('single'))
    else:
        myeps=copy_(eps)
    if (isempty_(tol)):
        tol=copy_(myeps)
    if (isempty_(trace)):
        trace=copy_(false)
    if (tol < myeps):
        tol=copy_(myeps)
    global __quadl_recurse_done__
    __quadl_recurse_done__=copy_(false)
    global __quadl_need_warning__
    __quadl_need_warning__=copy_(true)
    m=(a + b) / 2
    h=(b - a) / 2
    alpha=sqrt_(2 / 3)
    beta=1 / sqrt_(5)
    x1=0.942882415695
    x2=0.641853342346
    x3=0.236383199662
    x=matlabarray([a,m - x1 * h,m - alpha * h,m - x2 * h,m - beta * h,m - x3 * h,m,m + x3 * h,m + beta * h,m + x2 * h,m + alpha * h,m + x1 * h,b])
    y=feval_(f,x,varargin[:])
    fa=y[1]
    fb=y[13]
    i2=(h / 6) * (y[1] + y[13] + 5 * (y[5] + y[9]))
    i1=(h / 1470) * (77 * (y[1] + y[13]) + 432 * (y[3] + y[11]) + 625 * (y[5] + y[9]) + 672 * y[7])
    _is=h * (0.0158271919735 * (y[1] + y[13]) + 0.0942738402189 * (y[2] + y[12]) + 0.155071987337 * (y[3] + y[11]) + 0.18882157396 * (y[4] + y[10]) + 0.199773405227 * (y[5] + y[9]) + 0.224926465333 * (y[6] + y[8]) + 0.242611071901 * y[7])
    s=sign_(_is)
    if (s == 0):
        s=1
    erri1=abs_(i1 - _is)
    erri2=abs_(i2 - _is)
    if (erri2 != 0):
        R=erri1 / erri2
    else:
        R=1
    if (R > 0 and R < 1):
        tol=tol / R
    _is=s * abs_(_is) * tol / myeps
    if (_is == 0):
        _is=b - a
    q=adaptlobstp_(f,a,b,fa,fb,_is,trace,varargin[:])
    return q
def adaptlobstp_(f=None,a=None,b=None,fa=None,fb=None,is=None,trace=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[f,a,b,fa,fb,_is,trace].count(None)+len(args)

    global __quadl_recurse_done__
    global __quadl_need_warning__
    h=(b - a) / 2
    m=(a + b) / 2
    alpha=sqrt_(2 / 3)
    beta=1 / sqrt_(5)
    mll=m - alpha * h
    ml=m - beta * h
    mr=m + beta * h
    mrr=m + alpha * h
    x=matlabarray([mll,ml,m,mr,mrr])
    y=feval_(f,x,varargin[:])
    fmll=y[1]
    fml=y[2]
    fm=y[3]
    fmr=y[4]
    fmrr=y[5]
    i2=(h / 6) * (fa + fb + 5 * (fml + fmr))
    i1=(h / 1470) * (77 * (fa + fb) + 432 * (fmll + fmrr) + 625 * (fml + fmr) + 672 * fm)
    if ((_is + (i1 - i2) == _is or mll <= a or b <= mrr) and __quadl_recurse_done__):
        if ((m <= a or b <= m) and __quadl_need_warning__):
            warning_(char('quadl: interval contains no more machine number'))
            warning_(char('quadl: required tolerance may not be met'))
            __quadl_need_warning__=copy_(false)
        q=copy_(i1)
        if (trace):
            disp_([a,b - a,q])
    else:
        __quadl_recurse_done__=copy_(true)
        q=(adaptlobstp_(f,a,mll,fa,fmll,_is,trace,varargin[:]) + adaptlobstp_(f,mll,ml,fmll,fml,_is,trace,varargin[:]) + adaptlobstp_(f,ml,m,fml,fm,_is,trace,varargin[:]) + adaptlobstp_(f,m,mr,fm,fmr,_is,trace,varargin[:]) + adaptlobstp_(f,mr,mrr,fmr,fmrr,_is,trace,varargin[:]) + adaptlobstp_(f,mrr,b,fmrr,fb,_is,trace,varargin[:]))
    return q
def bitcmp_(A=None,k=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin == 2 and (not isscalar_(k) or (floor_(k) != k))):
        error_(char('bitcmp: K must be a scalar integer'))
    if (isa_(A,char('double'))):
        bmax=copy_(bitmax)
        amax=ceil_(log2_(bmax))
    else:
        if (isa_(A,char('single'))):
            bmax=bitmax_(char('single'))
            amax=ceil_(log2_(bmax))
        else:
            if (isa_(A,char('uint8'))):
                amax=8
            else:
                if (isa_(A,char('uint16'))):
                    amax=16
                else:
                    if (isa_(A,char('uint32'))):
                        amax=32
                    else:
                        if (isa_(A,char('uint64'))):
                            amax=64
                        else:
                            if (isa_(A,char('int8'))):
                                amax=8
                            else:
                                if (isa_(A,char('int16'))):
                                    amax=16
                                else:
                                    if (isa_(A,char('int32'))):
                                        amax=32
                                    else:
                                        if (isa_(A,char('int64'))):
                                            amax=64
                                        else:
                                            error_(char('bitcmp: invalid class %s'),class_(A))
            bmax=intmax_(class_(A))
    if (nargin == 1 or k == amax):
        C=bitxor_(A,bmax)
    else:
        m=double_(k)
        if (any_(m < 1) or any_(m > amax)):
            error_(char('bitcmp: K must be in the range [1,%d]'),amax)
        mask=bitshift_(bmax,k - amax)
        C=bitxor_(bitand_(A,mask),mask)
    return C
def cart2pol_(x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,z].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (nargin == 1):
        if (ismatrix_(x) and (columns_(x) == 2 or columns_(x) == 3)):
            if (columns_(x) == 3):
                z=x[:,3]
            y=x[:,2]
            x=x[:,1]
        else:
            error_(char('cart2pol: matrix input must have 2 or 3 columns [X, Y (, Z)]'))
    else:
        if (nargin == 2):
            if (not ((ismatrix_(x) and ismatrix_(y)) and (size_equal_(x,y) or isscalar_(x) or isscalar_(y)))):
                error_(char('cart2pol: arguments must be matrices of same size, or scalar'))
        else:
            if (nargin == 3):
                if (not ((ismatrix_(x) and ismatrix_(y) and ismatrix_(z)) and (size_equal_(x,y) or isscalar_(x) or isscalar_(y)) and (size_equal_(x,z) or isscalar_(x) or isscalar_(z)) and (size_equal_(y,z) or isscalar_(y) or isscalar_(z)))):
                    error_(char('cart2pol: arguments must be matrices of same size, or scalar'))
    theta=atan2_(y,x)
    r=sqrt_(x ** 2 + y ** 2)
    if (nargout <= 1):
        theta=matlabarray([theta[:],r[:],z[:]])
    return theta,r,z
def int2str_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (isempty_(n)):
        retval=char('')
        return retval
    n=round_(real_(n))
    sz=size_(n)
    nd=ndims_(n)
    nc=columns_(n)
    if (nc > 1):
        idx=repmat_([char(':')],nd,1)
        idx[2]=1
        ifmt=get_fmt_(n[idx[:]],0)
        idx[2]=arange_(2,sz[2])
        rfmt=get_fmt_(n[idx[:]],2)
        fmt=matlabarray([ifmt,repmat_(rfmt,1,nc - 1),char('\n')])
    else:
        fmt=matlabarray([get_fmt_(n,0),char('\n')])
    tmp=sprintf_(fmt,permute_(n,[2,1,arange_(3,nd)]))
    tmp[end()]=char('')
    retval=char_(ostrsplit_(tmp,char('\n')))
    return retval
def get_fmt_(x=None,sep=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,sep].count(None)+len(args)

    t=x[:]
    t=t[t != 0]
    if (isempty_(t)):
        fmt=sprintf_(char('%%%dd'),1 + sep)
    else:
        nan_inf=not isfinite_(t)
        if (any_(nan_inf)):
            if (any_(t[nan_inf] < 0)):
                min_fw=4 + sep
            else:
                min_fw=3 + sep
        else:
            min_fw=1 + sep
        t=t[not nan_inf]
        if (isempty_(t)):
            fmt=sprintf_(char('%%%dd'),min_fw)
        else:
            tfw=floor_(log10_(double_(abs_(t)))) + 1 + sep
            fw=max_(tfw)
            if (any_(t[tfw == fw] < 0)):
                fw
            fmt=sprintf_(char('%%%dd'),max_(fw,min_fw))
    return fmt
def accumarray_(subs=None,vals=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[subs,vals,sz,func,fillval,issparse].count(None)+len(args)

    if (nargin < 2 or nargin > 6):
        print_usage_()
    lenvals=length_(vals)
    if (iscell_(subs)):
        subs=cellfun_(vec,subs,char('uniformoutput'),false)
        ndims=numel_(subs)
        if (ndims == 1):
            subs=subs[1]
        lensubs=cellfun_(length,subs)
        if (any_(lensubs != lensubs[1]) or (lenvals > 1 and lenvals != lensubs[1])):
            error_(char('accumarray: dimension mismatch'))
    else:
        ndims=columns_(subs)
        if (lenvals > 1 and lenvals != rows_(subs)):
            error_(char('accumarray: dimension mismatch'))
    if (isempty_(fillval)):
        fillval=0
    if (isempty_(issparse)):
        issparse=copy_(false)
    if (issparse):
        if (fillval != 0):
            error_(char('accumarray: FILLVAL must be zero in the sparse case'))
        if (iscell_(subs)):
            subs=matlabarray([subs[:]])
        if (ndims == 1):
            subs[:,2]=1
        else:
            if (ndims != 2):
                error_(char('accumarray: in the sparse case, needs 1 or 2 subscripts'))
        if (isnumeric_(vals) or islogical_(vals)):
            vals=double_(vals)
        else:
            error_(char('accumarray: in the sparse case, values must be numeric or logical'))
        if (not (isempty_(func) or func == _sum)):
            subs,idx=sortrows_(subs,nargout=2)
            n=rows_(subs)
            jdx=find_(any_(diff_(subs,1,1),2))
            jdx=matlabarray([[jdx],[n]])
            vals=cellfun_(func,mat2cell_(vals[:](idx),diff_([[0],[jdx]])))
            subs=subs[jdx,:]
            mode=char('unique')
        else:
            mode=char('sum')
        if (isempty_(sz)):
            A=sparse_(subs[:,1],subs[:,2],vals,mode)
        else:
            if (length_(sz) == 2):
                if (sz[1] == 1):
                    i,j=deal_(subs[:,2],subs[:,1],nargout=2)
                else:
                    i,j=deal_(subs[:,1],subs[:,2],nargout=2)
                A=sparse_(i,j,vals,sz[1],sz[2],mode)
            else:
                error_(char('accumarray: dimensions mismatch'))
    else:
        if (ndims > 1):
            if (isempty_(sz)):
                if (iscell_(subs)):
                    sz=cellfun_(char('max'),subs)
                else:
                    sz=max_(subs,[],1)
            else:
                if (ndims != length_(sz)):
                    error_(char('accumarray: dimensions mismatch'))
            if (ismatrix_(subs)):
                subs=num2cell_(subs,1)
            subs=sub2ind_(sz,subs[:])
        else:
            if (not isempty_(sz) and length_(sz) < 2):
                error_(char('accumarray: needs at least 2 dimensions'))
            else:
                if (not isindex_(subs)):
                    error_(char('accumarray: indices must be positive integers'))
        if (isempty_(func) or func == _sum):
            if (isempty_(sz)):
                A=__accumarray_sum___(subs,vals)
            else:
                A=__accumarray_sum___(subs,vals,prod_(sz))
                A=reshape_(A,sz)
            if (fillval != 0):
                mask=true_(size_(A))
                mask[subs]=false
                A[mask]=fillval
        else:
            if (func == _max):
                if (isinteger_(vals)):
                    zero=intmin_(class_(vals))
                else:
                    if (islogical_(vals)):
                        zero=copy_(false)
                    else:
                        if (fillval == 0 and all_(vals[:] >= 0)):
                            zero=0
                        else:
                            zero=copy_(NaN)
                if (isempty_(sz)):
                    A=__accumarray_max___(subs,vals,zero)
                else:
                    A=__accumarray_max___(subs,vals,zero,prod_(sz))
                    A=reshape_(A,sz)
                if (fillval != zero and not (isnan_(fillval) or isnan_(zero))):
                    mask=true_(size_(A))
                    mask[subs]=false
                    A[mask]=fillval
            else:
                if (func == _min):
                    if (isinteger_(vals)):
                        zero=intmax_(class_(vals))
                    else:
                        if (islogical_(vals)):
                            zero=copy_(true)
                        else:
                            if (fillval == 0 and all_(vals[:] <= 0)):
                                zero=0
                            else:
                                zero=copy_(NaN)
                    if (isempty_(sz)):
                        A=__accumarray_min___(subs,vals,zero)
                    else:
                        A=__accumarray_min___(subs,vals,zero,prod_(sz))
                        A=reshape_(A,sz)
                    if (fillval != zero and not (isnan_(fillval) or isnan_(zero))):
                        mask=true_(size_(A))
                        mask[subs]=false
                        A[mask]=fillval
                else:
                    n=rows_(subs)
                    if (numel_(vals) == 1):
                        vals=vals[ones_(1,n),1]
                    else:
                        vals=vals[:]
                    subs,idx=sort_(subs,nargout=2)
                    jdx=find_(subs[1:n - 1] != subs[2:n])
                    jdx=matlabarray([[jdx],[n]])
                    vals=mat2cell_(vals[idx],diff_([[0],[jdx]]))
                    simple_cell_str=func2str_(lambda x: [x])
                    if (not strcmp_(func2str_(func),simple_cell_str)):
                        vals=cellfun_(func,vals)
                    subs=subs[jdx]
                    if (isempty_(sz)):
                        sz=max_(subs)
                        if (length_(sz) == 1):
                            sz[2]=1
                    if (iscell_(vals)):
                        A=cell_(sz)
                    else:
                        if (fillval == 0):
                            A=zeros_(sz,class_(vals))
                        else:
                            A=repmat_(fillval,sz)
                    A[subs]=vals
    return A
def narginchk_(minargs=None,maxargs=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[minargs,maxargs].count(None)+len(args)

    if (nargin != 2):
        print_usage
    else:
        if (not isnumeric_(minargs) or not isscalar_(minargs)):
            error_(char('minargs must be a numeric scalar'))
        else:
            if (not isnumeric_(maxargs) or not isscalar_(maxargs)):
                error_(char('maxargs must be a numeric scalar'))
            else:
                if (minargs > maxargs):
                    error_(char('minargs cannot be larger than maxargs'))
    args=evalin_(char('caller'),char('nargin;'))
    if (args < minargs):
        error_(char('not enough input arguments'))
    else:
        if (args > maxargs):
            error_(char('too many input arguments'))
    return
def profile_(option=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[option].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if char('on') == (option):
        __profiler_reset___()
        __profiler_enable___(true)
    else:
        if char('off') == (option):
            __profiler_enable___(false)
        else:
            if char('clear') == (option):
                __profiler_reset___()
            else:
                if char('resume') == (option):
                    __profiler_enable___(true)
                else:
                    if char('status') == (option):
                        enabled=__profiler_enable___()
                        if (enabled):
                            enabled=char('on')
                        else:
                            enabled=char('off')
                        retval=struct_(char('ProfilerStatus'),enabled)
                    else:
                        if char('info') == (option):
                            flat,tree=__profiler_data___(nargout=2)
                            retval=struct_(char('FunctionTable'),flat,char('Hierarchical'),tree)
                        else:
                            warning_(char("profile: Unrecognized option '%s'"),option)
                            print_usage_()
    return retval
def flipdim_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    nd=ndims_(x)
    sz=size_(x)
    if (nargin == 1):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and isindex_(dim))):
            error_(char('flipdim: DIM must be a positive integer'))
    idx[1:max_(nd,dim)]=[char(':')]
    idx[dim]=arange_(size_(x,dim),1,- 1)
    y=x[idx[:]]
    return y
def nargoutchk_(minargs=None,maxargs=None,nargs=None,outtype=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[minargs,maxargs,nargs,outtype].count(None)+len(args)

    if (nargout == 1 and (nargin == 3 or nargin == 4)):
        if (minargs > maxargs):
            error_(char('nargoutchk: MINARGS must be <= MAXARGS'))
        else:
            if (nargin == 3):
                outtype=char('string')
            else:
                if (not any_(strcmpi_(outtype,[char('string'),char('struct')]))):
                    error_(char('nargoutchk: output type must be either string or struct'))
                else:
                    if (not (isscalar_(minargs) and isscalar_(maxargs) and isscalar_(nargs))):
                        error_(char('nargoutchk: MINARGS, MAXARGS, and NARGS must be scalars'))
        msg=struct_(char('message'),char(''),char('identifier'),char(''))
        if (nargs < minargs):
            msg.message=char('not enough output arguments')
            msg.identifier=char('Octave:nargoutchk:not-enough-outputs')
        else:
            if (nargs > maxargs):
                msg.message=char('too many output arguments')
                msg.identifier=char('Octave:nargoutchk:too-many-outputs')
        if (strcmpi_(outtype,char('string'))):
            msg=msg.message
        else:
            if (isempty_(msg.message)):
                msg=resize_(msg,0,1)
    else:
        if (nargout == 0 and nargin == 2):
            if (not isnumeric_(minargs) or not isscalar_(minargs)):
                error_(char('minargs must be a numeric scalar'))
            else:
                if (not isnumeric_(maxargs) or not isscalar_(maxargs)):
                    error_(char('maxargs must be a numeric scalar'))
                else:
                    if (minargs > maxargs):
                        error_(char('minargs cannot be larger than maxargs'))
            args=evalin_(char('caller'),char('nargout;'))
            if (args < minargs):
                error_(char('Not enough output arguments.'))
            else:
                if (args > maxargs):
                    error_(char('Too many output arguments.'))
        else:
            print_usage
    return msg
def chop_(x=None,ndigits=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,ndigits,base].count(None)+len(args)

    if (nargin == 2 or nargin == 3):
        tmp=abs_(x)
        tmp[x == 0]=1
        tmp=floor_(log10_(tmp) + 1)
        inflate=10 ** (ndigits - tmp)
        deflate=10 ** (tmp - ndigits)
        if (nargin == 2):
            retval=deflate.dot(round_(x.dot(inflate)))
        else:
            retval=base.dot(deflate).dot(round_(round_(x.dot(inflate)) / base))
    else:
        print_usage_()
    return retval
def issquare_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (ndims_(x) == 2):
        r,c=size_(x,nargout=2)
        retval=r == c
    else:
        retval=copy_(false)
    return retval
def deal_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0):
        print_usage_()
    else:
        if (nargin == 1 or nargin == nargout):
            varargout[1:nargout]=varargin
        else:
            error_(char('deal: nargin > 1 and nargin != nargout'))
    return varargout
def isrow_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    sz=size_(x)
    retval=(ndims_(x) == 2 and (sz[1] == 1))
    return retval
def fliplr_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (ndims_(x) > 2):
        error_(char('fliplr: Only works with 2-D arrays'))
    nc=columns_(x)
    y=x[:,nc:- 1:1]
    return y
def cplxpair_(z=None,tol=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[z,tol,dim].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (length_(z) == 0):
        y=zeros_(size_(z))
        return y
    if (nargin < 2 or isempty_(tol)):
        if (isa_(z,char('single'))):
            tol=100 * eps_(char('single'))
        else:
            tol=100 * eps
    nd=ndims_(z)
    orig_dims=size_(z)
    if (nargin < 3):
        dim=0
        while (dim < nd and orig_dims[dim + 1] == 1):

            dim

        dim
        if (dim > nd):
            dim=1
    else:
        dim=floor_(dim)
        if (dim < 1 or dim > nd):
            error_(char('cplxpair: invalid dimension along which to sort'))
    perm=matlabarray([arange_(dim,nd),arange_(1,dim - 1)])
    z=permute_(z,perm)
    sz=size_(z)
    n=sz[1]
    m=prod_(sz) / n
    z=reshape_(z,n,m)
    q,idx=sort_(real_(z),1,nargout=2)
    z=z[idx + n * ones_(n,1) * [arange_(0,m - 1)]]
    cls=char('double')
    if (isa_(z,char('single'))):
        cls=char('single')
    idxi,idxj=find_(abs_(imag_(z)) / (abs_(z) + realmin_(cls)) < tol,nargout=2)
    q=sparse_(idxi,idxj,1,n,m)
    nr=sum_(q,1)
    q,idx=sort_(q,1,nargout=2)
    z=z[idx]
    y=copy_(z)
    for j in arange_(1,m).reshape(-1):
        p=n - nr[j]
        for i in arange_(1,p,2).reshape(-1):
            if (i + 1 > p):
                error_(char('cplxpair: could not pair all complex numbers'))
            v,idx=min_(abs_(z[i + 1:p] - conj_(z[i])),nargout=2)
            if (v > tol):
                error_(char('cplxpair: could not pair all complex numbers'))
            if (imag_(z[i]) < 0):
                y[[i,i + 1]]=z[[i,idx + i]]
            else:
                y[[i,i + 1]]=z[[idx + i,i]]
            z[idx + i]=z[i + 1]
    y=ipermute_(reshape_(y,sz),perm)
    return y
def fieldnames_(obj=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[obj].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (isstruct_(obj) or isobject_(obj)):
        names=__fieldnames___(obj)
    else:
        if (isjava_(obj) or ischar_(obj)):
            if (not ischar_(obj)):
                obj=class_(obj)
            names_str=javaMethod_(char('getFields'),char('org.octave.ClassHelper'),obj)
            names=ostrsplit_(names_str,char(';'))
        else:
            error_(char('fieldnames: Invalid input argument'))
    return names
def circshift_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (isempty_(x)):
        y=copy_(x)
        return y
    nd=ndims_(x)
    sz=size_(x)
    if (not isvector_(n) or length_(n) > nd):
        error_(char('circshift: N must be a vector, no longer than the number of dimension in X'))
    else:
        if (any_(n != fix_(n))):
            error_(char('circshift: all values of N must be integers'))
    idx=repmat_([char(':')],1,nd)
    for i in arange_(1,length_(n)).reshape(-1):
        b=n[i]
        d=sz[i]
        if (b > 0):
            b=rem_(b,d)
            idx[i]=[arange_(d - b + 1,d),arange_(1,d - b)]
        else:
            if (b < 0):
                b=rem_(abs_(b),d)
                idx[i]=[arange_(b + 1,d),arange_(1,b)]
    y=x[idx[:]]
    return y
def quadgk_(f=None,a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[f,a,b].count(None)+len(args)

    if (nargin < 3):
        print_usage_()
    if (b < a):
        q,err=quadgk_(f,b,a,varargin[:],nargout=2)
        q=- q
    else:
        abstol=1e-10
        reltol=1e-05
        waypoints=matlabarray([])
        maxint=650
        trace=copy_(false)
        if (nargin > 3):
            if (not ischar_(varargin[1])):
                if (not isempty_(varargin[1])):
                    abstol=varargin[1]
                    reltol=0
                if (nargin > 4):
                    trace=varargin[2]
                if (nargin > 5):
                    error_(char('quadgk: can not pass additional arguments to user function'))
            else:
                idx=1
                while (idx < nargin - 3):

                    if (ischar_(varargin[idx])):
                        _str=varargin[idx]
                        if (strcmpi_(_str,char('reltol'))):
                            reltol=varargin[idx]
                        else:
                            if (strcmpi_(_str,char('abstol'))):
                                abstol=varargin[idx]
                            else:
                                if (strcmpi_(_str,char('waypoints'))):
                                    waypoints=varargin[idx](arange_())
                                    if (isreal_(waypoints)):
                                        waypoints[waypoints < a or waypoints > b]=[]
                                else:
                                    if (strcmpi_(_str,char('maxintervalcount'))):
                                        maxint=varargin[idx]
                                    else:
                                        if (strcmpi_(_str,char('trace'))):
                                            trace=varargin[idx]
                                        else:
                                            error_(char("quadgk: unknown property '%s'"),_str)
                    else:
                        error_(char('quadgk: property PROP must be a string'))

                if (idx != nargin - 2):
                    error_(char('quadgk: property/value must occur in pairs'))
        if (ischar_(f)):
            f=lambda x: feval_(f,x)
        if (iscomplex_(a) or iscomplex_(b) or iscomplex_(waypoints)):
            subs=matlabarray([[a],[waypoints],[b]])
            h=sum_(abs_(diff_(subs)))
            h0=copy_(h)
            trans=lambda t: t
        else:
            if (isinf_(a) and isinf_(b)):
                if (not isempty_(waypoints)):
                    trans=lambda x: (2 * x) / (1 + sqrt_(1 + 4 * x ** 2))
                    subs=matlabarray([[- 1],[trans[waypoints]],[1]])
                else:
                    subs=linspace_(- 1,1,11).T
                h=2
                h0=b - a
                trans=lambda t: t / (1 - t ** 2)
                f=lambda t: f[t / (1 - t ** 2)].dot((1 + t ** 2)) / ((1 - t ** 2) ** 2)
            else:
                if (isinf_(a)):
                    if (not isempty_(waypoints)):
                        tmp=sqrt_(b - waypoints)
                        trans=lambda x: - x / (x + 1)
                        subs=matlabarray([[- 1],[trans[tmp]],[0]])
                    else:
                        subs=linspace_(- 1,0,11).T
                    h=1
                    h0=b - a
                    trans=lambda t: b - (t / (1 + t)) ** 2
                    f=lambda s: - 2 * s.dot(f[b - (s / (1 + s)) ** 2]) / ((1 + s) ** 3)
                else:
                    if (isinf_(b)):
                        if (not isempty_(waypoints)):
                            tmp=sqrt_(waypoints - a)
                            trans=lambda x: x / (x + 1)
                            subs=matlabarray([[0],[trans[tmp]],[1]])
                        else:
                            subs=linspace_(0,1,11).T
                        h=1
                        h0=b - a
                        trans=lambda t: a + (t / (1 - t)) ** 2
                        f=lambda s: 2 * s.dot(f[a + (s / (1 - s)) ** 2]) / ((1 - s) ** 3)
                    else:
                        if (not isempty_(waypoints)):
                            trans=__quadgk_finite_waypoint__
                            subs=matlabarray([[- 1],[trans[waypoints,a,b]],[1]])
                        else:
                            subs=linspace_(- 1,1,11).T
                        h=2
                        h0=b - a
                        trans=lambda t: ((b - a) / 4) * t.dot((3 - t ** 2)) + (b + a) / 2
                        f=lambda t: f[(b - a) / 4.dot(t).dot((3 - t ** 2)) + (b + a) / 2].dot(3).dot((b - a)) / 4.dot((1 - t ** 2))
        while (length_(subs) < 11):

            subs=[[subs.T],[subs[1:end() - 1].T + diff_(subs.T) / 2,NaN]](arange_())(arange_(1,end() - 1))

        subs=matlabarray([subs[1:end() - 1],subs[2:end()]])
        warning_(char('off'),char('Octave:divide-by-zero'),char('local'))
        warn_id=char('Octave:quadgk:warning-termination')
        q_subs,q_errs=__quadgk_eval___(f,subs,nargout=2)
        q0=sum_(q_subs)
        err0=sum_(q_errs)
        if (isa_(a,char('single')) or isa_(b,char('single')) or isa_(waypoints,char('single'))):
            myeps=eps_(char('single'))
        else:
            myeps=copy_(eps)
        first=copy_(true)
        while (true):

            if (any_(abs_(diff_(trans[subs],[],2) / h0) < 100 * myeps)):
                q=copy_(q0)
                err=copy_(err0)
                break
            if (any_(not isfinite_(q_subs))):
                warning_(warn_id,char('quadgk: non finite integrand encountered'))
                q=copy_(q0)
                err=copy_(err0)
                break
            tol=max_(abstol,reltol.dot(abs_(q0)))
            if (err0 < tol):
                q=copy_(q0)
                err=copy_(err0)
                break
            idx=find_(abs_(q_errs) < tol.dot(abs_(diff_(subs,[],2))) / h)
            if (first):
                q=sum_(q_subs[idx])
                err=sum_(q_errs[idx])
                first=copy_(false)
            else:
                q0=q + sum_(q_subs)
                err0=err + sum_(q_errs)
                q += sum_(q_subs[idx])
                err += sum_(q_errs[idx])
            subs[idx,:]=[]
            if (rows_(subs) == 0):
                break
            if (trace):
                disp_([rows_(subs),err,q0])
            mid=(subs[:,2] + subs[:,1]) / 2
            subs=matlabarray([[subs[:,1],mid],[mid,subs[:,2]]])
            if (rows_(subs) > maxint):
                warning_(warn_id,char('quadgk: maximum interval count (%d) met'),maxint)
                q += sum_(q_subs)
                err += sum_(q_errs)
                break
            q_subs,q_errs=__quadgk_eval___(f,subs,nargout=2)

        if (err > max_(abstol,reltol * abs_(q))):
            warning_(warn_id,char('quadgk: Error tolerance not met.  Estimated error %g'),err)
    return q,err
def __quadgk_eval___(f=None,subs=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,subs].count(None)+len(args)

    abscissa=matlabarray([- 0.991455371121,- 0.949107912343,- 0.86486442336,- 0.741531185599,- 0.586087235468,- 0.405845151377,- 0.207784955008,0.0,0.207784955008,0.405845151377,0.586087235468,0.741531185599,0.86486442336,0.949107912343,0.991455371121])
    weights15=diag_([0.0229353220105,0.06309209263,0.104790010322,0.140653259716,0.169004726639,0.190350578065,0.204432940075,0.209482141085,0.204432940075,0.190350578065,0.169004726639,0.140653259716,0.104790010322,0.06309209263,0.0229353220105])
    weights7=diag_([0.129484966169,0.279705391489,0.381830050505,0.417959183673,0.381830050505,0.279705391489,0.129484966169])
    halfwidth=diff_(subs,[],2) / 2
    center=sum_(subs,2) / 2
    x=bsxfun_(plus,halfwidth * abscissa,center)
    y=reshape_(f[x[:]],size_(x))
    q=sum_(y * weights15,2).dot(halfwidth)
    err=abs_(sum_(y[:,2:2:end()] * weights7,2).dot(halfwidth) - q)
    return q,err
def __quadgk_finite_waypoint___(x=None,a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    c=(- 4.dot(x) + 2.0 * (b + a)) / (b - a)
    k=((sqrt_(c ** 2 - 4) + c) / 2) ** (1 / 3)
    t=real_((sqrt_(3).dot(1j) * (1 - k ** 2) - (1 + k ** 2)) / 2 / k)
    return t
def trapz_(x=None,y=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,dim].count(None)+len(args)

    if (nargin < 1) or (nargin > 3):
        print_usage_()
    have_xy=have_dim=copy_(false)
    if (nargin == 3):
        have_xy=copy_(true)
        have_dim=copy_(true)
    else:
        if (nargin == 2):
            if (not size_equal_(x,y) and isscalar_(y)):
                dim=copy_(y)
                have_dim=copy_(true)
            else:
                have_xy=copy_(true)
    if (have_xy):
        nd=ndims_(y)
        sz=size_(y)
    else:
        nd=ndims_(x)
        sz=size_(x)
    if (not have_dim):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('trapz: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    idx1=idx2=repmat_([char(':')],[nd,1])
    idx1[dim]=arange_(2,n)
    idx2[dim]=arange_(1,(n - 1))
    if (not have_xy):
        z=0.5 * sum_(x[idx1[:]] + x[idx2[:]],dim)
    else:
        if (isvector_(x) and not isvector_(y)):
            if (length_(x) != sz[dim]):
                error_(char('trapz: length of X and length of Y along DIM must match'))
            shape=ones_(nd,1)
            shape[dim]=sz[dim]
            x=reshape_(x,shape)
            z=0.5 * sum_(bsxfun_(times,diff_(x),y[idx1[:]] + y[idx2[:]]),dim)
        else:
            if (not size_equal_(x,y)):
                error_(char('trapz: X and Y must have same shape'))
            z=0.5 * sum_(diff_(x,1,dim).dot((y[idx1[:]] + y[idx2[:]])),dim)
    return z
def rotdim_(x=None,n=None,plane=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,n,plane].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (nargin > 1 and not isempty_(n)):
        if (not isscalar_(n) or not isreal_(n) or fix_(n) != n):
            error_(char('rotdim: N must be a scalar integer'))
    else:
        n=1
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 3):
        if (nd > 2):
            plane=matlabarray([])
            dim=0
            while (dim < nd):

                dim=dim + 1
                if (sz[dim] != 1):
                    plane=matlabarray([plane,dim])
                    if (length_(plane) == 2):
                        break

            if (length_(plane) < 1):
                plane=matlabarray([1,2])
            else:
                if (length_(plane) < 2):
                    plane=matlabarray([1,plane])
        else:
            plane=matlabarray([1,2])
    else:
        if (not (isvector_(plane) and length_(plane) == 2 and all_(plane == fix_(plane)) and all_(plane > 0) and all_(plane < (nd + 1)) and plane[1] != plane[2])):
            error_(char('rotdim: PLANE must be a 2 element integer vector defining a valid PLANE'))
    n=rem_(n,4)
    if (n < 0):
        n=n + 4
    if (n == 0):
        y=copy_(x)
    else:
        if (n == 2):
            y=flipdim_(flipdim_(x,plane[1]),plane[2])
        else:
            if (n == 1 or n == 3):
                perm=arange_(1,nd)
                perm[plane[1]]=plane[2]
                perm[plane[2]]=plane[1]
                y=permute_(x,perm)
                if (n == 1):
                    y=flipdim_(y,min_(plane))
                else:
                    y=flipdim_(y,max_(plane))
            else:
                error_(char('rotdim: internal error!'))
    return y
def isequaln_(x1=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x1].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    retval=__isequal___(true,x1,varargin[:])
    return retval
def sph2cart_(theta=None,phi=None,r=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[theta,phi,r].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (nargin == 1):
        if (ismatrix_(theta) and columns_(theta) == 3):
            r=theta[:,3]
            phi=theta[:,2]
            theta=theta[:,1]
        else:
            error_(char('sph2cart: matrix input must have 3 columns [THETA, PHI, R]'))
    else:
        if (nargin == 3):
            if (not ((ismatrix_(theta) and ismatrix_(phi) and ismatrix_(r)) and (size_equal_(theta,phi) or isscalar_(theta) or isscalar_(phi)) and (size_equal_(theta,r) or isscalar_(theta) or isscalar_(r)) and (size_equal_(phi,r) or isscalar_(phi) or isscalar_(r)))):
                error_(char('sph2cart: THETA, PHI, and R must be matrices of the same size, or scalar'))
    x=r.dot(cos_(phi)).dot(cos_(theta))
    y=r.dot(cos_(phi)).dot(sin_(theta))
    z=r.dot(sin_(phi))
    if (nargout <= 1):
        x=matlabarray([x[:],y[:],z[:]])
    return x,y,z
def profshow_(data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[data,n].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    n=fix_(n)
    if (not isscalar_(n) or not isreal_(n) or not (n > 0)):
        error_(char('profile: N must be a positive integer'))
    m=length_(data.FunctionTable)
    n=min_(n,m)
    times=- [data.FunctionTable.TotalTime]
    __,p=sort_(times,nargout=2)
    nameLen=length_(char('Function'))
    for i in arange_(1,n).reshape(-1):
        nameLen=max_(nameLen,length_(data.FunctionTable(p[i]).FunctionName))
    headerFormat=sprintf_(char('%%4s %%%ds %%4s %%12s %%12s\n'),nameLen)
    rowFormat=sprintf_(char('%%4d %%%ds %%4s %%12.3f %%12d\n'),nameLen)
    printf_(headerFormat,char('#'),char('Function'),char('Attr'),char('Time (s)'),char('Calls'))
    printf_(char('%s\n'),repmat_(char('-'),1,nameLen + 2 * 5 + 2 * 13))
    for i in arange_(1,n).reshape(-1):
        row=data.FunctionTable(p[i])
        attr=char('')
        if (row.IsRecursive):
            attr=char('R')
        printf_(rowFormat,p[i],row.FunctionName,attr,row.TotalTime,row.NumCalls)
    return
def quadv_(f=None,a=None,b=None,tol=None,trace=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[f,a,b,tol,trace].count(None)+len(args)

    if (nargin < 3):
        print_usage_()
    if (nargin < 4):
        tol=matlabarray([])
    if (nargin < 5):
        trace=matlabarray([])
    if (isa_(a,char('single')) or isa_(b,char('single'))):
        myeps=eps_(char('single'))
    else:
        myeps=copy_(eps)
    if (isempty_(tol)):
        tol=1e-06
    if (isempty_(trace)):
        trace=0
    c=(a + b) / 2
    fa=feval_(f,a,varargin[:])
    fc=feval_(f,c,varargin[:])
    fb=feval_(f,b,varargin[:])
    nfun=3
    if (any_(isinf_(fa[:]))):
        fa=feval_(f,a + myeps * (b - a),varargin[:])
    if (any_(isinf_(fb[:]))):
        fb=feval_(f,b - myeps * (b - a),varargin[:])
    h=(b - a)
    q=(b - a) / 6 * (fa + 4 * fc + fb)
    q,nfun,hmin=simpsonstp_(f,a,b,c,fa,fb,fc,q,nfun,abs_(h),tol,trace,varargin[:],nargout=3)
    if (nfun > 10000):
        warning_(char('maximum iteration count reached'))
    else:
        if (any_(not isfinite_(q[:]))):
            warning_(char('infinite or NaN function evaluations were returned'))
        else:
            if (hmin < (b - a) * myeps):
                warning_(char('minimum step size reached -- possibly singular integral'))
    return q,nfun
def simpsonstp_(f=None,a=None,b=None,c=None,fa=None,fb=None,fc=None,q0=None,nfun=None,hmin=None,tol=None,trace=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 12-[f,a,b,c,fa,fb,fc,q0,nfun,hmin,tol,trace].count(None)+len(args)

    if (nfun > 10000):
        q=copy_(q0)
    else:
        d=(a + c) / 2
        e=(c + b) / 2
        fd=feval_(f,d,varargin[:])
        fe=feval_(f,e,varargin[:])
        nfun += 2
        q1=(c - a) / 6 * (fa + 4 * fd + fc)
        q2=(b - c) / 6 * (fc + 4 * fe + fb)
        q=q1 + q2
        if (abs_(a - c) < hmin):
            hmin=abs_(a - c)
        if (trace):
            disp_([nfun,a,b - a,q])
        if (nfun == 5 or norm_(q - q0,Inf) > tol):
            q1,nfun,hmin=simpsonstp_(f,a,c,d,fa,fc,fd,q1,nfun,hmin,tol,trace,varargin[:],nargout=3)
            q2,nfun,hmin=simpsonstp_(f,c,b,e,fc,fb,fe,q2,nfun,hmin,tol,trace,varargin[:],nargout=3)
            q=q1 + q2
    return q,nfun,hmin
def num2str_(x=None,arg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,arg].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    else:
        if (not ismatrix_(x)):
            error_(char('num2str: X must be a numeric, logical, or character array'))
    if (ischar_(x)):
        retval=copy_(x)
    else:
        if (isempty_(x)):
            retval=char('')
        else:
            if (isreal_(x)):
                if (nargin == 2):
                    if (ischar_(arg)):
                        fmt=copy_(arg)
                    else:
                        if (isnumeric_(arg) and isscalar_(arg) and arg >= 0):
                            fmt=sprintf_(char('%%%d.%dg'),arg + 7,arg)
                        else:
                            error_(char('num2str: PRECISION must be a scalar integer >= 0'))
                else:
                    if (isnumeric_(x)):
                        dgt=floor_(log10_(max_(abs_(x[not isinf_(x[:])]))))
                        if (isempty_(dgt)):
                            dgt=1
                        if (any_(x[:] != fix_(x[:]))):
                            dgt=max_(dgt + 4,5)
                            dgt=min_(dgt,16)
                            fmt=sprintf_(char('%%%d.%dg'),dgt + 7 + any_(x[:] < 0),dgt)
                        else:
                            dgt=max_(dgt + 1,1)
                            fmt=sprintf_(char('%%%d.%dg'),dgt + 2 + any_(x[:] < 0),dgt)
                    else:
                        fmt=char('%3d')
                fmt=matlabarray([deblank_(repmat_(fmt,1,columns_(x))),char('\n')])
                nd=ndims_(x)
                tmp=sprintf_(fmt,permute_(x,[2,1,arange_(3,nd)]))
                retval=strtrim_(char_(ostrsplit_(tmp[1:end() - 1],char('\n'))))
            else:
                if (nargin == 2):
                    if (ischar_(arg)):
                        fmt=matlabarray([arg,char('%-+'),arg[2:end()],char('i')])
                    else:
                        if (isnumeric_(arg) and isscalar_(arg) and arg >= 0):
                            fmt=sprintf_(char('%%%d.%dg%%-+%d.%dgi'),arg + 7,arg,arg + 7,arg)
                        else:
                            error_(char('num2str: PRECISION must be a scalar integer >= 0'))
                else:
                    dgt=floor_(log10_(max_(max_(abs_(real_(x[not isinf_(real_(x[:]))]))),max_(abs_(imag_(x[not isinf_(imag_(x[:]))]))))))
                    if (isempty_(dgt)):
                        dgt=1
                    if (any_(x[:] != fix_(x[:]))):
                        dgt=max_(dgt + 4,5)
                        dgt=min_(dgt,16)
                        fmt=sprintf_(char('%%%d.%dg%%-+%d.%dgi'),dgt + 7,dgt,dgt + 7,dgt)
                    else:
                        dgt=max_(1 + dgt,1)
                        fmt=sprintf_(char('%%%d.%dg%%-+%d.%dgi'),dgt + 2,dgt,dgt + 2,dgt)
                nc=columns_(x)
                nd=ndims_(x)
                idx=repmat_([char(':')],nd,1)
                perm[1:2:2 * nc]=arange_(1,nc)
                perm[2:2:2 * nc]=nc + (arange_(1,nc))
                idx[2]=perm
                x=horzcat_(real_(x),imag_(x))
                x=x[idx[:]]
                fmt=matlabarray([deblank_(repmat_(fmt,1,nc)),char('\n')])
                tmp=sprintf_(fmt,permute_(x,[2,1,arange_(3,nd)]))
                tmp=regexprep_(tmp,char(' +i\n'),char('i\n'))
                tmp=regexprep_(tmp,char('( +)i'),char('i$1'))
                retval=strtrim_(char_(ostrsplit_(tmp[1:end() - 1],char('\n'))))
    return retval
def blkdiag_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (not all_(cellfun_(char('isnumeric'),varargin))):
        error_(char('blkdiag: all arguments must be numeric'))
    if (not all_(cellfun_(char('ndims'),varargin) == 2)):
        error_(char('blkdiag: all arguments must be two-dimensional matrices'))
    tmp=cell2mat_(cellfun_(size,varargin.T,char('uniformoutput'),false))
    csz=cumsum_([[0,0],[tmp]],1)
    if (any_(cellfun_(char('issparse'),varargin))):
        retval=sparse_(csz[end(),1],csz[end(),2])
    else:
        retval=zeros_(csz[end(),:])
    for p in arange_(1,nargin).reshape(-1):
        vp=varargin[p]
        if (not isempty_(vp)):
            retval[(csz[p,1] + 1):csz[p + 1,1],(csz[p,2] + 1):csz[p + 1,2]]=vp
    return retval
def del2_(M=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[M].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    nd=ndims_(M)
    sz=size_(M)
    dx=cell_(1,nd)
    if (nargin == 2 or nargin == 1):
        if (nargin == 1):
            h=1
        else:
            h=varargin[1]
        for i in arange_(1,nd).reshape(-1):
            if (isscalar_(h)):
                dx[i]=h * ones_(sz[i],1)
            else:
                if (length_(h) == sz[i]):
                    dx[i]=diff_(h)(arange_())
                else:
                    error_(char('del2: dimensionality mismatch in %d-th spacing vector'),i)
    else:
        if (nargin - 1 == nd):
            tmp=varargin[1]
            varargin[1]=varargin[2]
            varargin[2]=tmp
            for i in arange_(1,nd).reshape(-1):
                if (isscalar_(varargin[i])):
                    dx[i]=varargin[i] * ones_(sz[i],1)
                else:
                    if (length_(varargin[i]) == sz[i]):
                        dx[i]=diff_(varargin[i])(arange_())
                    else:
                        error_(char('del2: dimensionality mismatch in %d-th spacing vector'),i)
        else:
            print_usage_()
    idx=cell_(1,nd)
    for i in arange_(1,nd).reshape(-1):
        idx[i]=char(':')
    D=zeros_(sz)
    for i in arange_(1,nd).reshape(-1):
        if (sz[i] >= 3):
            DD=zeros_(sz)
            idx1=idx2=idx3=copy_(idx)
            idx1[i]=arange_(1,sz[i] - 2)
            idx2[i]=arange_(2,sz[i] - 1)
            idx3[i]=arange_(3,sz[i])
            szi=copy_(sz)
            szi[i]=1
            h1=repmat_(shiftdim_(dx[i](arange_(1,sz[i] - 2)),1 - i),szi)
            h2=repmat_(shiftdim_(dx[i](arange_(2,sz[i] - 1)),1 - i),szi)
            DD[idx2[:]]=((M[idx1[:]] - M[idx2[:]]) / h1 + (M[idx3[:]] - M[idx2[:]]) / h2) / (h1 + h2)
            if (sz[i] == 3):
                DD[idx1[:]]=DD[idx3[:]]=DD[idx2[:]]
            else:
                idx1[i]=1
                idx2[i]=2
                idx3[i]=3
                DD[idx1[:]]=(dx[i](1) + dx[i](2)) / dx[i](2) * DD[idx2[:]] - dx[i](1) / dx[i](2) * DD[idx3[:]]
                idx1[i]=sz[i]
                idx2[i]=sz[i] - 1
                idx3[i]=sz[i] - 2
                DD[idx1[:]]=(dx[i](sz[i] - 1) + dx[i](sz[i] - 2)) / dx[i](sz[i] - 2) * DD[idx2[:]] - dx[i](sz[i] - 1) / dx[i](sz[i] - 2) * DD[idx3[:]]
            D += DD
    D=D / nd
    return D
def bincoeff_(n=None,k=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    retval,n,k=common_size_(n,k,nargout=3)
    if (retval > 0):
        error_(char('bincoeff: N and K must be of common size or scalars'))
    if (iscomplex_(n) or iscomplex_(k)):
        error_(char('bincoeff: N and K must not be complex'))
    b=zeros_(size_(n))
    ok=(k >= 0) and (k == fix_(k)) and (not isnan_(n))
    b[not ok]=NaN
    n_int=(n == fix_(n))
    idx=n_int and (n < 0) and ok
    b[idx]=(- 1) ** k[idx].dot(exp_(gammaln_(abs_(n[idx]) + k[idx]) - gammaln_(k[idx] + 1) - gammaln_(abs_(n[idx]))))
    idx=(n >= k) and ok
    b[idx]=exp_(gammaln_(n[idx] + 1) - gammaln_(k[idx] + 1) - gammaln_(n[idx] - k[idx] + 1))
    idx=(not n_int) and (n < k) and ok
    b[idx]=(1 / pi) * exp_(gammaln_(n[idx] + 1) - gammaln_(k[idx] + 1) + gammaln_(k[idx] - n[idx]) + log_(sin_(pi * (n[idx] - k[idx] + 1))))
    b[n_int]=round_(b[n_int])
    idx=not n_int
    b[idx]=real_(b[idx])
    return b
def loadobj_(a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[a].count(None)+len(args)

    error_(char('loadobj: not defined for class "%s"'),class_(a))
    return b
def rat_(x=None,tol=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,tol].count(None)+len(args)

    if (nargin != [1,2] or nargout > 2):
        print_usage_()
    y=x[:]
    y[isinf_(y)]=0
    if (nargin < 2):
        tol=1e-06 * norm_(y,1)
    n=round_(y)
    d=ones_(size_(y))
    frac=y - n
    lastn=ones_(size_(y))
    lastd=zeros_(size_(y))
    nd=ndims_(y)
    nsz=numel_(y)
    steps=zeros_([nsz,0])
    while (1):

        idx=find_(abs_(y - n / d) >= tol)
        if (isempty_(idx)):
            if (isempty_(steps)):
                steps=NaN_(nsz,1)
            break
        flip=1.0 / frac[idx]
        step=round_(flip)
        if (nargout < 2):
            tsteps=NaN_(nsz,1)
            tsteps[idx]=step
            steps=matlabarray([steps,tsteps])
        frac[idx]=flip - step
        nextn=copy_(n)
        nextd=copy_(d)
        n[idx]=n[idx].dot(step) + lastn[idx]
        d[idx]=d[idx].dot(step) + lastd[idx]
        lastn=copy_(nextn)
        lastd=copy_(nextd)

    if (nargout == 2):
        n=n.dot(sign_(d))
        d=abs_(d)
        n=reshape_(n,size_(x))
        d=reshape_(d,size_(x))
        n[isinf_(x)]=sign_(x[isinf_(x)])
        d[isinf_(x)]=0
        n=reshape_(n,size_(x))
        d=reshape_(d,size_(x))
    else:
        n=char('')
        nsteps=columns_(steps)
        for i in arange_(1,nsz).reshape(-1):
            s=matlabarray([int2str_(y[i]),char(' ')])
            j=1
            while (true):

                step=steps[i,j]
                if (isnan_(step)):
                    break
                if (j > nsteps or isnan_(steps[i,j])):
                    if (step < 0):
                        s=matlabarray([s[1:end() - 1],char(' + 1/('),int2str_(step),char(')')])
                    else:
                        s=matlabarray([s[1:end() - 1],char(' + 1/'),int2str_(step)])
                    break
                else:
                    s=matlabarray([s[1:end() - 1],char(' + 1/('),int2str_(step),char(')')])

            s=matlabarray([s,repmat_(char(')'),1,j - 2)])
            n_nc=columns_(n)
            s_nc=columns_(s)
            if (n_nc > s_nc):
                s[:,s_nc + 1:n_nc]=char(' ')
            else:
                if (s_nc > n_nc):
                    n[:,n_nc + 1:s_nc]=char(' ')
            n=cat_(1,n,s)
    return n,d
def interp3_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    method=char('linear')
    extrapval=copy_(NA)
    nargs=copy_(nargin)
    if (nargin < 1 or not isnumeric_(varargin[1])):
        print_usage_()
    if (ischar_(varargin[end()])):
        method=varargin[end()]
        nargs=nargs - 1
    else:
        if (nargs > 1 and ischar_(varargin[end() - 1])):
            if (not isnumeric_(varargin[end()]) or not isscalar_(varargin[end()])):
                error_(char('interp3: extrapal is expected to be a numeric scalar'))
            extrapval=varargin[end()]
            method=varargin[end() - 1]
            nargs=nargs - 2
    if (nargs < 3 or (nargs == 4 and not isvector_(varargin[1]) and nargs == (ndims_(varargin[1]) + 1))):
        v=varargin[1]
        if (ndims_(v) != 3):
            error_(char('interp3: expect 3-dimensional array of values'))
        x=varargin[2:nargs]
        if (any_(not cellfun_(isvector,x))):
            for i in arange_(2,3).reshape(-1):
                if (not size_equal_(x[1],x[i])):
                    error_(char('interp3: dimensional mismatch'))
                x[i]=permute_(x[i],[2,1,3])
            x[1]=permute_(x[1],[2,1,3])
        v=permute_(v,[2,1,3])
        vi=ipermute_(interpn_(v,x[:],method,extrapval),[2,1,3])
    else:
        if (nargs == 7 and nargs == (2 * ndims_(varargin[ceil_(nargs / 2)])) + 1):
            v=varargin[4]
            if (ndims_(v) != 3):
                error_(char('interp3: expect 3-dimensional array of values'))
            x=varargin[1:3]
            if (any_(not cellfun_(isvector,x))):
                for i in arange_(2,3).reshape(-1):
                    if (not size_equal_(x[1],x[i]) or not size_equal_(x[i],v)):
                        error_(char('interp3: dimensional mismatch'))
                    x[i]=permute_(x[i],[2,1,3])
                x[1]=permute_(x[1],[2,1,3])
            y=varargin[5:7]
            if (any_(not cellfun_(isvector,y))):
                for i in arange_(2,3).reshape(-1):
                    if (not size_equal_(y[1],y[i])):
                        error_(char('interp3: dimensional mismatch'))
                    y[i]=permute_(y[i],[2,1,3])
                y[1]=permute_(y[1],[2,1,3])
            v=permute_(v,[2,1,3])
            vi=ipermute_(interpn_(x[:],v,y[:],method,extrapval),[2,1,3])
        else:
            error_(char('interp3: wrong number or incorrectly formatted input arguments'))
    return vi
def __splinen___(x=None,y=None,xi=None,extrapval=None,f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[x,y,xi,extrapval,f].count(None)+len(args)

    isvec=lambda x: numel_(x) == length_(x)
    if (not iscell_(x) or length_(x) < ndims_(y) or any_(not cellfun_(isvec,x)) or not iscell_(xi) or length_(xi) < ndims_(y) or any_(not cellfun_(isvec,xi))):
        error_(char('__splinen__: %s: non-gridded data or dimensions inconsistent'),f)
    yi=copy_(y)
    for i in arange_(length_(x),1,- 1).reshape(-1):
        yi=permute_(spline_(x[i],yi,xi[i](arange_())),[length_(x),arange_(1,length_(x) - 1)])
    xi[:]=ndgrid_(cellfun_(lambda x: x[:],xi,char('uniformoutput'),false)[:])
    idx=zeros_(size_(xi[1]))
    for i in arange_(1,length_(x)).reshape(-1):
        idx |= xi[i] < min_(x[i](arange_())) or xi[i] > max_(x[i](arange_()))
    yi[idx]=extrapval
    return yi
def nextpow2_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (isscalar_(x) or isvector_(x))):
        error_(char('nextpow2: X must be a scalar or a vector'))
    t=length_(x)
    if (t > 1):
        x=copy_(t)
    f,n=log2_(abs_(x),nargout=2)
    if (f == 0.5):
        n=n - 1
    return n
def polyarea_(x=None,y=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,dim].count(None)+len(args)

    if (nargin != 2 and nargin != 3):
        print_usage_()
    else:
        if (size_equal_(x,y)):
            if (nargin == 2):
                a=abs_(sum_(x.dot((shift_(y,- 1) - shift_(y,1))))) / 2
            else:
                a=abs_(sum_(x.dot((shift_(y,- 1,dim) - shift_(y,1,dim))),dim)) / 2
        else:
            error_(char('polyarea: X and Y must have the same shape'))
    return a
def logspace_(base=None,limit=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[base,limit,n].count(None)+len(args)

    if (nargin != 2 and nargin != 3):
        print_usage_()
    if (not (isscalar_(base) and isscalar_(limit) and isscalar_(n))):
        error_(char('logspace: arguments BASE, LIMIT, and N must be scalars'))
    npoints=fix_(n)
    if (limit == pi):
        limit=log10_(pi)
    retval=10 ** (linspace_(base,limit,npoints))
    return retval
def interpft_(x=None,n=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,n,dim].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not (isscalar_(n) and n == fix_(n))):
        error_(char('interpft: N must be a scalar integer'))
    if (nargin == 2):
        if (isrow_(x)):
            dim=2
        else:
            dim=1
    nd=ndims_(x)
    if (dim < 1 or dim > nd):
        error_(char('interpft: invalid dimension DIM'))
    perm=matlabarray([arange_(dim,nd),arange_(1,(dim - 1))])
    x=permute_(x,perm)
    m=rows_(x)
    inc=ceil_(m / n)
    y=fft_(x) / m
    k=ceil_(m / 2)
    sz=size_(x)
    sz[1]=n * inc - m
    idx=repmat_([char(':')],nd,1)
    idx[1]=arange_(1,k)
    z=cat_(1,y[idx[:]],zeros_(sz))
    idx[1]=arange_(k + 1,m)
    z=cat_(1,z,y[idx[:]])
    if (sz[1] > 0 and k == m / 2):
        idx[1]=n * inc - k + 1
        tmp=z[idx[:]] / 2
        z[idx[:]]=tmp
        idx[1]=k + 1
        z[idx[:]]=tmp
    z=n * ifft_(z)
    if (inc != 1):
        sz[1]=n
        z=inc * reshape_(z[1:inc:end()],sz)
    z=ipermute_(z,perm)
    return z
def isa_(obj=None,classname=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[obj,classname].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (strcmp_(classname,char('float'))):
        retval=isfloat_(obj)
    else:
        if (strcmp_(classname,char('integer'))):
            retval=isinteger_(obj)
        else:
            if (strcmp_(classname,char('numeric'))):
                retval=isnumeric_(obj)
            else:
                class_of_obj=class_(obj)
                retval=strcmp_(class_of_obj,classname)
                if (not retval and isobject_(obj)):
                    retval=__isa_parent___(obj,classname)
    return retval
def methods_(obj=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[obj].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (isobject_(obj)):
        mtds_list=__methods___(obj)
    else:
        if (ischar_(obj)):
            mtds_list=__methods___(obj)
            if (isempty_(mtds_list)):
                mtds_str=javaMethod_(char('getMethods'),char('org.octave.ClassHelper'),obj)
                mtds_list=ostrsplit_(mtds_str,char(';'))
        else:
            if (isjava_(obj)):
                obj=class_(obj)
                mtds_str=javaMethod_(char('getMethods'),char('org.octave.ClassHelper'),obj)
                mtds_list=strsplit_(mtds_str,char(';'))
            else:
                error_(char('methods: Invalid input argument'))
    if (nargout == 0):
        classname=ifelse_(ischar_(obj),obj,class_(obj))
        printf_(char('Methods for class %s:\n'),classname)
        disp_(list_in_columns_(mtds_list))
    else:
        mtds=copy_(mtds_list)
    return mtds
def pol2cart_(theta=None,r=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[theta,r,z].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (nargin == 1):
        if (ismatrix_(theta) and (columns_(theta) == 2 or columns_(theta) == 3)):
            if (columns_(theta) == 3):
                z=theta[:,3]
            r=theta[:,2]
            theta=theta[:,1]
        else:
            error_(char('pol2cart: matrix input must have 2 or 3 columns [THETA, R (, Z)]'))
    else:
        if (nargin == 2):
            if (not ((ismatrix_(theta) and ismatrix_(r)) and (size_equal_(theta,r) or isscalar_(theta) or isscalar_(r)))):
                error_(char('pol2cart: arguments must be matrices of same size, or scalar'))
        else:
            if (nargin == 3):
                if (not ((ismatrix_(theta) and ismatrix_(r) and ismatrix_(z)) and (size_equal_(theta,r) or isscalar_(theta) or isscalar_(r)) and (size_equal_(theta,z) or isscalar_(theta) or isscalar_(z)) and (size_equal_(r,z) or isscalar_(r) or isscalar_(z)))):
                    error_(char('pol2cart: arguments must be matrices of same size, or scalar'))
    x=r.dot(cos_(theta))
    y=r.dot(sin_(theta))
    if (nargout <= 1):
        x=matlabarray([x[:],y[:],z[:]])
    return x,y,z
def isvector_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    sz=size_(x)
    retval=(ndims_(x) == 2 and (sz[1] == 1 or sz[2] == 1))
    return retval
def interpn_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    method=char('linear')
    extrapval=copy_(NA)
    nargs=copy_(nargin)
    if (nargin < 1 or not isnumeric_(varargin[1])):
        print_usage_()
    if (ischar_(varargin[end()])):
        method=varargin[end()]
        nargs -= 1
    else:
        if (nargs > 1 and ischar_(varargin[end() - 1])):
            if (not isnumeric_(varargin[end()]) or not isscalar_(varargin[end()])):
                error_(char('interpn: extrapal is expected to be a numeric scalar'))
            method=varargin[end() - 1]
            extrapval=varargin[end()]
            nargs -= 2
    if (nargs < 3):
        v=varargin[1]
        m=1
        if (nargs == 2):
            if (ischar_(varargin[2])):
                method=varargin[2]
            else:
                if (isnumeric_(m) and isscalar_(m) and fix_(m) == m):
                    m=varargin[2]
                else:
                    print_usage_()
        sz=size_(v)
        nd=ndims_(v)
        x=cell_(1,nd)
        y=cell_(1,nd)
        for i in arange_(1,nd).reshape(-1):
            x[i]=arange_(1,sz[i])
            y[i]=arange_(1,sz[i],(1 / (2 ** m)))
        y[1]=y[1].T
        y[:]=ndgrid_(y[:])
    else:
        if (not isvector_(varargin[1]) and nargs == (ndims_(varargin[1]) + 1)):
            v=varargin[1]
            sz=size_(v)
            nd=ndims_(v)
            x=cell_(1,nd)
            y=varargin[2:nargs]
            for i in arange_(1,nd).reshape(-1):
                x[i]=arange_(1,sz[i])
        else:
            if (rem_(nargs,2) == 1 and nargs == (2 * ndims_(varargin[ceil_(nargs / 2)])) + 1):
                nv=ceil_(nargs / 2)
                v=varargin[nv]
                sz=size_(v)
                nd=ndims_(v)
                x=varargin[1:(nv - 1)]
                y=varargin[(nv + 1):nargs]
            else:
                error_(char('interpn: wrong number or incorrectly formatted input arguments'))
    if (any_(not cellfun_(char('isvector'),x))):
        for i in arange_(2,nd).reshape(-1):
            if (not size_equal_(x[1],x[i]) or not size_equal_(x[i],v)):
                error_(char('interpn: dimensional mismatch'))
            idx[1:nd]=[1]
            idx[i]=char(':')
            x[i]=x[i](idx[:])(arange_())
        idx[1:nd]=[1]
        idx[1]=char(':')
        x[1]=x[1](idx[:])(arange_())
    method=tolower_(method)
    all_vectors=all_(cellfun_(char('isvector'),y))
    different_lengths=numel_(unique_(cellfun_(char('numel'),y))) > 1
    if (all_vectors and different_lengths):
        foobar_(arange_(1,numel_(y))).y=ndgrid_(y[:])
        y=[foobar.y]
    if (strcmp_(method,char('linear'))):
        vi=__lin_interpn___(x[:],v,y[:])
        vi[isna_(vi)]=extrapval
    else:
        if (strcmp_(method,char('nearest'))):
            yshape=size_(y[1])
            yidx=cell_(1,nd)
            for i in arange_(1,nd).reshape(-1):
                y[i]=y[i](arange_())
                yidx[i]=lookup_(x[i],y[i],char('lr'))
            idx=cell_(1,nd)
            for i in arange_(1,nd).reshape(-1):
                idx[i]=yidx[i] + (y[i] - x[i](yidx[i])(arange_()) >= x[i](yidx[i] + 1)(arange_()) - y[i])
            vi=v[sub2ind_(sz,idx[:])]
            idx=zeros_(prod_(yshape),1)
            for i in arange_(1,nd).reshape(-1):
                idx |= y[i] < min_(x[i](arange_())) or y[i] > max_(x[i](arange_()))
            vi[idx]=extrapval
            vi=reshape_(vi,yshape)
        else:
            if (strcmp_(method,char('spline'))):
                if (any_(not cellfun_(char('isvector'),y))):
                    for i in arange_(2,nd).reshape(-1):
                        if (not size_equal_(y[1],y[i])):
                            error_(char('interpn: dimensional mismatch'))
                        idx[1:nd]=[1]
                        idx[i]=char(':')
                        y[i]=y[i](idx[:])
                    idx[1:nd]=[1]
                    idx[1]=char(':')
                    y[1]=y[1](idx[:])
                vi=__splinen___(x,v,y,extrapval,char('interpn'))
                if (size_equal_(y[:])):
                    ly=length_(y[1])
                    idx=cell_(1,ly)
                    q=cell_(1,nd)
                    for i in arange_(1,ly).reshape(-1):
                        q[:]=i
                        idx[i]=q
                    vi=vi[cellfun_(lambda x: sub2ind_(size_(vi),x[:]),idx)]
                    vi=reshape_(vi,size_(y[1]))
            else:
                if (strcmp_(method,char('cubic'))):
                    error_(char('interpn: cubic interpolation not yet implemented'))
                else:
                    error_(char('interpn: unrecognized interpolation METHOD'))
    return vi
def bitset_(A=None,n=None,val=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[A,n,val].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (any_(A[:] < 0)):
        error_(char('bitset: A must be >= 0'))
    sz=size_(A)
    if (nargin == 2):
        val=true_(sz)
    cl=class_(A)
    if (isfloat_(A) and isreal_(A)):
        Bmax=bitmax_(cl)
        Amax=ceil_(log2_(Bmax))
    else:
        if (isinteger_(A)):
            Bmax=intmax_(cl)
            Amax=ceil_(log2_(Bmax))
        else:
            error_(char('bitset: invalid class %s'),cl)
    if (any_((n < 1)(arange_())) or any_((n > Amax)(arange_()))):
        error_(char('bitset: N must be in the range [1,%d]'),Amax)
    mask=bitshift_(cast_(1,cl),uint8_(n) - uint8_(1))
    on=logical_(val)
    off=not on
    if (isscalar_(mask)):
        onmask=copy_(mask)
        offmask=copy_(mask)
    else:
        if (not size_equal_(A,n)):
            error_(char('bitset: N must be scalar or the same size as A'))
        onmask=mask[on]
        offmask=mask[off]
    C=zeros_(sz,cl)
    C[on]=bitor_(A[on],onmask)
    C[off]=bitand_(A[off],bitcmp_(offmask))
    return C
def saveobj_(a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[a].count(None)+len(args)

    error_(char('saveobj: not defined for class "%s"'),class_(a))
    return b
def iscolumn_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    sz=size_(x)
    retval=(ndims_(x) == 2 and (sz[2] == 1))
    return retval
def celldisp_(c=None,name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[c,name].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (not iscell_(c)):
        error_(char('celldisp: C must be a cell array'))
    if (nargin == 1):
        name=inputname_(1)
    for i in arange_(1,numel_(c)).reshape(-1):
        if (iscell_(c[i])):
            celldisp_(c[i],sprintf_(char('%s{%s}'),name,indices_(size_(c),i)))
        else:
            disp_(sprintf_(char('%s{%s} = \n'),name,indices_(size_(c),i)))
            disp_(c[i])
            disp_(char(''))
    return
def indices_(dv=None,i=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[dv,i].count(None)+len(args)

    if (sum_(dv != 1) > 1):
        c=cell_(size_(dv))
        c[:]=ind2sub_(dv,i)
        s=sprintf_(char('%i,'),c[:])
        s[end()]=[]
    else:
        s=sprintf_(char('%i'),i)
    return s
def common_size_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 2):
        error_(char('common_size: only makes sense if nargin >= 2'))
    nscal=cellfun_(char('numel'),varargin) != 1
    i=find_(nscal,1)
    if (isempty_(i)):
        errorcode=0
        varargout=copy_(varargin)
    else:
        match=cellfun_(char('size_equal'),varargin,varargin[i])
        if (any_(nscal and not match)):
            errorcode=1
            varargout=copy_(varargin)
        else:
            errorcode=0
            if (nargout > 1):
                scal=not nscal
                varargout=copy_(varargin)
                if (any_(nscal)):
                    dims=size_(varargin[find_(nscal,1)])
                    subs=arrayfun_(ones,1,dims,char('uniformoutput'),false)
                    varargout[scal]=cellindexmat_(varargin[scal],subs[:])
    return errorcode,varargout
def shiftdim_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    nd=ndims_(x)
    orig_dims=size_(x)
    if (nargin == 1):
        n=find_(orig_dims != 1,1) - 1 or nd
    else:
        if (not (isscalar_(n) and n == fix_(n))):
            error_(char('shiftdim: N must be a scalar integer'))
    if (n >= nd):
        n=rem_(n,nd)
    if (n < 0):
        singleton_dims=ones_(1,- n)
        y=reshape_(x,[singleton_dims,orig_dims])
    else:
        if (n > 0):
            y=permute_(x,[arange_(n + 1,nd),arange_(1,n)])
        else:
            y=copy_(x)
    ns=copy_(n)
    return y,ns
def postpad_(x=None,l=None,c=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,l,c,dim].count(None)+len(args)

    if (nargin < 2 or nargin > 4):
        print_usage_()
    if (nargin < 3 or isempty_(c)):
        c=0
    else:
        if (not isscalar_(c)):
            error_(char('postpad: third argument must be empty or a scalar'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 4):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('postpad: DIM must be an integer and a valid dimension'))
    if (not isscalar_(l) or l < 0):
        error_(char('postpad: second argument must be a positive scaler'))
    if (dim > nd):
        sz[nd + 1:dim]=1
    d=sz[dim]
    if (d >= l):
        idx=repmat_([char(':')],nd,1)
        idx[dim]=arange_(1,l)
        y=x[idx[:]]
    else:
        sz[dim]=l - d
        y=cat_(dim,x,c[ones_(sz)])
    return y
def idivide_(x=None,y=None,op=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,op].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    else:
        if (nargin == 2):
            op=char('fix')
        else:
            op=tolower_(op)
    if (strcmp_(op,char('round'))):
        z=x / y
    else:
        if (isfloat_(x)):
            typ=class_(y)
        else:
            if (isfloat_(y)):
                typ=class_(x)
            else:
                typ=class_(x)
                if (not strcmp_(class_(x),class_(y))):
                    error_(char('idivide: incompatible types'))
        if (strcmp_(op,char('fix'))):
            z=cast_(fix_(double_(x) / double_(y)),typ)
        else:
            if (strcmp_(op,char('floor'))):
                z=cast_(floor_(double_(x) / double_(y)),typ)
            else:
                if (strcmp_(op,char('ceil'))):
                    z=cast_(ceil_(double_(x) / double_(y)),typ)
                else:
                    error_(char('idivide: unrecognized rounding type'))
    return z
def nthargout_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (isa_(varargin[1],char('function_handle')) or ischar_(varargin[1])):
        ntot=max_(n[:])
        func=varargin[1]
        args=varargin[2:end()]
    else:
        if (isnumeric_(varargin[1]) and (isa_(varargin[2],char('function_handle')) or ischar_(varargin[2]))):
            ntot=varargin[1]
            func=varargin[2]
            args=varargin[3:end()]
        else:
            print_usage_()
    if (any_(n != fix_(n)) or ntot != fix_(ntot) or any_(n <= 0) or ntot <= 0):
        error_(char('nthargout: N and NTOT must consist of positive integers'))
    outargs=cell_(1,ntot)
    try:
        outargs[:]=feval_(func,args[:])
        if (numel_(n) > 1):
            out=outargs[n]
        else:
            out=outargs[n]
    finally:
        pass
    return out
def display_(a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[a].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    _str=disp_(a)
    if (isempty_(strfind_(_str,char('<class ')))):
        disp_(_str)
    else:
        error_(char('display: not defined for class "%s"'),class_(a))
    return idx
def bicubic_(x=None,y=None,z=None,xi=None,yi=None,extrapval=None,spline_alpha=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[x,y,z,xi,yi,extrapval,spline_alpha].count(None)+len(args)

    if (nargin < 1 or nargin > 7):
        print_usage_()
    if (nargin == 7 and isscalar_(spline_alpha)):
        a=copy_(spline_alpha)
    else:
        a=0.5
    if (nargin < 6):
        extrapval=copy_(NaN)
    if (isa_(x,char('single')) or isa_(y,char('single')) or isa_(z,char('single')) or isa_(xi,char('single')) or isa_(yi,char('single'))):
        myeps=eps_(char('single'))
    else:
        myeps=eps_()
    if (nargin <= 2):
        if (nargin == 1):
            n=1
        else:
            n=copy_(y)
        z=copy_(x)
        x=matlabarray([])
        rz,cz=size_(z,nargout=2)
        s=linspace_(1,cz,(cz - 1) * pow2_(n) + 1)
        t=linspace_(1,rz,(rz - 1) * pow2_(n) + 1)
    else:
        if (nargin == 3):
            if (not isvector_(x) or not isvector_(y)):
                error_(char('bicubic: XI and YI must be vector'))
            s=copy_(y)
            t=copy_(z)
            z=copy_(x)
            rz,cz=size_(z,nargout=2)
        else:
            if (nargin == 5 or nargin == 6):
                rz,cz=size_(z,nargout=2)
                if (isvector_(x) and isvector_(y)):
                    if (rz != length_(y) or cz != length_(x)):
                        error_(char('bicubic: length of X and Y must match the size of Z'))
                else:
                    if (size_equal_(x,y) and size_equal_(x,z)):
                        x=x[1,:]
                        y=y[:,1]
                    else:
                        error_(char('bicubic: X, Y and Z must be equal size matrices of same size'))
                if (all_(diff_(x) < 0)):
                    flipx=copy_(true)
                    x=fliplr_(x)
                else:
                    if (all_(diff_(x) > 0)):
                        flipx=copy_(false)
                    else:
                        error_(char('bicubic:nonmonotonic'),char('bicubic: X values must be monotonic'))
                if (all_(diff_(y) < 0)):
                    flipy=copy_(true)
                    y=flipud_(y)
                else:
                    if (all_(diff_(y) > 0)):
                        flipy=copy_(false)
                    else:
                        error_(char('bicubic:nonmonotonic'),char('bicubic: Y values must be monotonic'))
                xfirst_ind=find_(xi < x[1])
                xlast_ind=find_(xi > x[cz])
                yfirst_ind=find_(yi < y[1])
                ylast_ind=find_(yi > y[rz])
                xi[xfirst_ind]=x[1]
                xi[xlast_ind]=x[cz]
                yi[yfirst_ind]=y[1]
                yi[ylast_ind]=y[rz]
                x=reshape_(x,1,cz)
                x[cz] *= 1 + sign_(x[cz]) * myeps
                if (x[cz] == 0):
                    x[cz]=myeps
                xi=reshape_(xi,1,length_(xi))
                m,i=sort_([x,xi],nargout=2)
                o=cumsum_(i <= cz)
                xidx=o[find_(i > cz)]
                y=reshape_(y,rz,1)
                y[rz] *= 1 + sign_(y[rz]) * myeps
                if (y[rz] == 0):
                    y[rz]=myeps
                yi=reshape_(yi,length_(yi),1)
                m,i=sort_([[y],[yi]],nargout=2)
                o=cumsum_(i <= rz)
                yidx=o[[find_(i > rz)]]
                s=xidx + ((xi- x[xidx]) / (x[xidx + 1]- x[xidx]))
                t=yidx + ((yi - y[yidx]) / (y[yidx + 1] - y[yidx]))
                if (flipx):
                    s=fliplr_(s)
                if (flipy):
                    t=flipud_(t)
            else:
                print_usage_()
    if (rz < 3 or cz < 3):
        error_(char('bicubic: Z at least a 3 by 3 matrices'))
    inds=floor_(s)
    d=find_(s == cz)
    s=s - floor_(s)
    inds[d]=cz - 1
    s[d]=1.0
    d=matlabarray([])
    indt=floor_(t)
    d=find_(t == rz)
    t=t - floor_(t)
    indt[d]=rz - 1
    t[d]=1.0
    d=matlabarray([])
    p=zeros_(size_(z) + 2)
    p[2:rz + 1,2:cz + 1]=z
    p[1,:]=(6 * (1 - a)) * p[2,:] - 3 * p[3,:] + (6 * a - 2) * p[4,:]
    p[rz + 2,:]=(6 * (1 - a)) * p[rz + 1,:] - 3 * p[rz,:] + (6 * a - 2) * p[rz - 1,:]
    p[:,1]=(6 * (1 - a)) * p[:,2] - 3 * p[:,3] + (6 * a - 2) * p[:,4]
    p[:,cz + 2]=(6 * (1 - a)) * p[:,cz + 1] - 3 * p[:,cz] + (6 * a - 2) * p[:,cz - 1]
    t2=t.dot(t)
    t3=t2.dot(t)
    ct0=- a.dot(t3) + (2 * a).dot(t2) - a.dot(t)
    ct1=(2 - a).dot(t3) + (- 3 + a).dot(t2) + 1
    ct2=(a - 2).dot(t3) + (- 2 * a + 3).dot(t2) + a.dot(t)
    ct3=a.dot(t3) - a.dot(t2)
    t=matlabarray([])
    t2=matlabarray([])
    t3=matlabarray([])
    s2=s.dot(s)
    s3=s2.dot(s)
    cs0=- a.dot(s3) + (2 * a).dot(s2) - a.dot(s)
    cs1=(2 - a).dot(s3) + (- 3 + a).dot(s2) + 1
    cs2=(a - 2).dot(s3) + (- 2 * a + 3).dot(s2) + a.dot(s)
    cs3=a.dot(s3) - a.dot(s2)
    s=matlabarray([])
    s2=matlabarray([])
    s3=matlabarray([])
    cs0=cs0[[1,1,1,1],:]
    cs1=cs1[[1,1,1,1],:]
    cs2=cs2[[1,1,1,1],:]
    cs3=cs3[[1,1,1,1],:]
    lent=length_(ct0)
    lens=columns_(cs0)
    zi=zeros_(lent,lens)
    for i in arange_(1,lent).reshape(-1):
        it=indt[i]
        _int=matlabarray([it,it + 1,it + 2,it + 3])
        zi[i,:]=([ct0[i],ct1[i],ct2[i],ct3[i]] * (p[_int,inds].dot(cs0) + p[_int,inds + 1].dot(cs1) + p[_int,inds + 2].dot(cs2) + p[_int,inds + 3].dot(cs3)))
    if (not (isempty_(xfirst_ind) and isempty_(xlast_ind))):
        zi[:,[xfirst_ind,xlast_ind]]=extrapval
    if (not (isempty_(yfirst_ind) and isempty_(ylast_ind))):
        zi[[[yfirst_ind],[ylast_ind]],:]=extrapval
    return zi
def dblquad_(f=None,xa=None,xb=None,ya=None,yb=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[f,xa,xb,ya,yb,tol,quadf].count(None)+len(args)

    if (nargin < 5):
        print_usage_()
    if (isempty_(tol)):
        tol=1e-06
    if (isempty_(quadf)):
        quadf=quadcc
    inner=__dblquad_inner__
    if (ischar_(f)):
        f=lambda x,y: feval_(f,x,y,varargin[:])
        varargin=[]
    q=feval_(quadf,lambda y: inner[y,f,xa,xb,tol,quadf,varargin[:]],ya,yb,tol)
    return q
def __dblquad_inner___(y=None,f=None,xa=None,xb=None,tol=None,quadf=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[y,f,xa,xb,tol,quadf].count(None)+len(args)

    q=zeros_(size_(y))
    for i in arange_(1,length_(y)).reshape(-1):
        q[i]=feval_(quadf,lambda x: f[x,y[i],varargin[:]],xa,xb,tol)
    return q
def interp1_(x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin < 2 or nargin > 6):
        print_usage_()
    method=char('linear')
    extrap=copy_(NA)
    xi=matlabarray([])
    ispp=copy_(false)
    firstnumeric=copy_(true)
    rightcontinuous=copy_(NaN)
    if (nargin > 2):
        for i in arange_(1,length_(varargin)).reshape(-1):
            arg=varargin[i]
            if (ischar_(arg)):
                arg=tolower_(arg)
                if (strcmp_(char('extrap'),arg)):
                    extrap=char('extrap')
                else:
                    if (strcmp_(char('pp'),arg)):
                        ispp=copy_(true)
                    else:
                        if (strcmp_(arg,char('right')) or strcmp_(arg,char('-right'))):
                            rightcontinuous=copy_(true)
                        else:
                            if (strcmp_(arg,char('left')) or strcmp_(arg,char('-left'))):
                                rightcontinuous=copy_(false)
                            else:
                                method=copy_(arg)
            else:
                if (firstnumeric):
                    xi=copy_(arg)
                    firstnumeric=copy_(false)
                else:
                    extrap=copy_(arg)
    if (isempty_(xi) and firstnumeric and not ispp):
        xi=copy_(y)
        y=copy_(x)
        if (isvector_(y)):
            x=arange_(1,numel_(y))
        else:
            x=arange_(1,rows_(y))
    x=x[:]
    nx=rows_(x)
    szx=size_(xi)
    if (isvector_(y)):
        y=y[:]
    szy=size_(y)
    y=y[:,:]
    ny,nc=size_(y,nargout=2)
    xi=xi[:]
    if (nx < 2 or ny < 2):
        error_(char('interp1: table too short'))
    if (not issorted_(x,char('either'))):
        x,p=sort_(x,nargout=2)
        y=y[p,:]
    if (isnan_(rightcontinuous)):
        if (x[end()] < x[1]):
            rightcontinuous=copy_(false)
        else:
            rightcontinuous=copy_(true)
    if ((rightcontinuous and (x[end()] < x[1])) or (not rightcontinuous and (x[end()] > x[1]))):
        x=flipud_(x)
        y=flipud_(y)
    starmethod=method[1] == char('*')
    if (starmethod):
        dx=x[2] - x[1]
    else:
        jumps=x[1:end() - 1] == x[2:end()]
        have_jumps=any_(jumps)
        if (have_jumps):
            if (strcmp_(method,char('linear')) or strcmp_(method,(char('nearest')))):
                if (any_(jumps[1:nx - 2] and jumps[2:nx - 1])):
                    warning_(char('interp1: multiple discontinuities at the same X value'))
            else:
                error_(char("interp1: discontinuities not supported for method '%s'"),method)
    if char('nearest') == (method):
        pp=mkpp_([[x[1]],[(x[1:nx - 1] + x[2:nx]) / 2],[x[nx]]],shiftdim_(y,1),szy[2:end()])
        pp.orient=char('first')
        if (ispp):
            yi=copy_(pp)
        else:
            yi=ppval_(pp,reshape_(xi,szx))
    else:
        if char('*nearest') == (method):
            pp=mkpp_([x[1],x[1] + [arange_(0.5,(nx - 1))] * dx,x[nx]],shiftdim_(y,1),szy[2:end()])
            pp.orient=char('first')
            if (ispp):
                yi=copy_(pp)
            else:
                yi=ppval_(pp,reshape_(xi,szx))
        else:
            if char('linear') == (method):
                xx=copy_(x)
                nxx=copy_(nx)
                yy=copy_(y)
                dy=diff_(yy)
                if (have_jumps):
                    xx[jumps]=[]
                    nxx=rows_(xx)
                    yy[jumps,:]=[]
                    dy[jumps,:]=[]
                dx=diff_(xx)
                dx=repmat_(dx,[1,size_(dy)(arange_(2,end()))])
                coefs=matlabarray([(dy / dx).T,yy[1:nxx - 1,:].T])
                pp=mkpp_(xx,coefs,szy[2:end()])
                pp.orient=char('first')
                if (ispp):
                    yi=copy_(pp)
                else:
                    yi=ppval_(pp,reshape_(xi,szx))
            else:
                if char('*linear') == (method):
                    dy=diff_(y)
                    coefs=matlabarray([(dy / dx).T(arange_()),y[1:nx - 1,:].T(arange_())])
                    pp=mkpp_(x,coefs,szy[2:end()])
                    pp.orient=char('first')
                    if (ispp):
                        yi=copy_(pp)
                    else:
                        yi=ppval_(pp,reshape_(xi,szx))
                else:
                    if [char('pchip'),char('*pchip'),char('cubic'),char('*cubic')] == (method):
                        if (nx == 2 or starmethod):
                            x=linspace_(x[1],x[nx],ny)
                        if (ispp):
                            y=shiftdim_(reshape_(y,szy),1)
                            yi=pchip_(x,y)
                            yi.orient=char('first')
                        else:
                            y=shiftdim_(y,1)
                            yi=pchip_(x,y,reshape_(xi,szx))
                            if (not isvector_(y)):
                                yi=shiftdim_(yi,1)
                    else:
                        if [char('spline'),char('*spline')] == (method):
                            if (nx == 2 or starmethod):
                                x=linspace_(x[1],x[nx],ny)
                            if (ispp):
                                y=shiftdim_(reshape_(y,szy),1)
                                yi=spline_(x,y)
                                yi.orient=char('first')
                            else:
                                y=shiftdim_(y,1)
                                yi=spline_(x,y,reshape_(xi,szx))
                                if (not isvector_(y)):
                                    yi=shiftdim_(yi,1)
                        else:
                            error_(char("interp1: invalid method '%s'"),method)
    if (not ispp and not ischar_(extrap)):
        minx=min_(x[1],x[nx])
        maxx=max_(x[1],x[nx])
        outliers=xi < minx or not (xi <= maxx)
        if (size_equal_(outliers,yi)):
            yi[outliers]=extrap
            yi=reshape_(yi,szx)
        else:
            if (not isvector_(yi)):
                yi[outliers,:]=extrap
            else:
                yi[outliers.T]=extrap
    return yi
def accumdim_(subs=None,vals=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[subs,vals,dim,n,func,fillval].count(None)+len(args)

    if (nargin < 2 or nargin > 6):
        print_usage_()
    if (isempty_(fillval)):
        fillval=0
    if (not isvector_(subs)):
        error_(char('accumdim: SUBS must be a subscript vector'))
    else:
        if (not isindex_(subs)):
            error_(char('accumdim: indices must be positive integers'))
        else:
            m=max_(subs)
            if (n == 0 or isempty_(n)):
                n=copy_(m)
            else:
                if (n < m):
                    error_(char('accumdim: N index out of range'))
    sz=size_(vals)
    if (nargin < 3):
        dim=find_(sz > 1,1) or 1
    else:
        if (not isindex_(dim)):
            error_(char('accumdim: DIM must be a valid dimension'))
        else:
            if (dim > length_(sz)):
                sz[end() + 1:dim]=1
    sz[dim]=n
    if (length_(subs) != size_(vals,dim)):
        error_(char('accumdim: dimension mismatch'))
    if (isempty_(func) or func == _sum):
        A=__accumdim_sum___(subs,vals,dim,n)
        if (fillval != 0):
            mask=true_(n,1)
            mask[subs]=false
            subsc=[char(':')](ones_(1,length_(sz)))
            subsc[dim]=mask
            A[subsc[:]]=fillval
        return A
    ns=length_(subs)
    subs,idx=sort_(subs[:],nargout=2)
    jdx=find_(subs[1:ns - 1] != subs[2:ns])
    jdx=matlabarray([[jdx],[ns]])
    szc=num2cell_(sz)
    szc[dim]=diff_([[0],[jdx]])
    subsc=[char(':')](ones_(1,length_(sz)))
    subsc[dim]=idx
    vals=mat2cell_(vals[subsc[:]],szc[:])
    if (func == _min or func == _max):
        vals=cellfun_(func,vals,[[]],[dim],char('uniformoutput'),false)
    else:
        vals=cellfun_(func,vals,[dim],char('uniformoutput'),false)
    subs=subs[jdx]
    vals=cat_(dim,vals[:])
    if (fillval == 0):
        A=zeros_(sz,class_(vals))
    else:
        A=repmat_(fillval,sz)
    subsc[dim]=subs
    A[subsc[:]]=vals
    return A
def cumtrapz_(x=None,y=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,dim].count(None)+len(args)

    if (nargin < 1) or (nargin > 3):
        print_usage_()
    have_xy=have_dim=copy_(false)
    if (nargin == 3):
        have_xy=copy_(true)
        have_dim=copy_(true)
    else:
        if (nargin == 2):
            if (not size_equal_(x,y) and isscalar_(y)):
                dim=copy_(y)
                have_dim=copy_(true)
            else:
                have_xy=copy_(true)
    if (have_xy):
        nd=ndims_(y)
        sz=size_(y)
    else:
        nd=ndims_(x)
        sz=size_(x)
    if (not have_dim):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('trapz: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    idx1=idx2=repmat_([char(':')],[nd,1])
    idx1[dim]=arange_(2,n)
    idx2[dim]=arange_(1,(n - 1))
    if (not have_xy):
        z=0.5 * cumsum_(x[idx1[:]] + x[idx2[:]],dim)
    else:
        if (isvector_(x) and not isvector_(y)):
            if (length_(x) != sz[dim]):
                error_(char('cumtrapz: length of X and length of Y along DIM must match'))
            shape=ones_(nd,1)
            shape[dim]=sz[dim]
            x=reshape_(x,shape)
            z=0.5 * cumsum_(bsxfun_(times,diff_(x),y[idx1[:]] + y[idx2[:]]),dim)
        else:
            if (not size_equal_(x,y)):
                error_(char('cumtrapz: X and Y must have same shape'))
            z=0.5 * cumsum_(diff_(x,1,dim).dot((y[idx1[:]] + y[idx2[:]])),dim)
    sz[dim]=1
    z=cat_(dim,zeros_(sz),z)
    return z
def structfun_(func=None,S=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[func,S].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    nargs=length_(varargin)
    recognized_opts=[char('UniformOutput'),char('ErrorHandler')]
    uo_str=recognized_opts[1]
    uniform_output=copy_(true)
    while (nargs >= 2):

        opt_match=strcmpi_(varargin[nargs - 1],recognized_opts)
        if (opt_match[1]):
            uniform_output=varargin[nargs]
        if (any_(opt_match)):
            nargs -= 2
        else:
            break

    if (nargs > 0):
        error_(char('structfun: invalid options'))
    varargout=cell_(max_([nargout,1]),1)
    varargout[:]=cellfun_(func,struct2cell_(S),varargin[:])
    if (not uniform_output):
        varargout=cellfun_(char('cell2struct'),varargout,[fieldnames_(S)],[1],uo_str,false)
    return varargout
def shift_(x=None,b=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,b,dim].count(None)+len(args)

    if (nargin != 2 and nargin != 3):
        print_usage_()
    if (numel_(x) < 1):
        error_(char('shift: X must not be empty'))
    else:
        if (not (isscalar_(b) and b == fix_(b))):
            error_(char('shift: B must be an integer'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin == 3):
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('shift: DIM must be an integer and a valid dimension'))
    else:
        dim=find_(sz > 1,1) or 1
    d=sz[dim]
    idx=repmat_([char(':')],nd,1)
    if (b > 0):
        b=rem_(b,d)
        idx[dim]=[arange_(d - b + 1,d),arange_(1,d - b)]
    else:
        if (b < 0):
            b=rem_(abs_(b),d)
            idx[dim]=[arange_(b + 1,d),arange_(1,b)]
    y=x[idx[:]]
    return y
def sortrows_(A=None,c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,c].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin == 2):
        if (not (isnumeric_(c) and isvector_(c))):
            error_(char('sortrows: C must be a numeric vector'))
        else:
            if (any_(c == 0) or any_(abs_(c) > columns_(A))):
                error_(char('sortrows: all elements of C must be in the range [1, columns (A)]'))
    default_mode=char('ascend')
    reverse_mode=char('descend')
    if (issparse_(A)):
        if (nargin == 1):
            i=sort_rows_idx_generic_(default_mode,reverse_mode,A)
        else:
            i=sort_rows_idx_generic_(default_mode,reverse_mode,A,c)
    else:
        if (nargin == 1):
            i=__sort_rows_idx___(A,default_mode)
        else:
            if (all_(c > 0)):
                i=__sort_rows_idx___(A[:,c],default_mode)
            else:
                if (all_(c < 0)):
                    i=__sort_rows_idx___(A[:,- c],reverse_mode)
                else:
                    i=sort_rows_idx_generic_(default_mode,reverse_mode,A,c)
    if (isargout_(1)):
        s=A[i,:]
    return s,i
def sort_rows_idx_generic_(default_mode=None,reverse_mode=None,m=None,c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[default_mode,reverse_mode,m,c].count(None)+len(args)

    if (nargin == 3):
        indices=[arange_(1,columns_(m))].T
        mode[1:columns_(m)]=[default_mode]
    else:
        for j in arange_(1,length_(c)).reshape(-1):
            if (c[j] < 0):
                mode[j]=reverse_mode
            else:
                mode[j]=default_mode
        indices=abs_(c[:])
    indices=flipud_(indices)
    mode=flipud_(mode.T)
    i=[arange_(1,rows_(m))].T
    for j in arange_(1,length_(indices)).reshape(-1):
        __,idx=sort_(m[i,indices[j]],mode[j],nargout=2)
        i=i[idx]
    return i
def nargchk_(minargs=None,maxargs=None,nargs=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[minargs,maxargs,nargs,outtype].count(None)+len(args)

    if (nargin < 3 or nargin > 4):
        print_usage_()
    else:
        if (minargs > maxargs):
            error_(char('nargchk: MINARGS must be <= MAXARGS'))
        else:
            if (not any_(strcmpi_(outtype,[char('string'),char('struct')]))):
                error_(char('nargchk: output type must be either "string" or "struct"'))
            else:
                if (not (isscalar_(minargs) and isscalar_(maxargs) and isscalar_(nargs))):
                    error_(char('nargchk: MINARGS, MAXARGS, and NARGS must be scalars'))
    msg=struct_(char('message'),char(''),char('identifier'),char(''))
    if (nargs < minargs):
        msg.message=char('not enough input arguments')
        msg.identifier=char('Octave:nargchk:not-enough-inputs')
    else:
        if (nargs > maxargs):
            msg.message=char('too many input arguments')
            msg.identifier=char('Octave:nargchk:too-many-inputs')
    if (strcmpi_(outtype,char('string'))):
        msg=msg.message
    else:
        if (isempty_(msg.message)):
            msg=resize_(msg,0,1)
    return msg
def curl_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    fidx=1
    if (nargin == 2):
        sz=size_(varargin[fidx])
        dx=(arange_(1,sz[2]))(arange_())
        dy=(arange_(1,sz[1]))(arange_())
    else:
        if (nargin == 3):
            sz=size_(varargin[fidx])
            dx=(arange_(1,sz[2]))(arange_())
            dy=(arange_(1,sz[1]))(arange_())
            dz=(arange_(1,sz[3]))(arange_())
        else:
            if (nargin == 4):
                fidx=3
                dx=varargin[1](1,arange_())
                dy=varargin[2](arange_(),1)
            else:
                if (nargin == 6):
                    fidx=4
                    dx=varargin[1](1,arange_(),1)(arange_())
                    dy=varargin[2](arange_(),1,1)(arange_())
                    dz=varargin[3](1,1,arange_())(arange_())
                else:
                    print_usage_()
    if ((nargin == 4) or (nargin == 2)):
        if (not size_equal_(varargin[fidx],varargin[fidx + 1])):
            error_(char('curl: size of X and Y must match'))
        else:
            if (ndims_(varargin[fidx]) != 2):
                error_(char('curl: expected two-dimensional matrices X and Y'))
            else:
                if ((length_(dx) != columns_(varargin[fidx])) or (length_(dy) != rows_(varargin[fidx]))):
                    error_(char('curl: size of dx and dy must match the respective dimension of X and Y'))
        dFx_dy=gradient_(varargin[fidx].T,dy,dx).T
        dFy_dx=gradient_(varargin[fidx + 1],dx,dy)
        rot_z=dFy_dx - dFx_dy
        av=rot_z / 2
        if (nargout == 0 or nargout == 1):
            varargout[1]=av
        else:
            varargout[1]=rot_z
            varargout[2]=av
    else:
        if ((nargin == 6) or (nargin == 3)):
            if (not size_equal_(varargin[fidx],varargin[fidx + 1],varargin[fidx + 2])):
                error_(char('curl: size of X, Y, and Z must match'))
            else:
                if (ndims_(varargin[fidx]) != 3):
                    error_(char('curl: expected two-dimensional matrices X, Y, and Z'))
                else:
                    if ((length_(dx) != size_(varargin[fidx],2)) or (length_(dy) != size_(varargin[fidx],1)) or (length_(dz) != size_(varargin[fidx],3))):
                        error_(char('curl: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z'))
            __,dFx_dy,dFx_dz=gradient_(varargin[fidx],dx,dy,dz,nargout=3)
            dFy_dx,__,dFy_dz=gradient_(varargin[fidx + 1],dx,dy,dz,nargout=3)
            dFz_dx,dFz_dy=gradient_(varargin[fidx + 2],dx,dy,dz,nargout=2)
            rot_x=dFz_dy - dFy_dz
            rot_y=dFx_dz - dFz_dx
            rot_z=dFy_dx - dFx_dy
            l=sqrt_(varargin[fidx] ** 2 + varargin[fidx + 1] ** 2 + varargin[fidx + 2] ** 2)
            av=(rot_x.dot(varargin[fidx]) + rot_y.dot(varargin[fidx + 1]) + rot_z.dot(varargin[fidx + 2])) / (2 * l)
            if (nargout == 0 or nargout == 1):
                varargout[1]=av
            else:
                varargout[1]=rot_x
                varargout[2]=rot_y
                varargout[3]=rot_z
                varargout[4]=av
    return varargout
def divergence_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    fidx=1
    if (nargin == 2):
        sz=size_(varargin[fidx])
        dx=(arange_(1,sz[2]))(arange_())
        dy=(arange_(1,sz[1]))(arange_())
    else:
        if (nargin == 3):
            sz=size_(varargin[fidx])
            dx=arange_(1,sz[2])
            dy=arange_(1,sz[1])
            dz=arange_(1,sz[3])
        else:
            if (nargin == 4):
                fidx=3
                dx=varargin[1](1,arange_())
                dy=varargin[2](arange_(),1)
            else:
                if (nargin == 6):
                    fidx=4
                    dx=varargin[1](1,arange_(),1)(arange_())
                    dy=varargin[2](arange_(),1,1)(arange_())
                    dz=varargin[3](1,1,arange_())(arange_())
                else:
                    print_usage_()
    if ((nargin == 4) or (nargin == 2)):
        if (not size_equal_(varargin[fidx],varargin[fidx + 1])):
            error_(char('divergence: size of X and Y must match'))
        else:
            if (ndims_(varargin[fidx]) != 2):
                error_(char('divergence: expected two-dimensional matrices X and Y'))
            else:
                if ((length_(dx) != columns_(varargin[fidx])) or (length_(dy) != rows_(varargin[fidx]))):
                    error_(char('divergence: size of dx and dy must match the respective dimension of X and Y'))
        retval=gradient_(varargin[fidx],dx,dy)
        retval += gradient_(varargin[fidx + 1].T,dy,dx).T
    else:
        if ((nargin == 6) or (nargin == 3)):
            if (not size_equal_(varargin[fidx],varargin[fidx + 1],varargin[fidx + 2])):
                error_(char('divergence: size of X, Y, and Z must match'))
            else:
                if (ndims_(varargin[fidx]) != 3):
                    error_(char('divergence: expected two-dimensional matrices X, Y, and Z'))
                else:
                    if ((length_(dx) != size_(varargin[fidx],2)) or (length_(dy) != size_(varargin[fidx],1)) or (length_(dz) != size_(varargin[fidx],3))):
                        error_(char('divergence: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z'))
            retval=gradient_(varargin[fidx],dx,dy,dz)
            retval += shiftdim_(gradient_(shiftdim_(varargin[fidx + 1],2),dy),1)
            retval += shiftdim_(gradient_(shiftdim_(varargin[fidx + 2],1),dz),2)
    return retval
def triplequad_(f=None,xa=None,xb=None,ya=None,yb=None,za=None,zb=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 9-[f,xa,xb,ya,yb,za,zb,tol,quadf].count(None)+len(args)

    if (nargin < 7):
        print_usage_()
    if (isempty_(tol)):
        tol=1e-06
    if (isempty_(quadf)):
        quadf=quadcc
    inner=__triplequad_inner__
    if (ischar_(f)):
        f=lambda x,y,z: feval_(f,x,y,z,varargin[:])
        varargin=[]
    q=dblquad_(lambda y,z: inner[y,z,f,xa,xb,tol,quadf,varargin[:]],ya,yb,za,zb,tol)
    return q
def __triplequad_inner___(y=None,z=None,f=None,xa=None,xb=None,tol=None,quadf=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[y,z,f,xa,xb,tol,quadf].count(None)+len(args)

    q=zeros_(size_(y))
    for i in arange_(1,length_(y)).reshape(-1):
        q[i]=feval_(quadf,lambda x: f[x,y[i],z,varargin[:]],xa,xb,tol)
    return q
def subsindex_(a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[a].count(None)+len(args)

    error_(char('subsindex: not defined for class "%s"'),class_(a))
    return idx
def prepad_(x=None,l=None,c=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,l,c,dim].count(None)+len(args)

    if (nargin < 2 or nargin > 4):
        print_usage_()
    if (nargin < 3 or isempty_(c)):
        c=0
    else:
        if (not isscalar_(c)):
            error_(char('prepad: pad value C must be empty or a scalar'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 4):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('prepad: DIM must be an integer and a valid dimension'))
    if (not isscalar_(l) or l < 0):
        error_(char('prepad: length L must be a positive scalar'))
    if (dim > nd):
        sz[nd + 1:dim]=1
    d=sz[dim]
    if (d >= l):
        idx=repmat_([char(':')],nd,1)
        idx[dim]=arange_(d - l + 1,d)
        y=x[idx[:]]
    else:
        sz[dim]=l - d
        y=cat_(dim,c * ones_(sz),x)
    return y
def isdir_(f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[f].count(None)+len(args)

    if (nargin != 1):
        print_usage_(char('isdir'))
    retval=(exist_(f,char('dir')) == 7)
    return retval
def isequal_(x1=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x1].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    retval=__isequal___(false,x1,varargin[:])
    return retval
def cart2sph_(x=None,y=None,z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,z].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (nargin == 1):
        if (ismatrix_(x) and columns_(x) == 3):
            z=x[:,3]
            y=x[:,2]
            x=x[:,1]
        else:
            error_(char('cart2sph: matrix input must have 3 columns [X, Y, Z]'))
    else:
        if (nargin == 3):
            if (not ((ismatrix_(x) and ismatrix_(y) and ismatrix_(z)) and (size_equal_(x,y) or isscalar_(x) or isscalar_(y)) and (size_equal_(x,z) or isscalar_(x) or isscalar_(z)) and (size_equal_(y,z) or isscalar_(y) or isscalar_(z)))):
                error_(char('cart2sph: X, Y, Z must be matrices of the same size, or scalar'))
    theta=atan2_(y,x)
    phi=atan2_(z,sqrt_(x ** 2 + y ** 2))
    r=sqrt_(x ** 2 + y ** 2 + z ** 2)
    if (nargout <= 1):
        theta=matlabarray([theta[:],phi[:],r[:]])
    return theta,phi,r
def rot90_(A=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (ndims_(A) > 2):
        error_(char('rot90: A must be a 2-D array'))
    else:
        if (not (isscalar_(k) and isreal_(k) and k == fix_(k))):
            error_(char('rot90: K must be a single real integer'))
    k=mod_(k,4)
    if (k == 0):
        B=copy_(A)
    else:
        if (k == 1):
            B=flipud_(A.T)
        else:
            if (k == 2):
                B=flipud_(fliplr_(A))
            else:
                if (k == 3):
                    B=(flipud_(A)).T
                else:
                    error_(char('rot90: internal error!'))
    return B
def bitget_(A=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (isa_(A,char('double'))):
        Amax=ceil_(log2_(bitmax))
        _conv=double
    else:
        if (isa_(A,char('single'))):
            Amax=ceil_(log2_(bitmax_(char('single'))))
            _conv=single
        else:
            if (isa_(A,char('uint8'))):
                Amax=8
                _conv=uint8
            else:
                if (isa_(A,char('uint16'))):
                    Amax=16
                    _conv=uint16
                else:
                    if (isa_(A,char('uint32'))):
                        Amax=32
                        _conv=uint32
                    else:
                        if (isa_(A,char('uint64'))):
                            Amax=64
                            _conv=uint64
                        else:
                            if (isa_(A,char('int8'))):
                                Amax=8
                                _conv=int8
                            else:
                                if (isa_(A,char('int16'))):
                                    Amax=16
                                    _conv=int16
                                else:
                                    if (isa_(A,char('int32'))):
                                        Amax=32
                                        _conv=int32
                                    else:
                                        if (isa_(A,char('int64'))):
                                            Amax=64
                                            _conv=int64
                                        else:
                                            error_(char('bitget: invalid class %s'),class_(A))
    m=double_(n[:])
    if (any_(m < 1) or any_(m > Amax)):
        error_(char('bitget: N must be in the range [1,%d]'),Amax)
    C=bitand_(A,bitshift_(_conv[1],uint8_(n) - uint8_(1))) != _conv[0]
    return C
def profexplore_(data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[data].count(None)+len(args)

    if (nargin == 0):
        data=profile_(char('info'))
    else:
        if (nargin != 1):
            print_usage_()
    __profexplore_worker_(data.FunctionTable,data.Hierarchical,char('Top\n'),char('  '))
    return
def __profexplore_worker_(fcn_table=None,tree=None,parents=None,prefix=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[fcn_table,tree,parents,prefix].count(None)+len(args)

    times=- [tree.TotalTime]
    __,p=sort_(times,nargout=2)
    tree=tree[p]
    while (true):

        printf_(char('\n%s'),parents)
        strings=cell_(length_(tree),1)
        for i in arange_(1,length_(tree)).reshape(-1):
            strings[i]=sprintf_(char('%s: %d calls, %.3f total, %.3f self'),fcn_table[tree[i].Index].FunctionName,tree[i].NumCalls,tree[i].TotalTime,tree[i].SelfTime)
            printf_(char('%s%d) %s\n'),prefix,i,strings[i])
        printf_(char('\n'))
        cmd=input_(char('profexplore> '),char('s'))
        option=fix_(str2double_(cmd))
        if (strcmp_(cmd,char('exit')) or strcmp_(cmd,char('quit'))):
            rv=0
            return rv
        else:
            if (strcmp_(cmd,char('help'))):
                printf_(char('\nCommands for profile explorer:\n\n'))
                printf_(char('exit   Return to Octave prompt.\n'))
                printf_(char('quit   Return to Octave prompt.\n'))
                printf_(char('help   Display this help message.\n'))
                printf_(char('up [N] Go up N levels, where N is an integer.  Default is 1.\n'))
                printf_(char('N      Go down a level into option N.\n'))
            else:
                if (not isnan_(option)):
                    if (option < 1 or option > length_(tree)):
                        printf_(char('The chosen option is out of range!\n'))
                    else:
                        newParents=sprintf_(char('%s%s%s\n'),parents,prefix,strings[option])
                        newPrefix=sprintf_(char('%s  '),prefix)
                        rv=__profexplore_worker_(fcn_table,tree[option].Children,newParents,newPrefix)
                        if (rv == 0):
                            return rv
                        else:
                            if (rv > 1):
                                rv=rv - 1
                                return rv
                            else:
                                assert_(rv == 1)
                else:
                    if (length_(cmd) >= 2 and strcmp_(substr_(cmd,1,2),char('up'))):
                        if (length_(cmd) == 2):
                            rv=1
                            return rv
                        if (length_(cmd) > 3 and cmd[3] == char(' ')):
                            opt=fix_(str2double_(substr_(cmd,3)))
                            if (not isnan_(opt) and opt > 0):
                                rv=copy_(opt)
                                return rv
                        printf_(char("Invalid 'up' command.  Type 'help' for further"))
                        printf_(char(' information.\n'))
                    else:
                        printf_(char("Unrecognized input.  Type 'help' to get a list of possible"))
                        printf_(char(' commands.\n'))

    return rv
def cell2mat_(c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[c].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not iscell_(c)):
        error_(char('cell2mat: C is not a cell array'))
    nb=numel_(c)
    if (nb == 0):
        m=matlabarray([])
    else:
        valid=cellfun_(char('isnumeric'),c)
        valid=cellfun_(char('islogical'),c[not valid])
        valid=cellfun_(char('isclass'),c[not valid],char('char'))
        if (not all_(valid[:])):
            valid=cellfun_(char('isclass'),c,char('cell'))
            if (not all_(valid[:])):
                valid=cellfun_(char('isclass'),c,char('struct'))
                if (not all_(valid[:])):
                    error_(char('cell2mat: wrong type elements or mixed cells, structs, and matrices'))
        sz=size_(c)
        if (all_(cellfun_(char('numel'),c)(arange_()) == 1)):
            m=reshape_(cat_(1,c[:]),sz)
        else:
            nd=ndims_(c)
            __,isz=sort_(sz,char('descend'),nargout=2)
            for idim in isz.reshape(-1):
                if (sz[idim] == 1):
                    continue
                xdim=matlabarray([arange_(1,idim - 1),arange_(idim + 1,nd)])
                cc=num2cell_(c,xdim)
                c=cellfun_(char('cat'),[idim],cc[:],char('uniformoutput'),false)
            m=c[1]
    return m
def isscalar_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    retval=numel_(x) == 1
    return retval
def gradient_(m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[m].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    nargout_with_ans=max_(1,nargout)
    if (ismatrix_(m)):
        varargout[1:nargout_with_ans]=matrix_gradient_(m,varargin[:])
    else:
        if (isa_(m,char('function_handle'))):
            varargout[1:nargout_with_ans]=handle_gradient_(m,varargin[:])
        else:
            if (ischar_(m)):
                varargout[1:nargout_with_ans]=handle_gradient_(str2func_(m),varargin[:])
            else:
                error_(char('gradient: first input must be an array or a function'))
    return varargout
def matrix_gradient_(m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[m].count(None)+len(args)

    transposed=copy_(false)
    if (isvector_(m)):
        transposed=(columns_(m) == 1)
        m=m[:].T
    nd=ndims_(m)
    sz=size_(m)
    if (length_(sz) > 1):
        tmp=sz[1]
        sz[1]=sz[2]
        sz[2]=tmp
    if (nargin > 2 and nargin != nd + 1):
        print_usage_()
    d=cell_(1,nd)
    if (nargin == 1):
        for i in arange_(1,nd).reshape(-1):
            d[i]=ones_(sz[i] - 1,1)
    else:
        if (nargin == 2):
            if (isscalar_(varargin[1])):
                for i in arange_(1,nd).reshape(-1):
                    d[i]=varargin[1] * ones_(sz[i] - 1,1)
            else:
                d[1]=diff_(varargin[1](arange_()))
        else:
            if (length_(varargin) != nd):
                error_(char('gradient: dimensions and number of spacing values do not match'))
            for i in arange_(1,nd).reshape(-1):
                if (isscalar_(varargin[i])):
                    d[i]=varargin[i] * ones_(sz[i] - 1,1)
                else:
                    d[i]=diff_(varargin[i](arange_()))
    m=shiftdim_(m,1)
    for i in arange_(1,min_(nd,nargout)).reshape(-1):
        mr=rows_(m)
        mc=numel_(m) / mr
        Y=zeros_(size_(m),class_(m))
        if (mr > 1):
            Y[1,:]=diff_(m[1:2,:]) / d[i](1)
            Y[mr,:]=diff_(m[mr - 1:mr,:] / d[i](mr - 1))
        if (mr > 2):
            Y[2:mr - 1,:]=((m[3:mr,:] - m[1:mr - 2,:]) / kron_(d[i](arange_(1,mr - 2)) + d[i](arange_(2,mr - 1)),ones_(1,mc)))
        if (i == 1):
            varargout[i]=shiftdim_(Y,nd - 1)
            m=shiftdim_(m,nd - 1)
        else:
            if (i == 2):
                varargout[i]=Y
                m=shiftdim_(m,2)
            else:
                varargout[i]=shiftdim_(Y,nd - i + 1)
                m=shiftdim_(m,1)
    if (transposed):
        varargout[1]=varargout[1].T
    return varargout
def handle_gradient_(f=None,p0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,p0].count(None)+len(args)

    p0_size=size_(p0)
    if (numel_(p0_size) != 2):
        error_(char('gradient: the second input argument should either be a vector or a matrix'))
    if (any_(p0_size == 1)):
        p0=p0[:]
        dim=1
        num_points=numel_(p0)
    else:
        num_points=p0_size[1]
        dim=p0_size[2]
    if (length_(varargin) == 0):
        delta=1
    else:
        if (length_(varargin) == 1 or length_(varargin) == dim):
            try:
                delta=matlabarray([varargin[:]])
            finally:
                pass
        else:
            error_(char('gradient: incorrect number of spacing parameters'))
    if (isscalar_(delta)):
        delta=repmat_(delta,1,dim)
    else:
        if (not isvector_(delta)):
            error_(char('gradient: spacing values must be scalars or a vector'))
    p0=mat2cell_(p0,num_points,ones_(1,dim))
    varargout=cell_(1,dim)
    for d in arange_(1,dim).reshape(-1):
        s=delta[d]
        df_dx=(f[p0[1:d - 1],p0[d] + s,p0[d + 1:end()]] - f[p0[1:d - 1],p0[d] - s,p0[d + 1:end()]]) / (2 * s)
        if (dim == 1):
            varargout[d]=reshape_(df_dx,p0_size)
        else:
            varargout[d]=df_dx
    return varargout
def interp2_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    Z=X=Y=XI=YI=n=matlabarray([])
    method=char('linear')
    extrapval=copy_(NA)
    if 1 == (nargin):
        Z=varargin[1]
        n=1
    else:
        if 2 == (nargin):
            if (ischar_(varargin[2])):
                Z,method=deal_(varargin[:],nargout=2)
                n=1
            else:
                Z,n=deal_(varargin[:],nargout=2)
        else:
            if 3 == (nargin):
                if (ischar_(varargin[3])):
                    Z,n,method=deal_(varargin[:],nargout=3)
                else:
                    Z,XI,YI=deal_(varargin[:],nargout=3)
            else:
                if 4 == (nargin):
                    if (ischar_(varargin[4])):
                        Z,XI,YI,method=deal_(varargin[:],nargout=4)
                    else:
                        Z,n,method,extrapval=deal_(varargin[:],nargout=4)
                else:
                    if 5 == (nargin):
                        if (ischar_(varargin[4])):
                            Z,XI,YI,method,extrapval=deal_(varargin[:],nargout=5)
                        else:
                            X,Y,Z,XI,YI=deal_(varargin[:],nargout=5)
                    else:
                        if 6 == (nargin):
                            X,Y,Z,XI,YI,method=deal_(varargin[:],nargout=6)
                        else:
                            if 7 == (nargin):
                                X,Y,Z,XI,YI,method,extrapval=deal_(varargin[:],nargout=7)
                            else:
                                print_usage_()
    if (not ismatrix_(Z)):
        error_(char('interp2: Z must be a matrix'))
    if (not isempty_(n) and not isscalar_(n)):
        error_(char('interp2: N must be a scalar'))
    if (not ischar_(method)):
        error_(char('interp2: METHOD must be a string'))
    if (ischar_(extrapval) or strcmp_(extrapval,char('extrap'))):
        extrapval=matlabarray([])
    else:
        if (not isscalar_(extrapval)):
            error_(char('interp2: EXTRAPVAL must be a scalar'))
    zr,zc=size_(Z,nargout=2)
    if (isempty_(X)):
        X=arange_(1,zc)
        Y=arange_(1,zr)
    if (not isnumeric_(X) or not isnumeric_(Y)):
        error_(char('interp2: X, Y must be numeric matrices'))
    if (not isempty_(n)):
        p=2 ** n
        XI=(arange_(p,p * zc)) / p
        YI=(arange_(p,p * zr)).T / p
    if (not isnumeric_(XI) or not isnumeric_(YI)):
        error_(char('interp2: XI, YI must be numeric'))
    if (strcmp_(method,char('linear')) or strcmp_(method,char('nearest')) or strcmp_(method,char('pchip'))):
        if (isvector_(X) and isvector_(Y)):
            X=X[:]
            Y=Y[:]
        else:
            if (size_equal_(X,Y)):
                X=X[1,:].T
                Y=Y[:,1]
            else:
                error_(char('interp2: X and Y must be matrices of same size'))
        if (columns_(Z) != length_(X) or rows_(Z) != length_(Y)):
            error_(char('interp2: X and Y size must match the dimensions of Z'))
        if ((rows_(XI) == 1 and columns_(YI) == 1) or (columns_(XI) == 1 and rows_(YI) == 1)):
            XI,YI=meshgrid_(XI,YI,nargout=2)
        else:
            if (not size_equal_(XI,YI)):
                error_(char('interp2: XI and YI must be matrices of equal size'))
        if (rows_(XI) == 1):
            if (rows_(X) != 1):
                X=X.T
            if (rows_(Y) != 1):
                Y=Y.T
        else:
            if (columns_(XI) == 1):
                if (columns_(X) != 1):
                    X=X.T
                if (columns_(Y) != 1):
                    Y=Y.T
        xidx=lookup_(X,XI,char('lr'))
        yidx=lookup_(Y,YI,char('lr'))
        if (strcmp_(method,char('linear'))):
            a=Z[1:(zr - 1),1:(zc - 1)]
            b=Z[1:(zr - 1),2:zc] - a
            c=Z[2:zr,1:(zc - 1)] - a
            d=Z[2:zr,2:zc] - a - b - c
            Xsc=(XI - X[xidx]) / (diff_(X)(xidx))
            Ysc=(YI - Y[yidx]) / (diff_(Y)(yidx))
            idx=sub2ind_(size_(a),yidx,xidx)
            clear_(char('xidx'),char('yidx'))
            ZI=a[idx] + b[idx].dot(Xsc) + c[idx].dot(Ysc) + d[idx].dot(Xsc).dot(Ysc)
        else:
            if (strcmp_(method,char('nearest'))):
                ii=(XI - X[xidx] >= X[xidx + 1] - XI)
                jj=(YI - Y[yidx] >= Y[yidx + 1] - YI)
                idx=sub2ind_(size_(Z),yidx + jj,xidx + ii)
                ZI=Z[idx]
            else:
                if (strcmp_(method,char('pchip'))):
                    if (length_(X) < 2 or length_(Y) < 2):
                        error_(char('interp2: pchip2 requires at least 2 points in each dimension'))
                    DX=__pchip_deriv___(X,Z,2)
                    DY=__pchip_deriv___(Y,Z,1)
                    DXY=(__pchip_deriv___(X,DY,2) + __pchip_deriv___(Y,DX,1)) / 2
                    hx=diff_(X)
                    hx=hx[xidx]
                    hy=diff_(Y)
                    hy=hy[yidx]
                    tx=(XI - X[xidx]) / hx
                    ty=(YI - Y[yidx]) / hy
                    t1=tx ** 2
                    t2=tx.dot(t1) - t1
                    xb[2,2]=hx.dot(t2)
                    t1=t2 - t1
                    xb[2,1]=hx.dot((t1 + tx))
                    t2 += t1
                    xb[1,2]=- t2
                    xb[1,1]=t2 + 1
                    t1=ty ** 2
                    t2=ty.dot(t1) - t1
                    yb[2,2]=hy.dot(t2)
                    t1=t2 - t1
                    yb[2,1]=hy.dot((t1 + ty))
                    t2 += t1
                    yb[1,2]=- t2
                    yb[1,1]=t2 + 1
                    ZI=zeros_(size_(XI))
                    for i in arange_(1,2).reshape(-1):
                        for j in arange_(1,2).reshape(-1):
                            zidx=sub2ind_(size_(Z),yidx + (j - 1),xidx + (i - 1))
                            ZI += xb[1,i].dot(yb[1,j]).dot(Z[zidx])
                            ZI += xb[2,i].dot(yb[1,j]).dot(DX[zidx])
                            ZI += xb[1,i].dot(yb[2,j]).dot(DY[zidx])
                            ZI += xb[2,i].dot(yb[2,j]).dot(DXY[zidx])
        if (not isempty_(extrapval)):
            if (X[1] < X[end()]):
                if (Y[1] < Y[end()]):
                    ZI[XI < X[1,1] or XI > X[end()] or YI < Y[1,1] or YI > Y[end()]]=extrapval
                else:
                    ZI[XI < X[1] or XI > X[end()] or YI < Y[end()] or YI > Y[1]]=extrapval
            else:
                if (Y[1] < Y[end()]):
                    ZI[XI < X[end()] or XI > X[1] or YI < Y[1] or YI > Y[end()]]=extrapval
                else:
                    ZI[XI < X[1,end()] or XI > X[1] or YI < Y[end()] or YI > Y[1]]=extrapval
    else:
        if (isvector_(X) and isvector_(Y)):
            X=X[:].T
            Y=Y[:]
            if (not isequal_([length_(Y),length_(X)],size_(Z))):
                error_(char('interp2: X and Y size must match the dimensions of Z'))
        else:
            if (not size_equal_(X,Y)):
                error_(char('interp2: X and Y must be matrices of equal size'))
                if (not size_equal_(X,Z)):
                    error_(char('interp2: X and Y size must match the dimensions of Z'))
        if (isvector_(XI) and isvector_(YI) and not size_equal_(XI,YI)):
            XI=XI[:].T
            YI=YI[:]
            XI,YI=meshgrid_(XI,YI,nargout=2)
        else:
            if (not size_equal_(XI,YI)):
                error_(char('interp2: XI and YI must be matrices of equal size'))
        if (strcmp_(method,char('cubic'))):
            if (isgriddata_(XI) and isgriddata_(YI.T)):
                ZI=bicubic_(X,Y,Z,XI[1,:],YI[:,1],extrapval)
            else:
                if (isgriddata_(X) and isgriddata_(Y.T)):
                    ZI=zeros_(size_(X))
                    inside=not (XI < X[1] or XI > X[end()] or YI < Y[1] or YI > Y[end()])
                    XI=(columns_(Z) - 1) * (XI - X[1]) / (X[end()] - X[1]) + 1
                    YI=(rows_(Z) - 1) * (YI - Y[1]) / (Y[end()] - Y[1]) + 1
                    K=floor_(XI)
                    L=floor_(YI)
                    AY1=bc_((YI - L + 1))
                    AX1=bc_((XI - K + 1))
                    AY0=bc_((YI - L + 0))
                    AX0=bc_((XI - K + 0))
                    AY_1=bc_((YI - L - 1))
                    AX_1=bc_((XI - K - 1))
                    AY_2=bc_((YI - L - 2))
                    AX_2=bc_((XI - K - 2))
                    sz=size_(Z)
                    ZI=AY_2.dot(AX_2).dot(Z[sym_sub2ind_(sz,L + 2,K + 2)]) + AY_2.dot(AX_1).dot(Z[sym_sub2ind_(sz,L + 2,K + 1)]) + AY_2.dot(AX0).dot(Z[sym_sub2ind_(sz,L + 2,K)]) + AY_2.dot(AX1).dot(Z[sym_sub2ind_(sz,L + 2,K - 1)]) + AY_1.dot(AX_2).dot(Z[sym_sub2ind_(sz,L + 1,K + 2)]) + AY_1.dot(AX_1).dot(Z[sym_sub2ind_(sz,L + 1,K + 1)]) + AY_1.dot(AX0).dot(Z[sym_sub2ind_(sz,L + 1,K)]) + AY_1.dot(AX1).dot(Z[sym_sub2ind_(sz,L + 1,K - 1)]) + AY0.dot(AX_2).dot(Z[sym_sub2ind_(sz,L,K + 2)]) + AY0.dot(AX_1).dot(Z[sym_sub2ind_(sz,L,K + 1)]) + AY0.dot(AX0).dot(Z[sym_sub2ind_(sz,L,K)]) + AY0.dot(AX1).dot(Z[sym_sub2ind_(sz,L,K - 1)]) + AY1.dot(AX_2).dot(Z[sym_sub2ind_(sz,L - 1,K + 2)]) + AY1.dot(AX_1).dot(Z[sym_sub2ind_(sz,L - 1,K + 1)]) + AY1.dot(AX0).dot(Z[sym_sub2ind_(sz,L - 1,K)]) + AY1.dot(AX1).dot(Z[sym_sub2ind_(sz,L - 1,K - 1)])
                    ZI[not inside]=extrapval
                else:
                    error_(char("interp2: input data must have 'meshgrid' format"))
        else:
            if (strcmp_(method,char('spline'))):
                if (isgriddata_(XI) and isgriddata_(YI.T)):
                    ZI=__splinen___([Y[:,1].T,X[1,:]],Z,[YI[:,1],XI[1,:]],extrapval,char('spline'))
                else:
                    error_(char("interp2: input data must have 'meshgrid' format"))
            else:
                error_(char('interp2: interpolation METHOD not recognized'))
    return ZI
def isgriddata_(X=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[X].count(None)+len(args)

    d1=diff_(X,1,1)
    b=all_(d1[:] == 0)
    return b
def bc_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    x=abs_(x)
    o=zeros_(size_(x))
    idx1=(x < 1)
    idx2=not idx1 and (x < 2)
    o[idx1]=1 - 2.0 * x[idx1] ** 2 + x[idx1] ** 3
    o[idx2]=4 - 8.0 * x[idx2] + 5.0 * x[idx2] ** 2 - x[idx2] ** 3
    return o
def sym_sub2ind_(sz=None,Y=None,X=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[sz,Y,X].count(None)+len(args)

    Y[Y < 1]=1 - Y[Y < 1]
    while (any_(Y[:] > 2 * sz[1])):

        Y[Y > 2 * sz[1]]=round_(Y[Y > 2 * sz[1]] / 2)

    Y[Y > sz[1]]=1 + 2 * sz[1] - Y[Y > sz[1]]
    X[X < 1]=1 - X[X < 1]
    while (any_(X[:] > 2 * sz[2])):

        X[X > 2 * sz[2]]=round_(X[X > 2 * sz[2]] / 2)

    X[X > sz[2]]=1 + 2 * sz[2] - X[X > sz[2]]
    ind=sub2ind_(sz,Y,X)
    return ind
def repmat_(A=None,m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[A,m,n].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (nargin == 3):
        if (not isempty_(m) and isempty_(n)):
            m=m[:].T
            n=1
        else:
            if (isempty_(m) and not isempty_(n)):
                m=n[:].T
                n=1
            else:
                if (isempty_(m) and isempty_(n)):
                    m=n=1
                else:
                    if (all_(size_(m) > 1)):
                        m=m[:,1]
                        if (numel_(m) < 3):
                            n=n[end()]
                        else:
                            n=matlabarray([])
                    if (all_(size_(n) > 1)):
                        n=n[:,1]
                    m=m[:].T
                    n=n[:].T
    else:
        if (isempty_(m)):
            m=n=1
        else:
            if (isscalar_(m)):
                n=copy_(m)
            else:
                if (ndims_(m) > 2):
                    error_(char('repmat: M has more than 2 dimensions'))
                else:
                    if (all_(size_(m) > 1)):
                        m=m[:,1].T
                        n=matlabarray([])
                    else:
                        m=m[:].T
                        n=matlabarray([])
    idx=matlabarray([m,n])
    if (all_(idx < 0)):
        error_(char('repmat: invalid dimensions'))
    else:
        idx=max_(idx,0)
    if (numel_(A) == 1):
        if (any_(idx == 0)):
            x=resize_(A,idx)
        else:
            x[1:prod_(idx)]=A
            x=reshape_(x,idx)
    else:
        if (ndims_(A) == 2 and length_(idx) < 3):
            if (issparse_(A)):
                x=kron_(ones_(idx),A)
            else:
                m=rows_(A)
                n=columns_(A)
                p=idx[1]
                q=idx[2]
                x=reshape_(A,m,1,n,1)
                x=x[:,ones_(1,p),:,ones_(1,q)]
                x=reshape_(x,m * p,n * q)
        else:
            aidx=size_(A)
            idx[end() + 1:length_(aidx)]=1
            aidx[end() + 1:length_(idx)]=1
            cidx=cell_(2,length_(aidx))
            for i in arange_(1,length_(aidx)).reshape(-1):
                cidx[1,i]=char(':')
                cidx[2,i]=ones_(1,idx[i])
            aaidx=copy_(aidx)
            aaidx[2,:]=1
            A=reshape_(A,aaidx[:])
            x=reshape_(A[cidx[:]],idx.dot(aidx))
    return x
def randi_(bounds=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[bounds].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (not (isnumeric_(bounds) and isreal_(bounds))):
        error_(char('randi: IMIN and IMAX must be real numeric bounds'))
    if (isscalar_(bounds)):
        imin=1
        imax=fix_(bounds)
        if (imax < 1):
            error_(char('randi: require IMAX >= 1'))
    else:
        imin=fix_(bounds[1])
        imax=fix_(bounds[2])
        if (imax < imin):
            error_(char('randi: require IMIN <= IMAX'))
    if (nargin > 1 and ischar_(varargin[end()])):
        rclass=varargin[end()]
        varargin[end()]=[]
    else:
        rclass=char('double')
    if (strfind_(rclass,char('int'))):
        if (imax > intmax_(rclass)):
            error_(char('randi: require IMAX < intmax (CLASS)'))
    else:
        if (strcmp_(rclass,char('single'))):
            if (imax > bitmax_(rclass)):
                error_(char('randi: require IMAX < bitmax (CLASS)'))
    if (imax > bitmax):
        error_(char('randi: maximum integer IMAX must be smaller than bitmax ()'))
    if ((imax - imin) > bitmax):
        error_(char('randi: maximum integer range must be smaller than bitmax ()'))
    ri=imin + floor_((imax - imin + 1) * rand_(varargin[:]))
    if (not strcmp_(rclass,char('double'))):
        ri=cast_(ri,rclass)
    return ri
def record_(sec=None,sampling_rate=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[sec,sampling_rate].count(None)+len(args)

    if (nargin == 1):
        sampling_rate=8000
    else:
        if (nargin != 2):
            print_usage_()
    try:
        _file=tmpnam_()
        input_(char('Please hit ENTER and speak afterwards!\n'),1)
        cmd=sprintf_(char('dd if=/dev/dsp of="%s" bs=%d count=%d'),_file,sampling_rate,sec)
        system_(cmd)
        num=fopen_(_file,char('rb'))
        Y,c=fread_(num,sampling_rate * sec,char('uchar'),nargout=2)
        fclose_(num)
    finally:
        unlink_(_file)
    X=Y - 127
    return X
def wavwrite_(y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[y].count(None)+len(args)

    BYTEORDER=char('ieee-le')
    if (nargin < 2 or nargin > 4):
        print_usage_()
    samples_per_sec=8000
    bits_per_sample=16
    filename=varargin[end()]
    if (nargin > 2):
        samples_per_sec=varargin[1]
        if (nargin > 3):
            bits_per_sample=varargin[2]
    n,channels=size_(y,nargout=2)
    if (n == 1):
        n=copy_(channels)
        channels=1
    if (channels < 1):
        error_(char('wavwrite: Y must have at least one column'))
    if (channels > 32767):
        error_(char('wavwrite: Y has more than 32767 columns (too many for a WAV-file)'))
    if 8 == (bits_per_sample):
        _format=char('uint8')
    else:
        if 16 == (bits_per_sample):
            _format=char('int16')
        else:
            if 32 == (bits_per_sample):
                _format=char('int32')
            else:
                error_(char('wavwrite: sample resolution not supported'))
    ck_size=n * channels * (bits_per_sample / 8)
    if (not ischar_(filename)):
        error_(char('wavwrite: expecting FILENAME to be a character string'))
    fid,msg=fopen_(filename,char('wb'),nargout=2)
    if (fid < 0):
        error_(char('wavwrite: %s'),msg)
    c=0
    c += fwrite_(fid,char('RIFF'),char('uchar'))
    c += fwrite_(fid,ck_size + 36,char('uint32'),0,BYTEORDER)
    c += fwrite_(fid,char('WAVEfmt '),char('uchar'))
    c += fwrite_(fid,16,char('uint32'),0,BYTEORDER)
    c += fwrite_(fid,1,char('uint16'),0,BYTEORDER)
    c += fwrite_(fid,channels,char('uint16'),0,BYTEORDER)
    c += fwrite_(fid,samples_per_sec,char('uint32'),0,BYTEORDER)
    byteps=samples_per_sec * channels * bits_per_sample / 8
    c += fwrite_(fid,byteps,char('uint32'),0,BYTEORDER)
    c += fwrite_(fid,channels * bits_per_sample / 8,char('uint16'),0,BYTEORDER)
    c += fwrite_(fid,bits_per_sample,char('uint16'),0,BYTEORDER)
    c += fwrite_(fid,char('data'),char('uchar'))
    c += fwrite_(fid,ck_size,char('uint32'),0,BYTEORDER)
    if (c < 25):
        fclose_(fid)
        error_(char('wavwrite: writing to file failed'))
    yi=reshape_(y.T,n * channels,1)
    if 8 == (bits_per_sample):
        yi=round_(yi * 128 + 128)
    else:
        if 16 == (bits_per_sample):
            yi=round_(yi * 32768)
        else:
            if 32 == (bits_per_sample):
                yi=round_(yi * 2147483648)
    c=fwrite_(fid,yi,_format,0,BYTEORDER)
    fclose_(fid)
    return
def mu2lin_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin == 2):
        if (n != 0 and n != 8 and n != 16):
            error_(char('mu2lin: N must be either 0, 8, or 16'))
    else:
        if (nargin != 1):
            print_usage_()
    ulaw=matlabarray([32124,31100,30076,29052,28028,27004,25980,24956,23932,22908,21884,20860,19836,18812,17788,16764,15996,15484,14972,14460,13948,13436,12924,12412,11900,11388,10876,10364,9852,9340,8828,8316,7932,7676,7420,7164,6908,6652,6396,6140,5884,5628,5372,5116,4860,4604,4348,4092,3900,3772,3644,3516,3388,3260,3132,3004,2876,2748,2620,2492,2364,2236,2108,1980,1884,1820,1756,1692,1628,1564,1500,1436,1372,1308,1244,1180,1116,1052,988,924,876,844,812,780,748,716,684,652,620,588,556,524,492,460,428,396,372,356,340,324,308,292,276,260,244,228,212,196,180,164,148,132,120,112,104,96,88,80,72,64,56,48,40,32,24,16,8,0])
    ulaw=matlabarray([- ulaw,ulaw])
    y=copy_(x)
    y[:]=ulaw[x + 1]
    if (n == 0):
        y=y / 32768
    else:
        if (n == 8):
            ld=max_(abs_(y[:]))
            if (ld < 16384 and ld > 0):
                sc=64 / ld
            else:
                sc=1 / 256
            y=fix_(y * sc)
    return y
def loadaudio_(name=None,ext=None,bps=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[name,ext,bps].count(None)+len(args)

    if (nargin == 0 or nargin > 3):
        print_usage_()
    if (nargin == 1):
        ext=char('lin')
    if (nargin < 3):
        bps=8
    else:
        if (bps != 8 and bps != 16):
            error_(char('loadaudio: BPS must be either 8 or 16'))
    name=matlabarray([name,char('.'),ext])
    num=fopen_(name,char('rb'))
    if (strcmp_(ext,char('lin')) or strcmp_(ext,char('raw')) or strcmp_(ext,char('pcm'))):
        if (bps == 8):
            Y,c=fread_(num,inf,char('uchar'),nargout=2)
            X=Y - 127
        else:
            X,c=fread_(num,inf,char('short'),nargout=2)
    else:
        if (strcmp_(ext,char('mu')) or strcmp_(ext,char('au')) or strcmp_(ext,char('snd')) or strcmp_(ext,char('ul'))):
            Y,c=fread_(num,inf,char('uchar'),nargout=2)
            m=find_(Y[1:64] == 0,1,char('last'))
            if (not isempty_(m)):
                Y[1:m]=[]
            X=mu2lin_(Y,bps)
        else:
            fclose_(num)
            error_(char('loadaudio: unsupported extension'))
    fclose_(num)
    return X
def saveaudio_(name=None,x=None,ext=None,bps=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[name,x,ext,bps].count(None)+len(args)

    if (nargin < 2 or nargin > 4):
        print_usage_()
    if (nargin == 2):
        ext=char('lin')
    if (nargin < 4):
        bps=8
    else:
        if (bps != 8 and bps != 16):
            error_(char('saveaudio: BPS must be either 8 or 16'))
    nr,nc=size_(x,nargout=2)
    if (nc != 1):
        if (nr == 1):
            x=x.T
            nr=copy_(nc)
        else:
            error_(char('saveaudio: X must be a vector'))
    num=fopen_([name,char('.'),ext],char('wb'))
    if (strcmp_(ext,char('lin')) or strcmp_(ext,char('raw'))):
        if (bps == 8):
            ld=max_(abs_(x))
            if (ld > 127):
                if (ld < 16384):
                    sc=64 / ld
                else:
                    sc=1 / 256
                x=fix_(x * sc)
            x=x + 127
            c=fwrite_(num,x,char('uchar'))
        else:
            c=fwrite_(num,x,char('short'))
    else:
        if (strcmp_(ext,char('mu')) or strcmp_(ext,char('au')) or strcmp_(ext,char('snd')) or strcmp_(ext,char('ul'))):
            y=lin2mu_(x)
            c=fwrite_(num,y,char('uchar'))
        else:
            fclose_(num)
            error_(char('saveaudio: unsupported extension'))
    fclose_(num)
    return
def wavread_(filename=None,param=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[filename,param].count(None)+len(args)

    FORMAT_PCM=1
    FORMAT_IEEE_FLOAT=3
    BYTEORDER=char('ieee-le')
    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (not ischar_(filename)):
        error_(char('wavread: FILENAME must be a character string'))
    fid=- 1
    try:
        fid,msg=fopen_(filename,char('rb'),nargout=2)
        if (fid < 0):
            error_(char('wavread: %s'),msg)
        fseek_(fid,0,char('eof'))
        file_size=ftell_(fid)
        fseek_(fid,0,char('bof'))
        riff_size=find_chunk_(fid,char('RIFF'),file_size)
        riff_pos=ftell_(fid)
        if (riff_size == - 1):
            error_(char('wavread: file contains no RIFF chunk'))
        riff_size=min_(riff_size,file_size - riff_pos)
        riff_type=char_(fread_(fid,4)).T
        if (not strcmp_(riff_type,char('WAVE'))):
            error_(char('wavread: file contains no WAVE signature'))
        riff_pos=riff_pos + 4
        riff_size=riff_size - 4
        fseek_(fid,riff_pos,char('bof'))
        fmt_size=find_chunk_(fid,char('fmt '),riff_size)
        fmt_pos=ftell_(fid)
        if (fmt_size == - 1):
            error_(char('wavread: file contains no format chunk'))
        fseek_(fid,riff_pos,char('bof'))
        data_size=find_chunk_(fid,char('data'),riff_size)
        data_pos=ftell_(fid)
        if (data_size == - 1):
            error_(char('wavread: file contains no data chunk'))
        data_size=min_(data_size,file_size - data_pos)
        fseek_(fid,fmt_pos,char('bof'))
        format_tag=fread_(fid,1,char('uint16'),0,BYTEORDER)
        if (format_tag != FORMAT_PCM and format_tag != FORMAT_IEEE_FLOAT):
            error_(char('wavread: sample format %#x is not supported'),format_tag)
        channels=fread_(fid,1,char('uint16'),0,BYTEORDER)
        samples_per_sec=fread_(fid,1,char('uint32'),0,BYTEORDER)
        fseek_(fid,6,char('cof'))
        bits_per_sample=fread_(fid,1,char('uint16'),0,BYTEORDER)
        fseek_(fid,data_pos,char('bof'))
        if (format_tag == FORMAT_PCM):
            if 8 == (bits_per_sample):
                _format=char('uint8')
            else:
                if 16 == (bits_per_sample):
                    _format=char('int16')
                else:
                    if 24 == (bits_per_sample):
                        _format=char('uint8')
                    else:
                        if 32 == (bits_per_sample):
                            _format=char('int32')
                        else:
                            error_(char('wavread: %d bits sample resolution is not supported with PCM'),bits_per_sample)
        else:
            if 32 == (bits_per_sample):
                _format=char('float32')
            else:
                if 64 == (bits_per_sample):
                    _format=char('float64')
                else:
                    error_(char('wavread: %d bits sample resolution is not supported with IEEE float'),bits_per_sample)
        if (nargin == 1):
            length=idivide_(8 * data_size,bits_per_sample)
        else:
            nparams=numel_(param)
            if (nparams == 1):
                length=param * channels
            else:
                if (nparams == 2):
                    if (fseek_(fid,(param[1] - 1) * channels * (bits_per_sample / 8),char('cof')) < 0):
                        warning_(char('wavread: seeking failed'))
                    length=(param[2] - param[1] + 1) * channels
                else:
                    if (nparams == 4 and char_(param) == char('size')):
                        y=idivide_(8 * data_size,channels * bits_per_sample)
                        samples_per_sec=copy_(channels)
                        return y,samples_per_sec,bits_per_sample
                    else:
                        error_(char('wavread: invalid PARAM argument'))
        if (bits_per_sample == 24):
            length *= 3
        yi,n=fread_(fid,length,_format,0,BYTEORDER,nargout=2)
    finally:
        if (fid >= 0):
            fclose_(fid)
    if (mod_(numel_(yi),channels) != 0):
        error_(char("wavread: data in %s doesn't match the number of channels"),filename)
    if (bits_per_sample == 24):
        yi=reshape_(yi,3,rows_(yi) / 3).T
        yi[yi[:,3] >= 128,3] -= 256
        yi=yi * [[1],[256],[65536]]
    if (format_tag == FORMAT_PCM):
        if 8 == (bits_per_sample):
            yi=(yi - 128) / 128
        else:
            if 16 == (bits_per_sample):
                yi /= 32768
            else:
                if 24 == (bits_per_sample):
                    yi /= 8388608
                else:
                    if 32 == (bits_per_sample):
                        yi /= 2147483648
    nr=numel_(yi) / channels
    y=reshape_(yi,channels,nr).T
    return y,samples_per_sec,bits_per_sample
def find_chunk_(fid=None,chunk_id=None,size=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[fid,chunk_id,size].count(None)+len(args)

    _id=char('')
    offset=8
    chunk_size=0
    while (not strcmp_(_id,chunk_id) and (offset < size)):

        fseek_(fid,chunk_size,char('cof'))
        _id=char_(fread_(fid,4)).T
        chunk_size=fread_(fid,1,char('uint32'),0,char('ieee-le'))
        chunk_size += rem_(chunk_size,2)
        offset=offset + 8 + chunk_size

    if (not strcmp_(_id,chunk_id)):
        chunk_size=- 1
    return chunk_size
def playaudio_(name=None,ext=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[name,ext].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin == 1 and isnumeric_(name)):
        if (not isvector_(name)):
            error_(char('playaudio: X must be a vector'))
        X=name[:] + 127
        try:
            _file=tmpnam_()
            fid=fopen_(_file,char('wb'))
            fwrite_(fid,X,char('uchar'))
            fclose_(fid)
            status,out=system_(sprintf_(char('cat "%s" > /dev/dsp'),_file),nargout=2)
            if (status != 0):
                system_(sprintf_(char('paplay --raw "%s"'),_file))
        finally:
            unlink_(_file)
    else:
        if (nargin >= 1 and ischar_(name)):
            if (nargin == 1):
                name=matlabarray([name,char('.lin')])
            else:
                if (nargin == 2):
                    name=matlabarray([name,char('.'),ext])
            if (any_(strcmp_(ext,[char('lin'),char('raw')]))):
                status,out=system_(sprintf_(char('cat "%s" > /dev/dsp'),name),nargout=2)
                if (status != 0):
                    system_(sprintf_(char('paplay --raw "%s"'),name))
            else:
                if (any_(strcmp_(ext,[char('mu'),char('au'),char('snd'),char('ul')]))):
                    status,out=system_(sprintf_(char('cat "%s" > /dev/audio'),name),nargout=2)
                    if (status != 0):
                        system_(sprintf_(char('paplay "%s"'),name))
                else:
                    error_(char("playaudio: unsupported extension '%s'"),ext)
        else:
            print_usage_()
    return
def lin2mu_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin == 1):
        _range=max_(abs_(x[:]))
        if (_range <= 1):
            n=0
        else:
            if (_range <= 128):
                n=8
                warning_(char('lin2mu: no precision specified, so using %d'),n)
            else:
                n=16
    else:
        if (nargin == 2):
            if (n != 0 and n != 8 and n != 16):
                error_(char('lin2mu: N must be either 0, 8 or 16'))
        else:
            print_usage_()
    if (n == 0):
        x=32768 * x
    else:
        if (n != 16):
            x=2 ** (16 - n).dot(x)
    sig=sign_(x) + (x == 0)
    x=min_(abs_(x),32635) + 132
    f,e=log2_(x,nargout=2)
    y=64 * sig - 16 * e - fix_(32 * f) + 335
    return y
def setaudio_(w_type=None,value=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[w_type,value].count(None)+len(args)

    if (nargin == 0):
        system_(char('mixer'))
    else:
        if (nargin == 1):
            system_(sprintf_(char('mixer %s'),w_type))
        else:
            if (nargin == 2):
                system_(sprintf_(char('mixer %s %d'),w_type,value))
            else:
                print_usage_()
    return
def textread_(filename=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[filename,_format].count(None)+len(args)

    BUFLENGTH=4096
    if (nargin < 1):
        print_usage_()
    if (not ischar_(filename) or not ischar_(_format)):
        error_(char('textread: FILENAME and FORMAT arguments must be strings'))
    if (not isempty_(varargin) and isnumeric_(varargin[1])):
        nlines=varargin[1]
    else:
        nlines=copy_(Inf)
    if (nlines < 1):
        printf_(char('textread: N = 0, no data read\n'))
        varargout=cell_(1,nargout)
        return varargout
    fid=fopen_(filename,char('r'))
    if (fid == - 1):
        error_(char("textread: could not open '%s' for reading"),filename)
    headerlines=find_(strcmpi_(varargin,char('headerlines')),1)
    if (not isempty_(headerlines)):
        if (headerlines == numel_(varargin) or not isnumeric_(varargin[headerlines + 1])):
            error_(char("missing or illegal value for 'headerlines'"))
        varargin[headerlines + 1]=round_(varargin[headerlines + 1])
        if (varargin[headerlines + 1] > 0):
            fskipl_(fid,varargin[headerlines + 1])
            varargin[headerlines:headerlines + 1]=[]
            nargin=nargin - 2
        else:
            if (varargin[headerlines + 1] < 0):
                warning_(char('textread: negative headerline value ignored'))
    st_pos=ftell_(fid)
    _str,count=fscanf_(fid,char('%c'),BUFLENGTH,nargout=2)
    if (isempty_(_str) or count < 1):
        warning_(char('textread: empty file'))
        varargout=cell_(1,nargout)
        return varargout
    endofline=find_(strcmpi_(varargin,char('endofline')),1)
    if (not isempty_(endofline)):
        if (not ischar_(varargin[endofline + 1])):
            error_(char('character value required for EndOfLine'))
    else:
        eol_srch_len=min_(length_(_str),BUFLENGTH)
        if (not isempty_(strfind_(_str[1:eol_srch_len],char('\r\n')))):
            eol_char=char('\r\n')
        else:
            if (not isempty_(strfind_(_str[1:eol_srch_len],char('\r')))):
                eol_char=char('\r')
            else:
                eol_char=char('\n')
        varargin[end() + 1:end() + 2]=[char('endofline'),eol_char]
    if (isfinite_(nlines) and (nlines > 0)):
        l_eol_char=length_(eol_char)
        eoi=findstr_(_str,eol_char)
        n_eoi=length_(eoi)
        nblks=0
        while (n_eoi < nlines and count == BUFLENGTH):

            nstr,count=fscanf_(fid,char('%c'),BUFLENGTH,nargout=2)
            if (count > 0):
                if (l_eol_char > 1):
                    _str=matlabarray([_str[end() - length_(eol_char) + 2:end()],nstr])
                else:
                    _str=copy_(nstr)
                eoi=findstr_(_str,eol_char)
                n_eoi += numel_(eoi)
                ++ nblks

        if (isempty_(eoi)):
            printf_(char('textread: format repeat count specified but no endofline found\n'))
            eoi_pos=nblks * BUFLENGTH + count
        else:
            eoi_pos=(nblks * BUFLENGTH) + eoi[end() + min_(nlines,n_eoi) - n_eoi]
        fseek_(fid,st_pos,char('bof'))
        _str=fscanf_(fid,char('%c'),eoi_pos)
    else:
        fseek_(fid,st_pos,char('bof'))
        _str=fread_(fid,char('char=>char')).T
    fclose_(fid)
    if (isempty_(find_(strcmpi_(char('whitespace'),varargin)))):
        varargin[end() + 1:end() + 2]=[char('whitespace'),char(' \x08\t')]
    varargout[1:max_(nargout,1)]=strread_(_str,_format,varargin[:])
    if (isempty_(_format)):
        iwhsp=find_(strcmpi_(char('whitespace'),varargin))
        whsp=varargin[iwhsp + 1]
        idx=regexp_(_str,eol_char,char('once'))
        if (not isempty_(idx)):
            _str=_str[1:idx - 1]
        idelimiter=find_(strcmpi_(varargin,char('delimiter')),1)
        if (isempty_(idelimiter)):
            _str=regexprep_(_str,sprintf_(char('[%s]+'),whsp),char(' '))
            _str=strtrim_(_str)
            ncols=numel_(strfind_(_str,char(' '))) + 1
        else:
            delimiter=varargin[idelimiter + 1]
            ncols=numel_(regexp_(_str,sprintf_(char('[%s]'),delimiter))) + 1
        nrows=ceil_(numel_(varargout[1]) / ncols)
        pad=mod_(numel_(varargout[1]),ncols)
        if (pad > 0):
            pad=ncols - pad
            varargout[1][end() + 1:end() + pad]=NaN
        varargout[1]=reshape_(varargout[1],ncols,nrows).T
        varargout[1][find_(isnan_(varargout[1]))]=0
    return varargout
def csvread_(filename=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[filename].count(None)+len(args)

    x=dlmread_(filename,char(','),varargin[:])
    return x
def csvwrite_(filename=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[filename,x].count(None)+len(args)

    dlmwrite_(filename,x,char(','),varargin[:])
    return
def strread_(str=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[_str,_format].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (isempty_(_str)):
        varargout=cell_(1,nargout)
        return varargout
    if (isempty_(_format)):
        _format=char('%f')
    if (not ischar_(_str) or not ischar_(_format)):
        error_(char('strread: STR and FORMAT arguments must be strings'))
    if (strcmp_(typeinfo_(_format),char('sq_string'))):
        _format=do_string_escapes_(_format)
    nfields=length_(strfind_(_format,char('%'))) - length_(strfind_(_format,char('%*')))
    if ((max_(nargout,1) != nfields) and not strcmp_(_format,char('%f'))):
        error_(char('strread: the number of output variables must match that specified by FORMAT'))
    format_repeat_count=- 1
    if (nargin > 2 and isnumeric_(varargin[1])):
        if (varargin[1] >= 0):
            format_repeat_count=varargin[1]
        if (nargin > 3):
            varargin=varargin[2:end()]
        else:
            varargin=[]
    comment_flag=copy_(false)
    delimiter_str=char('')
    empty_str=char('')
    eol_char=char('')
    err_action=0
    mult_dlms_s1=copy_(false)
    numeric_fill_value=copy_(NaN)
    white_spaces=char(' \x08\r\n\t')
    for n in arange_(1,length_(varargin),2).reshape(-1):
        if char('bufsize') == (lower__________(varargin[n])):
            warning_(char("strread: property 'bufsize' is not implemented"))
        else:
            if char('commentstyle') == (lower__________(varargin[n])):
                comment_flag=copy_(true)
                if char('c') == (lower____(varargin[n + 1])):
                    comment_start,comment_end=deal_(char('/*'),char('*/'),nargout=2)
                else:
                    if char('c++') == (lower____(varargin[n + 1])):
                        comment_start,comment_end=deal_(char('//'),char('eol_char'),nargout=2)
                    else:
                        if char('shell') == (lower____(varargin[n + 1])):
                            comment_start,comment_end=deal_(char('#'),char('eol_char'),nargout=2)
                        else:
                            if char('matlab') == (lower____(varargin[n + 1])):
                                comment_start,comment_end=deal_(char('%'),char('eol_char'),nargout=2)
                            else:
                                if (ischar_(varargin[n + 1]) or (numel_(varargin[n + 1]) == 1 and iscellstr_(varargin[n + 1]))):
                                    comment_start,comment_end=deal_(char_(varargin[n + 1]),char('eol_char'),nargout=2)
                                else:
                                    if (iscellstr_(varargin[n + 1]) and numel_(varargin[n + 1]) == 2):
                                        comment_start,comment_end=deal_(varargin[n + 1][:],nargout=2)
                                    else:
                                        error_(char("strread: unknown or unrecognized comment style '%s'"),varargin[n + 1])
            else:
                if char('delimiter') == (lower__________(varargin[n])):
                    delimiter_str=varargin[n + 1]
                    if (strcmp_(typeinfo_(delimiter_str),char('sq_string'))):
                        delimiter_str=do_string_escapes_(delimiter_str)
                else:
                    if char('emptyvalue') == (lower__________(varargin[n])):
                        numeric_fill_value=varargin[n + 1]
                    else:
                        if char('expchars') == (lower__________(varargin[n])):
                            warning_(char("strread: property 'expchars' is not implemented"))
                        else:
                            if char('whitespace') == (lower__________(varargin[n])):
                                white_spaces=varargin[n + 1]
                                if (strcmp_(typeinfo_(white_spaces),char('sq_string'))):
                                    white_spaces=do_string_escapes_(white_spaces)
                            else:
                                if char('endofline') == (lower__________(varargin[n])):
                                    eol_char=varargin[n + 1]
                                    if (strcmp_(typeinfo_(eol_char),char('sq_string'))):
                                        eol_char=do_string_escapes_(eol_char)
                                else:
                                    if char('returnonerror') == (lower__________(varargin[n])):
                                        err_action=varargin[n + 1]
                                    else:
                                        if char('multipledelimsasone') == (lower__________(varargin[n])):
                                            mult_dlms_s1=varargin[n + 1]
                                        else:
                                            if char('treatasempty') == (lower__________(varargin[n])):
                                                if (iscellstr_(varargin[n + 1])):
                                                    empty_str=varargin[n + 1]
                                                else:
                                                    if (ischar_(varargin[n + 1])):
                                                        empty_str=varargin[n + 1]
                                                    else:
                                                        error_(char("strread: 'treatasempty' value must be string or cellstr"))
                                            else:
                                                warning_(char("strread: unknown property '%s'"),varargin[n])
    if (strcmpi_(strtrim_(_format),char('%f'))):
        fmt_words=cell_(max_(nargout,1),1)
        fmt_words[1:max_(nargout,1)]=_format
    else:
        _format=strrep_(_format,char('%'),char(' %'))
        fmt_words=regexp_(_format,char('[^ ]+'),char('match'))
        idy2=find_(not cellfun_(char('isempty'),regexp_(fmt_words,char('^%'))))
        errpat=char('(\\[.*\\]|[cq]|[nfdu]8|[nfdu]16|[nfdu]32|[nfdu]64)')
        if (not all_(cellfun_(char('isempty'),regexp_(fmt_words[idy2],errpat)))):
            error_(char('strread: %q, %c, %[] or bit width format specifiers are not supported yet.'))
        a=strfind_(fmt_words[idy2],char('%'))
        b=regexp_(fmt_words[idy2],char('[nfdus]'),char('end'))
        for jj in arange_(1,numel_(a)).reshape(-1):
            ii=numel_(a) - jj + 1
            if (isempty_(b[ii])):
                error_(char("strread: unknown format specifier #%d ('%s')\n"),ii,fmt_words[idy2[ii]])
            if (not (length_(fmt_words[idy2[ii]]) == b[ii](1))):
                fmt_words[idy2[ii] + 1:end() + 1]=fmt_words[idy2[ii]:end()]
                fmt_words[idy2[ii]]=fmt_words[idy2[ii]](arange_(a[ii],b[ii](1)))
                fmt_words[idy2[ii] + 1]=fmt_words[idy2[ii] + 1](arange_(b[ii] + 1,end()))
    num_words_per_line=numel_(fmt_words)
    if (not isempty_(eol_char) and strcmp_(eol_char,char('\r\n'))):
        _str=strrep_(_str,char('\r\n'),char('\n'))
        eol_char=char('\n')
    if (comment_flag):
        comment_end=regexprep_(comment_end,char('eol_char'),eol_char)
        cstart=strfind_(_str,comment_start)
        cstop=strfind_(_str,comment_end)
        if (isempty_(cstop) or cstop[end()] != length_(_str)):
            cstop[end() + 1]=length_(_str)
        if (not isempty_(cstart)):
            idx,cidx=unique_(lookup_(cstop,cstart),char('first'),nargout=2)
            if (idx[end()] == length_(cstop)):
                cidx[end()]=[]
            cstart=cstart[cidx]
        if (not isempty_(cstop)):
            idx,cidx=unique_(lookup_(cstart,cstop),char('first'),nargout=2)
            if (idx[1] == 0):
                cidx[1]=[]
            cstop=cstop[cidx]
        _len=length_(_str)
        c2len=length_(comment_end)
        _str=cellslices_(_str,[1,cstop + c2len],[cstart - 1,_len])
        _str=matlabarray([_str[:]])
    if (not isempty_(white_spaces)):
        if (isempty_(strfind_(_format,char('%s')))):
            delimiter_str=unique_([white_spaces,delimiter_str])
        else:
            white_spaces=setdiff_(white_spaces,delimiter_str)
    if (isempty_(delimiter_str)):
        delimiter_str=char(' ')
    if (not isempty_(eol_char)):
        delimiter_str=unique_([delimiter_str,eol_char])
        white_spaces=strrep_(white_spaces,eol_char,char(''))
    ii=numel_(fmt_words)
    while (ii > 0):

        if (ismember_(fmt_words[ii],delimiter_str)(1)):
            fmt_words[ii]=[]
            -- num_words_per_line
        -- ii

    pad_out=0
    if (not isempty_(white_spaces)):
        if ((_str[end()] == 10) and (nargout > 1)):
            pad_out=1
        rxp_wsp=sprintf_(char('[%s]+'),white_spaces)
        _str=regexprep_(_str,rxp_wsp,char(' '))
        if (_str[1] == 32):
            _str=_str[2:end()]
        if (not isempty_(delimiter_str)):
            dlmstr=setdiff_(delimiter_str,char(' '))
            if (not isempty_(dlmstr)):
                rxp_dlmwsp=sprintf_(char('( [%s] | [%s]|[%s] )'),dlmstr,dlmstr,dlmstr)
                _str=regexprep_(_str,rxp_dlmwsp,delimiter_str[1])
        if (not isempty_(eol_char)):
            _str=strrep_(_str,[eol_char,char(' ')],eol_char)
            _str=strrep_(_str,[char(' '),eol_char],eol_char)
    words=split_by_(_str,delimiter_str,mult_dlms_s1,eol_char)
    if (not isempty_(white_spaces)):
        words=strtrim_(words)
    num_words=numel_(words)
    num_lines=ceil_(num_words / num_words_per_line)
    if (not isempty_(empty_str)):
        for ii in arange_(1,numel_(empty_str)).reshape(-1):
            idz=strncmp_(empty_str[ii],words,length_(empty_str[ii]))
            words[idz]=[char('')]
    idf=cellfun_(char('isempty'),strfind_(fmt_words,char('%')))
    idg=not cellfun_(char('isempty'),regexp_(fmt_words,char('%\\*?\\d')))
    idy=find_(idf or idg)
    idn=not cellfun_(char('isempty'),regexp_(fmt_words,char('%[dnfu]')))
    if (not isempty_(idy)):
        try:
            iwrd=1
            iwrdp=0
            iwrdl=length_(words[1])
            fwptr=zeros_(1,numel_(fmt_words))
            ii=1
            while (ii <= numel_(fmt_words)):

                nxt_wrd=0
                fwptr[ii]=iwrd
                if (idf[ii]):
                    if (isempty_(strfind_(fmt_words[ii],words[iwrd]))):
                        nxt_wrd=1
                    else:
                        iwrdp += length_(fmt_words[ii])
                        if (iwrdp > iwrdl):
                            warning_(char("strread: literal '%s' (fmt spec # %d) does not match data"),fmt_words[ii],ii)
                            nxt_wrd=1
                        else:
                            if (iwrdp == iwrdl):
                                nxt_wrd=1
                else:
                    if (idg[ii]):
                        sw=regexp_(fmt_words[ii],char('\\d'),char('once'))
                        ew=regexp_(fmt_words[ii],char('[nfuds]')) - 1
                        iwrdp += floor_(str2double_(fmt_words[ii](arange_(sw,ew))))
                        if (iwrdp > iwrdl):
                            warning_(char("strread: field width '%s' (fmt spec # %d) extends beyond actual word limit"),fmt_words[ii],ii)
                            nxt_wrd=1
                        else:
                            if (iwrdp == iwrdl):
                                nxt_wrd=1
                    else:
                        if (ii < numel_(fmt_words) and idf[ii + 1]):
                            if (not index_(words[iwrd](arange_(iwrdp + 1,end())),fmt_words[ii + 1])):
                                nxt_wrd=1
                            else:
                                iwrdp += index_(words[iwrd](arange_(iwrdp + 1,end())),fmt_words[ii + 1]) - 1
                        else:
                            if (iwrdp <= iwrdl):
                                nxt_wrd=1
                if (nxt_wrd):
                    ++ iwrd
                    iwrdp=0
                    if (iwrd > numel_(words)):
                        ii=numel_(fmt_words)
                    else:
                        if (ii < numel_(fmt_words) and iwrd <= numel_(words)):
                            iwrdl=length_(words[iwrd])
                ++ ii

            words_period=max_(iwrd - 1,1)
            num_lines=ceil_(num_words / words_period)
            num_words_padded=num_lines * words_period - num_words
            if (num_words_padded):
                words=matlabarray([[words.T],[cell_(num_words_padded,1)]])
            words=reshape_(words,words_period,num_lines)
            icol=1
            ii=1
            while (ii <= num_words_per_line):

                if ((idf[ii] or idg[ii]) and (rows_(words) < num_words_per_line)):
                    if (idf[ii]):
                        s=strfind_(words[icol,1],fmt_words[ii])
                        if (isempty_(s[:])):
                            error_(char("strread: Literal '%s' not found in column %d"),fmt_words[ii],icol)
                        s=s[:](1)
                        e=s[1] + length_(fmt_words[ii]) - 1
                    if (not strcmp_(fmt_words[ii],words[icol,1])):
                        words[icol + 1:end() + 1,:]=words[icol:end(),:]
                        jptr=find_(not cellfun_(char('isempty'),words[icol,:]))
                        if (not idg[ii] and not isempty_(s) and s[1] == 1):
                            jptr=find_(cellfun_(char('length'),words[icol + 1,jptr],char('UniformOutput'),false) > e[1])
                            words[icol + 1,:]=[char('')]
                            words[icol + 1,jptr]=cellfun_(lambda x: substr_(x,e[1] + 1,length_(x) - e[1]),words[icol,jptr],char('UniformOutput'),false)
                            words[icol,jptr]=fmt_words[ii]
                            fwptr=matlabarray([fwptr[1:ii],(++ fwptr(arange_(ii + 1,end())))])
                        else:
                            if (not idg[ii] and not isempty_(strfind_(fmt_words[ii - 1],char('%s')))):
                                warning_(char("strread: ambiguous '%s' specifier next to literal in column %d"),icol)
                            else:
                                if (idg[ii]):
                                    sw=regexp_(fmt_words[ii],char('\\d'),char('once'))
                                    ew=regexp_(fmt_words[ii],char('[nfuds]')) - 1
                                    wdth=floor_(str2double_(fmt_words[ii](arange_(sw,ew))))
                                    words[icol + 1,jptr]=cellfun_(lambda x: x[wdth + 1:end()],words[icol,jptr],char('UniformOutput'),false)
                                    if (isempty_([words[icol + 1,:][:]])):
                                        words[icol + 1,:]=[]
                                    else:
                                        words[icol,jptr]=strtrunc_(words[icol,jptr],wdth)
                                        fwptr=matlabarray([fwptr[1:ii],(++ fwptr(arange_(ii + 1,end())))])
                                else:
                                    clear_(char('wrds'))
                                    wrds[1:2:2 * numel_(words[icol,jptr])]=strrep_(words[icol,jptr],fmt_words[ii],[char_(255),char_(254)])
                                    wrds[2:2:2 * numel_(words[icol,jptr]) - 1]=char_(255)
                                    wrds=ostrsplit_([wrds[:]],char_(255))
                                    words[icol,jptr]=wrds[find_(cellfun_(char('isempty'),strfind_(wrds,char_(254))))]
                                    wrds[find_(cellfun_(char('isempty'),strfind_(wrds,char_(254))))]=char_(255)
                                    words[icol + 1,jptr]=ostrsplit_(strrep_([wrds[2:end()]],char_(254),fmt_words[ii]),char_(255))
                                    -- ii
                                    fwptr=matlabarray([fwptr[1:ii],(++ fwptr(arange_(ii + 1,end())))])
                else:
                    if (ii < num_words_per_line):
                        if (fwptr[ii] == fwptr[ii + 1]):
                            -- icol
                ++ ii
                ++ icol

            words=reshape_(words,1,numel_(words))(arange_(1,end() - num_words_padded))
        finally:
            pass
    k=1
    for m in arange_(1,num_words_per_line).reshape(-1):
        try:
            if (format_repeat_count < 0):
                data=words[m:num_words_per_line:end()]
            else:
                if (format_repeat_count == 0):
                    data=[]
                else:
                    lastline=min_(num_words_per_line * format_repeat_count + m - 1,numel_(words))
                    data=words[m:num_words_per_line:lastline]
            if char('%s') == (fmt_words[m](arange_(1,min____(2,length____(fmt_words[m]))))):
                if (pad_out):
                    data[end() + 1:num_lines]=[char('')]
                varargout[k]=data.T
                k
            else:
                if [char('%d'),char('%u'),char('%f'),char('%n')] == (fmt_words[m](arange_(1,min____(2,length____(fmt_words[m]))))):
                    n=cellfun_(char('isempty'),data)
                    data=str2double_(data)
                    if (not isempty_(regexp_(fmt_words[m],char('%[du]')))):
                        data=int32_(data)
                    data[n]=numeric_fill_value
                    if (pad_out):
                        data[end() + 1:num_lines]=numeric_fill_value
                    varargout[k]=data.T
                    k
                else:
                    if [char('%0'),char('%1'),char('%2'),char('%3'),char('%4'),char('%5'),char('%6'),char('%7'),char('%8'),char('%9')] == (fmt_words[m](arange_(1,min____(2,length____(fmt_words[m]))))):
                        sw=regexp_(fmt_words[m],char('\\d'),char('once'))
                        ew=regexp_(fmt_words[m],char('[nfudsq]')) - 1
                        nfmt=ostrsplit_(fmt_words[m](arange_(2,ew)),char('.'))
                        swidth=str2double_(nfmt[1])
                        if [char('d'),char('u'),char('f'),char('n')] == (fmt_words[m](ew + 1)):
                            n=cellfun_(char('isempty'),data)
                            data=str2double_(strtrunc_(data,swidth))
                            data[n]=numeric_fill_value
                            if (pad_out):
                                data[end() + 1:num_lines]=numeric_fill_value
                            if (numel_(nfmt) > 1):
                                sprec=str2double_(nfmt[2])
                                data=10 ** - sprec * round_(10 ** sprec * data)
                            else:
                                if (not isempty_(regexp_(fmt_words[m],char('[du]')))):
                                    data=int32_(data)
                            varargout[k]=data.T
                            k
                        else:
                            if char('s') == (fmt_words[m](ew + 1)):
                                if (pad_out):
                                    data[end() + 1:num_lines]=[char('')]
                                varargout[k]=strtrunc_(data,swidth).T
                                k
                    else:
                        if [char('%*'),char('%*s')] == (fmt_words[m](arange_(1,min____(2,length____(fmt_words[m]))))):
                            pass
                        else:
                            n=find_(not cellfun_(char('isempty'),data))
                            if (numel_(unique_(data[n])) > 1 or not strcmpi_(unique_(data),fmt_words[m])):
                                error_(char('strread: FORMAT does not match data'))
        finally:
            pass
    return varargout
def split_by_(text=None,sep=None,mult_dlms_s1=None,eol_char=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[text,sep,mult_dlms_s1,eol_char].count(None)+len(args)

    if (mult_dlms_s1):
        mult_dlms_s1=copy_(true)
        enchr=char(' ')
        if (index_(sep,eol_char)):
            enchr=char_(255)
        text=strrep_(text,eol_char,[enchr,eol_char,enchr])
    else:
        mult_dlms_s1=copy_(false)
    out=ostrsplit_(text,sep,mult_dlms_s1)
    if (index_(sep,eol_char)):
        out=strrep_(out,char_(255),char(''))
    if (not isempty_(out) and any_(sep == text[end()])):
        out[end()]=[]
    out[cellfun_(char('isempty'),out)]=[char('')]
    return out
def is_valid_file_id_(fid=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[fid].count(None)+len(args)

    retval=copy_(false)
    if (nargin == 1):
        try:
            if (isscalar_(fid)):
                _file,mode,arch=fopen_(fid,nargout=3)
                retval=not isempty_(_file)
        finally:
            pass
    else:
        print_usage_()
    return retval
def fileread_(filename=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[filename].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not ischar_(filename)):
        error_(char('fileread: FILENAME argument must be a string'))
    fid=fopen_(filename,char('r'))
    if (fid < 0):
        error_(char('fileread: cannot open file'))
    try:
        _str=(fread_(fid,char('*char'))).T
    finally:
        fclose_(fid)
    return _str
def beep_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin != 0):
        print_usage_()
    puts_(char('\x07'))
    return
def dlmwrite_(file=None,M=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[_file,M].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    delim=char(',')
    r=c=0
    newline=char('\n')
    if (ischar_(M)):
        precision=char('%c')
    else:
        precision=char('%.16g')
    opentype=char('wt')
    i=0
    while (i < length_(varargin)):

        i
        if (strcmpi_(varargin[i],char('delimiter'))):
            delim=varargin[++ i]
        else:
            if (strcmpi_(varargin[i],char('newline'))):
                newline=varargin[++ i]
                if (strcmpi_(newline,char('unix'))):
                    newline=char('\n')
                else:
                    if (strcmpi_(newline,char('pc'))):
                        newline=char('\r\n')
                    else:
                        if (strcmpi_(newline,char('mac'))):
                            newline=char('\r')
            else:
                if (strcmpi_(varargin[i],char('roffset'))):
                    r=varargin[++ i]
                else:
                    if (strcmpi_(varargin[i],char('coffset'))):
                        c=varargin[++ i]
                    else:
                        if (strcmpi_(varargin[i],char('precision'))):
                            precision=varargin[++ i]
                            if (not strcmpi_(class_(precision),char('char'))):
                                precision=sprintf_(char('%%.%gg'),precision)
                        else:
                            if (strcmpi_(varargin[i],char('-append'))):
                                opentype=char('at')
                            else:
                                if (strcmpi_(varargin[i],char('append'))):
                                    i
                                    if (strcmpi_(varargin[i],char('on'))):
                                        opentype=char('at')
                                    else:
                                        if (strcmpi_(varargin[i],char('off'))):
                                            opentype=char('wt')
                                        else:
                                            error_(char('dlmwrite: append must be "on" or "off"'))
                                else:
                                    if (i == 1):
                                        delim=varargin[i]
                                    else:
                                        if (i == 2):
                                            r=varargin[i]
                                        else:
                                            if (i == 3):
                                                c=varargin[i]
                                            else:
                                                print_usage_()

    if (strcmp_(delim,char('\\t'))):
        delim=char('\t')
    if (ischar_(_file)):
        fid,msg=fopen_(_file,opentype,nargout=2)
    else:
        if (isscalar_(_file) and isnumeric_(_file)):
            fid,msg=deal_(_file,char('invalid file number'),nargout=2)
        else:
            error_(char('dlmwrite: FILE must be a filename string or numeric FID'))
    if (fid < 0):
        error_([char('dlmwrite: '),msg])
    else:
        if (r > 0):
            fprintf_(fid,char('%s'),repmat_([repmat_(delim,1,c + columns_(M) - 1),newline],1,r))
        if (iscomplex_(M)):
            cprecision=regexprep_(precision,char('^%([-\\d.])'),char('%+$1'))
            template=matlabarray([precision,cprecision,char('i'),repmat_([delim,precision,cprecision,char('i')],1,columns_(M) - 1),newline])
        else:
            template=matlabarray([precision,repmat_([delim,precision],1,columns_(M) - 1),newline])
        if (c > 0):
            template=matlabarray([repmat_(delim,1,c),template])
        if (iscomplex_(M)):
            M=M.T
            b=zeros_(2 * rows_(M),columns_(M))
            b[1:2:end(),:]=real_(M)
            b[2:2:end(),:]=imag_(M)
            fprintf_(fid,template,b)
        else:
            fprintf_(fid,template,M.T)
        if (not isscalar_(_file)):
            fclose_(fid)
    return
def textscan_(fid=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[fid,_format].count(None)+len(args)

    BUFLENGTH=4096
    emptfmt=0
    if (nargin < 1):
        print_usage_()
    if (isempty_(_format)):
        emptfmt=1
        _format=char('%f')
    if (not ischar_(_format)):
        error_(char('textscan: FORMAT must be a string'))
    num_fields=numel_(strfind_(_format,char('%'))) - numel_(strfind_(_format,char('%*')))
    C=cell_(1,num_fields)
    if (not (isa_(fid,char('double')) and fid > 0) and not ischar_(fid)):
        error_(char('textscan: first argument must be a file id or character string'))
    args=copy_(varargin)
    if (nargin > 2 and isnumeric_(args[1])):
        nlines=args[1]
    else:
        nlines=copy_(Inf)
    if (nlines < 1):
        printf_(char('textscan: N = 0, no data read\n'))
        return C,position
    if (not any_(strcmpi_(args,char('emptyvalue')))):
        args[end() + 1:end() + 2]=[char('emptyvalue'),NaN]
    ipos=find_(strcmpi_(args,char('whitespace')))
    if (isempty_(ipos)):
        args[end() + 1:end() + 2]=[char('whitespace'),char(' \x08\t')]
        whitespace=char(' \x08\t')
    else:
        has_str_fmt=regexp_(_format,char('%[*]?\\d*s'),char('once'))
        if (not (isempty_(args[ipos + 1]) and has_str_fmt)):
            args[ipos + 1]=unique_([char(' '),args[ipos + 1]])
        whitespace=args[ipos + 1]
    if (not any_(strcmpi_(args,char('delimiter')))):
        args[end() + 1:end() + 2]=[char('delimiter'),char('')]
        delimiter=char('')
    else:
        delimiter=args[find_(strcmpi_(args,char('delimiter'))) + 1]
    collop=copy_(false)
    ipos=find_(strcmpi_(args,char('collectoutput')))
    if (not isempty_(ipos)):
        if (isscalar_(args[ipos + 1]) and (islogical_(args[ipos + 1]) or isnumeric_(args[ipos + 1]))):
            collop=args[ipos + 1]
        else:
            warning_(char('textscan: illegal value for CollectOutput parameter - ignored'))
        args[ipos:ipos + 1]=[]
    if (any_(strcmpi_(args,char('returnonerror')))):
        warning_(char('textscan: ReturnOnError is not fully implemented'))
    else:
        args[end() + 1:end() + 2]=[char('returnonerror'),1]
    headerlines=find_(strcmpi_(args,char('headerlines')),1)
    if (not isempty_(headerlines)):
        if (ischar_(fid)):
            warning_(char("textscan: 'headerlines' ignored when reading from strings"))
    if (ischar_(fid)):
        if (nargout == 2):
            error_(char('textscan: cannot provide position information for character input'))
        _str=copy_(fid)
    else:
        st_pos=ftell_(fid)
        if (not isempty_(headerlines)):
            if (headerlines == numel_(args) or not isnumeric_(args[headerlines + 1])):
                error_(char("Missing or illegal value for 'headerlines'"))
            args[headerlines + 1]=round_(args[headerlines + 1])
            if (args[headerlines + 1] > 0):
                fskipl_(fid,args[headerlines + 1])
                args[headerlines:headerlines + 1]=[]
                st_pos=ftell_(fid)
            else:
                if (args[headerlines + 1] < 0):
                    warning_(char('textscan.m: negative headerline value ignored'))
        _str,count=fscanf_(fid,char('%c'),BUFLENGTH,nargout=2)
    if (isempty_(_str)):
        warning_(char('textscan: no data read'))
        return C,position
    endofline=find_(strcmpi_(args,char('endofline')),1)
    if (not isempty_(endofline)):
        if (ischar_(args[endofline + 1])):
            eol_char=args[endofline + 1]
            if (not any_(strcmp_(eol_char,[char(''),char('\n'),char('\r'),char('\r\n')]))):
                error_(char('textscan: illegal EndOfLine character value specified'))
        else:
            error_(char('textscan: character value required for EndOfLine'))
    else:
        if (not ischar_(fid)):
            eol_srch_len=min_(length_(_str),BUFLENGTH)
            if (not isempty_(strfind_(_str[1:eol_srch_len],char('\r\n')))):
                eol_char=char('\r\n')
            else:
                if (not isempty_(strfind_(_str[1:eol_srch_len],char('\r')))):
                    eol_char=char('\r')
                else:
                    eol_char=char('\n')
        else:
            eol_char=char('\n')
        args[end() + 1:end() + 2]=[char('endofline'),eol_char]
    if (not ischar_(fid)):
        if (isfinite_(nlines) and (nlines >= 0)):
            l_eol_char=length_(eol_char)
            eoi=findstr_(_str,eol_char)
            n_eoi=length_(eoi)
            nblks=0
            while (n_eoi < nlines and count == BUFLENGTH):

                nstr,count=fscanf_(fid,char('%c'),BUFLENGTH,nargout=2)
                if (count > 0):
                    if (l_eol_char > 1):
                        _str=matlabarray([_str[end() - length_(eol_char) + 2:end()],nstr])
                    else:
                        _str=copy_(nstr)
                    eoi=findstr_(_str,eol_char)
                    n_eoi += numel_(eoi)
                    ++ nblks

            if (isempty_(eoi)):
                printf_(char('textscan: format repeat count specified but no endofline found\n'))
                data_size=nblks * BUFLENGTH + count
            else:
                data_size=(nblks * BUFLENGTH) + eoi[end() + min_(nlines,n_eoi) - n_eoi] + l_eol_char - 1
            fseek_(fid,st_pos,char('bof'))
            _str=fscanf_(fid,char('%c'),data_size)
        else:
            fseek_(fid,st_pos,char('bof'))
            _str=fread_(fid,char('char=>char')).T
    eol_at_end=strcmp_(_str[end() - length_(eol_char) + 1:end()],eol_char)
    if (collop or emptfmt):
        if (not eol_at_end):
            _str[end() + 1:end() + length_(eol_char)]=eol_char
    else:
        if (eol_at_end):
            _str[end() - length_(eol_char) + 1:end()]=char('')
            if (isempty_(_str)):
                return C,position
    C=cell_(1,num_fields)
    C[:]=strread_(_str,_format,args[:])
    if (emptfmt):
        eoi=index_(_str,eol_char)
        if (eoi):
            ncols=countcols_(C,_str[1:eoi - 1],delimiter,whitespace)
            pad=mod_(numel_(C[1]),ncols)
            if (pad):
                C[1]=[[C[1]],[NaN_(ncols - pad,1)]]
            ipos=find_(strcmpi_(args,char('emptyvalue')))
            if (ipos):
                C[1][find_(isnan_(C[1]))]=args[ipos + 1]
            nrows=floor_(numel_(C[1]) / ncols)
            C[1]=reshape_(C[1],ncols,numel_(C[1]) / ncols).T
            for ii in arange_(2,ncols).reshape(-1):
                C[ii]=C[1](arange_(),ii)
            C[1]=C[1](arange_(),1)
    if (collop):
        C=colloutp_(C)
    if (nargout == 2):
        position=ftell_(fid)
    return C,position
def countcols_(C=None,str=None,dlm=None,wsp=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[C,_str,dlm,wsp].count(None)+len(args)

    if (isempty_(dlm)):
        _str=regexprep_(_str,sprintf_(char('[%s]'),wsp),char(' '))
        _str=strtrim_(_str)
        ncols=numel_(strfind_(_str,char(' '))) + 1
    else:
        ncols=numel_(regexp_(_str,sprintf_(char('[%s]'),dlm))) + 1
    return ncols
def colloutp_(C=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[C].count(None)+len(args)

    ii=numel_(C)
    while (ii > 1):

        clss1=class_(C[ii])
        jj=copy_(ii)
        while (jj > 1 and strcmp_(clss1,class_(C[jj - 1]))):

            -- jj

        if (jj < ii):
            C[jj]=[C[jj:ii]]
            C[jj + 1:ii]=[]
            ii=jj - 1
        else:
            -- ii

    return C
def ezcontourf_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    htmp,needusage=__ezplot___(char('contourf'),varargin[:],nargout=2)
    if (needusage):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def fill_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('fill'),varargin[:],nargout=2)
    hlist=matlabarray([])
    iargs=__find_patches___(varargin[:])
    opts=[]
    if (numel_(varargin) > iargs[end()] + 2):
        opts=varargin[iargs[end()] + 3:end()]
    if (not all_(cellfun_(lambda x: iscolorspec_(x),varargin[iargs + 2]))):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        old_nxtplt=get_(hax,char('nextplot'))
        try:
            set_(hax,char('nextplot'),char('add'))
            for i in arange_(1,length_(iargs)).reshape(-1):
                cdata=varargin[iargs[i] + 2]
                if (isnumeric_(cdata) and isrow_(cdata)):
                    popt=matlabarray([char('facecolor'),char('flat'),opts])
                else:
                    popt=copy_(opts)
                htmp,fail=__patch___(hax,varargin[iargs[i] + (arange_(0,1))],cdata,popt[:],nargout=2)
                if (fail):
                    print_usage_()
                hlist[end() + 1,1]=htmp
        finally:
            if (strcmp_(old_nxtplt,char('replace'))):
                set_(hax,char('nextplot'),old_nxtplt)
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(hlist)
    return h
def __find_patches___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    iargs=arange_(1,nargin,3)
    optidx=find_(not cellfun_(isnumeric,varargin[iargs]),1)
    iargs[optidx:end()]=[]
    return iargs
def iscolorspec_(arg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[arg].count(None)+len(args)

    retval=copy_(false)
    if (ischar_(arg)):
        colors=[char('y'),char('yellow'),char('r'),char('red'),char('m'),char('magenta'),char('c'),char('cyan'),char('g'),char('green'),char('b'),char('blue'),char('w'),char('white'),char('k'),char('black')]
        if (any_(strcmpi_(arg,colors))):
            retval=copy_(true)
    else:
        if (isnumeric_(arg)):
            retval=copy_(true)
    return retval
def surfnorm_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('surfnorm'),varargin[:],nargout=3)
    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (nargin == 1):
        z=varargin[1]
        x,y=meshgrid_(arange_(1,rows_(z)),arange_(1,columns_(z)),nargout=2)
        ioff=2
    else:
        x=varargin[1]
        y=varargin[2]
        z=varargin[3]
        ioff=4
    if (not ismatrix_(z) or isvector_(z) or isscalar_(z)):
        error_(char('surfnorm: Z argument must be a matrix'))
    if (not size_equal_(x,y,z)):
        error_(char('surfnorm: X, Y, and Z must have the same dimensions'))
    xx=matlabarray([2.dot(x[:,1]) - x[:,2],x,2.dot(x[:,end()]) - x[:,end() - 1]])
    xx=matlabarray([[2.dot(xx[1,:]) - xx[2,:]],[xx],[2.dot(xx[end(),:]) - xx[end() - 1,:]]])
    yy=matlabarray([2.dot(y[:,1]) - y[:,2],y,2.dot(y[:,end()]) - y[:,end() - 1]])
    yy=matlabarray([[2.dot(yy[1,:]) - yy[2,:]],[yy],[2.dot(yy[end(),:]) - yy[end() - 1,:]]])
    zz=matlabarray([2.dot(z[:,1]) - z[:,2],z,2.dot(z[:,end()]) - z[:,end() - 1]])
    zz=matlabarray([[2.dot(zz[1,:]) - zz[2,:]],[zz],[2.dot(zz[end(),:]) - zz[end() - 1,:]]])
    u.x=xx[1:end() - 1,1:end() - 1] - xx[2:end(),2:end()]
    u.y=yy[1:end() - 1,1:end() - 1] - yy[2:end(),2:end()]
    u.z=zz[1:end() - 1,1:end() - 1] - zz[2:end(),2:end()]
    v.x=xx[1:end() - 1,2:end()] - xx[2:end(),1:end() - 1]
    v.y=yy[1:end() - 1,2:end()] - yy[2:end(),1:end() - 1]
    v.z=zz[1:end() - 1,2:end()] - zz[2:end(),1:end() - 1]
    c=cross_([u.x(arange_()),u.y(arange_()),u.z(arange_())],[v.x(arange_()),v.y(arange_()),v.z(arange_())])
    w.x=reshape_(c[:,1],size_(u.x))
    w.y=reshape_(c[:,2],size_(u.y))
    w.z=reshape_(c[:,3],size_(u.z))
    nx=(w.x(arange_(1,end() - 1),arange_(1,end() - 1)) + w.x(arange_(1,end() - 1),arange_(2,end())) + w.x(arange_(2,end()),arange_(1,end() - 1)) + w.x(arange_(2,end()),arange_(2,end()))) / 4
    ny=(w.y(arange_(1,end() - 1),arange_(1,end() - 1)) + w.y(arange_(1,end() - 1),arange_(2,end())) + w.y(arange_(2,end()),arange_(1,end() - 1)) + w.y(arange_(2,end()),arange_(2,end()))) / 4
    nz=(w.z(arange_(1,end() - 1),arange_(1,end() - 1)) + w.z(arange_(1,end() - 1),arange_(2,end())) + w.z(arange_(2,end()),arange_(1,end() - 1)) + w.z(arange_(2,end()),arange_(2,end()))) / 4
    _len=sqrt_(nx ** 2 + ny ** 2 + nz ** 2)
    nx=nx / _len
    ny=ny / _len
    nz=nz / _len
    if (nargout == 0):
        oldfig=matlabarray([])
        if (not isempty_(hax)):
            oldfig=get_(0,char('currentfigure'))
        try:
            hax=newplot_(hax)
            surf_(x,y,z,varargin[ioff:end()])
            old_hold_state=get_(hax,char('nextplot'))
            try:
                set_(hax,char('nextplot'),char('add'))
                plot3_([[x[:].T],[x[:].T + nx[:].T],[NaN_(size_(x[:].T))]](arange_()),[[y[:].T],[y[:].T + ny[:].T],[NaN_(size_(y[:].T))]](arange_()),[[z[:].T],[z[:].T + nz[:].T],[NaN_(size_(z[:].T))]](arange_()),varargin[ioff:end()])
            finally:
                set_(hax,char('nextplot'),old_hold_state)
        finally:
            if (not isempty_(oldfig)):
                set_(0,char('currentfigure'),oldfig)
    else:
        Nx=copy_(nx)
        Ny=copy_(ny)
        Nz=copy_(nz)
    return Nx,Ny,Nz
def scatter3_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('scatter3'),varargin[:],nargout=3)
    if (nargin < 2):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=__scatter___(hax,3,char('scatter3'),varargin[:])
        if (not ishold_(hax)):
            set_(hax,char('view'),[- 37.5,30],char('box'),char('off'),char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        retval=copy_(htmp)
    return retval
def meshc_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (not all_(cellfun_(char('isreal'),varargin))):
        error_(char('meshc: X, Y, Z, C arguments must be real'))
    hax,varargin,nargin=__plt_get_axis_arg___(char('meshc'),varargin[:],nargout=3)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=surface_(varargin[:])
        set_(htmp,char('facecolor'),char('w'))
        set_(htmp,char('edgecolor'),char('flat'))
        if (not ishold_()):
            set_(hax,char('view'),[- 37.5,30],char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'),char('xlimmode'),char('manual'),char('ylimmode'),char('manual'))
        drawnow_()
        zmin=get_(hax,char('zlim'))(1)
        __,htmp2=__contour___(hax,zmin,varargin[:],nargout=2)
        htmp=matlabarray([[htmp],[htmp2]])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def fplot_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('fplot'),varargin[:],nargout=3)
    if (nargin < 2 or nargin > 5):
        print_usage_()
    fn=varargin[1]
    limits=varargin[2]
    varargin=varargin[3:end()]
    if (strcmp_(typeinfo_(fn),char('inline function'))):
        fn=vectorize_(fn)
        nam=formula_(fn)
    else:
        if (isa_(fn,char('function_handle'))):
            nam=func2str_(fn)
        else:
            if (all_(isalnum_(fn))):
                nam=copy_(fn)
            else:
                if (ischar_(fn)):
                    fn=vectorize_(inline_(fn))
                    nam=formula_(fn)
                else:
                    error_(char('fplot: FN must be a function handle, inline function, or string'))
    if (iscomplex_(limits) or (numel_(limits) != 2 and numel_(limits) != 4)):
        error_(char('fplot: LIMITS must be a real vector with 2 or 4 elements'))
    n=5
    tol=0.002
    fmt=char('')
    for i in arange_(1,numel_(varargin)).reshape(-1):
        arg=varargin[i]
        if (ischar_(arg)):
            fmt=copy_(arg)
        else:
            if (isnumeric_(arg) and isscalar_(arg) and arg > 0):
                if (arg == fix_(arg)):
                    n=copy_(arg)
                else:
                    tol=copy_(arg)
            else:
                error_(char('fplot: bad input in position %d'),i + 2)
    if (n != 5):
        x0=linspace_(limits[1],limits[2],n / 2 + 1).T
        y0=feval_(fn,x0)
        x=linspace_(limits[1],limits[2],n).T
        y=feval_(fn,x)
    else:
        x0=linspace_(limits[1],limits[2],5).T
        y0=feval_(fn,x0)
        n=8
        x=linspace_(limits[1],limits[2],n).T
        y=feval_(fn,x)
    if (rows_(x0) != rows_(y0)):
        y0=repmat_(y0,size_(x0))
        y=repmat_(y,size_(x))
    err0=copy_(Inf)
    while (n < 2 ** 18):

        yi=interp1_(x0,y0,x,char('linear'))
        err=0.5 * max_(abs_((yi - y) / (yi + y))(arange_()))
        if (err < tol or abs_(err - err0) < tol / 2):
            break
        x0=copy_(x)
        y0=copy_(y)
        err0=copy_(err)
        n=2 * (n - 1) + 1
        x=linspace_(limits[1],limits[2],n).T
        y=feval_(fn,x)

    if (nargout == 2):
        X=copy_(x)
        Y=copy_(y)
    else:
        if (isempty_(hax)):
            hax=gca_()
        plot_(hax,x,y,fmt)
        axis_(hax,limits)
        if (isvector_(y)):
            legend_(hax,nam)
        else:
            for i in arange_(1,columns_(y)).reshape(-1):
                nams[i]=sprintf_(char('%s(:,%i)'),nam,i)
            legend_(hax,nams[:])
    return X,Y
def contour_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('contour'),varargin[:],nargout=2)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        ctmp,htmp=__contour___(hax,char('none'),varargin[:],nargout=2)
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        c=copy_(ctmp)
        h=copy_(htmp)
    return c,h
def semilogyerr_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('semilogyerr'),varargin[:],nargout=2)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        set_(hax,char('yscale'),char('log'))
        if (not ishold_(hax)):
            set_(hax,char('yminortick'),char('on'))
        htmp=__errcomm___(char('semilogyerr'),hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def loglog_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargs=__plt_get_axis_arg___(char('loglog'),varargin[:],nargout=3)
    if (nargs < 1):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        set_(hax,char('xscale'),char('log'),char('yscale'),char('log'))
        if (not ishold_(hax)):
            set_(hax,char('xminortick'),char('on'),char('yminortick'),char('on'))
        htmp=__plt___(char('loglog'),hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def semilogy_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargs=__plt_get_axis_arg___(char('semilogy'),varargin[:],nargout=3)
    if (nargs < 1):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        set_(hax,char('yscale'),char('log'))
        if (not ishold_(hax)):
            set_(hax,char('yminortick'),char('on'))
        htmp=__plt___(char('semilogy'),hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def loglogerr_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('loglogerr'),varargin[:],nargout=2)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        set_(hax,char('xscale'),char('log'),char('yscale'),char('log'))
        if (not ishold_(hax)):
            set_(hax,char('xminortick'),char('on'),char('yminortick'),char('on'))
        htmp=__errcomm___(char('loglogerr'),hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def slice_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargs=__plt_get_axis_arg___(char('slice'),varargin[:],nargout=3)
    method=char('linear')
    if (ischar_(varargin[end()])):
        method=varargin[end()]
        nargs -= 1
    if (nargs == 4):
        v=varargin[1]
        if (ndims_(v) != 3):
            error_(char('slice: V must be a 3-dimensional array of values'))
        nx,ny,nz=size_(v,nargout=3)
        x,y,z=meshgrid_(arange_(1,nx),arange_(1,ny),arange_(1,nz),nargout=3)
        sx=varargin[2]
        sy=varargin[3]
        sz=varargin[4]
    else:
        if (nargs == 7):
            v=varargin[4]
            if (ndims_(v) != 3):
                error_(char('slice: V must be a 3-dimensional array of values'))
            x=varargin[1]
            y=varargin[2]
            z=varargin[3]
            if (isvector_(x) and isvector_(y) and isvector_(z)):
                x,y,z=meshgrid_(x,y,z,nargout=3)
            else:
                if (ndims_(x) == 3 and size_equal_(x,y,z)):
                    pass
                else:
                    error_(char('slice: X, Y, Z size mismatch'))
            sx=varargin[5]
            sy=varargin[6]
            sz=varargin[7]
        else:
            print_usage_()
    if (any_([isvector_(sx),isvector_(sy),isvector_(sz)])):
        have_sval=copy_(true)
    else:
        if (ndims_(sx) == 2 and size_equal_(sx,sy,sz)):
            have_sval=copy_(false)
        else:
            error_(char('slice: dimensional mismatch for (XI, YI, ZI) or (SX, SY, SZ)'))
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        sidx=1
        minv=min_(v[:])
        maxv=max_(v[:])
        set_(hax,char('clim'),[minv,maxv])
        if (have_sval):
            ns=length_(sx) + length_(sy) + length_(sz)
            hs=zeros_(ns,1)
            ny,nx,nz=size_(v,nargout=3)
            if (length_(sz) > 0):
                for i in arange_(1,length_(sz)).reshape(-1):
                    xi,yi,zi=meshgrid_(squeeze_(x[1,:,1]),squeeze_(y[:,1,1]),sz[i],nargout=3)
                    vz=squeeze_(interp3_(x,y,z,v,xi,yi,zi,method))
                    htmp[sidx]=surface_(xi,yi,sz[i] * ones_(size_(yi)),vz)
            if (length_(sy) > 0):
                for i in arange_(length_(sy),1,- 1).reshape(-1):
                    xi,yi,zi=meshgrid_(squeeze_(x[1,:,1]),sy[i],squeeze_(z[1,1,:]),nargout=3)
                    vy=squeeze_(interp3_(x,y,z,v,xi,yi,zi,method))
                    htmp[sidx]=surface_(squeeze_(xi),squeeze_(sy[i] * ones_(size_(zi))),squeeze_(zi),vy)
            if (length_(sx) > 0):
                for i in arange_(length_(sx),1,- 1).reshape(-1):
                    xi,yi,zi=meshgrid_(sx[i],squeeze_(y[:,1,1]),squeeze_(z[1,1,:]),nargout=3)
                    vx=squeeze_(interp3_(x,y,z,v,xi,yi,zi,method))
                    htmp[sidx]=surface_(squeeze_(sx[i] * ones_(size_(zi))),squeeze_(yi),squeeze_(zi),vx)
        else:
            vi=interp3_(x,y,z,v,sx,sy,sz)
            htmp=surface_(sx,sy,sz,vi)
        if (not ishold_()):
            set_(hax,char('view'),[- 37.5,30.0],char('box'),char('off'),char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def ezplot3_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    htmp,needusage=__ezplot___(char('plot3'),varargin[:],nargout=2)
    if (needusage):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def surface_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('surface'),varargin[:],nargout=2)
    if (isempty_(hax)):
        hax=gca_()
    else:
        hax=hax[1]
    htmp,bad_usage=__surface___(hax,varargin[:],nargout=2)
    if (bad_usage):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def __surface___(ax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[ax].count(None)+len(args)

    h=0
    bad_usage=copy_(false)
    firststring=copy_(nargin)
    for i in arange_(1,(nargin - 1)).reshape(-1):
        if (ischar_(varargin[i])):
            firststring=copy_(i)
            break
    if (firststring > 5):
        bad_usage=copy_(true)
        return h,bad_usage
    else:
        if (firststring == 5):
            x=varargin[1]
            y=varargin[2]
            z=varargin[3]
            c=varargin[4]
            if (iscomplex_(x) or iscomplex_(y) or iscomplex_(z) or iscomplex_(c)):
                error_(char('mesh: X, Y, Z, C arguments must be real'))
            z_nr,z_nc=size_(z,nargout=2)
            c_nr,c_nc,c_np=size_(c,nargout=3)
            if (not (z_nr == c_nr and z_nc == c_nc and (c_np == 1 or c_np == 3))):
                error_(char('surface: Z and C must have the same size'))
            if (isvector_(x) and isvector_(y) and ismatrix_(z)):
                if (rows_(z) == length_(y) and columns_(z) == length_(x)):
                    x=x[:].T
                    y=y[:]
                else:
                    error_(char('surface: rows (Z) must be the same as length (Y) and columns (Z) must be the same as length (X)'))
            else:
                if (ismatrix_(x) and ismatrix_(y) and ismatrix_(z)):
                    if (not size_equal_(x,y,z)):
                        error_(char('surface: X, Y, and Z must have the same dimensions'))
                else:
                    error_(char('surface: X and Y must be vectors and Z must be a matrix'))
        else:
            if (firststring == 4):
                x=varargin[1]
                y=varargin[2]
                z=varargin[3]
                c=copy_(z)
                if (iscomplex_(x) or iscomplex_(y) or iscomplex_(z)):
                    error_(char('mesh: X, Y, Z arguments must be real'))
                if (isvector_(x) and isvector_(y) and ismatrix_(z)):
                    if (rows_(z) == length_(y) and columns_(z) == length_(x)):
                        x=x[:].T
                        y=y[:]
                    else:
                        error_(char('surface: rows (Z) must be the same as length (Y) and columns (Z) must be the same as length (X)'))
                else:
                    if (ismatrix_(x) and ismatrix_(y) and ismatrix_(z)):
                        if (not size_equal_(x,y,z)):
                            error_(char('surface: X, Y, and Z must have the same dimensions'))
                    else:
                        error_(char('surface: X and Y must be vectors and Z must be a matrix'))
            else:
                if (firststring == 3):
                    z=varargin[1]
                    c=varargin[2]
                    if (iscomplex_(z) or iscomplex_(c)):
                        error_(char('mesh: X, C arguments must be real'))
                    if (ismatrix_(z) and not isvector_(z) and not isscalar_(z)):
                        nr,nc=size_(z,nargout=2)
                        x=arange_(1,nc)
                        y=(arange_(1,nr)).T
                    else:
                        error_(char('surface: Z argument must be a matrix'))
                else:
                    if (firststring == 2):
                        z=varargin[1]
                        c=copy_(z)
                        if (iscomplex_(z)):
                            error_(char('mesh: Z argument must be real'))
                        if (ismatrix_(z) and not isvector_(z) and not isscalar_(z)):
                            nr,nc=size_(z,nargout=2)
                            x=arange_(1,nc)
                            y=(arange_(1,nr)).T
                        else:
                            error_(char('surface: Z argument must be a matrix'))
                    else:
                        if (firststring == 1):
                            x=arange_(1,3)
                            y=x.T
                            c=z=eye_(3)
                        else:
                            bad_usage=copy_(true)
                            return h,bad_usage
    if (firststring < nargin):
        other_args=varargin[firststring:end()]
    else:
        other_args=[]
    h=__go_surface___(ax,char('xdata'),x,char('ydata'),y,char('zdata'),z,char('cdata'),c,other_args[:])
    if (not ishold_()):
        set_(ax,char('view'),[0,90],char('box'),char('off'))
    return h,bad_usage
def scatter_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('scatter'),varargin[:],nargout=3)
    if (nargin < 2):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=__scatter___(hax,2,char('scatter'),varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        retval=copy_(htmp)
    return retval
def pie_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('pie'),varargin[:],nargout=3)
    if (nargin < 1):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=__pie___(char('pie'),hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def ezcontour_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    htmp,needusage=__ezplot___(char('contour'),varargin[:],nargout=2)
    if (needusage):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def comet_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('comet'),varargin[:],nargout=3)
    if (nargin == 0):
        print_usage_()
    else:
        if (nargin == 1):
            y=varargin[1]
            x=arange_(1,numel_(y))
            p=0.1
        else:
            if (nargin == 2):
                x=varargin[1]
                y=varargin[2]
                p=0.1
            else:
                if (nargin == 3):
                    x=varargin[1]
                    y=varargin[2]
                    p=varargin[3]
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        limits=matlabarray([min_(x),max_(x),min_(y),max_(y)])
        num=numel_(y)
        dn=round_(num / 10)
        hl=plot_(x[1],y[1],char('color'),char('r'),char('marker'),char('none'),x[1],y[1],char('color'),char('g'),char('marker'),char('none'),x[1],y[1],char('color'),char('b'),char('marker'),char('o'))
        axis_(limits)
        for n in arange_(2,(num + dn)).reshape(-1):
            m=n - dn
            m=max_([m,1])
            k=min_([n,num])
            set_(hl[1],char('xdata'),x[1:m],char('ydata'),y[1:m])
            set_(hl[2],char('xdata'),x[m:k],char('ydata'),y[m:k])
            set_(hl[3],char('xdata'),x[k],char('ydata'),y[k])
            drawnow_()
            pause_(p)
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    return
def surf_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('surf'),varargin[:],nargout=2)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=surface_(varargin[:])
        if (not ishold_(hax)):
            set_(hax,char('view'),[- 37.5,30],char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        retval=copy_(htmp)
    return retval
def colorbar_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hcb,varargin,nargin=__plt_get_axis_arg___(char('colorbar'),varargin[:],nargout=3)
    if (hcb and not strcmp_(get_(hcb,char('tag')),char('colorbar'))):
        ax=copy_(hcb)
        hcb=matlabarray([])
    else:
        ax=matlabarray([])
    loc=char('')
    args=[]
    deleting=copy_(false)
    i=1
    while (i <= nargin):

        arg=varargin[i]
        if (ischar_(arg)):
            if char('peer') == (tolower____(arg)):
                if (i > nargin):
                    error_(char('colorbar: missing axes handle after "peer"'))
                else:
                    ax=varargin[i]
                    if (not isscalar_(ax) and not isaxes_(ax)):
                        error_(char('colorbar: expecting an axes handle following "peer"'))
            else:
                if [char('north'),char('south'),char('east'),char('west'),char('northoutside'),char('southoutside'),char('eastoutside'),char('westoutside')] == (tolower____(arg)):
                    loc=tolower_(arg)
                else:
                    if char('location') == (tolower____(arg)):
                        if (i > nargin):
                            error_(char('colorbar: missing value after "location"'))
                        else:
                            loc=tolower_(varargin[i])
                    else:
                        if [char('delete'),char('hide'),char('off'),char('none')] == (tolower____(arg)):
                            deleting=copy_(true)
                        else:
                            args[end() + 1]=arg
        else:
            args[end() + 1]=arg

    if (not isempty_(hcb)):
        if (deleting):
            delete_(hcb)
            if (nargout > 0):
                h=copy_(hcb)
            return h
        else:
            ax=get_(get_(hcb,char('parent')),char('currrentaxes'))
    if (isempty_(loc)):
        loc=char('eastoutside')
    if (isempty_(ax)):
        ax=gca_()
    showhiddenhandles=get_(0,char('showhiddenhandles'))
    try:
        set_(0,char('showhiddenhandles'),char('on'))
        cax=findobj_(get_(ax,char('parent')),char('tag'),char('colorbar'),char('type'),char('axes'),char('axes'),ax)
        if (not isempty_(cax)):
            delete_(cax)
    finally:
        set_(0,char('showhiddenhandles'),showhiddenhandles)
    if (not deleting):
        set_(ax,char('activepositionproperty'),char('position'))
        obj=get_(ax)
        obj.__cbar_hax__=ax
        position=obj.position
        hpar=get_(ax,char('parent'))
        clen=rows_(get_(hpar,char('colormap')))
        cext=get_(ax,char('clim'))
        cdiff=(cext[2] - cext[1]) / clen / 2
        cmin=cext[1] + cdiff
        cmax=cext[2] - cdiff
        pos,cpos,vertical,mirror=__position_colorbox___(loc,obj,ancestor_(ax,char('figure')),nargout=4)
        set_(ax,char('position'),pos)
        cax=__go_axes___(hpar,char('tag'),char('colorbar'),char('handlevisibility'),char('on'),char('activepositionproperty'),char('position'),char('position'),cpos)
        addproperty_(char('location'),cax,char('radio'),char('eastoutside|east|westoutside|west|northoutside|north|southoutside|south'),loc)
        addproperty_(char('axes'),cax,char('handle'),ax)
        if (vertical):
            hi=image_(cax,char('xdata'),[0,1],char('ydata'),[cmin,cmax],char('cdata'),[arange_(1,clen)].T)
            if (mirror):
                set_(cax,char('xtick'),[],char('xdir'),char('normal'),char('ydir'),char('normal'),char('ylim'),cext,char('ylimmode'),char('manual'),char('yaxislocation'),char('right'),args[:])
            else:
                set_(cax,char('xtick'),[],char('xdir'),char('normal'),char('ydir'),char('normal'),char('ylim'),cext,char('ylimmode'),char('manual'),char('yaxislocation'),char('left'),args[:])
        else:
            hi=image_(cax,char('xdata'),[cmin,cmax],char('ydata'),[0,1],char('cdata'),[arange_(1,clen)])
            if (mirror):
                set_(cax,char('ytick'),[],char('xdir'),char('normal'),char('ydir'),char('normal'),char('xlim'),cext,char('xlimmode'),char('manual'),char('xaxislocation'),char('top'),args[:])
            else:
                set_(cax,char('ytick'),[],char('xdir'),char('normal'),char('ydir'),char('normal'),char('xlim'),cext,char('xlimmode'),char('manual'),char('xaxislocation'),char('bottom'),args[:])
        ctext=text_(0,0,char(''),char('tag'),char('colorbar'),char('visible'),char('off'),char('handlevisibility'),char('off'),char('xliminclude'),char('off'),char('yliminclude'),char('off'),char('zliminclude'),char('off'),char('deletefcn'),[deletecolorbar,cax,obj])
        set_(cax,char('deletefcn'),[resetaxis,ax,obj])
        addlistener_(hpar,char('colormap'),[update_colorbar_cmap,hi,vertical,clen])
        addlistener_(ax,char('clim'),[update_colorbar_clim,hi,vertical])
        addlistener_(ax,char('dataaspectratio'),[update_colorbar_axis,cax,obj])
        addlistener_(ax,char('dataaspectratiomode'),[update_colorbar_axis,cax,obj])
        addlistener_(ax,char('plotboxaspectratio'),[update_colorbar_axis,cax,obj])
        addlistener_(ax,char('plotboxaspectratiomode'),[update_colorbar_axis,cax,obj])
        addlistener_(ax,char('position'),[update_colorbar_axis,cax,obj])
    if (nargout > 0):
        h=copy_(cax)
    return h
def deletecolorbar_(h=None,d=None,hc=None,orig_props=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[h,d,hc,orig_props].count(None)+len(args)

    if (isaxes_(hc) and (isempty_(gcbf_()) or strcmp_(get_(gcbf_(),char('beingdeleted')),char('off')))):
        if (strcmp_(get_(hc,char('beingdeleted')),char('off'))):
            delete_(hc)
        if (not isempty_(ancestor_(h,char('axes'))) and strcmp_(get_(ancestor_(h,char('axes')),char('beingdeleted')),char('off'))):
            ax=ancestor_(h,char('axes'))
            units=get_(ax,char('units'))
            set_(ax,char('units'),orig_props.units)
            set_(ancestor_(h,char('axes')),char('position'),orig_props.position,char('outerposition'),orig_props.outerposition,char('activepositionproperty'),orig_props.activepositionproperty)
            set_(ax,char('units'),units)
    return
def resetaxis_(cax=None,d=None,ax=None,orig_props=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[cax,d,ax,orig_props].count(None)+len(args)

    if (isaxes_(ax)):
        dellistener_(get_(ax,char('parent')),char('colormap'))
        dellistener_(ax,char('clim'))
        dellistener_(ax,char('dataaspectratio'))
        dellistener_(ax,char('dataaspectratiomode'))
        dellistener_(ax,char('plotboxaspectratio'))
        dellistener_(ax,char('plotboxaspectratiomode'))
        dellistener_(ax,char('position'))
        units=get_(ax,char('units'))
        set_(ax,char('units'),orig_props.units)
        set_(ax,char('position'),orig_props.position,char('outerposition'),orig_props.outerposition,char('activepositionproperty'),orig_props.activepositionproperty)
        set_(ax,char('units'),units)
    return
def update_colorbar_clim_(hax=None,d=None,hi=None,vert=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[hax,d,hi,vert].count(None)+len(args)

    if (isaxes_(hax) and (isempty_(gcbf_()) or strcmp_(get_(gcbf_(),char('beingdeleted')),char('off')))):
        clen=rows_(get_(get_(hax,char('parent')),char('colormap')))
        cext=get_(hax,char('clim'))
        cdiff=(cext[2] - cext[1]) / clen / 2
        cmin=cext[1] + cdiff
        cmax=cext[2] - cdiff
        hiax=get_(hi,char('parent'))
        if (vert):
            set_(hi,char('ydata'),[cmin,cmax])
            set_(hiax,char('ylim'),cext)
        else:
            set_(hi,char('xdata'),[cmin,cmax])
            set_(hiax,char('xlim'),cext)
        pos=get_(hiax,char('position'))
        pos[1] += eps
        set_(hiax,char('position'),pos)
        pos[1] -= eps
        set_(hiax,char('position'),pos)
    return
def update_colorbar_cmap_(hf=None,d=None,hi=None,vert=None,init_sz=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[hf,d,hi,vert,init_sz].count(None)+len(args)

    sz=copy_(init_sz)
    if (ishandle_(hf) and strcmp_(get_(hf,char('type')),char('figure')) and (isempty_(gcbf_()) or strcmp_(get_(gcbf_(),char('beingdeleted')),char('off')))):
        clen=rows_(get_(hf,char('colormap')))
        if (clen != sz):
            if (vert):
                set_(hi,char('cdata'),[arange_(1,clen)].T)
            else:
                set_(hi,char('cdata'),[arange_(1,clen)])
            sz=copy_(clen)
            update_colorbar_clim_(get_(hi,char('parent')),d,hi,vert)
    return
def update_colorbar_axis_(h=None,d=None,cax=None,orig_props=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[h,d,cax,orig_props].count(None)+len(args)

    if (isaxes_(cax) and (isempty_(gcbf_()) or strcmp_(get_(gcbf_(),char('beingdeleted')),char('off')))):
        loc=get_(cax,char('location'))
        obj=get_(h)
        obj.__cbar_hax__=h
        obj.position=orig_props.position
        obj.outerposition=orig_props.outerposition
        pos,cpos,vertical,mirror=__position_colorbox___(loc,obj,ancestor_(h,char('figure')),nargout=4)
        if (vertical):
            if (mirror):
                set_(cax,char('xtick'),[],char('xdir'),char('normal'),char('ydir'),char('normal'),char('yaxislocation'),char('right'),char('position'),cpos)
            else:
                set_(cax,char('xtick'),[],char('xdir'),char('normal'),char('ydir'),char('normal'),char('yaxislocation'),char('left'),char('position'),cpos)
        else:
            if (mirror):
                set_(cax,char('ytick'),[],char('xdir'),char('normal'),char('ydir'),char('normal'),char('xaxislocation'),char('top'),char('position'),cpos)
            else:
                set_(cax,char('ytick'),[],char('xdir'),char('normal'),char('ydir'),char('normal'),char('xaxislocation'),char('bottom'),char('position'),cpos)
    return
def __position_colorbox___(cbox=None,obj=None,cf=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[cbox,obj,cf].count(None)+len(args)

    pos=obj.position
    sz=pos[3:4]
    if (strcmp_(obj.plotboxaspectratiomode,char('manual')) or strcmp_(obj.dataaspectratiomode,char('manual'))):
        if (isempty_(strfind_(cbox,char('outside')))):
            scale=1.0
        else:
            scale=0.8
        if (isempty_(strfind_(cbox,char('east'))) and isempty_(strfind_(cbox,char('west')))):
            scale=matlabarray([1,scale])
        else:
            scale=matlabarray([scale,1])
        if (strcmp_(get_(cf,char('__graphics_toolkit__')),char('gnuplot')) and strcmp_(obj.activepositionproperty,char('outerposition'))):
            obj.outerposition=obj.outerposition.dot([1,1,scale])
            off=0.5 * (obj.outerposition(arange_(3,4)) - __actual_axis_position___(obj)(arange_(3,4)))
        else:
            obj.position=obj.position.dot([1,1,scale])
            off=0.5 * (obj.position(arange_(3,4)) - __actual_axis_position___(obj)(arange_(3,4)))
    else:
        off=0.0
    if char('northoutside') == (cbox):
        origin=pos[1:2] + [0.0,0.9].dot(sz) + [1,- 1].dot(off)
        sz=sz.dot([1.0,0.06])
        pos[4]=0.8 * pos[4]
        mirr=copy_(true)
        vertical=copy_(false)
    else:
        if char('north') == (cbox):
            origin=pos[1:2] + [0.05,0.9].dot(sz) + [1,- 1].dot(off)
            sz=sz.dot([1.0,0.06]) * 0.9
            mirr=copy_(false)
            vertical=copy_(false)
        else:
            if char('southoutside') == (cbox):
                origin=pos[1:2] + off
                sz=sz.dot([1.0,0.06])
                pos[2]=pos[2] + pos[4] * 0.2
                pos[4]=0.8 * pos[4]
                mirr=copy_(false)
                vertical=copy_(false)
            else:
                if char('south') == (cbox):
                    origin=pos[1:2] + [0.05,0.05].dot(sz) + off
                    sz=sz.dot([1.0,0.06]) * 0.9
                    mirr=copy_(true)
                    vertical=copy_(false)
                else:
                    if char('eastoutside') == (cbox):
                        origin=pos[1:2] + [0.9,0].dot(sz) + [- 1,1].dot(off)
                        sz=sz.dot([0.06,1.0])
                        pos[3]=0.8 * pos[3]
                        mirr=copy_(true)
                        vertical=copy_(true)
                    else:
                        if char('east') == (cbox):
                            origin=pos[1:2] + [0.9,0.05].dot(sz) + [- 1,1].dot(off)
                            sz=sz.dot([0.06,1.0]) * 0.9
                            mirr=copy_(false)
                            vertical=copy_(true)
                        else:
                            if char('westoutside') == (cbox):
                                origin=pos[1:2] + off
                                sz=sz.dot([0.06,1.0])
                                pos[1]=pos[1] + pos[3] * 0.2
                                pos[3]=0.8 * pos[3]
                                mirr=copy_(false)
                                vertical=copy_(true)
                            else:
                                if char('west') == (cbox):
                                    origin=pos[1:2] + [0.05,0.05].dot(sz) + off
                                    sz=sz.dot([0.06,1.0]).dot(0.9)
                                    mirr=copy_(true)
                                    vertical=copy_(true)
    cpos=matlabarray([origin,sz])
    if (strcmp_(obj.plotboxaspectratiomode,char('manual')) or strcmp_(obj.dataaspectratiomode,char('manual'))):
        obj.position=pos
        actual_pos=__actual_axis_position___(obj)
        if (strfind_(cbox,char('outside'))):
            scale=1.0
        else:
            scale=0.9
        if (sz[1] > sz[2]):
            dx=(1 - scale) * actual_pos[3]
            cpos[1]=actual_pos[1] + dx / 2
            cpos[3]=actual_pos[3] - dx
        else:
            dy=(1 - scale) * actual_pos[4]
            cpos[2]=actual_pos[2] + dy / 2
            cpos[4]=actual_pos[4] - dy
    return pos,cpos,vertical,mirr
def stairs_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('stairs'),varargin[:],nargout=3)
    if (nargin < 1):
        print_usage_()
    if (nargout < 2):
        oldfig=matlabarray([])
        if (not isempty_(hax)):
            oldfig=get_(0,char('currentfigure'))
        try:
            hax=newplot_(hax)
            htmp,xxs,yys=__stairs___(true,varargin[:],nargout=3)
        finally:
            if (not isempty_(oldfig)):
                set_(0,char('currentfigure'),oldfig)
        if (nargout == 1):
            xs=copy_(htmp)
    else:
        __,xs,ys=__stairs___(false,varargin[:],nargout=3)
    return xs,ys
def __stairs___(doplot=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[doplot].count(None)+len(args)

    if (nargin == 2 or ischar_(varargin[2])):
        y=varargin[1]
        varargin[1]=[]
        if (not ismatrix_(y) or ndims_(y) > 2):
            error_(char('stairs: Y must be a numeric 2-D vector or matrix'))
        if (isvector_(y)):
            y=y[:]
        x=arange_(1,rows_(y))
    else:
        x=varargin[1]
        y=varargin[2]
        varargin[1:2]=[]
        if (not ismatrix_(x) or not ismatrix_(y) or ndims_(x) > 2 or ndims_(y) > 2):
            error_(char('stairs: X and Y must be numeric 2-D vectors or matrices'))
    vec_x=isvector_(x)
    if (vec_x):
        x=x[:]
    if (isvector_(y)):
        y=y[:]
    else:
        if (ismatrix_(y) and vec_x):
            x=repmat_(x,[1,columns_(y)])
    if (not size_equal_(x,y)):
        error_(char('stairs: X and Y sizes must match'))
    nr,nc=size_(y,nargout=2)
    _len=2 * nr - 1
    xs=ys=zeros_(_len,nc)
    xs[1,:]=x[1,:]
    ys[1,:]=y[1,:]
    xtmp=x[2:nr,:]
    ridx=arange_(2,_len - 1,2)
    xs[ridx,:]=xtmp
    ys[ridx,:]=y[1:nr - 1,:]
    ridx=arange_(3,_len,2)
    xs[ridx,:]=xtmp
    ys[ridx,:]=y[2:nr,:]
    have_line_spec=copy_(false)
    for i in arange_(1,numel_(varargin),2).reshape(-1):
        arg=varargin[i]
        if (ischar_(arg) or iscellstr_(arg)):
            linespec,valid=__pltopt___(char('stairs'),arg,false,nargout=2)
            if (valid):
                have_line_spec=copy_(true)
                varargin[i]=[]
                break
    if (doplot):
        h=matlabarray([])
        hold_state=get_(gca_(),char('nextplot'))
        try:
            for i in arange_(1,columns_(y)).reshape(-1):
                if (have_line_spec):
                    lc=linespec.color
                    if (isempty_(lc)):
                        lc=__next_line_color___()
                    ls=linespec.linestyle
                    if (isempty_(ls)):
                        ls=char('-')
                    mk=linespec.marker
                    if (isempty_(mk)):
                        mk=char('none')
                else:
                    lc=__next_line_color___()
                    ls=char('-')
                    mk=char('none')
                hg=hggroup_()
                h=matlabarray([[h],[hg]])
                args=__add_datasource___(char('stairs'),hg,[char('x'),char('y')],varargin[:])
                addproperty_(char('xdata'),hg,char('data'),x[:,i].T)
                addproperty_(char('ydata'),hg,char('data'),y[:,i].T)
                addlistener_(hg,char('xdata'),update_data)
                addlistener_(hg,char('ydata'),update_data)
                htmp=line_(xs[:,i].T,ys[:,i].T,char('color'),lc,char('linestyle'),ls,char('marker'),mk,char('parent'),hg)
                addproperty_(char('color'),hg,char('linecolor'),get_(htmp,char('color')))
                addproperty_(char('linestyle'),hg,char('linelinestyle'),get_(htmp,char('linestyle')))
                addproperty_(char('linewidth'),hg,char('linelinewidth'),get_(htmp,char('linewidth')))
                addproperty_(char('marker'),hg,char('linemarker'),get_(htmp,char('marker')))
                addproperty_(char('markeredgecolor'),hg,char('linemarkeredgecolor'),get_(htmp,char('markeredgecolor')))
                addproperty_(char('markerfacecolor'),hg,char('linemarkerfacecolor'),get_(htmp,char('markerfacecolor')))
                addproperty_(char('markersize'),hg,char('linemarkersize'),get_(htmp,char('markersize')))
                addlistener_(hg,char('color'),update_props)
                addlistener_(hg,char('linestyle'),update_props)
                addlistener_(hg,char('linewidth'),update_props)
                addlistener_(hg,char('marker'),update_props)
                addlistener_(hg,char('markeredgecolor'),update_props)
                addlistener_(hg,char('markerfacecolor'),update_props)
                addlistener_(hg,char('markersize'),update_props)
                addproperty_(char('hittestarea'),hg,char('radio'),char('on|{off}'),char('off'))
                if (not isempty_(args)):
                    set_(hg,args[:])
        finally:
            set_(gca_(),char('nextplot'),hold_state)
    else:
        h=0
    return h,xs,ys
def update_props_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    set_(get_(h,char('children')),[char('color'),char('linestyle'),char('linewidth'),char('marker'),char('markeredgecolor'),char('markerfacecolor'),char('markersize')],get_(h,[char('color'),char('linestyle'),char('linewidth'),char('marker'),char('markeredgecolor'),char('markerfacecolor'),char('markersize')]))
    return
def update_data_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    x=get_(h,char('xdata'))
    y=get_(h,char('ydata'))
    sz=min_([[size_(x)],[size_(y)]])
    x=x[1:sz[1],1:sz[2]]
    y=y[1:sz[1],1:sz[2]]
    nr=length_(x)
    _len=2 * nr - 1
    xs=ys=zeros_(1,_len)
    xs[1]=x[1]
    ys[1]=y[1]
    xtmp=x[2:nr]
    ridx=arange_(2,_len - 1,2)
    xs[ridx]=xtmp
    ys[ridx]=y[1:nr - 1]
    ridx=arange_(3,_len,2)
    xs[ridx]=xtmp
    ys[ridx]=y[2:nr]
    set_(get_(h,char('children')),char('xdata'),xs,char('ydata'),ys)
    return
def semilogxerr_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('semilogxerr'),varargin[:],nargout=2)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        set_(hax,char('xscale'),char('log'))
        if (not ishold_(hax)):
            set_(hax,char('xminortick'),char('on'))
        htmp=__errcomm___(char('semilogxerr'),hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def isonormals_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    na=copy_(nargin)
    negate=copy_(false)
    if (ischar_(varargin[nargin])):
        na=nargin - 1
        if (strcmp_(lower_(varargin[nargin]),char('negate'))):
            negate=copy_(true)
        else:
            error_(char("isonormals: Unknown option '%s'"),varargin[nargin])
    if 2 == (na):
        c=varargin[1]
        vp=varargin[2]
        x=arange_(1,size_(c,2))
        y=arange_(1,size_(c,1))
        z=arange_(1,size_(c,3))
    else:
        if 5 == (na):
            x=varargin[1]
            y=varargin[2]
            z=varargin[3]
            c=varargin[4]
            vp=varargin[5]
        else:
            print_usage_()
    if (ismatrix_(vp) and columns_(vp) == 3):
        pa=matlabarray([])
        v=copy_(vp)
    else:
        if (ishandle_(vp)):
            pa=copy_(vp)
            v=get_(pa,char('Vertices'))
        else:
            error_(char('isonormals: Last argument is not a vertex list or a patch handle'))
    if (negate):
        normals=- __interp_cube___(x,y,z,c,v,char('normals'))
    else:
        normals=__interp_cube___(x,y,z,c,v,char('normals'))
    if 0 == (nargout):
        if (not isempty_(pa)):
            set_(pa,char('VertexNormals'),normals)
    else:
        if 1 == (nargout):
            varargout=[normals]
        else:
            print_usage_()
    return varargout
def ribbon_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('ribbon'),varargin[:],nargout=3)
    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (nargin == 1):
        y=varargin[1]
        if (isvector_(y)):
            y=y[:]
        nr,nc=size_(y,nargout=2)
        x=repmat_((arange_(1,nr)).T,1,nc)
        width=0.75
    else:
        if (nargin == 2):
            x=varargin[1]
            y=varargin[2]
            width=0.75
        else:
            x=varargin[1]
            y=varargin[2]
            width=varargin[3]
    if (isvector_(x) and isvector_(y)):
        if (length_(x) != length_(y)):
            error_(char('ribbon: vectors X and Y must have the same length'))
        else:
            x,y=meshgrid_(x,y,nargout=2)
    else:
        if (not size_equal_(x,y)):
            error_(char('ribbon: matrices X and Y must have the same size'))
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        nr,nc=size_(y,nargout=2)
        htmp=zeros_(nc,1)
        for c in arange_(nc,1,- 1).reshape(-1):
            zz=matlabarray([y[:,c],y[:,c]])
            yy=x[:,c]
            xx=matlabarray([c - width / 2,c + width / 2])
            xx,yy=meshgrid_(xx,yy,nargout=2)
            cc=repmat_(c,size_(zz))
            htmp[c]=surface_(xx,yy,zz,cc)
        if (not ishold_()):
            set_(hax,char('view'),[- 37.5,30],char('box'),char('off'),char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def isosurface_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 2 or nargin > 8 or nargout > 3):
        print_usage_()
    calc_colors=copy_(false)
    f=v=c=matlabarray([])
    verbose=copy_(false)
    noshare=copy_(false)
    if (nargin >= 5):
        x=varargin[1]
        y=varargin[2]
        z=varargin[3]
        val=varargin[4]
        iso=varargin[5]
        if (nargin >= 6 and ismatrix_(varargin[6])):
            colors=varargin[6]
            calc_colors=copy_(true)
    else:
        val=varargin[1]
        n2,n1,n3=size_(val,nargout=3)
        x,y,z=meshgrid_(arange_(1,n1),arange_(1,n2),arange_(1,n3),nargout=3)
        iso=varargin[2]
        if (nargin >= 3 and ismatrix_(varargin[3])):
            colors=varargin[3]
            calc_colors=copy_(true)
    if (calc_colors):
        if (nargout == 2):
            warning_(char('isosurface: colors will be calculated, but no output argument to receive it.'))
        fvc.faces,fvc.vertices,fvc.facevertexcdata=__marching_cube___(x,y,z,val,iso,colors,nargout=3)
    else:
        fvc.faces,fvc.vertices=__marching_cube___(x,y,z,val,iso,nargout=2)
    if (isempty_(fvc.vertices) or isempty_(fvc.faces)):
        warning_(char('isosurface: triangulation is empty'))
    if 0 == (nargout):
        hax=newplot_()
        if (calc_colors):
            pa=patch_(char('Faces'),fvc.faces,char('Vertices'),fvc.vertices,char('FaceVertexCData'),fvc.facevertexcdata,char('FaceColor'),char('flat'),char('EdgeColor'),char('none'))
        else:
            pa=patch_(char('Faces'),fvc.faces,char('Vertices'),fvc.vertices,char('FaceColor'),char('g'),char('EdgeColor'),char('k'))
        if (not ishold_()):
            set_(hax,char('view'),[- 37.5,30],char('box'),char('off'))
    else:
        if 1 == (nargout):
            varargout=[fvc]
        else:
            if 2 == (nargout):
                varargout=[fvc.faces,fvc.vertices]
            else:
                if 3 == (nargout):
                    varargout=[fvc.faces,fvc.vertices,fvc.facevertexcdata]
                else:
                    print_usage_()
    return varargout
def ezmesh_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    htmp,needusage=__ezplot___(char('mesh'),varargin[:],nargout=2)
    if (needusage):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def patch_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('patch'),varargin[:],nargout=2)
    if (isempty_(hax)):
        hax=gca_()
    htmp,failed=__patch___(hax,varargin[:],nargout=2)
    if (failed):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def feather_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('feather'),varargin[:],nargout=3)
    if (nargin == 0 or nargin > 3):
        print_usage_()
    if (nargin == 1 or (nargin == 2 and not isnumeric_(varargin[2]))):
        z=varargin[1](arange_()).T
        u=real_(z)
        v=imag_(z)
        have_line_spec=(nargin == 2)
    else:
        if (nargin >= 2 and isnumeric_(varargin[2])):
            ioff=3
            u=varargin[1](arange_()).T
            v=varargin[2](arange_()).T
            have_line_spec=(nargin == 3)
        else:
            print_usage_()
    arrowsize=0.2
    line_spec=char('-b')
    if (have_line_spec):
        arg=varargin[end()]
        if (ischar_(arg) or iscellstr_(arg)):
            __,valid=__pltopt___(char('feather'),arg,false,nargout=2)
            if (valid):
                line_spec=copy_(arg)
            else:
                error_(char('feather: invalid linestyle STYLE'))
        else:
            error_(char('feather: invalid linestyle STYLE'))
    n=length_(u)
    xend=[arange_(1,n)] + u
    xtmp=[arange_(1,n)] + u.dot((1 - arrowsize))
    yend=copy_(v)
    ytmp=v.dot((1 - arrowsize))
    x=matlabarray([[[arange_(1,n)]],[xend],[xtmp - v * arrowsize / 3],[xend],[xtmp + v * arrowsize / 3]])
    y=matlabarray([[zeros_(1,n)],[yend],[ytmp + u * arrowsize / 3],[yend],[ytmp - u * arrowsize / 3]])
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        hlist=plot_(x,y,line_spec,[1,n],[0,0],line_spec)
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(hlist)
    return h
def surfc_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('surfc'),varargin[:],nargout=3)
    if (nargin < 1):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=surface_(varargin[:])
        set_(htmp,char('facecolor'),char('flat'))
        if (not ishold_()):
            set_(hax,char('view'),[- 37.5,30],char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'),char('xlimmode'),char('manual'),char('ylimmode'),char('manual'))
        drawnow_()
        stop_idx=find_(cellfun_(char('isclass'),varargin,char('char')),1)
        if (isempty_(stop_idx)):
            stop_idx=copy_(nargin)
        else:
            stop_idx
        if (stop_idx - 1 == 1 or stop_idx - 1 == 3):
            stop_idx -= 1
        zmin=get_(hax,char('zlim'))(1)
        __,htmp2=__contour___(hax,zmin,varargin[1:stop_idx],nargout=2)
        htmp=matlabarray([[htmp],[htmp2]])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def pie3_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('pie3'),varargin[:],nargout=3)
    if (nargin < 1):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=__pie___(char('pie3'),hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def __quiver___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h=varargin[1]
    is3d=varargin[2]
    autoscale=0.9
    arrowsize=0.2
    firstnonnumeric=find_(not cellfun_(char('isnumeric'),varargin[3:nargin]),1)
    if (isempty_(firstnonnumeric)):
        firstnonnumeric=copy_(Inf)
    else:
        firstnonnumeric += 2
    ioff=3
    if (nargin < (6 + is3d) or firstnonnumeric < (6 + is3d)):
        u=varargin[ioff]
        v=varargin[ioff]
        if (is3d):
            w=varargin[ioff]
            x,y,z=meshgrid_(arange_(1,columns_(u)),arange_(1,rows_(u)),arange_(1,max_(size_(w))),nargout=3)
        else:
            x,y=meshgrid_(arange_(1,columns_(u)),arange_(1,rows_(u)),nargout=2)
        if (nargin >= ioff and isnumeric_(varargin[ioff]) and isscalar_(varargin[ioff])):
            autoscale=varargin[ioff]
    else:
        x=varargin[ioff]
        y=varargin[ioff]
        if (is3d):
            z=varargin[ioff]
        u=varargin[ioff]
        v=varargin[ioff]
        if (is3d):
            w=varargin[ioff]
            if (isvector_(x) and isvector_(y) and isvector_(z) and (not isvector_(u) or not isvector_(v) or not isvector_(w))):
                x,y,z=meshgrid_(x,y,z,nargout=3)
        else:
            if (isvector_(x) and isvector_(y) and (not isvector_(u) or not isvector_(v))):
                x,y=meshgrid_(x,y,nargout=2)
        if (nargin >= ioff and isnumeric_(varargin[ioff]) and isscalar_(varargin[ioff])):
            autoscale=varargin[ioff]
    have_filled=copy_(false)
    have_line_spec=copy_(false)
    args=[]
    while (ioff <= nargin):

        arg=varargin[ioff]
        if (ischar_(arg) and strcmpi_(arg,char('filled'))):
            have_filled=copy_(true)
        else:
            if ((ischar_(arg) or iscellstr_(arg)) and not have_line_spec):
                linespec,valid=__pltopt___(char('quiver'),arg,false,nargout=2)
                if (valid):
                    have_line_spec=copy_(true)
                    if (isempty_(linespec.linestyle) or strcmp_(linespec.linestyle,char('none'))):
                        linespec.linestyle=char('-')
                else:
                    args[end() + 1]=arg
                    if (ioff <= nargin):
                        args[end() + 1]=varargin[ioff]
            else:
                args[end() + 1]=arg
                if (ioff <= nargin):
                    args[end() + 1]=varargin[ioff]

    arrowsize /= 0.2 * 3
    if (autoscale and numel_(u) > 1):
        if (isvector_(x)):
            nx=ny=sqrt_(length_(x))
        else:
            ny,nx=size_(x,nargout=2)
        dx=(max_(x[:]) - min_(x[:])) / nx
        dy=(max_(y[:]) - min_(y[:])) / ny
        if (is3d):
            dz=(max_(z[:]) - min_(z[:])) / max_(nx,ny)
            _len=max_(sqrt_(u[:] ** 2 + v[:] ** 2 + w[:] ** 2))
        else:
            dz=0
            _len=max_(sqrt_(u[:] ** 2 + v[:] ** 2))
        if (_len > 0):
            sd=sqrt_(dx ** 2 + dy ** 2 + dz ** 2) / _len
            if (sd != 0):
                s=autoscale * sd
            else:
                s=copy_(autoscale)
            uu=s * u
            vv=s * v
            if (is3d):
                ww=s * w
    else:
        uu=copy_(u)
        vv=copy_(v)
        if (is3d):
            ww=copy_(w)
    hstate=get_(h,char('nextplot'))
    try:
        if (have_line_spec):
            ls=linespec.linestyle
            lc=linespec.color
        else:
            ls=char('-')
            lc=__next_line_color___()
        hg=hggroup_()
        if (is3d):
            args=__add_datasource___(char('quiver3'),hg,[char('x'),char('y'),char('z'),char('u'),char('v'),char('w')],args[:])
        else:
            args=__add_datasource___(char('quiver'),hg,[char('x'),char('y'),char('z'),char('u'),char('v'),char('w')],args[:])
        hold_(char('on'))
        addproperty_(char('xdata'),hg,char('data'),x)
        addproperty_(char('ydata'),hg,char('data'),y)
        addproperty_(char('udata'),hg,char('data'),u)
        addproperty_(char('vdata'),hg,char('data'),v)
        if (is3d):
            addproperty_(char('zdata'),hg,char('data'),z)
            addproperty_(char('wdata'),hg,char('data'),w)
        else:
            addproperty_(char('zdata'),hg,char('data'),[])
            addproperty_(char('wdata'),hg,char('data'),[])
        addlistener_(hg,char('xdata'),update_data)
        addlistener_(hg,char('ydata'),update_data)
        addlistener_(hg,char('zdata'),update_data)
        addlistener_(hg,char('udata'),update_data)
        addlistener_(hg,char('vdata'),update_data)
        addlistener_(hg,char('wdata'),update_data)
        x=x[:]
        y=y[:]
        xend=x + uu[:]
        yend=y + vv[:]
        if (is3d):
            z=z[:]
            zend=z + ww[:]
        if (is3d):
            h1=plot3_([[x.T],[xend.T],[NaN_(1,length_(x))]](arange_()),[[y.T],[yend.T],[NaN_(1,length_(y))]](arange_()),[[z.T],[zend.T],[NaN_(1,length_(z))]](arange_()),char('linestyle'),ls,char('color'),lc,char('parent'),hg)
        else:
            h1=plot_([[x.T],[xend.T],[NaN_(1,length_(x))]](arange_()),[[y.T],[yend.T],[NaN_(1,length_(y))]](arange_()),char('linestyle'),ls,char('color'),lc,char('parent'),hg)
        xtmp=x + uu[:] * (1 - arrowsize)
        ytmp=y + vv[:] * (1 - arrowsize)
        if (is3d):
            xydist=sqrt_(uu[:] ** 2 + vv[:] ** 2 + ww[:] ** 2) / (sqrt_(uu[:] ** 2 + vv[:] ** 2) + eps)
            xarrw1=xtmp + vv[:].dot(xydist) * arrowsize / 4
            xarrw2=xtmp - vv[:].dot(xydist) * arrowsize / 4
            yarrw1=ytmp - uu[:].dot(xydist) * arrowsize / 4
            yarrw2=ytmp + uu[:].dot(xydist) * arrowsize / 4
            zarrw1=zarrw2=zend - ww[:] * arrowsize
        else:
            xarrw1=xtmp + vv[:] * arrowsize / 3
            xarrw2=xtmp - vv[:] * arrowsize / 3
            yarrw1=ytmp - uu[:] * arrowsize / 3
            yarrw2=ytmp + uu[:] * arrowsize / 3
        if (have_line_spec):
            if (not isempty_(linespec.marker) and not strcmp_(linespec.marker,char('none'))):
                ls=char('none')
        if (is3d):
            h2=plot3_([[xarrw1.T],[xend.T],[xarrw2.T],[NaN_(1,length_(x))]](arange_()),[[yarrw1.T],[yend.T],[yarrw2.T],[NaN_(1,length_(y))]](arange_()),[[zarrw1.T],[zend.T],[zarrw2.T],[NaN_(1,length_(z))]](arange_()),char('linestyle'),ls,char('color'),lc,char('parent'),hg)
        else:
            h2=plot_([[xarrw1.T],[xend.T],[xarrw2.T],[NaN_(1,length_(x))]](arange_()),[[yarrw1.T],[yend.T],[yarrw2.T],[NaN_(1,length_(y))]](arange_()),char('linestyle'),ls,char('color'),lc,char('parent'),hg)
        if (not have_line_spec or isempty_(linespec.marker)):
            mk=char('none')
        else:
            mk=linespec.marker
        if (is3d):
            h3=plot3_(x,y,z,char('linestyle'),char('none'),char('marker'),mk,char('parent'),hg)
        else:
            h3=plot_(x,y,char('linestyle'),char('none'),char('marker'),mk,char('parent'),hg)
        if (have_filled):
            set_(h3,char('markerfacecolor'),get_(h1,char('color')))
        if (autoscale):
            addproperty_(char('autoscale'),hg,char('radio'),char('{on}|off'),char('on'))
            addproperty_(char('autoscalefactor'),hg,char('data'),autoscale)
        else:
            addproperty_(char('autoscale'),hg,char('radio'),char('{on}|off'),char('off'))
            addproperty_(char('autoscalefactor'),hg,char('data'),1.0)
        addlistener_(hg,char('autoscale'),update_data)
        addlistener_(hg,char('autoscalefactor'),update_data)
        addproperty_(char('maxheadsize'),hg,char('data'),arrowsize * 0.2 * 3)
        addlistener_(hg,char('maxheadsize'),update_data)
        addproperty_(char('showarrowhead'),hg,char('radio'),char('{on}|off'),char('on'))
        addlistener_(hg,char('showarrowhead'),update_props)
        addproperty_(char('color'),hg,char('linecolor'),get_(h1,char('color')))
        addproperty_(char('linestyle'),hg,char('linelinestyle'),get_(h1,char('linestyle')))
        addproperty_(char('linewidth'),hg,char('linelinewidth'),get_(h1,char('linewidth')))
        addproperty_(char('marker'),hg,char('linemarker'),get_(h3,char('marker')))
        addproperty_(char('markerfacecolor'),hg,char('linemarkerfacecolor'),get_(h3,char('markerfacecolor')))
        addproperty_(char('markersize'),hg,char('linemarkersize'),get_(h3,char('markersize')))
        addlistener_(hg,char('color'),update_props)
        addlistener_(hg,char('linestyle'),update_props)
        addlistener_(hg,char('linewidth'),update_props)
        addlistener_(hg,char('marker'),update_props)
        addlistener_(hg,char('markerfacecolor'),update_props)
        addlistener_(hg,char('markersize'),update_props)
        addproperty_(char('hittestarea'),hg,char('radio'),char('on|{off}'),char('off'))
        if (not isempty_(args)):
            set_(hg,args[:])
    finally:
        set_(h,char('nextplot'),hstate)
    return hg
def update_data_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    x=get_(h,char('xdata'))
    y=get_(h,char('ydata'))
    z=get_(h,char('zdata'))
    u=get_(h,char('udata'))
    v=get_(h,char('vdata'))
    w=get_(h,char('wdata'))
    s=get_(h,char('autoscalefactor'))
    arrowsize=get_(h,char('maxheadsize'))
    arrowsize /= 0.2 * 3
    kids=get_(h,char('children'))
    if (isempty_(z) or isempty_(w)):
        is3d=copy_(false)
    else:
        is3d=copy_(true)
    if (strcmp_(get_(h,char('autoscale')),char('on')) and s != 0):
        if (isvector_(x)):
            nx=ny=sqrt_(length_(x))
        else:
            ny,nx=size_(x,nargout=2)
        dx=(max_(x[:]) - min_(x[:])) / nx
        dy=(max_(y[:]) - min_(y[:])) / ny
        if (is3d):
            dz=(max_(z[:]) - min_(z[:])) / max_(nx,ny)
            _len=max_(sqrt_(u[:] ** 2 + v[:] ** 2 + w[:] ** 2))
        else:
            dz=0
            _len=max_(sqrt_(u[:] ** 2 + v[:] ** 2))
        if (_len > 0):
            sd=sqrt_(dx ** 2 + dy ** 2 + dz ** 2) / _len
            if (sd != 0):
                s *= sd
            u=s * u
            v=s * v
            if (is3d):
                w=s * w
    x=x[:]
    y=y[:]
    xend=x + u[:]
    yend=y + v[:]
    if (is3d):
        z=z[:]
        zend=z + w[:]
    set_(kids[3],char('xdata'),[[x.T],[xend.T],[NaN_(1,length_(x))]](arange_()))
    set_(kids[3],char('ydata'),[[y.T],[yend.T],[NaN_(1,length_(y))]](arange_()))
    if (is3d):
        set_(kids[3],char('zdata'),[[z.T],[zend.T],[NaN_(1,length_(z))]](arange_()))
    xtmp=x + u[:] * (1 - arrowsize)
    ytmp=y + v[:] * (1 - arrowsize)
    if (is3d):
        xydist=sqrt_(u[:] ** 2 + v[:] ** 2 + w[:] ** 2) / (sqrt_(u[:] ** 2 + v[:] ** 2) + eps)
        xarrw1=xtmp + v[:].dot(xydist) * arrowsize / 4
        xarrw2=xtmp - v[:].dot(xydist) * arrowsize / 4
        yarrw1=ytmp - u[:].dot(xydist) * arrowsize / 4
        yarrw2=ytmp + u[:].dot(xydist) * arrowsize / 4
        zarrw1=zarrw2=zend - w[:] * arrowsize
    else:
        xarrw1=xtmp + v[:] * arrowsize / 3
        xarrw2=xtmp - v[:] * arrowsize / 3
        yarrw1=ytmp - u[:] * arrowsize / 3
        yarrw2=ytmp + u[:] * arrowsize / 3
    set_(kids[2],char('xdata'),[[x.T],[xend.T],[NaN_(1,length_(x))]](arange_()))
    set_(kids[2],char('ydata'),[[y.T],[yend.T],[NaN_(1,length_(y))]](arange_()))
    if (is3d):
        set_(kids[2],char('zdata'),[[z.T],[zend.T],[NaN_(1,length_(z))]](arange_()))
    set_(kids[2],char('xdata'),[[xarrw1.T],[xend.T],[xarrw2.T],[NaN_(1,length_(x))]](arange_()))
    set_(kids[2],char('ydata'),[[yarrw1.T],[yend.T],[yarrw2.T],[NaN_(1,length_(y))]](arange_()))
    if (is3d):
        set_(kids[2],char('zdata'),[[zarrw1.T],[zend.T],[zarrw2.T],[NaN_(1,length_(z))]](arange_()))
    set_(kids[1],char('xdata'),x)
    set_(kids[1],char('ydata'),y)
    if (is3d):
        set_(kids[1],char('zdata'),z)
    return
def update_props_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    kids=get_(h,char('children'))
    set_(kids[[3,2]],[char('color'),char('linestyle'),char('linewidth')],get_(h,[char('color'),char('linestyle'),char('linewidth')]))
    set_(kids[2],char('visible'),get_(h,char('showarrowhead')))
    set_(kids[1],[char('color'),char('marker'),char('markerfacecolor'),char('markersize')],get_(h,[char('color'),char('marker'),char('markerfacecolor'),char('markersize')]))
    return
def __errcomm___(caller=None,hax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[caller,hax].count(None)+len(args)

    if (nargin < 4):
        print_usage_(caller)
    retval=matlabarray([])
    data=cell_(6,1)
    nargs=numel_(varargin)
    k=1
    while (k <= nargs):

        arg=varargin[k]
        if (not ismatrix_(arg)):
            error_(char('%s: data argument %d must be numeric'),caller,k - 1)
        if (isvector_(arg)):
            arg=arg[:]
        sz=size_(arg)
        ndata=1
        data[ndata]=arg
        while (k <= nargs):

            arg=varargin[k]
            if (ischar_(arg) or iscellstr_(arg)):
                retval[end() + 1,1]=__errplot___(arg,hax,data[1:ndata])
                break
            if (not ismatrix_(arg)):
                error_(char('%s: data argument %d must be numeric'),caller,k - 1)
            if (isvector_(arg)):
                arg=arg[:]
            if (not isscalar_(arg) and ((isvector_(arg) and numel_(arg) != prod_(sz)) or any_(size_(arg) != sz))):
                error_(char('%s: size of argument %d does not match others'),caller,k - 1)
            data[++ ndata]=arg
            if (ndata > 6):
                error_(char('%s: too many arguments to plot'),caller)


    if (not (ischar_(arg) or iscellstr_(arg))):
        retval=matlabarray([[retval],[__errplot___(char('~'),hax,data[1:ndata])]])
    drawnow_()
    return retval
def __errplot___(fstr=None,hax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[fstr,hax].count(None)+len(args)

    fmt=__pltopt___(char('__errplot__'),fstr)
    if char('~') == (fmt.errorstyle):
        ifmt=char('yerr')
    else:
        if char('>') == (fmt.errorstyle):
            ifmt=char('xerr')
        else:
            if char('~>') == (fmt.errorstyle):
                ifmt=char('xyerr')
            else:
                if char('#') == (fmt.errorstyle):
                    ifmt=char('box')
                else:
                    if char('#~') == (fmt.errorstyle):
                        ifmt=char('boxy')
                    else:
                        if char('#~>') == (fmt.errorstyle):
                            ifmt=char('boxxy')
                        else:
                            ifmt=char('yerr')
    h=matlabarray([])
    nplots=columns_(varargin[1])
    for i in arange_(1,nplots).reshape(-1):
        if (isempty_(fmt.color)):
            lc=__next_line_color___()
        else:
            lc=fmt.color()
        if (isempty_(fmt.marker) and isempty_(fmt.linestyle)):
            ls,mk=__next_line_style___(nargout=2)
        else:
            ls=fmt.linestyle
            mk=fmt.marker
        hg=hggroup_(char('parent'),hax)
        h=matlabarray([[h],[hg]])
        args=__add_datasource___(char('__errplot__'),hg,[char('x'),char('y'),char('l'),char('u'),char('xl'),char('xu')])
        hl=matlabarray([(__line___(hg,char('color'),lc,char('linestyle'),char('-'),char('marker'),char('none'))),(__line___(hg,char('color'),lc,char('linestyle'),ls,char('marker'),mk))])
        if 2 == (numel____(varargin)):
            ydata=varargin[1](arange_(),i)
            xdata=arange_(1,numel_(ydata))
            if (strcmp_(ifmt,char('yerr')) or strcmp_(ifmt,char('boxy'))):
                ldata=varargin[2](arange_(),i)
                udata=copy_(ldata)
                xldata=matlabarray([])
                xudata=matlabarray([])
            else:
                if (strcmp_(ifmt,char('xerr')) or strcmp_(ifmt,char('box'))):
                    xldata=varargin[2](arange_(),i)
                    xudata=copy_(ldata)
                    ldata=matlabarray([])
                    udata=matlabarray([])
                else:
                    error_(char('errorbar: 2 column errorplot is only valid for xerr or yerr'))
        else:
            if 3 == (numel____(varargin)):
                if (strcmp_(ifmt,char('yerr')) or strcmp_(ifmt,char('boxy'))):
                    xdata=varargin[1](arange_(),i)
                    ydata=varargin[2](arange_(),i)
                    ldata=varargin[3](arange_(),i)
                    udata=copy_(ldata)
                    xldata=matlabarray([])
                    xudata=matlabarray([])
                else:
                    if (strcmp_(ifmt,char('xyerr')) or strcmp_(ifmt,char('boxxy'))):
                        ydata=varargin[1](arange_(),i)
                        xdata=arange_(1,numel_(ydata))
                        xldata=varargin[2](arange_(),i)
                        xudata=copy_(xldata)
                        ldata=varargin[3](arange_(),i)
                        udata=copy_(ldata)
                    else:
                        xdata=varargin[1](arange_(),i)
                        ydata=varargin[2](arange_(),i)
                        xldata=varargin[3](arange_(),i)
                        xudata=copy_(xldata)
                        ldata=matlabarray([])
                        udata=matlabarray([])
            else:
                if 4 == (numel____(varargin)):
                    if (strcmp_(ifmt,char('yerr')) or strcmp_(ifmt,char('boxy'))):
                        xdata=varargin[1](arange_(),i)
                        ydata=varargin[2](arange_(),i)
                        ldata=varargin[3](arange_(),i)
                        udata=varargin[4](arange_(),i)
                        xldata=matlabarray([])
                        xudata=matlabarray([])
                    else:
                        if (strcmp_(ifmt,char('xyerr')) or strcmp_(ifmt,char('boxxy'))):
                            xdata=varargin[1](arange_(),i)
                            ydata=varargin[2](arange_(),i)
                            xldata=varargin[3](arange_(),i)
                            xudata=copy_(xldata)
                            ldata=varargin[4](arange_(),i)
                            udata=copy_(ldata)
                        else:
                            xdata=varargin[1](arange_(),i)
                            ydata=varargin[2](arange_(),i)
                            xldata=varargin[3](arange_(),i)
                            xudata=varargin[4](arange_(),i)
                            ldata=matlabarray([])
                            udata=matlabarray([])
                else:
                    if 6 == (numel____(varargin)):
                        if (strcmp_(ifmt,char('xyerr')) or strcmp_(ifmt,char('boxxy'))):
                            xdata=varargin[1](arange_(),i)
                            ydata=varargin[2](arange_(),i)
                            xldata=varargin[3](arange_(),i)
                            xudata=varargin[4](arange_(),i)
                            ldata=varargin[5](arange_(),i)
                            udata=varargin[6](arange_(),i)
                        else:
                            error_(char('errorbar: error plot with 6 columns only valid for xyerr and boxxy'))
                    else:
                        error_(char('errorbar: error plot requires 2, 3, 4, or 6 arguments'))
        addproperty_(char('xdata'),hg,char('data'),xdata[:])
        addproperty_(char('ydata'),hg,char('data'),ydata[:])
        addproperty_(char('ldata'),hg,char('data'),ldata[:])
        addproperty_(char('udata'),hg,char('data'),udata[:])
        addproperty_(char('xldata'),hg,char('data'),xldata[:])
        addproperty_(char('xudata'),hg,char('data'),xudata[:])
        addproperty_(char('format'),hg,char('string'),ifmt)
        addproperty_(char('color'),hg,char('linecolor'),get_(hl[2],char('color')))
        addproperty_(char('linestyle'),hg,char('linelinestyle'),get_(hl[2],char('linestyle')))
        addproperty_(char('linewidth'),hg,char('linelinewidth'),get_(hl[2],char('linewidth')))
        addproperty_(char('marker'),hg,char('linemarker'),get_(hl[2],char('marker')))
        addproperty_(char('markeredgecolor'),hg,char('linemarkerfacecolor'),get_(hl[2],char('markeredgecolor')))
        addproperty_(char('markerfacecolor'),hg,char('linemarkerfacecolor'),get_(hl[2],char('markerfacecolor')))
        addproperty_(char('markersize'),hg,char('linemarkersize'),get_(hl[2],char('markersize')))
        addproperty_(char('hittestarea'),hg,char('radio'),char('on|{off}'),char('off'))
        fcn=[update_props,hl]
        addlistener_(hg,char('color'),fcn)
        addlistener_(hg,char('linestyle'),fcn)
        addlistener_(hg,char('linewidth'),fcn)
        addlistener_(hg,char('marker'),fcn)
        addlistener_(hg,char('markeredgecolor'),fcn)
        addlistener_(hg,char('markerfacecolor'),fcn)
        addlistener_(hg,char('markersize'),fcn)
        fcn=[update_data,hl]
        addlistener_(hg,char('xdata'),fcn)
        addlistener_(hg,char('ydata'),fcn)
        addlistener_(hg,char('ldata'),fcn)
        addlistener_(hg,char('udata'),fcn)
        addlistener_(hg,char('xldata'),fcn)
        addlistener_(hg,char('xudata'),fcn)
        addlistener_(hg,char('format'),fcn)
        hax=ancestor_(hg,char('axes'))
        addlistener_(hax,char('xscale'),fcn)
        addlistener_(hax,char('yscale'),fcn)
        update_data_(hg,[],hl)
    if (not isempty_(fmt.key)):
        hlegend=matlabarray([])
        fkids=get_(gcf_(),char('children'))
        for i in arange_(1,numel_(fkids)).reshape(-1):
            if (strcmp_(get_(fkids[i],char('type')),char('axes')) and strcmp_(get_(fkids[i],char('tag')),char('legend'))):
                udata=get_(fkids[i],char('userdata'))
                if (not isempty_(intersect_(udata.handle,gca_()))):
                    hlegend=fkids[i]
                    break
        if (isempty_(hlegend)):
            hlgnd=matlabarray([])
            tlgnd=[]
        else:
            hlgnd,tlgnd=__getlegenddata___(hlegend,nargout=2)
        hlgnd[end() + 1]=hg
        tlgnd[end() + 1]=fmt.key
        legend_(gca_(),hlgnd,tlgnd)
    return h
def errorbar_data_(xdata=None,ydata=None,ldata=None,udata=None,xldata=None,xudata=None,ifmt=None,xscale=None,yscale=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 9-[xdata,ydata,ldata,udata,xldata,xudata,ifmt,xscale,yscale].count(None)+len(args)

    if (strcmp_(xscale,char('linear'))):
        dx=0.01 * (max_(xdata[:]) - min_(xdata[:]))
        xlo=xdata - dx
        xhi=xdata + dx
    else:
        n=xdata > 0
        if (not any_(n)):
            n=xdata < 0
        logdata=log_(abs_(xdata[n]))
        rx=exp_(0.01 * (max_(logdata) - min_(logdata)))
        xlo=xdata / rx
        xhi=xdata * rx
    if (strcmp_(yscale,char('linear'))):
        dy=0.01 * (max_(ydata[:]) - min_(ydata[:]))
        ylo=ydata - dy
        yhi=ydata + dy
    else:
        n=ydata > 0
        if (not any_(n)):
            n=ydata < 0
        logdata=log_(abs_(ydata[n]))
        ry=exp_(0.01 * (max_(logdata) - min_(logdata)))
        ylo=ydata / ry
        yhi=ydata * ry
    nans=NaN + xdata[:]
    if (strcmp_(ifmt,char('yerr'))):
        xdata=matlabarray([xdata,xdata,nans,xlo,xhi,nans,xlo,xhi,nans])
        ydata=matlabarray([ydata - ldata,ydata + udata,nans,ydata + udata,ydata + udata,nans,ydata - ldata,ydata - ldata,nans])
    else:
        if (strcmp_(ifmt,char('xerr'))):
            xdata=matlabarray([xdata - xldata,xdata + xudata,nans,xdata + xudata,xdata + xudata,nans,xdata - xldata,xdata - xldata,nans])
            ydata=matlabarray([ydata,ydata,nans,ylo,yhi,nans,ylo,yhi,nans])
        else:
            if (strcmp_(ifmt,char('boxy'))):
                dx=0.01 * (max_(xdata[:]) - min_(xdata[:]))
                xdata=matlabarray([xlo,xhi,xhi,xlo,xlo,nans])
                ydata=matlabarray([ydata - ldata,ydata - ldata,ydata + udata,ydata + udata,ydata - ldata,nans])
            else:
                if (strcmp_(ifmt,char('box'))):
                    dy=0.01 * (max_(ydata[:]) - min_(ydata[:]))
                    xdata=matlabarray([xdata - xldata,xdata + xudata,xdata + xudata,xdata - xldata,xdata - xldata,nans])
                    ydata=matlabarray([ylo,ylo,yhi,yhi,ylo,nans])
                else:
                    if (strcmp_(ifmt,char('boxxy'))):
                        xdata=matlabarray([xdata - xldata,xdata + xudata,xdata + xudata,xdata - xldata,xdata - xldata,nans])
                        ydata=matlabarray([ydata - ldata,ydata - ldata,ydata + udata,ydata + udata,ydata - ldata,nans])
                    else:
                        if (strcmp_(ifmt,char('xyerr'))):
                            x1,y1=errorbar_data_(xdata,ydata,ldata,udata,xldata,xudata,char('xerr'),xscale,yscale,nargout=2)
                            x2,y2=errorbar_data_(xdata,ydata,ldata,udata,xldata,xudata,char('yerr'),xscale,yscale,nargout=2)
                            xdata=matlabarray([[x1],[x2]])
                            ydata=matlabarray([[y1],[y2]])
                            return xdata,ydata
                        else:
                            error_(char('errorbar: valid error bar types are xerr, yerr, xyerr, box, boxy, boxxy'))
    xdata=xdata.T(arange_())
    ydata=ydata.T(arange_())
    return xdata,ydata
def update_props_(hg=None,__=None,hl=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[hg,__,hl].count(None)+len(args)

    set_(hl,char('color'),get_(hg,char('color')),char('linewidth'),get_(hg,char('linewidth')))
    set_(hl[2],char('linestyle'),get_(hg,char('linestyle')),char('marker'),get_(hg,char('marker')),char('markeredgecolor'),get_(hg,char('markeredgecolor')),char('markerfacecolor'),get_(hg,char('markerfacecolor')),char('markersize'),get_(hg,char('markersize')))
    return
def update_data_(hg=None,__=None,hl=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[hg,__,hl].count(None)+len(args)

    if (strcmp_(get_(hg,char('type')),char('axes'))):
        hax=copy_(hg)
        hg=ancestor_(hl[2],char('hggroup'))
    else:
        hax=ancestor_(hg,char('axes'))
    xscale=get_(hax,char('xscale'))
    yscale=get_(hax,char('yscale'))
    xdata=get_(hg,char('xdata'))
    ydata=get_(hg,char('ydata'))
    ldata=get_(hg,char('ldata'))
    udata=get_(hg,char('udata'))
    xldata=get_(hg,char('xldata'))
    xudata=get_(hg,char('xudata'))
    ifmt=get_(hg,char('format'))
    set_(hl[2],char('xdata'),xdata)
    set_(hl[2],char('ydata'),ydata)
    errorbar_xdata,errorbar_ydata=errorbar_data_(xdata,ydata,ldata,udata,xldata,xudata,ifmt,xscale,yscale,nargout=2)
    set_(hl[1],char('xdata'),errorbar_xdata)
    set_(hl[1],char('ydata'),errorbar_ydata)
    return
def __add_datasource___(fcn=None,h=None,data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[fcn,h,data].count(None)+len(args)

    if (ischar_(data)):
        data=[data]
    for i in arange_(1,numel_(data)).reshape(-1):
        addproperty_(strcat_(data[i],char('datasource')),h,char('string'),char(''))
    i=0
    newargs=[]
    while (i < numel_(varargin)):

        arg=varargin[++ i]
        if (i != numel_(varargin) and ischar_(arg) and length_(arg) > 9 and strcmpi_(arg[end() - 9:end()],char('datasource'))):
            arg=tolower_(arg)
            val=varargin[++ i]
            if (ischar_(val)):
                set_(h,arg,val)
            else:
                error_(char('%s: expecting data source to be a string'),fcn)
        else:
            newargs[end() + 1]=arg

    return newargs
def __ezplot___(pltfunc=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[pltfunc].count(None)+len(args)

    ezfunc=matlabarray([char('ez'),pltfunc])
    hax,varargin,nargin=__plt_get_axis_arg___(ezfunc,varargin[:],nargout=3)
    h=matlabarray([])
    needusage=copy_(false)
    if (nargin < 1):
        needusage=copy_(true)
        return h,needusage
    iscontour=strncmp_(pltfunc,char('contour'),7)
    isplot=copy_(true)
    isplot3=copy_(false)
    ispolar=copy_(false)
    nargs=1
    if char('plot') == (pltfunc):
        pass
    else:
        if char('plot3') == (pltfunc):
            isplot=copy_(false)
            isplot3=copy_(true)
        else:
            if char('polar') == (pltfunc):
                isplot=copy_(false)
                ispolar=copy_(true)
            else:
                isplot=copy_(false)
                nargs=2
    parametric=copy_(false)
    fun=varargin[1]
    if (ischar_(fun)):
        if (exist_(fun,char('file')) or exist_(fun,char('builtin'))):
            fun=inline_([fun,char('(t)')])
        else:
            fun=vectorize_(inline_(fun))
        argids=argnames_(fun)
        if (isplot and length_(argids) == 2):
            nargs=2
        else:
            if (numel_(argids) != nargs):
                error_(char('%s: expecting a function of %d arguments'),ezfunc,nargs)
        fstr=formula_(fun)
        if (isplot):
            xarg=argids[1]
            if (nargs == 2):
                yarg=argids[2]
            else:
                yarg=char('')
        else:
            if (isplot3):
                xarg=char('x')
                yarg=char('y')
            else:
                if (ispolar):
                    xarg=char('')
                    yarg=char('')
                else:
                    xarg=argids[1]
                    yarg=argids[2]
    else:
        if (strcmp_(typeinfo_(fun),char('inline function'))):
            argids=argnames_(fun)
            if (isplot and length_(argids) == 2):
                nargs=2
            else:
                if (numel_(argids) != nargs):
                    error_(char('%s: expecting a function of %d arguments'),ezfunc,nargs)
            fun=vectorize_(fun)
            fstr=formula_(fun)
            if (isplot):
                xarg=argids[1]
                if (nargs == 2):
                    yarg=argids[2]
                else:
                    yarg=char('')
            else:
                if (isplot3):
                    xarg=char('x')
                    yarg=char('y')
                else:
                    if (isplot or ispolar):
                        xarg=char('')
                        yarg=char('')
                    else:
                        xarg=argids[1]
                        yarg=argids[2]
        else:
            if (isa_(fun,char('function_handle'))):
                fstr=func2str_(fun)
                idx=index_(fstr,char(')'))
                if (idx != 0):
                    args=regexp_(fstr[3:(idx - 1)],char('\\w+'),char('match'))
                    fstr=fstr[idx + 2:end()]
                else:
                    args=[char('x')]
                if (isplot and length_(args) == 2):
                    nargs=2
                else:
                    if (numel_(args) != nargs):
                        error_(char('%s: expecting a function of %d arguments'),ezfunc,nargs)
                if (isplot):
                    xarg=args[1]
                    if (nargs == 2):
                        yarg=args[2]
                    else:
                        yarg=char('')
                else:
                    if (isplot3):
                        xarg=char('x')
                        yarg=char('y')
                    else:
                        if (ispolar):
                            xarg=char('')
                            yarg=char('')
                        else:
                            xarg=args[1]
                            yarg=args[2]
            else:
                error_(char('%s: expecting string, inline function, or function handle'),ezfunc)
    if (nargin > 2 or (nargin == 2 and isplot)):
        funx=copy_(fun)
        fstrx=copy_(fstr)
        funy=varargin[2]
        if (ischar_(funy) and not strcmp_(funy,char('circ')) and not strcmp_(funy,char('animate'))):
            parametric=copy_(true)
            if (exist_(funy,char('file')) or exist_(funy,char('builtin'))):
                funy=inline_([funy,char('(t)')])
            else:
                funy=vectorize_(inline_(funy))
            if (numel_(argnames_(funy)) != nargs):
                error_(char('%s: expecting a function of %d arguments'),ezfunc,nargs)
            fstry=formula_(funy)
        else:
            if (strcmp_(typeinfo_(funy),char('inline function'))):
                parametric=copy_(true)
                if (numel_(argnames_(funy)) != nargs):
                    error_(char('%s: expecting a function of %d arguments'),ezfunc,nargs)
                funy=vectorize_(funy)
                fstry=formula_(funy)
            else:
                if (isa_(funy,char('function_handle'))):
                    parametric=copy_(true)
                    fstry=func2str_(funy)
                    idx=index_(fstry,char(')'))
                    if (idx != 0):
                        args=regexp_(fstry[3:(idx - 1)],char('\\w+'),char('match'))
                        fstry=fstry[idx + 2:end()]
                    else:
                        args=[char('y')]
                    if (numel_(args) != nargs):
                        error_(char('%s: expecting a function of %d arguments'),ezfunc,nargs)
        if (not parametric and isplot3):
            needusage=copy_(true)
            return h,needusage
        else:
            if (parametric and isplot):
                if (nargs == 2):
                    error_(char('%s: can not define a parametric function in this manner'),ezfunc)
                else:
                    xarg=char('x')
                    yarg=char('y')
            else:
                if (parametric):
                    funz=varargin[3]
                    if (ischar_(funz) and not strcmp_(funz,char('circ')) and not strcmp_(funz,char('animate'))):
                        if (exist_(funz,char('file')) or exist_(funz,char('builtin'))):
                            funz=inline_([funz,char('(t)')])
                        else:
                            funz=vectorize_(inline_(funz))
                        if (numel_(argnames_(funz)) > nargs):
                            error_(char('%s: expecting a function of %d arguments'),ezfunc,nargs)
                        fstrz=formula_(funz)
                    else:
                        if (strcmp_(typeinfo_(funz),char('inline function'))):
                            if (numel_(argnames_(funz)) != nargs):
                                error_(char('%s: expecting a function of %d arguments'),ezfunc,nargs)
                            funz=vectorize_(funz)
                            fstrz=formula_(funz)
                        else:
                            if (isa_(funz,char('function_handle'))):
                                fstrz=func2str_(funz)
                                idx=index_(fstrz,char(')'))
                                if (idx != 0):
                                    args=regexp_(fstrz[3:(idx - 1)],char('\\w+'),char('match'))
                                    fstrz=fstrz[idx + 2:end()]
                                else:
                                    args=[char('z')]
                                if (numel_(args) != nargs):
                                    error_(char('%s: expecting a function of %d arguments'),ezfunc,nargs)
                            else:
                                error_(char('%s: parametric plots expect 3 functions'),ezfunc)
    if ((isplot and nargs != 2) or isplot3 or ispolar):
        n=500
    else:
        n=60
    domain=matlabarray([])
    circ=copy_(false)
    animate=copy_(false)
    if (parametric):
        if (isplot):
            iarg=3
        else:
            iarg=4
    else:
        iarg=2
    while (iarg <= nargin):

        arg=varargin[iarg]
        if (ischar_(arg) and strcmp_(arg,char('circ'))):
            circ=copy_(true)
        else:
            if (ischar_(arg) and strcmp_(arg,char('animate'))):
                animate=copy_(true)
            else:
                if (isscalar_(arg)):
                    n=copy_(arg)
                else:
                    if (numel_(arg) == 2):
                        domain=matlabarray([arg[1],arg[2],arg[1],arg[2]])
                    else:
                        if (numel_(arg) == 4):
                            domain=arg[:].T
                        else:
                            error_(char('%s: expecting scalar, 2-, or 4-element vector'),ezfunc)

    if (circ and (iscontour or isplot3 or isplot)):
        needusage=copy_(true)
        return h,needusage
    else:
        if (circ and parametric):
            error_(char('%s: can not have both circular domain and parametric function'),ezfunc)
    if (animate and not isplot3):
        error_(char('%s: animate option only valid for ezplot3'),ezfunc)
    if (parametric):
        fstrx=regexprep_(regexprep_(regexprep_(fstrx,char('\\s*\\.?(?:\\^|\\*\\*)\\s*'),char('^')),char('\\.([/+-])'),char('$1')),char('\\s*\\.?\\*\\s*'),char(' '))
        fstry=regexprep_(regexprep_(regexprep_(fstry,char('\\s*\\.?(?:\\^|\\*\\*)\\s*'),char('^')),char('\\.([/+-])'),char('$1')),char('\\s*\\.?\\*\\s*'),char(' '))
        if (isplot):
            fstr=matlabarray([char('x = '),fstrx,char(', y = '),fstry])
        else:
            fstrz=regexprep_(regexprep_(regexprep_(fstrz,char('\\s*\\.?(?:\\^|\\*\\*)\\s*'),char('^')),char('\\.([/+-])'),char('$1')),char('\\s*\\.?\\*\\s*'),char(' '))
            fstr=matlabarray([char('x = '),fstrx,char(',y = '),fstry,char(', z = '),fstrz])
    else:
        fstr=regexprep_(regexprep_(regexprep_(fstr,char('\\s*\\.?(?:\\^|\\*\\*)\\s*'),char('^')),char('\\.([/+-])'),char('$1')),char('\\s*\\.?\\*\\s*'),char(' '))
        if (isplot and nargs == 2):
            fstr=matlabarray([fstr,char(' = 0')])
    if (isempty_(domain)):
        auto_domain=copy_(true)
        if (isplot3 or ispolar):
            domain=matlabarray([0,2 * pi,0,2 * pi])
        else:
            domain=matlabarray([- 2 * pi,2 * pi,- 2 * pi,2 * pi])
    else:
        auto_domain=copy_(false)
    auto_domain_done=copy_(false)
    do
    domain_ok=copy_(true)
    if ((isplot and nargs == 1) or isplot3 or ispolar):
        X=linspace_(domain[1],domain[2],n)
    else:
        if (isplot and numel_(domain) == 2):
            x=linspace_(domain[1],domain[2],n)
            X,Y=meshgrid_(x,x,nargout=2)
        else:
            if (circ):
                cent=[domain[1] + domain[2],domain[3] + domain[4]] / 2
                rmax=sqrt_((domain[2] - cent[1]) ** 2 + (domain[4] - cent[2]) ** 2)
                r=linspace_(0,rmax,n)
                t=linspace_(0,2 * pi,n)
                T,R=meshgrid_(t,r,nargout=2)
                X=R.dot(cos_(T)) + cent[1]
                Y=R.dot(sin_(T)) + cent[2]
                domain=matlabarray([- rmax + cent[1],+ rmax + cent[1],- rmax + cent[2],+ rmax + cent[2]])
            else:
                x=linspace_(domain[1],domain[2],n)
                y=linspace_(domain[3],domain[4],n)
                X,Y=meshgrid_(x,y,nargout=2)
    if (parametric):
        if (isplot):
            XX=feval_(funx,X)
            Z=feval_(funy,X)
            X=copy_(XX)
        else:
            if (isplot3):
                Z=feval_(funz,X)
                XX=feval_(funx,X)
                YY=feval_(funy,X)
                X=copy_(XX)
                Y=copy_(YY)
            else:
                Z=feval_(funz,X,Y)
                XX=feval_(funx,X,Y)
                YY=feval_(funy,X,Y)
                X=copy_(XX)
                Y=copy_(YY)
                X=__eliminate_sing___(X)
                Y=__eliminate_sing___(Y)
                Z=__eliminate_sing___(Z)
    else:
        if (isplot and nargs == 2):
            Z=feval_(fun,X,Y)
            c,__=contourc_(X,Y,Z,[0,0],nargout=2)
            i=1
            XX=YY=[]
            while (i < length_(c)):

                clev=c[1,i]
                clen=c[2,i]
                XX=matlabarray([XX,[c[1,i + 1:i + clen]]])
                YY=matlabarray([YY,[c[2,i + 1:i + clen]]])
                i += clen + 1

        else:
            if (ispolar):
                Z=feval_(fun,X)
            else:
                if (isplot):
                    Z=feval_(fun,X)
                    Z=__eliminate_sing___(Z)
                    domain=find_valid_domain_(X,[],Z)
                else:
                    if (iscontour):
                        Z=feval_(fun,X,Y)
                        Z=__eliminate_sing___(Z)
                    else:
                        Z=feval_(fun,X,Y)
                        Z=__eliminate_sing___(Z)
                        if (circ):
                            pass
                        else:
                            if (auto_domain and not auto_domain_done):
                                valid_domain=find_valid_domain_(X,Y,Z)
                                domain_ok=isequal_(domain,valid_domain)
                                domain=copy_(valid_domain)
                                auto_domain_done=copy_(true)
                            else:
                                if (not auto_domain_done):
                                    domain=find_valid_domain_(X,Y,Z)
    until_(domain_ok)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        if (iscontour):
            __,h=feval_(pltfunc,hax,X,Y,Z,nargout=2)
        else:
            if (isplot and nargs == 2):
                h=zeros_(length_(XX),1)
                hold_state=get_(hax,char('nextplot'))
                for i in arange_(1,length_(XX)).reshape(-1):
                    h[i]=plot_(hax,XX[i],YY[i])
                    if (i == 1):
                        set_(hax,char('nextplot'),char('add'))
                set_(hax,char('nextplot'),hold_state)
                axis_(hax,domain)
            else:
                if (isplot or ispolar):
                    h=feval_(pltfunc,hax,X,Z)
                    if (isplot and not parametric):
                        axis_(hax,domain)
                else:
                    if (isplot3):
                        if (animate):
                            comet3_(hax,X,Y,Z,0.05)
                        h=feval_(pltfunc,hax,X,Y,Z)
                        set_(hax,char('box'),char('off'))
                        grid_(hax,char('on'))
                        zlabel_(hax,char('z'))
                    else:
                        h=feval_(pltfunc,hax,X,Y,Z)
                        if (not parametric):
                            axis_(hax,domain)
        xlabel_(hax,xarg)
        ylabel_(hax,yarg)
        title_(hax,fstr)
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    return h,needusage
def __eliminate_sing___(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (iscomplex_(x)):
        x[imag_(x) != 0]=NaN
    x[isinf_(x)]=NaN
    threshold=0.2 * (max_(x[:]) - min_(x[:]))
    x[abs_(del2_(x)) > threshold]=NaN
    return x
def find_valid_domain_(X=None,Y=None,Z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[X,Y,Z].count(None)+len(args)

    if (isvector_(Z)):
        domain=matlabarray([X[1],X[end()]])
        XX=sort_(Z[isfinite_(Z)])
        if (length_(X) > 4):
            irlo=XX[fix_(1 / 8 * length_(XX))]
            irhi=XX[fix_(7 / 8 * length_(XX))]
            d=irhi - irlo
            domain[3]=max_(XX[1] - d / 8,irlo - d)
            domain[4]=min_(XX[end()] + d / 8,irhi + d)
        else:
            domain[3:4]=[XX[1],XX[end()]]
        idx=arange_(2,length_(Z))
        idx=find_(((Z[idx] > yrange_(2) / 2) and (Z[idx - 1] < yrange_(1) / 2)) or ((Z[idx] < yrange_(1) / 2) and (Z[idx - 1] > yrange_(2) / 2)))
        Z[idx]=NaN
    else:
        Zfinite=not isnan_(Z)
        Zrows=any_(Zfinite,2)
        rmin=find_(Zrows,1,char('first'))
        rmax=find_(Zrows,1,char('last'))
        Zcols=any_(Zfinite,1)
        cmin=find_(Zcols,1,char('first'))
        cmax=find_(Zcols,1,char('last'))
        if (isempty_(rmin)):
            rmin=1
            rmax=rows_(Z)
        if (isempty_(cmin)):
            cmin=1
            cmax=columns_(Z)
        if (not any_(isnan_(Z[[rmin,rmax],:](arange_()))) and not any_(isnan_(Z[:,[cmin,cmax]](arange_())))):
            Zx,Zy=gradient_(Z[rmin:rmax,cmin:cmax],nargout=2)
            Zgrad=sqrt_(Zx ** 2 + Zy ** 2)
            slope=((max_(Z[:]) - min_(Z[:])) / sqrt_((rmax - rmin) ** 2 + (cmax - cmin) ** 2))
            slope /= 125
            Zrows=any_(Zgrad > slope,2)
            rmin += find_(Zrows,1,char('first')) - 1
            rmax += find_(Zrows,1,char('last')) - rows_(Zrows)
            Zcols=any_(Zgrad > slope,1)
            cmin += find_(Zcols,1,char('first')) - 1
            cmax += find_(Zcols,1,char('last')) - columns_(Zcols)
        domain=matlabarray([X[1,cmin],X[1,cmax],Y[rmin,1],Y[rmax,1]])
    return domain
def __scatter___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax=varargin[1]
    nd=varargin[2]
    fcn=varargin[3]
    x=varargin[4](arange_())
    y=varargin[5](arange_())
    if (nd == 2):
        istart=6
    else:
        z=varargin[6](arange_())
        istart=7
    if (istart <= nargin):
        s=varargin[istart](arange_())
        if (isempty_(s) or ischar_(s)):
            s=6
        if (not ischar_(varargin[istart])):
            istart
    else:
        s=6
    idx=isnan_(x) or isnan_(y) or isnan_(s)
    if (nd == 3):
        idx |= isnan_(z)
        z[idx]=[]
    x[idx]=[]
    y[idx]=[]
    if (nd == 2):
        z=zeros_(length_(x),0)
    if (numel_(s) > 1):
        s[idx]=[]
    firstnonnumeric=find_(not cellfun_(char('isnumeric'),varargin[istart:nargin]),1)
    if (isempty_(firstnonnumeric)):
        firstnonnumeric=copy_(Inf)
    else:
        firstnonnumeric += istart - 1
    if (istart <= nargin and firstnonnumeric > istart):
        c=varargin[istart]
        if (isvector_(c) and columns_(c) != 3):
            c=c[:]
    else:
        if (firstnonnumeric == istart and ischar_(varargin[istart]) and not (strcmpi_(varargin[istart],char('filled')) or strcmpi_(varargin[istart],char('fill')))):
            c=varargin[istart]
            firstnonnumeric
        else:
            c=matlabarray([])
    newargs=[]
    filled=copy_(false)
    have_marker=copy_(false)
    marker=char('o')
    iarg=copy_(firstnonnumeric)
    while (iarg <= nargin):

        arg=varargin[iarg]
        if (ischar_(arg) and (strcmpi_(arg,char('filled')) or strcmpi_(arg,char('fill')))):
            filled=copy_(true)
        else:
            if ((ischar_(arg) or iscellstr_(arg)) and not have_marker):
                linespec,valid=__pltopt___(fcn,arg,false,nargout=2)
                if (valid):
                    have_marker=copy_(true)
                    marker=linespec.marker
                    if (strcmp_(marker,char('none'))):
                        marker=char('o')
                    else:
                        if (isempty_(marker)):
                            have_marker=copy_(false)
                            __,marker=__next_line_style___(nargout=2)
                else:
                    error_(char('%s: invalid linespec'),fcn)
            else:
                newargs[end() + 1]=arg
                if (iarg <= nargin):
                    newargs[end() + 1]=varargin[iarg]

    if (isempty_(c)):
        c=__next_line_color___()
    hg=hggroup_()
    newargs=__add_datasource___(fcn,hg,[char('x'),char('y'),char('z'),char('c'),char('size')],newargs[:])
    addproperty_(char('xdata'),hg,char('data'),x)
    addproperty_(char('ydata'),hg,char('data'),y)
    addproperty_(char('zdata'),hg,char('data'),z)
    if (ischar_(c)):
        addproperty_(char('cdata'),hg,char('data'),[])
    else:
        addproperty_(char('cdata'),hg,char('data'),c)
    addproperty_(char('sizedata'),hg,char('data'),s)
    addlistener_(hg,char('xdata'),update_data)
    addlistener_(hg,char('ydata'),update_data)
    addlistener_(hg,char('zdata'),update_data)
    addlistener_(hg,char('cdata'),update_data)
    addlistener_(hg,char('sizedata'),update_data)
    one_explicit_color=ischar_(c) or isequal_(size_(c),[1,3])
    if (numel_(x) <= 100):
        if (numel_(s) == 1):
            s=repmat_(s,numel_(x),1)
        if (one_explicit_color):
            for i in arange_(1,numel_(x)).reshape(-1):
                if (filled):
                    __go_patch___(hg,char('xdata'),x[i],char('ydata'),y[i],char('zdata'),z[i,:],char('faces'),1,char('vertices'),[x[i],y[i],z[i,:]],char('facecolor'),char('none'),char('edgecolor'),char('none'),char('marker'),marker,char('markersize'),s[i],char('markeredgecolor'),c,char('markerfacecolor'),c,char('linestyle'),char('none'))
                else:
                    __go_patch___(hg,char('xdata'),x[i],char('ydata'),y[i],char('zdata'),z[i,:],char('faces'),1,char('vertices'),[x[i],y[i],z[i,:]],char('facecolor'),char('none'),char('edgecolor'),char('none'),char('marker'),marker,char('markersize'),s[i],char('markeredgecolor'),c,char('markerfacecolor'),char('none'),char('linestyle'),char('none'))
        else:
            if (rows_(c) == 1):
                c=repmat_(c,rows_(x),1)
            for i in arange_(1,numel_(x)).reshape(-1):
                if (filled):
                    __go_patch___(hg,char('xdata'),x[i],char('ydata'),y[i],char('zdata'),z[i,:],char('faces'),1,char('vertices'),[x[i],y[i],z[i,:]],char('facecolor'),char('none'),char('edgecolor'),char('none'),char('marker'),marker,char('markersize'),s[i],char('markeredgecolor'),char('none'),char('markerfacecolor'),char('flat'),char('cdata'),c[i,:],char('facevertexcdata'),c[i,:],char('linestyle'),char('none'))
                else:
                    __go_patch___(hg,char('xdata'),x[i],char('ydata'),y[i],char('zdata'),z[i,:],char('faces'),1,char('vertices'),[x[i],y[i],z[i,:]],char('facecolor'),char('none'),char('edgecolor'),char('none'),char('marker'),marker,char('markersize'),s[i],char('markeredgecolor'),char('flat'),char('markerfacecolor'),char('none'),char('cdata'),c[i,:],char('facevertexcdata'),c[i,:],char('linestyle'),char('none'))
    else:
        vert=matlabarray([x,y,z])
        if (one_explicit_color):
            render_size_color_(hg,vert,s,c,marker,filled,true)
        else:
            if (rows_(c) == 1):
                c=repmat_(c,rows_(x),1)
            cc,__,c_to_cc=unique_(c,char('rows'),nargout=3)
            for i in arange_(1,rows_(cc)).reshape(-1):
                idx=(i == c_to_cc)
                if (isscalar_(s)):
                    render_size_color_(hg,vert[idx,:],s,c[idx,:],marker,filled,true)
                else:
                    render_size_color_(hg,vert[idx,:],s[idx],c[idx,:],marker,filled,true)
    if (not ischar_(c) and rows_(c) > 1):
        ax=get_(hg,char('parent'))
        clim=get_(ax,char('clim'))
        if (min_(c[:]) < clim[1]):
            clim[1]=min_(c[:])
            set_(ax,char('clim'),clim)
        if (max_(c[:]) > clim[2]):
            set_(ax,char('clim'),[clim[1],max_(c[:])])
    addproperty_(char('linewidth'),hg,char('patchlinewidth'),0.5)
    addproperty_(char('marker'),hg,char('patchmarker'),marker)
    if (filled):
        addproperty_(char('markeredgecolor'),hg,char('patchmarkeredgecolor'),char('none'))
        if (one_explicit_color):
            addproperty_(char('markerfacecolor'),hg,char('patchmarkerfacecolor'),c)
        else:
            addproperty_(char('markerfacecolor'),hg,char('patchmarkerfacecolor'),char('flat'))
    else:
        addproperty_(char('markerfacecolor'),hg,char('patchmarkerfacecolor'),char('none'))
        if (one_explicit_color):
            addproperty_(char('markeredgecolor'),hg,char('patchmarkeredgecolor'),c)
        else:
            addproperty_(char('markeredgecolor'),hg,char('patchmarkeredgecolor'),char('flat'))
    addlistener_(hg,char('linewidth'),update_props)
    addlistener_(hg,char('marker'),update_props)
    addlistener_(hg,char('markerfacecolor'),update_props)
    addlistener_(hg,char('markeredgecolor'),update_props)
    addproperty_(char('hittestarea'),hg,char('radio'),char('on|{off}'),char('off'))
    if (not isempty_(newargs)):
        set_(hg,newargs[:])
    return hg
def render_size_color_(hg=None,vert=None,s=None,c=None,marker=None,filled=None,isflat=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[hg,vert,s,c,marker,filled,isflat].count(None)+len(args)

    if (isscalar_(s)):
        x=vert[:,1]
        y=vert[:,2]
        z=vert[:,3:end()]
        toolkit=get_(ancestor_(hg,char('figure')),char('__graphics_toolkit__'))
        gnuplot_hack=(numel_(x) > 1 and columns_(c) == 3 and strcmp_(toolkit,char('gnuplot')))
        if (ischar_(c) or not isflat or gnuplot_hack):
            if (filled):
                __go_patch___(hg,char('xdata'),x,char('ydata'),y,char('zdata'),z,char('faces'),arange_(1,numel_(x)),char('vertices'),vert,char('facecolor'),char('none'),char('edgecolor'),char('none'),char('marker'),marker,char('markeredgecolor'),char('none'),char('markerfacecolor'),c[1,:],char('markersize'),s,char('linestyle'),char('none'))
            else:
                __go_patch___(hg,char('xdata'),x,char('ydata'),y,char('zdata'),z,char('faces'),arange_(1,numel_(x)),char('vertices'),vert,char('facecolor'),char('none'),char('edgecolor'),char('none'),char('marker'),marker,char('markeredgecolor'),c[1,:],char('markerfacecolor'),char('none'),char('markersize'),s,char('linestyle'),char('none'))
        else:
            if (filled):
                __go_patch___(hg,char('xdata'),x,char('ydata'),y,char('zdata'),z,char('faces'),arange_(1,numel_(x)),char('vertices'),vert,char('facecolor'),char('none'),char('edgecolor'),char('none'),char('marker'),marker,char('markersize'),s,char('markeredgecolor'),char('none'),char('markerfacecolor'),char('flat'),char('cdata'),c,char('facevertexcdata'),c,char('linestyle'),char('none'))
            else:
                __go_patch___(hg,char('xdata'),x,char('ydata'),y,char('zdata'),z,char('faces'),arange_(1,numel_(x)),char('vertices'),vert,char('facecolor'),char('none'),char('edgecolor'),char('none'),char('marker'),marker,char('markersize'),s,char('markeredgecolor'),char('flat'),char('markerfacecolor'),char('none'),char('cdata'),c,char('facevertexcdata'),c,char('linestyle'),char('none'))
    else:
        ss,__,s_to_ss=unique_(ceil_(s * 10) / 10,nargout=3)
        for i in arange_(1,rows_(ss)).reshape(-1):
            idx=(i == s_to_ss)
            render_size_color_(hg,vert[idx,:],ss[i],c,marker,filled,isflat)
    return
def update_props_(h=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,d].count(None)+len(args)

    lw=get_(h,char('linewidth'))
    m=get_(h,char('marker'))
    fc=get_(h,char('markerfacecolor'))
    ec=get_(h,char('markeredgecolor'))
    kids=get_(h,char('children'))
    set_(kids,char('linewidth'),lw,char('marker'),m,char('markerfacecolor'),fc,char('markeredgecolor'),ec)
    return
def update_data_(h=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,d].count(None)+len(args)

    x=get_(h,char('xdata'))
    y=get_(h,char('ydata'))
    z=get_(h,char('zdata'))
    c=get_(h,char('cdata'))
    if (rows_(c) == 1):
        c=repmat_(c,numel_(x),1)
    s=get_(h,char('sizedata'))
    if (numel_(s) == 1):
        s=repmat_(s,numel_(x),1)
    hlist=get_(h,char('children'))
    if (isempty_(z)):
        for i in arange_(1,length_(hlist)).reshape(-1):
            set_(hlist[i],char('vertices'),[x[i],y[i]],char('cdata'),reshape_(c[i,:],[1,size_(c)(arange_(2,end()))]),char('facevertexcdata'),c[i,:],char('markersize'),s[i])
    else:
        for i in arange_(1,length_(hlist)).reshape(-1):
            set_(hlist[i],char('vertices'),[x[i],y[i],z[i]],char('cdata'),reshape_(cd_(i,arange_()),[1,size_(cd)(arange_(2,end()))]),char('facevertexcdata'),cd_(i,arange_()),char('markersize'),s[i])
    return
def __patch___(p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[p].count(None)+len(args)

    h=copy_(NaN)
    failed=copy_(false)
    is_numeric_arg=cellfun_(isnumeric,varargin)
    if (isempty_(varargin)):
        args=[char('xdata'),[[0],[1],[0]],char('ydata'),[[1],[1],[0]],char('facecolor'),[0,0,0]]
        args=setvertexdata_(args)
    else:
        if (isstruct_(varargin[1])):
            if (isfield_(varargin[1],char('vertices')) and isfield_(varargin[1],char('faces'))):
                args[1]=char('faces')
                args[2]=getfield_(varargin[1],char('faces'))
                args[3]=char('vertices')
                args[4]=getfield_(varargin[1],char('vertices'))
                args[5]=char('facevertexcdata')
                if (isfield_(varargin[1],char('facevertexcdata'))):
                    args[6]=getfield_(varargin[1],char('facevertexcdata'))
                else:
                    args[6]=[]
                args=matlabarray([[args],[varargin[2:end()]]])
                args=setdata_(args)
            else:
                failed=copy_(true)
        else:
            if (is_numeric_arg[1]):
                if (nargin < 3 or not is_numeric_arg[2]):
                    failed=copy_(true)
                else:
                    if (nargin > 4 and all_(is_numeric_arg[1:4])):
                        x=varargin[1]
                        y=varargin[2]
                        z=varargin[3]
                        c=varargin[4]
                        iarg=5
                    else:
                        if (nargin > 3 and all_(is_numeric_arg[1:3])):
                            x=varargin[1]
                            y=varargin[2]
                            iarg=4
                            if (rem_(nargin - iarg,2) == 1):
                                c=varargin[iarg]
                                z=varargin[3]
                                iarg=5
                            else:
                                z=matlabarray([])
                                c=varargin[3]
                        else:
                            if (nargin > 2 and all_(is_numeric_arg[1:2])):
                                x=varargin[1]
                                y=varargin[2]
                                z=matlabarray([])
                                iarg=3
                                if (rem_(nargin - iarg,2) == 1):
                                    c=varargin[iarg]
                                    iarg
                                else:
                                    c=matlabarray([])
                    if (isvector_(x)):
                        x=x[:]
                        y=y[:]
                        z=z[:]
                        if (isnumeric_(c)):
                            if (isvector_(c) and numel_(c) == numel_(x)):
                                c=c[:]
                            else:
                                if (rows_(c) != numel_(x) and columns_(c) == numel_(x)):
                                    c=c.T
                    args[1]=char('xdata')
                    args[2]=x
                    args[3]=char('ydata')
                    args[4]=y
                    args[5]=char('zdata')
                    args[6]=z
                    if (isnumeric_(c)):
                        if (ndims_(c) == 3 and columns_(c) == 1):
                            c=permute_(c,[1,3,2])
                        if (isvector_(c) and numel_(c) == columns_(x)):
                            if (isnan_(c)):
                                args[7]=char('facecolor')
                                args[8]=[1,1,1]
                                args[9]=char('cdata')
                                args[10]=c
                            else:
                                if (isnumeric_(c)):
                                    args[7]=char('facecolor')
                                    args[8]=char('flat')
                                    args[9]=char('cdata')
                                    args[10]=c
                                else:
                                    error_(char('patch: color value not valid'))
                        else:
                            if (isvector_(c) and numel_(c) == 3):
                                args[7]=char('facecolor')
                                args[8]=c
                                args[9]=char('cdata')
                                args[10]=[]
                            else:
                                if (ndims_(c) == 3 and size_(c,3) == 3):
                                    if ((rows_(c) == 1 and columns_(c) == 1) or (rows_(c) == 1 and columns_(c) == columns_(x))):
                                        args[7]=char('facecolor')
                                        args[8]=char('flat')
                                        args[9]=char('cdata')
                                        args[10]=c
                                    else:
                                        if (rows_(c) == rows_(x) and columns_(c) == columns_(x)):
                                            args[7]=char('facecolor')
                                            args[8]=char('interp')
                                            args[9]=char('cdata')
                                            args[10]=c
                                        else:
                                            error_(char('patch: color value not valid'))
                                else:
                                    if (isempty_(c)):
                                        args[7]=char('facecolor')
                                        args[8]=char('interp')
                                        args[9]=char('cdata')
                                        args[10]=[]
                                    else:
                                        if (isequal_(size_(c),size_(x)) and isequal_(size_(c),size_(y))):
                                            args[7]=char('facecolor')
                                            args[8]=char('interp')
                                            args[9]=char('cdata')
                                            args[10]=c
                                        else:
                                            error_(char('patch: size of x, y, and c must be equal'))
                    else:
                        if (ischar_(c) and rem_(nargin - iarg,2) == 0):
                            args[7]=char('facecolor')
                            args[8]=tolower_(c)
                            args[9]=char('cdata')
                            args[10]=[]
                        else:
                            args[7]=char('facecolor')
                            args[8]=[0,1,0]
                            args[9]=char('cdata')
                            args[10]=[]
                    args=matlabarray([args,varargin[iarg:end()]])
                    args=setvertexdata_(args)
            else:
                args=copy_(varargin)
                if (any_(strcmpi_(args,char('faces')) or strcmpi_(args,char('vertices')))):
                    args=setdata_(args)
                else:
                    args=setvertexdata_(args)
    if (not failed):
        h=__go_patch___(p,args[:])
        addlistener_(h,char('xdata'),update_data)
        addlistener_(h,char('ydata'),update_data)
        addlistener_(h,char('zdata'),update_data)
        addlistener_(h,char('cdata'),update_data)
        addlistener_(h,char('faces'),update_fvc)
        addlistener_(h,char('vertices'),update_fvc)
        addlistener_(h,char('facevertexcdata'),update_fvc)
    return h,failed
def delfields_(args=None,flds=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[args,flds].count(None)+len(args)

    idx=cellfun_(char('isclass'),args,char('char'))
    idx[idx]=ismember_(args[idx],flds)
    if (rows_(idx) == 1):
        idx |= [false,idx[1:end() - 1]]
    else:
        idx |= [[false],[idx[1:end() - 1]]]
    args[idx]=[]
    return args
def setdata_(args=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[args].count(None)+len(args)

    args=delfields_(args,[char('xdata'),char('ydata'),char('zdata'),char('cdata')])
    args=delfields_(args,[char('type'),char('uicontextmenu')])
    nargs=length_(args)
    idx=find_(strcmpi_(args,char('faces')),1,char('last')) + 1
    if (idx > nargs):
        faces=matlabarray([])
    else:
        faces=args[idx]
    idx=find_(strcmpi_(args,char('vertices')),1,char('last')) + 1
    if (idx > nargs):
        vert=matlabarray([])
    else:
        vert=args[idx]
    idx=find_(strcmpi_(args,char('facevertexcdata')),1,char('last')) + 1
    if (isempty_(idx) or idx > nargs):
        fvc=matlabarray([])
    else:
        fvc=args[idx]
    idx=find_(strcmpi_(args,char('facecolor')),1,char('last')) + 1
    if (isempty_(idx) or idx > nargs):
        if (not isempty_(fvc)):
            fc=char('flat')
        else:
            fc=matlabarray([0,1,0])
        args=[char('facecolor'),fc,args[:]]
    nc=rows_(faces)
    idx=faceschar(';\n  t1 = isnan (idx);\n  for i = find (any (t1))\n    first_idx_in_column = find (t1(:,i), 1);\n    idx(first_idx_in_column:end,i) = idx(first_idx_in_column-1,i);\n  endfor\n  x = reshape (vert(:,1)(idx), size (idx));\n  y = reshape (vert(:,2)(idx), size (idx));\n  if (columns (vert) > 2)\n    z = reshape (vert(:,3)(idx), size (idx));\n  else\n    z = [];\n  endif\n\n  if (rows (fvc) == nc || rows (fvc) == 1)\n    c = reshape (fvc, [1, size(fvc)]);\n  else\n    if (columns (fvc) == 3)\n      c = cat (3, reshape (fvc(idx, 1), size (idx)),\n               reshape (fvc(idx, 2), size (idx)),\n               reshape (fvc(idx, 3), size (idx)));\n    elseif (isempty (fvc))\n      c = [];\n    else ## if (columnns (fvc) == 1)\n      c = permute (fvc(faces), [2, 1]);\n    endif\n  endif\n  args = {"xdata", x, "ydata", y, "zdata", z, "cdata", c, args{:}};\nendfunction\n\nfunction args = setvertexdata (args)\n  args = delfields (args, {"vertices", "faces", "facevertexcdata"});\n  ## Remove the readonly fields as well\n  args = delfields (args, {"type", "uicontextmenu"});\n  nargs = length (args);\n  idx = find (strcmpi (args, "xdata"), 1, "last") + 1;\n  if (idx > nargs)\n    x = [];\n  else\n    x = args {idx};\n  endif\n  idx = find (strcmpi (args, "ydata"), 1, "last") + 1;\n  if (idx > nargs)\n    y = [];\n  else\n    y = args {idx};\n  endif\n  idx = find (strcmpi (args, "zdata"), 1, "last") + 1;\n  if (isempty (idx) || idx > nargs)\n    z = [];\n  else\n    z = args {idx};\n  endif\n  idx = find (strcmpi (args, "cdata"), 1, "last") + 1;\n  if (isempty (idx) || idx > nargs)\n    c = [];\n  else\n    c = args {idx};\n  endif\n  idx = find (strcmpi (args, "facecolor"), 1, "last") + 1;\n  if (isempty (idx) || idx > nargs)\n    if (!isempty (c))\n      fc = "flat";\n    else\n      fc = [0, 1, 0];\n    endif\n    args = {"facecolor", fc, args{:}};\n  endif\n\n  [nr, nc] = size (x);\n  if (nr == 1 && nc > 1)\n    nr = nc;\n    nc = 1;\n  endif\n  if (!isempty (z))\n    vert = [x(:), y(:), z(:)];\n  else\n    vert = [x(:), y(:)];\n  endif\n  faces = reshape (1:numel (x), nr, nc);\n  faces = faces')
    if (ndims_(c) == 3):
        fvc=reshape_(c,rows_(c) * columns_(c),size_(c,3))
    else:
        fvc=c_(arange_())
    args=[char('faces'),faces,char('vertices'),vert,char('facevertexcdata'),fvc,args[:]]
    return args
def update_data_(h=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,d].count(None)+len(args)

    update_handle_(h,false)
    return
def update_fvc_(h=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,d].count(None)+len(args)

    update_handle_(h,true)
    return
def update_handle_(h=None,isfv=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,isfv].count(None)+len(args)

    recursive=copy_(false)
    if (not recursive):
        recursive=copy_(true)
        f=get_(h)
        if (isfv):
            set_(h,setdata_([fieldnames_(f),struct2cell_(f)].T(arange_()))[:])
        else:
            set_(h,setvertexdata_([fieldnames_(f),struct2cell_(f)].T(arange_()))[:])
        recursive=copy_(false)
    return
def __contour___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    ax=varargin[1]
    zlevel=varargin[2]
    filled=char('off')
    linespec.color=char('auto')
    linespec.linestyle=char('-')
    for i in arange_(3,nargin,2).reshape(-1):
        arg=varargin[i]
        if (ischar_(arg) or iscellstr_(arg)):
            lspec,valid=__pltopt___(char('__contour__'),arg,false,nargout=2)
            if (valid):
                have_line_spec=copy_(true)
                varargin[i]=[]
                linespec=copy_(lspec)
                if (isempty_(linespec.color)):
                    linespec.color=char('auto')
                if (isempty_(linespec.linestyle)):
                    linespec.linestyle=char('-')
                break
    opts=[]
    i=3
    while (i < length_(varargin)):

        if (ischar_(varargin[i])):
            if (strcmpi_(varargin[i],char('fill'))):
                filled=varargin[i + 1]
                varargin[i:i + 1]=[]
            else:
                if (strcmpi_(varargin[i],char('linecolor'))):
                    linespec.color=varargin[i + 1]
                    varargin[i:i + 1]=[]
                else:
                    opts[end() + (arange_(1,2))]=varargin[i:i + 1]
                    varargin[i:i + 1]=[]
        else:
            i

    if (length_(varargin) < 5):
        z1=varargin[3]
        x1=arange_(1,columns_(z1))
        y1=arange_(1,rows_(z1))
    else:
        x1=varargin[3]
        y1=varargin[4]
        z1=varargin[5]
    if (not ismatrix_(z1) or not ismatrix_(x1) or not ismatrix_(y1)):
        error_(char('__contour__: X, Y, and Z must be matrices'))
    if (length_(varargin) == 4 or length_(varargin) == 6):
        vn=varargin[end()]
        vnauto=copy_(false)
    else:
        vn=10
        vnauto=copy_(true)
    if (isscalar_(vn)):
        lvl=linspace_(min_(z1[not isinf_(z1)]),max_(z1[not isinf_(z1)]),vn + 2)
        lvl=lvl[1:end() - 1]
    else:
        lvl=sort_(vn)
    if (strcmpi_(filled,char('on'))):
        if (isvector_(x1) or isvector_(y1)):
            x1,y1=meshgrid_(x1,y1,nargout=2)
        nr,nc=size_(z1,nargout=2)
        x0=prepad_(x1,nc + 1,2 * x1[1,1] - x1[1,2],2)
        x0=postpad_(x0,nc + 2,2 * x1[1,nc] - x1[1,nc - 1],2)
        x0=matlabarray([[x0[1,:]],[x0],[x0[1,:]]])
        y0=prepad_(y1,nr + 1,2 * y1[1,1] - y1[2,1],1)
        y0=postpad_(y0,nr + 2,2 * y1[nr,1] - y1[nr - 1,1])
        y0=matlabarray([y0[:,1],y0,y0[:,1]])
        z0=- Inf_(nr + 2,nc + 2)
        z0[2:nr + 1,2:nc + 1]=z1
        c,lev=contourc_(x0,y0,z0,lvl,nargout=2)
    else:
        c,lev=contourc_(x1,y1,z1,lvl,nargout=2)
    hg=hggroup_()
    opts=__add_datasource___(char('__countour__'),hg,[char('x'),char('y'),char('z')],opts[:])
    addproperty_(char('xdata'),hg,char('data'),x1)
    addproperty_(char('ydata'),hg,char('data'),y1)
    addproperty_(char('zdata'),hg,char('data'),z1)
    addproperty_(char('contourmatrix'),hg,char('data'),c)
    addlistener_(hg,char('xdata'),update_data)
    addlistener_(hg,char('ydata'),update_data)
    addlistener_(hg,char('zdata'),update_data)
    addlistener_(hg,char('contourmatrix'),update_data)
    addproperty_(char('fill'),hg,char('radio'),char('on|{off}'),filled)
    if (isnumeric_(zlevel)):
        addproperty_(char('zlevelmode'),hg,char('radio'),char('{none}|auto|manual'),char('manual'))
        addproperty_(char('zlevel'),hg,char('data'),zlevel)
    else:
        addproperty_(char('zlevelmode'),hg,char('radio'),char('{none}|auto|manual'),zlevel)
        addproperty_(char('zlevel'),hg,char('data'),0.0)
    lvlstep=sum_(diff_(lvl)) / (length_(lvl) - 1)
    addproperty_(char('levellist'),hg,char('data'),lev)
    addproperty_(char('levelstep'),hg,char('double'),lvlstep)
    if (vnauto):
        addproperty_(char('levellistmode'),hg,char('radio'),char('{auto}|manual'),char('auto'))
        addproperty_(char('levelstepmode'),hg,char('radio'),char('{auto}|manual'),char('auto'))
    else:
        if (isscalar_(vn)):
            addproperty_(char('levellistmode'),hg,char('radio'),char('{auto}|manual'),char('auto'))
            addproperty_(char('levelstepmode'),hg,char('radio'),char('{auto}|manual'),char('manual'))
        else:
            addproperty_(char('levellistmode'),hg,char('radio'),char('{auto}|manual'),char('manual'))
            addproperty_(char('levelstepmode'),hg,char('radio'),char('{auto}|manual'),char('auto'))
    addproperty_(char('labelspacing'),hg,char('double'),144)
    addproperty_(char('textlist'),hg,char('data'),lev)
    addproperty_(char('textlistmode'),hg,char('radio'),char('{auto}|manual'),char('auto'))
    addproperty_(char('textstep'),hg,char('double'),lvlstep)
    addproperty_(char('textstepmode'),hg,char('radio'),char('{auto}|manual'),char('auto'))
    addproperty_(char('showtext'),hg,char('radio'),char('on|{off}'),char('off'))
    addproperty_(char('linecolor'),hg,char('color'),linespec.color,char('{auto}|none'))
    addproperty_(char('linestyle'),hg,char('linelinestyle'),linespec.linestyle)
    addproperty_(char('linewidth'),hg,char('linelinewidth'),0.5)
    addproperty_(char('hittestarea'),hg,char('radio'),char('on|{off}'),char('off'))
    addlistener_(hg,char('fill'),[update_data,char('fill')])
    addlistener_(hg,char('zlevelmode'),update_zlevel)
    addlistener_(hg,char('zlevel'),update_zlevel)
    addlistener_(hg,char('levellist'),[update_data,char('levellist')])
    addlistener_(hg,char('levelstep'),[update_data,char('levelstep')])
    addlistener_(hg,char('levellistmode'),update_data)
    addlistener_(hg,char('levelstepmode'),update_data)
    addlistener_(hg,char('labelspacing'),update_text)
    addlistener_(hg,char('textlist'),[update_text,char('textlist')])
    addlistener_(hg,char('textlistmode'),update_text)
    addlistener_(hg,char('textstep'),[update_text,char('textstep')])
    addlistener_(hg,char('textstepmode'),update_text)
    addlistener_(hg,char('showtext'),update_text)
    addlistener_(hg,char('linecolor'),update_line)
    addlistener_(hg,char('linestyle'),update_line)
    addlistener_(hg,char('linewidth'),update_line)
    if (all_(strcmp_(get_(gca_(),[char('xlimmode'),char('ylimmode')]),char('auto')))):
        axis_([min_(x1[:]),max_(x1[:]),min_(y1[:]),max_(y1[:])])
    add_patch_children_(hg)
    if (not isempty_(opts)):
        set_(hg,opts[:])
    return c,hg
def add_patch_children_(hg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[hg].count(None)+len(args)

    c=get_(hg,char('contourmatrix'))
    lev=get_(hg,char('levellist'))
    fill=get_(hg,char('fill'))
    zlev=get_(hg,char('zlevel'))
    zmode=get_(hg,char('zlevelmode'))
    lc=get_(hg,char('linecolor'))
    lw=get_(hg,char('linewidth'))
    ls=get_(hg,char('linestyle'))
    filled=get_(hg,char('fill'))
    ca=gca_()
    climmode=get_(ca,char('climmode'))
    set_(ca,char('climmode'),char('manual'))
    if (strcmp_(lc,char('auto'))):
        lc=char('flat')
    if (strcmp_(filled,char('on'))):
        lvl_eps=get_lvl_eps_(lev)
        i=1
        ncont=0
        while (i < columns_(c)):

            ncont
            cont_lev[ncont]=c[1,i]
            cont_len[ncont]=c[2,i]
            cont_idx[ncont]=i + 1
            ii=i + (arange_(1,cont_len[ncont]))
            cont_area[ncont]=polyarea_(c[1,ii],c[2,ii])
            i += cont_len[ncont] + 1

        for k in arange_(1,numel_(lev)).reshape(-1):
            lvl_idx=find_(abs_(cont_lev - lev[k]) < lvl_eps)
            _len=numel_(lvl_idx)
            if (_len > 1):
                mark=false_(size_(lvl_idx))
                a=1
                while (a < _len):

                    pa_idx=lvl_idx[a]
                    curr_ct_idx=cont_idx[pa_idx]
                    curr_ct_len=cont_len[pa_idx]
                    curr_ct=c[:,curr_ct_idx:curr_ct_idx + curr_ct_len - 1]
                    b_vec=arange_((a + 1),_len)
                    next_ct_pt_vec=c[:,cont_idx[lvl_idx[b_vec]]]
                    _in=inpolygon_(next_ct_pt_vec[1,:],next_ct_pt_vec[2,:],curr_ct[1,:],curr_ct[2,:])
                    mark[b_vec[_in]]=not mark[b_vec[_in]]
                    a

                if (numel_(mark) > 0):
                    ma_idx=lvl_idx[mark]
                    if (k > 1):
                        tmp=find_(abs_(cont_lev - lev[k - 1]) < lvl_eps)
                        lvl_bel_idx=tmp[1]
                        cont_lev[ma_idx]=cont_lev[lvl_bel_idx]
                    else:
                        cont_lev[ma_idx]=NaN
        del_idx=matlabarray([])
        max_idx=find_(cont_area == max_(cont_area))
        if (numel_(max_idx) > 1):
            del_idx=max_idx[1:end() - 1]
            cont_area[del_idx]=cont_lev[del_idx]=[]
            cont_len[del_idx]=cont_idx[del_idx]=[]
        __,svec=sort_(cont_area,nargout=2)
        _len=ncont - numel_(del_idx)
        h=matlabarray([])
        for n in arange_(_len,1,- 1).reshape(-1):
            idx=svec[n]
            ctmp=c[:,cont_idx[idx]:cont_idx[idx] + cont_len[idx] - 1]
            if (all_(ctmp[:,1] == ctmp[:,end()])):
                ctmp[:,end()]=[]
            if (isnan_(cont_lev[idx])):
                fc=get_(ca,char('color'))
                if (strcmp_(fc,char('none'))):
                    fc=get_(ancestor_(ca,char('figure')),char('color'))
            else:
                fc=char('flat')
            h=matlabarray([[h],[__go_patch___(ca,char('xdata'),ctmp[1,:](arange_()),char('ydata'),ctmp[2,:](arange_()),char('vertices'),ctmp.T,char('faces'),arange_(1,(cont_len[idx] - 1)),char('facevertexcdata'),cont_lev[idx],char('facecolor'),fc,char('cdata'),cont_lev[idx],char('edgecolor'),lc,char('linestyle'),ls,char('linewidth'),lw,char('parent'),hg)]])
        if (min_(lev) == max_(lev)):
            set_(ca,char('clim'),[min_(lev) - 1,max_(lev) + 1],char('layer'),char('top'))
        else:
            set_(ca,char('clim'),[min_(lev),max_(lev)],char('layer'),char('top'))
    else:
        h=matlabarray([])
        i=1
        while (i < length_(c)):

            clev=c[1,i]
            clen=c[2,i]
            if (all_(c[:,i + 1] == c[:,i + clen])):
                p=c[:,i + 1:i + clen - 1].T
            else:
                p=[c[:,i + 1:i + clen],NaN_(2,1)].T
            if char('none') == (zmode):
                h=matlabarray([[h],[__go_patch___(ca,char('xdata'),p[:,1],char('ydata'),p[:,2],char('zdata'),[],char('vertices'),p,char('faces'),arange_(1,rows_(p)),char('facevertexcdata'),clev,char('facecolor'),char('none'),char('cdata'),clev,char('edgecolor'),lc,char('linestyle'),ls,char('linewidth'),lw,char('parent'),hg)]])
            else:
                if char('auto') == (zmode):
                    h=matlabarray([[h],[__go_patch___(ca,char('xdata'),p[:,1],char('ydata'),p[:,2],char('zdata'),clev * ones_(rows_(p),1),char('vertices'),[p,clev * ones_(rows_(p),1)],char('faces'),arange_(1,rows_(p)),char('facevertexcdata'),clev,char('facecolor'),char('none'),char('cdata'),clev,char('edgecolor'),lc,char('linestyle'),ls,char('linewidth'),lw,char('parent'),hg)]])
                else:
                    h=matlabarray([[h],[__go_patch___(ca,char('xdata'),p[:,1],char('ydata'),p[:,2],char('zdata'),zlev * ones_(rows_(p),1),char('vertices'),[p,zlev * ones_(rows_(p),1)],char('faces'),arange_(1,rows_(p)),char('facevertexcdata'),clev,char('facecolor'),char('none'),char('cdata'),clev,char('edgecolor'),lc,char('linestyle'),ls,char('linewidth'),lw,char('parent'),hg)]])
            i += clen + 1

    set_(ca,char('climmode'),climmode)
    return
def update_zlevel_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    z=get_(h,char('zlevel'))
    zmode=get_(h,char('zlevelmode'))
    kids=get_(h,char('children'))
    if char('none') == (zmode):
        set_(kids,char('zdata'),[])
    else:
        if char('auto') == (zmode):
            for i in arange_(1,length_(kids)).reshape(-1):
                set_(kids[i],char('zdata'),get_(kids[i],char('cdata')).dot(ones_(size_(get_(kids[i],char('xdata'))))))
        else:
            for i in arange_(1,length_(kids)).reshape(-1):
                set_(kids[i],char('zdata'),z.dot(ones_(size_(get_(kids[i],char('xdata'))))))
    return
def update_line_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    lc=get_(h,char('linecolor'))
    if (strcmp_(lc,char('auto'))):
        lc=char('flat')
    set_(findobj_(h,char('type'),char('patch')),char('edgecolor'),lc,char('linewidth'),get_(h,char('linewidth')),char('linestyle'),get_(h,char('linestyle')))
    return
def update_data_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,__,prop].count(None)+len(args)

    recursive=copy_(false)
    if (not recursive):
        recursive=copy_(true)
        delete_(get_(h,char('children')))
        if char('levellist') == (prop):
            set_(h,char('levellistmode'),char('manual'))
        else:
            if char('levelstep') == (prop):
                set_(h,char('levelstepmode'),char('manual'))
            else:
                if char('fill') == (prop):
                    if (strcmp_(get_(h,char('fill')),char('off'))):
                        set_(h,char('linecolor'),char('auto'))
                    else:
                        set_(h,char('linecolor'),char('black'))
        if (strcmp_(get_(h,char('levellistmode')),char('manual')) and not strcmp_(prop,char('levelstep'))):
            lvl=get_(h,char('levellist'))
        else:
            if (strcmp_(get_(h,char('levelstepmode')),char('manual'))):
                z=get_(h,char('zdata'))
                lvs=get_(h,char('levelstep'))
                lvl[1]=ceil_(min_(z[:]) / lvs) * lvs
                lvl[2]=floor_(max_(z[:]) / lvs) * lvs
                if (lvl[1] >= lvl[2]):
                    lvl=median_(z[:])
                else:
                    lvl=arange_(lvl[1],lvl[2],lvs)
                set_(h,char('levellist'),lvl)
                set_(h,char('levellistmode'),char('auto'))
            else:
                z=get_(h,char('zdata'))
                lvl=linspace_(min_(z[not isinf_(z)]),max_(z[not isinf_(z)]),10 + 2)
                lvl=lvl[1:end() - 1]
        if (strcmp_(get_(h,char('fill')),char('on'))):
            X=get_(h,char('xdata'))
            Y=get_(h,char('ydata'))
            Z=get_(h,char('zdata'))
            if (isvector_(X) or isvector_(Y)):
                X,Y=meshgrid_(X,Y,nargout=2)
            nr,nc=size_(Z,nargout=2)
            X0=prepad_(X,nc + 1,2 * X[1,1] - X[1,2],2)
            X0=postpad_(X0,nc + 2,2 * X[1,nc] - X[1,nc - 1],2)
            X0=matlabarray([[X0[1,:]],[X0],[X0[1,:]]])
            Y0=prepad_(Y,nr + 1,2 * Y[1,1] - Y[2,1],1)
            Y0=postpad_(Y0,nr + 2,2 * Y[nr,1] - Y[nr - 1,1])
            Y0=matlabarray([Y0[:,1],Y0,Y0[:,1]])
            Z0=- Inf_(nr + 2,nc + 2)
            Z0[2:nr + 1,2:nc + 1]=Z
            c,lev=contourc_(X0,Y0,Z0,lvl,nargout=2)
        else:
            c,lev=contourc_(get_(h,char('xdata')),get_(h,char('ydata')),get_(h,char('zdata')),lvl,nargout=2)
        set_(h,char('contourmatrix'),c)
        if (strcmp_(get_(h,char('levellistmode')),char('manual'))):
            pass
        else:
            if (strcmp_(get_(h,char('levelstepmode')),char('manual'))):
                set_(h,char('levellist'),lev)
            else:
                set_(h,char('levellist'),lev)
                lvlstep=sum_(diff_(lvl)) / (length_(lvl) - 1)
                set_(h,char('levelstep'),lvlstep)
        add_patch_children_(h)
        update_text_(h)
        recursive=copy_(false)
    return
def update_text_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,__,prop].count(None)+len(args)

    recursive=copy_(false)
    if (not recursive):
        recursive=copy_(true)
        delete_(findobj_(h,char('type'),char('text')))
        if char('textlist') == (prop):
            set_(h,char('textlistmode'),char('manual'))
        else:
            if char('textstep') == (prop):
                set_(h,char('textstepmode'),char('manual'))
        if (strcmp_(get_(h,char('textlistmode')),char('manual'))):
            lvl=get_(h,char('textlist'))
        else:
            if (strcmp_(get_(h,char('textstepmode')),char('manual'))):
                lev=get_(h,char('levellist'))
                lvl_eps=get_lvl_eps_(lev)
                stp=get_(h,char('textstep'))
                t=matlabarray([0,floor_(cumsum_(diff_(lev)) / (abs_(stp) - lvl_eps))])
                lvl=lev[[true,t[1:end() - 1] != t[2:end()]]]
                set_(h,char('textlist'),lvl)
            else:
                lvl=get_(h,char('levellist'))
                set_(h,char('textlist'),lvl,char('textstep'),get_(h,char('levelstep')))
        if (strcmp_(get_(h,char('showtext')),char('on'))):
            if char('manual') == (get__(h,char('zlevelmode'))):
                __clabel___(get_(h,char('contourmatrix')),lvl,h,get_(h,char('labelspacing')),get_(h,char('zlevel')))
            else:
                if char('auto') == (get__(h,char('zlevelmode'))):
                    __clabel___(get_(h,char('contourmatrix')),lvl,h,get_(h,char('labelspacing')),char('auto'))
                else:
                    __clabel___(get_(h,char('contourmatrix')),lvl,h,get_(h,char('labelspacing')),[])
        recursive=copy_(false)
    return
def get_lvl_eps_(lev=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[lev].count(None)+len(args)

    if (isscalar_(lev)):
        lvl_eps=abs_(lev) * sqrt_(eps) + sqrt_(eps)
    else:
        tmp=min_(abs_(diff_(lev)))
        if (tmp < 10 * eps):
            lvl_eps=sqrt_(eps)
        else:
            lvl_eps=tmp / 1000.0
    return lvl_eps
def __bar___(vertical=None,func=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[vertical,func].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(func,varargin[:],nargout=3)
    width=0.8 - 10 * eps
    group=copy_(true)
    histc=copy_(NA)
    bv=0
    if (nargin > 1 and isnumeric_(varargin[2])):
        x=varargin[1]
        if (isvector_(x)):
            x=x[:]
        y=varargin[2]
        if (isvector_(y)):
            y=y[:]
        if (rows_(x) != rows_(y)):
            y=varargin[1]
            if (isvector_(y)):
                y=y[:]
            x=[arange_(1,rows_(y))].T
            idx=2
        else:
            if (not isvector_(x)):
                error_(char('%s: X must be a vector'),func)
            idx=3
    else:
        y=varargin[1]
        if (isvector_(y)):
            y=y[:]
        x=[arange_(1,rows_(y))].T
        idx=2
    newargs=[]
    have_line_spec=copy_(false)
    while (idx <= nargin):

        if (ischar_(varargin[idx]) and strcmpi_(varargin[idx],char('grouped'))):
            group=copy_(true)
            idx
        else:
            if (ischar_(varargin[idx]) and strcmpi_(varargin[idx],char('stacked'))):
                group=copy_(false)
                idx
            else:
                if (ischar_(varargin[idx]) and strcmpi_(varargin[idx],char('histc'))):
                    group=copy_(true)
                    histc=copy_(true)
                    idx
                else:
                    if (ischar_(varargin[idx]) and strcmpi_(varargin[idx],char('hist'))):
                        group=copy_(true)
                        histc=copy_(false)
                        idx
                    else:
                        if ((ischar_(varargin[idx]) or iscellstr_(varargin[idx])) and not have_line_spec):
                            linespec,valid=__pltopt___(func,varargin[idx],false,nargout=2)
                            if (valid):
                                have_line_spec=copy_(true)
                                newargs=matlabarray([[char('facecolor'),linespec.color],newargs])
                                idx
                                continue
                        if (isscalar_(varargin[idx])):
                            width=varargin[idx]
                        else:
                            if (idx == nargin):
                                newargs=matlabarray([newargs,varargin[idx]])
                            else:
                                if (ischar_(varargin[idx]) and strcmpi_(varargin[idx],char('basevalue')) and isscalar_(varargin[idx + 1])):
                                    bv=varargin[idx + 1]
                                    idx += 2
                                else:
                                    newargs=matlabarray([newargs,varargin[idx:idx + 1]])
                                    idx += 2

    ngrp=rows_(x)
    if (ngrp != rows_(y)):
        error_(char('%s: length of X and Y must be equal'),func)
    if (any_(x[2:end()] < x[1:end() - 1])):
        error_(char('%s: X vector values must be in ascending order'),func)
    nbars=columns_(y)
    if (islogical_(histc)):
        cwidth=1
        if (nbars == 1):
            gwidth=1
        else:
            gwidth=width ** 2
    else:
        if (nbars == 1):
            cwidth=1
            gwidth=copy_(width)
        else:
            cwidth=gwidth=copy_(width)
    if (numel_(x) > 1):
        cutoff=min_(diff_(double_(x))) / 2
    else:
        cutoff=1
    if (group):
        gdelta=cutoff * gwidth / nbars
        cdelta=repmat_((1 - ((1 - cwidth) / 2)) * gdelta,size_(x))
    else:
        cdelta=repmat_(cutoff * gwidth,size_(x))
    x1=(x - cdelta)(arange_()).T
    x2=(x + cdelta)(arange_()).T
    xb=repmat_([[x1],[x1],[x2],[x2]](arange_()),1,nbars)
    if (group):
        if (islogical_(histc) and histc):
            offset=2 * cdelta * [arange_(0,(nbars - 1))] + cdelta[1]
        else:
            offset=2 * cdelta * [arange_(- (nbars - 1) / 2,(nbars - 1) / 2)]
        xb[1:4:4 * ngrp,:] += offset + (1 - cwidth) / 2 * (2 * gdelta)
        xb[2:4:4 * ngrp,:] += offset + (1 - cwidth) / 2 * (2 * gdelta)
        xb[3:4:4 * ngrp,:] += offset - (1 - cwidth) / 2 * (2 * gdelta)
        xb[4:4:4 * ngrp,:] += offset - (1 - cwidth) / 2 * (2 * gdelta)
        y0=zeros_(size_(y)) + bv
        y1=copy_(y)
    else:
        y1=cumsum_(y,2)
        y0=matlabarray([zeros_(ngrp,1) + bv,y1[:,1:end() - 1]])
    yb=zeros_(4 * ngrp,nbars)
    yb[1:4:4 * ngrp,:]=y0
    yb[2:4:4 * ngrp,:]=y1
    yb[3:4:4 * ngrp,:]=y1
    yb[4:4:4 * ngrp,:]=y0
    xb=reshape_(xb,[4,ngrp,nbars])
    yb=reshape_(yb,[4,ngrp,nbars])
    if (nargout < 2):
        oldfig=matlabarray([])
        if (not isempty_(hax)):
            oldfig=get_(0,char('currentfigure'))
        try:
            hax=newplot_(hax)
            htmp=bars_(hax,vertical,x,y,xb,yb,gwidth,group,have_line_spec,bv,newargs[:])
            if (not ishold_(hax)):
                if (all_(x[:,1] == fix_(x[:,1]))):
                    if (vertical):
                        set_(hax,char('xtick'),x[:,1])
                    else:
                        set_(hax,char('ytick'),x[:,1])
                if (vertical):
                    set_(hax,char('clim'),[0,1],char('xlimmode'),char('manual'))
                else:
                    set_(hax,char('clim'),[0,1],char('ylimmode'),char('manual'))
        finally:
            if (not isempty_(oldfig)):
                set_(0,char('currentfigure'),oldfig)
        if (nargout == 1):
            varargout[1]=htmp
    else:
        if (vertical):
            varargout[1]=xb
            varargout[2]=yb
        else:
            varargout[1]=yb
            varargout[2]=xb
    return varargout
def bars_(hax=None,vertical=None,x=None,y=None,xb=None,yb=None,width=None,group=None,have_color_spec=None,base_value=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 10-[hax,vertical,x,y,xb,yb,width,group,have_color_spec,base_value].count(None)+len(args)

    nbars=columns_(y)
    clim=get_(hax,char('clim'))
    hglist=matlabarray([])
    for i in arange_(1,nbars).reshape(-1):
        hg=hggroup_()
        hglist=matlabarray([[hglist],[hg]])
        args=__add_datasource___(char('bar'),hg,[char('x'),char('y')],varargin[:])
        if (vertical):
            if (not have_color_spec):
                if (nbars == 1):
                    lev=clim[1]
                else:
                    lev=(i - 1) * (clim[2] - clim[1]) / (nbars - 1) - clim[1]
                h=patch_(hax,xb[:,:,i],yb[:,:,i],char('FaceColor'),char('flat'),char('cdata'),lev,char('parent'),hg)
            else:
                h=patch_(hax,xb[:,:,i],yb[:,:,i],char('parent'),hg)
        else:
            if (not have_color_spec):
                if (nbars == 1):
                    lev=clim[1]
                else:
                    lev=(i - 1) * (clim[2] - clim[1]) / (nbars - 1) - clim[1]
                h=patch_(hax,yb[:,:,i],xb[:,:,i],char('FaceColor'),char('flat'),char('cdata'),lev,char('parent'),hg)
            else:
                h=patch_(hax,yb[:,:,i],xb[:,:,i],char('parent'),hg)
        if (i == 1):
            x_axis_range=get_(hax,char('xlim'))
            h_baseline=line_(hax,x_axis_range,[base_value,base_value],char('color'),[0,0,0])
            set_(h_baseline,char('handlevisibility'),char('off'),char('xliminclude'),char('off'))
            set_(h_baseline,char('parent'),get_(hg,char('parent')))
        addproperty_(char('showbaseline'),hg,char('radio'),char('{on}|off'))
        addproperty_(char('basevalue'),hg,char('data'),base_value)
        addproperty_(char('baseline'),hg,char('data'),h_baseline)
        addlistener_(hg,char('showbaseline'),[show_baseline,char('showbl')])
        addlistener_(hg,char('visible'),[show_baseline,char('visib')])
        addlistener_(hg,char('basevalue'),move_baseline)
        addproperty_(char('barwidth'),hg,char('data'),width)
        if (group):
            addproperty_(char('barlayout'),hg,char('radio'),char('stacked|{grouped}'),char('grouped'))
        else:
            addproperty_(char('barlayout'),hg,char('radio'),char('{stacked}|grouped'),char('stacked'))
        if (vertical):
            addproperty_(char('horizontal'),hg,char('radio'),char('on|{off}'),char('off'))
        else:
            addproperty_(char('horizontal'),hg,char('radio'),char('{on}|off'),char('on'))
        addlistener_(hg,char('barwidth'),update_group)
        addlistener_(hg,char('barlayout'),update_group)
        addlistener_(hg,char('horizontal'),update_group)
        addproperty_(char('edgecolor'),hg,char('patchedgecolor'),get_(h,char('edgecolor')))
        addproperty_(char('facecolor'),hg,char('patchfacecolor'),get_(h,char('facecolor')))
        addproperty_(char('linestyle'),hg,char('patchlinestyle'),get_(h,char('linestyle')))
        addproperty_(char('linewidth'),hg,char('patchlinewidth'),get_(h,char('linewidth')))
        addlistener_(hg,char('edgecolor'),update_props)
        addlistener_(hg,char('facecolor'),update_props)
        addlistener_(hg,char('linestyle'),update_props)
        addlistener_(hg,char('linewidth'),update_props)
        if (isvector_(x)):
            addproperty_(char('xdata'),hg,char('data'),x)
        else:
            addproperty_(char('xdata'),hg,char('data'),x[:,i])
        addproperty_(char('ydata'),hg,char('data'),y[:,i])
        addlistener_(hg,char('xdata'),update_data)
        addlistener_(hg,char('ydata'),update_data)
        addproperty_(char('bargroup'),hg,char('data'))
        set_(hglist,char('bargroup'),hglist)
        addproperty_(char('hittestarea'),hg,char('radio'),char('on|{off}'),char('off'))
        if (not isempty_(args)):
            set_(hg,args[:])
    update_xlim_(hax,[])
    addlistener_(hax,char('xlim'),update_xlim)
    addlistener_(h_baseline,char('ydata'),update_baseline)
    addlistener_(h_baseline,char('visible'),update_baseline)
    return hglist
def update_xlim_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    kids=get_(h,char('children'))
    xlim=get_(h,char('xlim'))
    for i in arange_(1,length_(kids)).reshape(-1):
        obj=get_(kids[i])
        if (strcmp_(obj.type,char('hggroup')) and isfield_(obj,char('baseline'))):
            if (any_(get_(obj.baseline,char('xdata')) != xlim)):
                set_(obj.baseline,char('xdata'),xlim)
    return
def update_baseline_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    visible=get_(h,char('visible'))
    ydata=get_(h,char('ydata'))(1)
    kids=get_(get_(h,char('parent')),char('children'))
    for i in arange_(1,length_(kids)).reshape(-1):
        obj=get_(kids[i])
        if (strcmp_(obj.type,char('hggroup')) and isfield_(obj,char('baseline')) and obj.baseline == h):
            set_(obj.bargroup,char('showbaseline'),visible,char('basevalue'),ydata)
            break
    return
def show_baseline_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,__,prop].count(None)+len(args)

    recursion=copy_(false)
    if (not recursion):
        try:
            recursion=copy_(true)
            hlist=get_(h,char('bargroup'))
            if (strcmp_(prop,char('showbl'))):
                showbaseline=get_(h,char('showbaseline'))
                hlist=hlist[hlist != h]
                set_(hlist,char('showbaseline'),showbaseline)
            else:
                if (strcmp_(prop,char('visib'))):
                    showbaseline=char('on')
                    if (all_(strcmp_(get_(hlist,char('visible')),char('off')))):
                        showbaseline=char('off')
            set_(get_(h,char('baseline')),char('visible'),showbaseline)
        finally:
            recursion=copy_(false)
    return
def move_baseline_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    recursion=copy_(false)
    if (not recursion):
        recursion=copy_(true)
        try:
            b0=get_(h,char('basevalue'))
            bl=get_(h,char('baseline'))
            set_(bl,char('ydata'),[b0,b0])
            if (strcmp_(get_(h,char('barlayout')),char('grouped'))):
                update_data_(h)
        finally:
            recursion=copy_(false)
    return
def update_props_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    kids=get_(h,char('children'))
    set_(kids,[char('edgecolor'),char('linewidth'),char('linestyle'),char('facecolor')],get_(h,[char('edgecolor'),char('linewidth'),char('linestyle'),char('facecolor')]))
    return
def update_data_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    recursion=copy_(false)
    if (not recursion):
        try:
            recursion=copy_(true)
            hlist=get_(h,char('bargroup'))
            x=get_(h,char('xdata'))
            if (not isvector_(x)):
                x=x[:]
            ydat=get_(hlist,char('ydata'))
            if (iscell_(ydat)):
                y=cell2mat_(ydat.T)
            else:
                y=copy_(ydat)
            xb,yb=bar_(x,y,get_(h,char('barwidth')),get_(h,char('barlayout')),char('basevalue'),get_(h,char('basevalue')),nargout=2)
            vertical=strcmp_(get_(h,char('horizontal')),char('off'))
            for i in arange_(1,columns_(y)).reshape(-1):
                hp=get_(hlist[i],char('children'))
                if (vertical):
                    set_(hp,char('xdata'),xb[:,:,i],char('ydata'),yb[:,:,i])
                else:
                    set_(hp,char('xdata'),yb[:,:,i],char('ydata'),xb[:,:,i])
        finally:
            recursion=copy_(false)
    return
def update_group_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    recursion=copy_(false)
    if (not recursion):
        try:
            recursion=copy_(true)
            hlist=get_(h,char('bargroup'))
            barwidth=get_(h,char('barwidth'))
            barlayout=get_(h,char('barlayout'))
            horizontal=get_(h,char('horizontal'))
            hlist=hlist[hlist != h]
            set_(hlist,char('barwidth'),barwidth,char('barlayout'),barlayout,char('horizontal'),horizontal)
            update_data_(h)
        finally:
            recursion=copy_(false)
    return
def __plt___(caller=None,h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[caller,h].count(None)+len(args)

    warned_callers=[]
    nargs=nargin - 2
    if (nargs > 0):
        k=1
        x_set=copy_(false)
        y_set=copy_(false)
        property_set=copy_(false)
        properties=[]
        hlegend=matlabarray([])
        fkids=get_(gcf_(),char('children'))
        for i in arange_(1,numel_(fkids)).reshape(-1):
            if (strcmp_(get_(fkids[i],char('type')),char('axes')) and strcmp_(get_(fkids[i],char('tag')),char('legend'))):
                udata=get_(fkids[i],char('userdata'))
                if (not isempty_(intersect_(udata.handle,gca_()))):
                    hlegend=fkids[i]
                    break
        setlgnd=copy_(false)
        if (isempty_(hlegend)):
            hlgnd=matlabarray([])
            tlgnd=[]
        else:
            hlgnd,tlgnd=__getlegenddata___(hlegend,nargout=2)
        retval=matlabarray([])
        while (nargs > 0 or x_set):

            if (nargs == 0):
                next_cell=[]
                next_arg=[char('')]
            else:
                next_cell=varargin[k]
                next_arg=varargin[k]
            if (isnumeric_(next_arg) and ndims_(next_arg) > 2 and any_(size_(next_arg) == 1)):
                next_arg=squeeze_(next_arg)
                if (not any_(strcmp_(caller,warned_callers)) and ndims_(next_arg) < 3):
                    warning_([char('%s: N-d inputs have been squeezed to less than '),char('three dimensions')],caller)
                    warned_callers[end() + 1]=caller
            if (isnumeric_(next_arg) and ndims_(next_arg) > 2):
                error_(char('%s: plot arrays must have less than 2 dimensions'),caller)
            nargs
            if (ischar_(next_arg) or iscellstr_(next_arg)):
                if (x_set):
                    options,valid=__pltopt___(caller,next_arg,false,nargout=2)
                    if (not valid):
                        if (nargs == 0):
                            error_(char('%s: properties must appear followed by a value'),caller)
                        properties=matlabarray([properties,[next_cell,varargin[k]]])
                        nargs
                        continue
                    else:
                        while (nargs > 0 and ischar_(varargin[k])):

                            if (nargs < 2):
                                error_(char('%s: properties must appear followed by a value'),caller)
                            properties=matlabarray([properties,varargin[k:k + 1]])
                            k += 2
                            nargs -= 2

                    if (y_set):
                        tmp=__plt2___(h,x,y,options,properties)
                        hlgnd,tlgnd,setlgnd=__plt_key___(tmp,options,hlgnd,tlgnd,setlgnd,nargout=3)
                        properties=[]
                        retval=matlabarray([[retval],[tmp]])
                    else:
                        tmp=__plt1___(h,x,options,properties)
                        hlgnd,tlgnd,setlgnd=__plt_key___(tmp,options,hlgnd,tlgnd,setlgnd,nargout=3)
                        properties=[]
                        retval=matlabarray([[retval],[tmp]])
                    x_set=copy_(false)
                    y_set=copy_(false)
                else:
                    error_(char('plot: no data to plot'))
            else:
                if (x_set):
                    if (y_set):
                        options=__pltopt___(caller,[char('')])
                        tmp=__plt2___(h,x,y,options,properties)
                        hlgnd,tlgnd,setlgnd=__plt_key___(tmp,options,hlgnd,tlgnd,setlgnd,nargout=3)
                        retval=matlabarray([[retval],[tmp]])
                        x=copy_(next_arg)
                        y_set=copy_(false)
                        properties=[]
                    else:
                        y=copy_(next_arg)
                        y_set=copy_(true)
                else:
                    x=copy_(next_arg)
                    x_set=copy_(true)

        if (setlgnd):
            legend_(gca_(),hlgnd,tlgnd)
    else:
        error_(char('__plt__: invalid number of arguments'))
    return retval
def __plt_key___(h=None,options=None,hlgnd=None,tlgnd=None,setlgnd=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[h,options,hlgnd,tlgnd,setlgnd].count(None)+len(args)

    n=numel_(h)
    if (numel_(options) == 1):
        options=repmat_(options[:],n,1)
    for i in arange_(1,n).reshape(-1):
        key=options[i].key
        if (not isempty_(key)):
            hlgnd=matlabarray([[hlgnd[:]],[h[i]]])
            tlgnd=[tlgnd[:],key]
            setlgnd=copy_(true)
    return hlgnd,tlgnd,setlgnd
def __plt1___(h=None,x1=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[h,x1,options,properties].count(None)+len(args)

    if (nargin < 3 or isempty_(options)):
        options=__default_plot_options___()
    if (not isstruct_(options)):
        error_(char('__plt1__: options must be a struct array'))
    nr,nc=size_(x1,nargout=2)
    if (nr == 1):
        x1=x1.T
        nr,nc=deal_(nc,nr,nargout=2)
    if (iscomplex_(x1)):
        x1_i=imag_(x1)
        if (any_((x1_i[:]))):
            x2=copy_(x1_i)
            x1=real_(x1)
        else:
            x2=copy_(x1)
            x1=(arange_(1,nr)).T
    else:
        x2=copy_(x1)
        x1=(arange_(1,nr)).T
    retval=__plt2___(h,x1,x2,options,properties)
    return retval
def __plt2___(h=None,x1=None,x2=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[h,x1,x2,options,properties].count(None)+len(args)

    if (nargin < 4 or isempty_(options)):
        options=__default_plot_options___()
    if (not isstruct_(options)):
        error_(char('__plt2__: options must be a struct array'))
    if (islogical_(x1)):
        x1=int8_(x1)
    else:
        if (iscomplex_((x1))):
            x1=real_(x1)
    if (islogical_(x2)):
        x2=int8_(x2)
    else:
        if (iscomplex_(x2)):
            x2=real_(x2)
    h_set=copy_(false)
    if (isempty_(x1) and isempty_(x2)):
        retval=zeros_(0,1)
    else:
        if (isscalar_(x1)):
            if (isscalar_(x2)):
                retval=__plt2ss___(h,x1,x2,options,properties)
            else:
                if (isvector_(x2)):
                    retval=__plt2sv___(h,x1,x2,options,properties)
                else:
                    error_(char('__plt2__: invalid data for plotting'))
        else:
            if (isvector_(x1)):
                if (isscalar_(x2)):
                    retval=__plt2vs___(h,x1,x2,options,properties)
                else:
                    if (isvector_(x2)):
                        retval=__plt2vv___(h,x1,x2,options,properties)
                    else:
                        if (ismatrix_(x2)):
                            retval=__plt2vm___(h,x1,x2,options,properties)
                        else:
                            error_(char('__plt2__: invalid data for plotting'))
            else:
                if (ismatrix_(x1)):
                    if (isvector_(x2)):
                        retval=__plt2mv___(h,x1,x2,options,properties)
                    else:
                        if (ismatrix_(x2)):
                            retval=__plt2mm___(h,x1,x2,options,properties)
                        else:
                            error_(char('__plt2__: invalid data for plotting'))
                else:
                    error_(char('__plt2__: invalid data for plotting'))
    return retval
def __plt2mm___(h=None,x=None,y=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[h,x,y,options,properties].count(None)+len(args)

    if (nargin < 4 or isempty_(options)):
        options=__default_plot_options___()
    x_nr,x_nc=size_(x,nargout=2)
    y_nr,y_nc=size_(y,nargout=2)
    if (x_nr != y_nr and x_nc != y_nc):
        error_(char('__plt2mm__: matrix dimensions must match'))
    if (numel_(options) == 1):
        options=repmat_(options[:],x_nc,1)
    retval=zeros_(x_nc,1)
    for i in arange_(1,x_nc).reshape(-1):
        linestyle=options[i].linestyle
        marker=options[i].marker
        if (isempty_(marker) and isempty_(linestyle)):
            linestyle,marker=__next_line_style___(nargout=2)
        color=options[i].color
        if (isempty_(color)):
            color=__next_line_color___()
        retval[i]=line_(x[:,i],y[:,i],char('color'),color,char('linestyle'),linestyle,char('marker'),marker,properties[:])
    return retval
def __plt2mv___(h=None,x=None,y=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[h,x,y,options,properties].count(None)+len(args)

    if (nargin < 4 or isempty_(options)):
        options=__default_plot_options___()
    y=y[:]
    y_nr,y_nc=size_(y,nargout=2)
    x_nr,x_nc=size_(x,nargout=2)
    if (x_nr == y_nr):
        pass
    else:
        if (x_nc == y_nr):
            x=x.T
            x_nr,x_nc=deal_(x_nc,x_nr,nargout=2)
        else:
            error_(char('__plt2mv__: matrix dimensions must match'))
    if (numel_(options) == 1):
        options=repmat_(options[:],x_nc,1)
    retval=zeros_(x_nc,1)
    for i in arange_(1,x_nc).reshape(-1):
        linestyle=options[i].linestyle
        marker=options[i].marker
        if (isempty_(marker) and isempty_(linestyle)):
            linestyle,marker=__next_line_style___(nargout=2)
        color=options[i].color
        if (isempty_(color)):
            color=__next_line_color___()
        retval[i]=line_(x[:,i],y,char('color'),color,char('linestyle'),linestyle,char('marker'),marker,properties[:])
    return retval
def __plt2ss___(h=None,x=None,y=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[h,x,y,options,properties].count(None)+len(args)

    if (nargin < 4 or isempty_(options)):
        options=__default_plot_options___()
    if (numel_(options) > 1):
        options=options[1]
    linestyle=options.linestyle
    marker=options.marker
    if (isempty_(marker) and isempty_(linestyle)):
        linestyle=char('-')
        marker=char('.')
    color=options.color
    if (isempty_(color)):
        color=__next_line_color___()
    retval=line_(x,y,char('color'),color,char('linestyle'),linestyle,char('marker'),marker,properties[:])
    return retval
def __plt2sv___(h=None,x=None,y=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[h,x,y,options,properties].count(None)+len(args)

    if (nargin < 4 or isempty_(options)):
        options=__default_plot_options___()
    _len=numel_(y)
    if (numel_(options) == 1):
        options=repmat_(options[:],_len,1)
    retval=zeros_(_len,1)
    for i in arange_(1,_len).reshape(-1):
        linestyle=options[i].linestyle
        marker=options[i].marker
        if (isempty_(marker) and isempty_(linestyle)):
            linestyle=char('-')
            marker=char('.')
        color=options[i].color
        if (isempty_(color)):
            color=__next_line_color___()
        retval[i]=line_(x,y[i],char('color'),color,char('linestyle'),linestyle,char('marker'),marker,properties[:])
    return retval
def __plt2vm___(h=None,x=None,y=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[h,x,y,options,properties].count(None)+len(args)

    if (nargin < 4 or isempty_(options)):
        options=__default_plot_options___()
    x=x[:]
    x_nr,x_nc=size_(x,nargout=2)
    y_nr,y_nc=size_(y,nargout=2)
    if (x_nr == y_nr):
        pass
    else:
        if (x_nr == y_nc):
            y=y.T
            y_nr,y_nc=deal_(y_nc,y_nr,nargout=2)
        else:
            error_(char('__plt2vm__: matrix dimensions must match'))
    if (numel_(options) == 1):
        options=repmat_(options[:],y_nc,1)
    retval=zeros_(y_nc,1)
    for i in arange_(1,y_nc).reshape(-1):
        linestyle=options[i].linestyle
        marker=options[i].marker
        if (isempty_(marker) and isempty_(linestyle)):
            linestyle,marker=__next_line_style___(nargout=2)
        color=options[i].color
        if (isempty_(color)):
            color=__next_line_color___()
        retval[i]=line_(x,y[:,i],char('color'),color,char('linestyle'),linestyle,char('marker'),marker,properties[:])
    return retval
def __plt2vs___(h=None,x=None,y=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[h,x,y,options,properties].count(None)+len(args)

    if (nargin < 4 or isempty_(options)):
        options=__default_plot_options___()
    _len=numel_(x)
    if (numel_(options) == 1):
        options=repmat_(options[:],_len,1)
    retval=zeros_(_len,1)
    for i in arange_(1,_len).reshape(-1):
        linestyle=options[i].linestyle
        marker=options[i].marker
        if (isempty_(marker) and isempty_(linestyle)):
            linestyle=char('-')
            marker=char('.')
        color=options[i].color
        if (isempty_(color)):
            color=__next_line_color___()
        retval[i]=line_(x[i],y,char('color'),color,char('linestyle'),linestyle,char('marker'),marker,properties[:])
    return retval
def __plt2vv___(h=None,x=None,y=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[h,x,y,options,properties].count(None)+len(args)

    if (nargin < 4 or isempty_(options)):
        options=__default_plot_options___()
    if (numel_(options) > 1):
        options=options[1]
    x=x[:]
    y=y[:]
    if (length_(x) != length_(y)):
        error_(char('__plt2vv__: vector lengths must match'))
    linestyle=options.linestyle
    marker=options.marker
    if (isempty_(marker) and isempty_(linestyle)):
        linestyle,marker=__next_line_style___(nargout=2)
    color=options.color
    if (isempty_(color)):
        color=__next_line_color___()
    retval=line_(x,y,char('color'),color,char('linestyle'),linestyle,char('marker'),marker,properties[:])
    return retval
def __interp_cube___(x=None,y=None,z=None,val=None,v=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[x,y,z,val,v,req].count(None)+len(args)

    if (ismatrix_(x) and ndims_(x) == 3 and ismatrix_(y) and ndims_(y) == 3 and ismatrix_(z) and ndims_(z) == 3 and size_equal_(x,y,z,val)):
        x=squeeze_(x[1,:,1])(arange_())
        y=squeeze_(y[:,1,1])(arange_())
        z=squeeze_(z[1,1,:])(arange_())
    else:
        if (isvector_(x) and isvector_(y) and isvector_(z)):
            x=x[:]
            y=y[:]
            z=z[:]
        else:
            error_(char('__interp_cube__: X, Y, Z have wrong dimensions'))
    if (size_(val) != [length_(x),length_(y),length_(z)]):
        error_(char('__interp_cube__: VAL has wrong dimensions'))
    if (columns_(v) != 3):
        error_(char('V has to be Nx3 matrix'))
    if (isempty_(v)):
        Vxyz=idx=frac=matlabarray([])
        return Vxyz,idx,frac
    if char('normals') == (req):
        idx,frac=cube_idx_(x,y,z,v,nargout=2)
        dx=x[2:end()] - x[1:end() - 1]
        dy=y[2:end()] - y[1:end() - 1]
        dz=z[2:end()] - z[1:end() - 1]
        dx=0.5.dot([[dx],[dx[end()]]](idx[:,2]))
        dy=0.5.dot([[dy],[dy[end()]]](idx[:,1]))
        dz=0.5.dot([[dz],[dz[end()]]](idx[:,3]))
        p000=matlabarray([v[:,1] - dx,v[:,2] - dy,v[:,3] - dz])
        p100=matlabarray([v[:,1] + dx,v[:,2] - dy,v[:,3] - dz])
        p010=matlabarray([v[:,1] - dx,v[:,2] + dy,v[:,3] - dz])
        p001=matlabarray([v[:,1] - dx,v[:,2] - dy,v[:,3] + dz])
        p011=matlabarray([v[:,1] - dx,v[:,2] + dy,v[:,3] + dz])
        p101=matlabarray([v[:,1] + dx,v[:,2] - dy,v[:,3] + dz])
        p110=matlabarray([v[:,1] + dx,v[:,2] + dy,v[:,3] - dz])
        p111=matlabarray([v[:,1] + dx,v[:,2] + dy,v[:,3] + dz])
        v000=interp_cube_trilin_(x,y,z,val,p000)
        v100=interp_cube_trilin_(x,y,z,val,p100)
        v010=interp_cube_trilin_(x,y,z,val,p010)
        v001=interp_cube_trilin_(x,y,z,val,p001)
        v011=interp_cube_trilin_(x,y,z,val,p011)
        v101=interp_cube_trilin_(x,y,z,val,p101)
        v110=interp_cube_trilin_(x,y,z,val,p110)
        v111=interp_cube_trilin_(x,y,z,val,p111)
        Dx=- v000+ v100- v010- v001- v011+ v101+ v110+ v111
        Dy=- v000- v100+ v010- v001+ v011- v101+ v110+ v111
        Dz=- v000- v100- v010+ v001+ v011+ v101- v110+ v111
        Vxyz=0.5.dot([Dx / dx,Dy / dy,Dz / dz])
    else:
        if char('normals8') == (req):
            idx,frac=cube_idx_(x,y,z,v,nargout=2)
            dx=x[2:end()] - x[1:end() - 1]
            dy=y[2:end()] - y[1:end() - 1]
            dz=z[2:end()] - z[1:end() - 1]
            dx=[[dx],[dx[end()]]](idx[:,2])
            dy=[[dy],[dy[end()]]](idx[:,1])
            dz=[[dz],[dz[end()]]](idx[:,3])
            Dx,Dy,Dz,idx,frac=interp_cube_trilin_grad_(x,y,z,val,v,nargout=5)
            Vxyz=matlabarray([Dx / dx,Dy / dy,Dz / dz])
        else:
            if char('values') == (req):
                Vxyz,idx,frac=interp_cube_trilin_(x,y,z,val,v,nargout=3)
            else:
                error_(char('__interp_cube__: Invalid request type "%s", use "values", "normals" or "normals8"'),req)
    return Vxyz,idx,frac
def interp_cube_trilin_(x=None,y=None,z=None,val=None,v=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[x,y,z,val,v].count(None)+len(args)

    idx,frac=cube_idx_(x[:],y[:],z[:],v,nargout=2)
    sval=size_(val)
    i000=sub2ind_(sval,idx[:,1],idx[:,2],idx[:,3])
    i100=sub2ind_(sval,idx[:,1] + 1,idx[:,2],idx[:,3])
    i010=sub2ind_(sval,idx[:,1],idx[:,2] + 1,idx[:,3])
    i001=sub2ind_(sval,idx[:,1],idx[:,2],idx[:,3] + 1)
    i101=sub2ind_(sval,idx[:,1] + 1,idx[:,2],idx[:,3] + 1)
    i011=sub2ind_(sval,idx[:,1],idx[:,2] + 1,idx[:,3] + 1)
    i110=sub2ind_(sval,idx[:,1] + 1,idx[:,2] + 1,idx[:,3])
    i111=sub2ind_(sval,idx[:,1] + 1,idx[:,2] + 1,idx[:,3] + 1)
    Bx=frac[:,1]
    By=frac[:,2]
    Bz=frac[:,3]
    Vxyz=val[i000].dot((1- Bx)).dot((1- By)).dot((1- Bz)+ val[i100]).dot(Bx).dot((1- By)).dot((1- Bz)+ val[i010]).dot((1- Bx)).dot(By).dot((1- Bz)+ val[i001]).dot((1- Bx)).dot((1- By)).dot(Bz+ val[i011]).dot((1- Bx)).dot(By).dot(Bz+ val[i101]).dot(Bx).dot((1- By)).dot(Bz+ val[i110]).dot(Bx).dot(By).dot((1- Bz)+ val[i111]).dot(Bx).dot(By).dot(Bz)
    return Vxyz,idx,frac
def interp_cube_trilin_grad_(x=None,y=None,z=None,val=None,v=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[x,y,z,val,v].count(None)+len(args)

    idx,frac=cube_idx_(x[:],y[:],z[:],v,nargout=2)
    sval=size_(val)
    i000=sub2ind_(sval,idx[:,1],idx[:,2],idx[:,3])
    i100=sub2ind_(sval,idx[:,1] + 1,idx[:,2],idx[:,3])
    i010=sub2ind_(sval,idx[:,1],idx[:,2] + 1,idx[:,3])
    i001=sub2ind_(sval,idx[:,1],idx[:,2],idx[:,3] + 1)
    i101=sub2ind_(sval,idx[:,1] + 1,idx[:,2],idx[:,3] + 1)
    i011=sub2ind_(sval,idx[:,1],idx[:,2] + 1,idx[:,3] + 1)
    i110=sub2ind_(sval,idx[:,1] + 1,idx[:,2] + 1,idx[:,3])
    i111=sub2ind_(sval,idx[:,1] + 1,idx[:,2] + 1,idx[:,3] + 1)
    Bx=frac[:,1]
    By=frac[:,2]
    Bz=frac[:,3]
    Dx=val[i000].dot(- 1).dot((1- By)).dot((1- Bz)+ val[i100]).dot((1- By)).dot((1- Bz)+ val[i010]).dot(- 1).dot(By).dot((1- Bz)+ val[i001]).dot(- 1).dot((1- By)).dot(Bz+ val[i011]).dot(- 1).dot(By).dot(Bz+ val[i101]).dot((1- By)).dot(Bz+ val[i110]).dot(By).dot((1- Bz)+ val[i111]).dot(By).dot(Bz)
    Dy=val[i000].dot((1- Bx)).dot(- 1).dot((1- Bz)+ val[i100]).dot(Bx).dot(- 1).dot((1- Bz)+ val[i010]).dot((1- Bx)).dot((1- Bz)+ val[i001]).dot((1- Bx)).dot(- 1).dot(Bz+ val[i011]).dot((1- Bx)).dot(Bz+ val[i101]).dot(Bx).dot(- 1).dot(Bz+ val[i110]).dot(Bx).dot((1- Bz)+ val[i111]).dot(Bx).dot(Bz)
    Dz=val[i000].dot((1- Bx)).dot((1- By)).dot(- 1+ val[i100]).dot(Bx).dot((1- By)).dot(- 1+ val[i010]).dot((1- Bx)).dot(By).dot(- 1+ val[i001]).dot((1- Bx)).dot((1- By)+ val[i011]).dot((1- Bx)).dot(By) + val[i101].dot(Bx).dot((1- By)+ val[i110]).dot(Bx).dot(By).dot(- 1+ val[i111]).dot(Bx).dot(By)
    return Dx,Dy,Dz,idx,frac
def cube_idx_(x=None,y=None,z=None,v=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,y,z,v].count(None)+len(args)

    idx=zeros_(size_(v))
    frac=zeros_(size_(v))
    idx[:,2]=lookup_(x[2:end() - 1],v[:,1]) + 1
    frac[:,2]=(v[:,1] - x[idx[:,2]]) / (x[idx[:,2] + 1] - x[idx[:,2]])
    idx[:,1]=lookup_(y[2:end() - 1],v[:,2]) + 1
    frac[:,1]=(v[:,2] - y[idx[:,1]]) / (y[idx[:,1] + 1] - y[idx[:,1]])
    idx[:,3]=lookup_(z[2:end() - 1],v[:,3]) + 1
    frac[:,3]=(v[:,3] - z[idx[:,3]]) / (z[idx[:,3] + 1] - z[idx[:,3]])
    return idx,frac
def __pie___(caller=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[caller].count(None)+len(args)

    h=varargin[1]
    x=abs_(varargin[2])
    iarg=3
    if (not isvector_(x)):
        error_(char('%s: expecting vector argument'),caller)
    _len=length_(x)
    have_explode=copy_(false)
    have_labels=copy_(false)
    while (iarg <= nargin - 1):

        arg=varargin[iarg]
        if (iscell_(arg)):
            labels=copy_(arg)
            have_labels=copy_(true)
            if (numel_(x) != numel_(labels)):
                error_(char('%s: mismatch in number of labels and data'),caller)
        else:
            if (isnumeric_(arg) or islogical_(arg)):
                explode=copy_(arg)
                have_explode=copy_(true)
                if (not size_equal_(x,explode)):
                    error_(char('%s: mismatch in number of elements in explode and data'),caller)
            else:
                error_(char('%s: %s is invalid as an optional argument'),caller,class_(arg))

    if (not have_explode):
        explode=zeros_(size_(x))
    normalize=copy_(true)
    if (sum_(x[:]) < 1):
        normalize=copy_(false)
    if (not have_labels):
        if (normalize):
            xp=round_(100 * x / sum_(x))
        else:
            xp=round_(100 * x)
        for i in arange_(1,_len).reshape(-1):
            labels[i]=sprintf_(char('%d%%'),xp[i])
    hlist=matlabarray([])
    refinement=90
    phi=arange_(0,360,refinement)
    if (normalize):
        xphi=cumsum_(x / sum_(x) * 360)
    else:
        xphi=cumsum_(x * 360)
    for i in arange_(1,_len).reshape(-1):
        if (i == 1):
            xn=arange_(0,xphi[i],360 / refinement)
        else:
            xn=arange_(xphi[i - 1],xphi[i],360 / refinement)
        if (xn[end()] != xphi[i]):
            xn=matlabarray([xn,xphi[i]])
        xn2=(xn[1] + xn[end()]) / 2
        if (explode[i]):
            xoff=- 0.1 * sind_(xn2)
            yoff=0.1 * cosd_(xn2)
        else:
            xoff=0
            yoff=0
        xt=- 1.2 * sind_(xn2)
        yt=1.2 * cosd_(xn2)
        if (_len == 1):
            set_(h,char('clim'),[1,2])
        else:
            set_(h,char('clim'),[1,_len])
        if (strcmp_(caller,char('pie3'))):
            ln=length_(xn)
            zlvl=0.35
            sx=repmat_(xoff + [0,- sind_(xn),0],[2,1])
            sy=repmat_(yoff + [0,cosd_(xn),0],[2,1])
            sz=matlabarray([[zeros_(1,ln + 2)],[zlvl * ones_(1,ln + 2)]])
            sc=i * ones_(size_(sz))
            hlist=matlabarray([[hlist],[patch_(xoff + [0,- sind_(xn)],yoff + [0,cosd_(xn)],zeros_(1,ln + 1),i)],[surface_(sx,sy,sz,sc)],[patch_(xoff + [0,- sind_(xn)],yoff + [0,cosd_(xn)],zlvl * ones_(1,ln + 1),i)],[text_(xt,yt,zlvl,labels[i])]])
        else:
            if (strcmp_(caller,char('pie'))):
                if (xt > 0):
                    align=char('left')
                else:
                    align=char('right')
                hlist=matlabarray([[hlist],[patch_(xoff + [0,- sind_(xn)],yoff + [0,cosd_(xn)],i)],[text_(xt,yt,labels[i],char('horizontalalignment'),align)]])
            else:
                error_(char("__pie__: unknown caller '%s'"),caller)
    addlistener_(gca,char('view'),[update_text_pos,hlist])
    if (strcmp_(caller,char('pie3'))):
        axis_([- 1.25,1.25,- 1.25,1.25,- 0.05,0.4],char('equal'),char('off'))
        view_(- 37.5,30)
    else:
        if (strcmp_(caller,char('pie'))):
            axis_([- 1.5,1.5,- 1.5,1.5],char('square'),char('off'))
    return hlist
def update_text_pos_(all_handles=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[all_handles].count(None)+len(args)

    tobj=findobj_(all_handles,char('type'),char('text'))
    s=findobj_(all_handles,char('type'),char('surface'))
    is_pie3=copy_(false)
    if (length_(s) > 0):
        is_pie3=copy_(true)
    if (length_(tobj) > 0):
        ax=get_(tobj[1],char('parent'))
        azel=get_(ax,char('view'))
        pos=get_(tobj,char('position'))
        if (iscell_(pos)):
            pos=cell2mat_(pos)
        phi=atand_(pos[:,1] / pos[:,2])
        theta,r=cart2pol_(pos[:,1],pos[:,2],nargout=2)
        theta *= 180 / pi
        theta -= azel[1]
        theta=mod_(theta,360)
        ud_mask=(theta > 180)
        lr_mask=(theta > 90) and (theta < 270)
        for i in arange_(1,length_(tobj)).reshape(-1):
            if (is_pie3):
                if (ud_mask[i]):
                    set_(tobj[i],char('position'),[pos[i,1],pos[i,2],- 0.05])
                else:
                    set_(tobj[i],char('position'),[pos[i,1],pos[i,2],0.4])
            if (lr_mask[i]):
                set_(tobj[i],char('horizontalalignment'),char('right'))
            else:
                set_(tobj[i],char('horizontalalignment'),char('left'))
    return
def __stem___(have_z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[have_z].count(None)+len(args)

    if (have_z):
        caller=char('stem3')
    else:
        caller=char('stem')
    hax,varargin,nargin=__plt_get_axis_arg___(caller,varargin[:],nargout=3)
    x,y,z,dofill,llc,ls,mmc,ms,varargin=check_stem_arg_(have_z,varargin[:],nargout=9)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        hold_state=get_(hax,char('nextplot'))
        set_(hax,char('nextplot'),char('add'))
        h=matlabarray([])
        nx=rows_(x)
        for i in arange_(1,columns_(x)).reshape(-1):
            if (have_z):
                xt=x[:].T
                xt=[[xt],[xt],[NaN_(1,nx)]](arange_())
                yt=y[:].T
                yt=[[yt],[yt],[NaN_(1,nx)]](arange_())
                zt=z[:].T
                zt=[[zeros_(1,nx)],[zt],[NaN_(1,nx)]](arange_())
            else:
                xt=x[:,i].T
                xt=[[xt],[xt],[NaN_(1,nx)]](arange_())
                yt=y[:,i].T
                yt=[[zeros_(1,nx)],[yt],[NaN_(1,nx)]](arange_())
            if (isempty_(llc)):
                lc=__next_line_color___()
            else:
                lc=copy_(llc)
            if (isempty_(mmc)):
                mc=copy_(lc)
            else:
                mc=copy_(mmc)
            if (dofill):
                fc=copy_(mc)
            else:
                fc=char('none')
            hg=hggroup_()
            h=matlabarray([[h],[hg]])
            args=__add_datasource___(caller,hg,[char('x'),char('y'),char('z')],varargin[:])
            if (have_z):
                __line___(hax,xt,yt,zt,char('color'),lc,char('linestyle'),ls,char('parent'),hg)
                __line___(hax,x,y,z,char('color'),mc,char('linestyle'),char('none'),char('marker'),ms,char('markerfacecolor'),fc,char('parent'),hg)
                h_baseline=matlabarray([])
            else:
                __line___(hax,xt,yt,char('color'),lc,char('linestyle'),ls,char('parent'),hg)
                __line___(hax,x[:,i],y[:,i],char('color'),mc,char('linestyle'),char('none'),char('marker'),ms,char('markerfacecolor'),fc,char('parent'),hg)
                x_axis_range=get_(hax,char('xlim'))
                h_baseline=line_(hax,x_axis_range,[0,0],char('color'),[0,0,0])
                set_(h_baseline,char('handlevisibility'),char('off'),char('xliminclude'),char('off'))
                addlistener_(hax,char('xlim'),update_xlim)
                addproperty_(char('basevalue'),h_baseline,char('data'),0)
                addlistener_(h_baseline,char('basevalue'),[update_baseline,0])
                addlistener_(h_baseline,char('ydata'),[update_baseline,1])
                addlistener_(h_baseline,char('visible'),[update_baseline,2])
            addproperty_(char('showbaseline'),hg,char('radio'),char('{on}|off'))
            addproperty_(char('baseline'),hg,char('data'),h_baseline)
            addproperty_(char('basevalue'),hg,char('data'),0)
            if (not have_z):
                addlistener_(hg,char('showbaseline'),show_baseline)
                addlistener_(hg,char('basevalue'),move_baseline)
            addproperty_(char('color'),hg,char('linecolor'),lc)
            addproperty_(char('linestyle'),hg,char('linelinestyle'),ls)
            addproperty_(char('linewidth'),hg,char('linelinewidth'),0.5)
            addproperty_(char('marker'),hg,char('linemarker'),ms)
            addproperty_(char('markeredgecolor'),hg,char('linemarkerfacecolor'),mc)
            addproperty_(char('markerfacecolor'),hg,char('linemarkerfacecolor'),fc)
            addproperty_(char('markersize'),hg,char('linemarkersize'),6)
            addlistener_(hg,char('color'),update_props)
            addlistener_(hg,char('linestyle'),update_props)
            addlistener_(hg,char('linewidth'),update_props)
            addlistener_(hg,char('marker'),update_props)
            addlistener_(hg,char('markeredgecolor'),update_props)
            addlistener_(hg,char('markerfacecolor'),update_props)
            addlistener_(hg,char('markersize'),update_props)
            addproperty_(char('xdata'),hg,char('data'),x[:,i])
            addproperty_(char('ydata'),hg,char('data'),y[:,i])
            if (have_z):
                addproperty_(char('zdata'),hg,char('data'),z[:,i])
            else:
                addproperty_(char('zdata'),hg,char('data'),[])
            addlistener_(hg,char('xdata'),update_data)
            addlistener_(hg,char('ydata'),update_data)
            addlistener_(hg,char('zdata'),update_data)
            addproperty_(char('hittestarea'),hg,char('radio'),char('on|{off}'),char('off'))
            if (not isempty_(args)):
                set_(hg,args[:])
            if (i == 1 and not isempty_(h_baseline)):
                set_(h_baseline,char('parent'),get_(hg,char('parent')))
        if (not strcmp_(hold_state,char('add')) and have_z):
            set_(hax,char('view'),[- 37.5,30],char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
        set_(hax,char('nextplot'),hold_state)
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    return h
def check_stem_arg_(have_z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[have_z].count(None)+len(args)

    if (have_z):
        caller=char('stem3')
    else:
        caller=char('stem')
    nargin=nargin - 1
    num_numeric=find_(cellfun_(char('isclass'),varargin,char('char')),1) - 1
    if (isempty_(num_numeric)):
        num_numeric=copy_(nargin)
    if (num_numeric < 1 or num_numeric > 3):
        print_usage_(caller)
    x=y=z=matlabarray([])
    if (num_numeric == 1):
        if (have_z):
            z=varargin[1]
        else:
            y=varargin[1]
    else:
        if (num_numeric == 2):
            if (have_z):
                error_(char('stem3: must define X, Y, and Z'))
            else:
                x=varargin[1]
                y=varargin[2]
        else:
            if (have_z):
                x=varargin[1]
                y=varargin[2]
                z=varargin[3]
            else:
                error_(char('stem: can not define Z for 2-D stem plot'))
    if (have_z):
        if (isempty_(x)):
            nr,nc=size_(z,nargout=2)
            if (nr >= nc):
                x=repmat_([arange_(1,nc)],nr,1)
                y=repmat_([arange_(1,nr)].T,1,nc)
            else:
                x=repmat_([arange_(1,nc)],nr,1)
                y=repmat_([arange_(1,nr)].T,1,nc)
        if (not (ismatrix_(x) and ismatrix_(y) and ismatrix_(z))):
            error_(char('stem3: X, Y, and Z must be numeric'))
    else:
        if (isempty_(x)):
            if (isvector_(y)):
                x=arange_(1,length_(y))
            else:
                if (ismatrix_(y)):
                    x=arange_(1,rows_(y))
        if (not (ismatrix_(x) and ismatrix_(y))):
            error_(char('stem: X and Y must be numeric'))
    if (have_z):
        if (not size_equal_(x,y,z)):
            error_(char('stem3: inconsistent sizes for X, Y, and Z'))
        x=x[:]
        y=y[:]
        z=z[:]
    else:
        if (isvector_(x)):
            x=x[:]
            if (isvector_(y)):
                if (length_(x) != length_(y)):
                    error_(char('stem: inconsistent sizes for X and Y'))
                y=y[:]
            else:
                if (length_(x) == rows_(y)):
                    x=repmat_(x[:],1,columns_(y))
                else:
                    error_(char('stem: inconsistent sizes for X and Y'))
        else:
            if (not size_equal_(x,y)):
                error_(char('stem: inconsistent sizes for X and Y'))
    dofill=copy_(false)
    have_line_spec=copy_(false)
    lc,ls,mc,ms=set_default_values_(nargout=4)
    args=[]
    ioff=num_numeric + 1
    while (ioff <= nargin):

        arg=varargin[ioff]
        if (ischar_(arg) and any_(strcmpi_(arg,[char('fill'),char('filled')]))):
            dofill=copy_(true)
        else:
            if ((ischar_(arg) or iscellstr_(arg)) and not have_line_spec):
                linespec,valid=__pltopt___(caller,arg,false,nargout=2)
                if (valid):
                    have_line_spec=copy_(true)
                    lc,ls,mc,ms=stem_line_spec_(linespec,nargout=4)
                else:
                    args[end() + 1]=arg
                    if (ioff <= nargin):
                        args[end() + 1]=varargin[ioff]
                    else:
                        error_(char('%s: No value specified for property "%s"'),caller,arg)
            else:
                args[end() + 1]=arg
                if (ioff <= nargin):
                    args[end() + 1]=varargin[ioff]
                else:
                    error_(char('%s: No value specified for property "%s"'),caller,arg)

    return x,y,z,dofill,lc,ls,mc,ms,args
def stem_line_spec_(lspec=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[lspec].count(None)+len(args)

    lc,ls,mc,ms=set_default_values_(nargout=4)
    if (not isempty_(lspec.color)):
        lc=mc=lspec.color
    if (not isempty_(lspec.linestyle) and not strcmp_(lspec.linestyle,char('none'))):
        ls=lspec.linestyle
    if (not isempty_(lspec.marker) and not strcmp_(lspec.marker,char('none'))):
        ms=lspec.marker
    return lc,ls,mc,ms
def set_default_values_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    mc=matlabarray([])
    lc=matlabarray([])
    ls=char('-')
    ms=char('o')
    return lc,ls,mc,ms
def update_xlim_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    kids=get_(h,char('children'))
    xlim=get_(h,char('xlim'))
    for i in arange_(1,length_(kids)).reshape(-1):
        obj=get_(kids[i])
        if (strcmp_(obj.type,char('hggroup')) and isfield_(obj,char('baseline'))):
            if (any_(get_(obj.baseline,char('xdata')) != xlim)):
                set_(obj.baseline,char('xdata'),xlim)
    return
def update_baseline_(h=None,__=None,src=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,__,src].count(None)+len(args)

    visible=get_(h,char('visible'))
    if (src == 0):
        basevalue=get_(h,char('basevalue'))
    else:
        basevalue=get_(h,char('ydata'))(1)
    kids=get_(get_(h,char('parent')),char('children'))
    for i in arange_(1,length_(kids)).reshape(-1):
        obj=get_(kids[i])
        if (strcmp_(obj.type,char('hggroup')) and isfield_(obj,char('baseline')) and obj.baseline == h):
            if (not strcmp_(get_(kids[i],char('showbaseline')),visible)):
                set_(kids[i],char('showbaseline'),visible)
            if (get_(kids[i],char('basevalue')) != basevalue):
                set_(kids[i],char('basevalue'),basevalue)
    return
def show_baseline_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    set_(get_(h,char('baseline')),char('visible'),get_(h,char('showbaseline')))
    return
def move_baseline_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    b0=get_(h,char('basevalue'))
    bl=get_(h,char('baseline'))
    set_(bl,char('ydata'),[b0,b0])
    kids=get_(h,char('children'))
    yt=get_(h,char('ydata'))(arange_()).T
    ny=length_(yt)
    yt=[[b0 * ones_(1,ny)],[yt],[NaN_(1,ny)]](arange_())
    set_(kids[2],char('ydata'),yt)
    return
def update_props_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    kids=get_(h,char('children'))
    set_(kids[2],char('color'),get_(h,char('color')),char('linestyle'),get_(h,char('linestyle')),char('linewidth'),get_(h,char('linewidth')))
    set_(kids[1],char('color'),get_(h,char('markeredgecolor')),char('marker'),get_(h,char('marker')),char('markerfacecolor'),get_(h,char('markerfacecolor')),char('markersize'),get_(h,char('markersize')))
    return
def update_data_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    x=get_(h,char('xdata'))
    y=get_(h,char('ydata'))
    z=get_(h,char('zdata'))
    if (not isempty_(z) and size_equal_(x,y,z)):
        sz=min_([[size_(x)],[size_(y)],[size_(z)]])
        x=x[1:sz[1],1:sz[2]]
        y=y[1:sz[1],1:sz[2]]
        z=z[1:sz[1],1:sz[2]]
    else:
        if (numel_(x) != numel_(y)):
            sz=min_([[size_(x)],[size_(y)]])
            x=x[1:sz[1],1:sz[2]]
            y=y[1:sz[1],1:sz[2]]
    bl=get_(h,char('basevalue'))
    nx=numel_(x)
    x=x[:].T
    xt=[[x],[x],[NaN_(1,nx)]](arange_())
    if (not isempty_(z)):
        y=y[:].T
        yt=[[y],[y],[NaN_(1,nx)]](arange_())
        z=z[:].T
        zt=[[bl * ones_(1,nx)],[z],[NaN_(1,nx)]](arange_())
    else:
        y=y[:].T
        yt=[[bl * ones_(1,nx)],[y],[NaN_(1,nx)]](arange_())
        zt=matlabarray([])
    kids=get_(h,char('children'))
    set_(kids[2],char('xdata'),xt,char('ydata'),yt,char('zdata'),zt)
    set_(kids[1],char('xdata'),x,char('ydata'),y,char('zdata'),z)
    return
def stem_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    htmp=__stem___(false,varargin[:])
    if (nargout > 0):
        h=copy_(htmp)
    return h
def meshz_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (not all_(cellfun_(char('isreal'),varargin))):
        error_(char('meshz: X, Y, Z, C arguments must be real'))
    hax,varargin,nargin=__plt_get_axis_arg___(char('meshz'),varargin[:],nargout=3)
    charidx=find_(cellfun_(char('isclass'),varargin,char('char')),1)
    have_c=copy_(false)
    if (isempty_(charidx)):
        if (nargin == 2 or nargin == 4):
            have_c=copy_(true)
            charidx=copy_(nargin)
        else:
            charidx=nargin + 1
    if (charidx == 2):
        z=varargin[1]
        m,n=size_(z,nargout=2)
        x=arange_(1,n)
        y=(arange_(1,m)).T
    else:
        x=varargin[1]
        y=varargin[2]
        z=varargin[3]
    if (isvector_(x) and isvector_(y)):
        x=matlabarray([x[1],x[:].T,x[end()]])
        y=matlabarray([[y[1]],[y[:]],[y[end()]]])
    else:
        x=matlabarray([[x[1,1],x[1,:],x[1,end()]],[x[:,1],x,x[:,end()]],[x[end(),1],x[end(),:],x[end(),end()]]])
        y=matlabarray([[y[1,1],y[1,:],y[1,end()]],[y[:,1],y,y[:,end()]],[y[end(),1],y[end(),:],y[end(),end()]]])
    zref=min_(z[isfinite_(z)])
    z=matlabarray([[zref.dot(ones_(1,columns_(z) + 2))],[zref.dot(ones_(rows_(z),1)),z,zref.dot(ones_(rows_(z),1))],[zref.dot(ones_(1,columns_(z) + 2))]])
    if (have_c):
        c=varargin[charidx]
        cref=min_(c[isfinite_(c)])
        c=matlabarray([[cref.dot(ones_(1,columns_(c) + 2))],[cref.dot(ones_(rows_(c),1)),c,cref.dot(ones_(rows_(c),1))],[cref.dot(ones_(1,columns_(c) + 2))]])
        varargin[charidx]=c
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=mesh_(x,y,z,varargin[charidx:end()])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def ezplot_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    htmp,needusage=__ezplot___(char('plot'),varargin[:],nargout=2)
    if (needusage):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def sphere_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('sphere'),varargin[:],nargout=3)
    if (nargin > 1):
        print_usage_()
    else:
        if (nargin == 1):
            n=varargin[1]
        else:
            n=20
    theta=linspace_(0,2 * pi,n + 1)
    phi=linspace_(- pi / 2,pi / 2,n + 1)
    theta,phi=meshgrid_(theta,phi,nargout=2)
    x=cos_(phi).dot(cos_(theta))
    y=cos_(phi).dot(sin_(theta))
    z=sin_(phi)
    if (nargout > 0):
        xx=copy_(x)
        yy=copy_(y)
        zz=copy_(z)
    else:
        oldfig=matlabarray([])
        if (not isempty_(hax)):
            oldfig=get_(0,char('currentfigure'))
        try:
            hax=newplot_(hax)
            surf_(x,y,z)
        finally:
            if (not isempty_(oldfig)):
                set_(0,char('currentfigure'),oldfig)
    return xx,yy,zz
def plotyy_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin > 1 and length_(varargin[1]) == 2 and ishandle_(varargin[1](1)) and ishandle_(varargin[1](2)) and all_(floor_(varargin[1]) != varargin[1])):
        obj1=get_(varargin[1](1))
        obj2=get_(varargin[1](2))
        if (strcmp_(obj1.type,char('axes')) or strcmp_(obj2.type,char('axes'))):
            ax=matlabarray([obj1,obj2])
            varargin[1]=[]
            if (isempty_(varargin)):
                varargin=[]
        else:
            error_(char('plotyy: expecting first argument to be axes handle'))
        oldh=gca_()
    else:
        f=get_(0,char('currentfigure'))
        if (isempty_(f)):
            f=figure_()
        ca=get_(f,char('currentaxes'))
        if (isempty_(ca)):
            ax=matlabarray([])
        else:
            if (ishandle_(ca) and isprop_(ca,char('__plotyy_axes__'))):
                ax=get_(ca,char('__plotyy_axes__'))
            else:
                ax=copy_(ca)
        if (length_(ax) > 2):
            for i in arange_(3,length_(ax)).reshape(-1):
                delete_(ax[i])
            ax=ax[1:2]
        else:
            if (length_(ax) == 1):
                ax[2]=axes_()
                set_(ax[2],char('nextplot'),get_(ax[1],char('nextplot')))
            else:
                if (isempty_(ax)):
                    ax[1]=axes_()
                    ax[2]=axes_()
                    ca=ax[2]
        if (nargin < 2):
            varargin=[]
        oldh=copy_(ca)
    if (nargin < 4):
        print_usage_()
    try:
        ax,h1,h2=__plotyy___(ax,varargin[:],nargout=3)
    finally:
        if (isaxes_(oldh)):
            axes_(oldh)
    if (nargout > 0):
        Ax=copy_(ax)
        H1=copy_(h1)
        H2=copy_(h2)
    return Ax,H1,H2
def __plotyy___(ax=None,x1=None,y1=None,x2=None,y2=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[ax,x1,y1,x2,y2].count(None)+len(args)

    if (nargin > 5):
        fun1=varargin[1]
    else:
        fun1=plot
    if (nargin > 6):
        fun2=varargin[2]
    else:
        fun2=copy_(fun1)
    xlim=matlabarray([min_([[x1[:]],[x2[:]]]),max_([[x1[:]],[x2[:]]])])
    if (isaxes_(ax[1])):
        axes_(ax[1])
    else:
        ax[1]=axes_()
    newplot_()
    h1=feval_(fun1,x1,y1)
    set_(ax[1],char('ycolor'),getcolor_(h1[1]))
    set_(ax[1],char('xlim'),xlim)
    set_(ax[1],char('color'),char('none'))
    cf=gcf_()
    set_(cf,char('nextplot'),char('add'))
    if (isaxes_(ax[2])):
        axes_(ax[2])
    else:
        ax[2]=axes_()
        set_(ax[2],char('nextplot'),get_(ax[1],char('nextplot')))
    newplot_()
    colors=get_(ax[1],char('colororder'))
    set_(ax[2],char('colororder'),[[colors[2:end(),:]],[colors[1,:]]])
    if (strcmp_(get_(ax[1],char('autopos_tag')),char('subplot'))):
        set_(ax[2],char('autopos_tag'),char('subplot'))
    else:
        set_(ax,char('activepositionproperty'),char('position'))
    set_(ax[2],char('nextplot'),char('replacechildren'))
    h2=feval_(fun2,ax[2],x2,y2)
    set_(ax[2],char('yaxislocation'),char('right'))
    set_(ax[2],char('ycolor'),getcolor_(h2[1]))
    if (strcmp_(get_(ax[1],char('activepositionproperty')),char('position'))):
        set_(ax[2],char('position'),get_(ax[1],char('position')))
    else:
        set_(ax[2],char('outerposition'),get_(ax[1],char('outerposition')))
        set_(ax[2],char('looseinset'),get_(ax[1],char('looseinset')))
    set_(ax[2],char('xlim'),xlim)
    set_(ax[2],char('color'),char('none'))
    set_(ax[2],char('box'),char('off'))
    t1=text_(0,0,char(''),char('parent'),ax[1],char('tag'),char('plotyy'),char('handlevisibility'),char('off'),char('visible'),char('off'),char('xliminclude'),char('off'),char('yliminclude'),char('off'))
    t2=text_(0,0,char(''),char('parent'),ax[2],char('tag'),char('plotyy'),char('handlevisibility'),char('off'),char('visible'),char('off'),char('xliminclude'),char('off'),char('yliminclude'),char('off'))
    set_(t1,char('deletefcn'),[deleteplotyy,ax[2],t2])
    set_(t2,char('deletefcn'),[deleteplotyy,ax[1],t1])
    addlistener_(ax[1],char('position'),[update_position,ax[2]])
    addlistener_(ax[2],char('position'),[update_position,ax[1]])
    addlistener_(ax[1],char('outerposition'),[update_position,ax[2]])
    addlistener_(ax[2],char('outerposition'),[update_position,ax[1]])
    addlistener_(ax[1],char('looseinset'),[update_position,ax[2]])
    addlistener_(ax[2],char('looseinset'),[update_position,ax[1]])
    addlistener_(ax[1],char('view'),[update_position,ax[2]])
    addlistener_(ax[2],char('view'),[update_position,ax[1]])
    addlistener_(ax[1],char('plotboxaspectratio'),[update_position,ax[2]])
    addlistener_(ax[2],char('plotboxaspectratio'),[update_position,ax[1]])
    addlistener_(ax[1],char('plotboxaspectratiomode'),[update_position,ax[2]])
    addlistener_(ax[2],char('plotboxaspectratiomode'),[update_position,ax[1]])
    addlistener_(ax[1],char('nextplot'),[update_nextplot,ax[2]])
    addlistener_(ax[2],char('nextplot'),[update_nextplot,ax[1]])
    if (ishandle_(ax[1]) and not isprop_(ax[1],char('__plotyy_axes__'))):
        addproperty_(char('__plotyy_axes__'),ax[1],char('data'),ax)
    else:
        if (ishandle_(ax[1])):
            set_(ax[1],char('__plotyy_axes__'),ax)
        else:
            error_(char("plotyy.m: This shouldn't happen. File a bug report."))
    if (ishandle_(ax[2]) and not isprop_(ax[2],char('__plotyy_axes__'))):
        addproperty_(char('__plotyy_axes__'),ax[2],char('data'),ax)
    else:
        if (ishandle_(ax[2])):
            set_(ax[2],char('__plotyy_axes__'),ax)
        else:
            error_(char("plotyy.m: This shouldn't happen. File a bug report."))
    return ax,h1,h2
def deleteplotyy_(h=None,d=None,ax2=None,t2=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[h,d,ax2,t2].count(None)+len(args)

    if (isaxes_(ax2) and (isempty_(gcbf_()) or strcmp_(get_(gcbf_(),char('beingdeleted')),char('off'))) and strcmp_(get_(ax2,char('beingdeleted')),char('off'))):
        set_(t2,char('deletefcn'),[])
        delete_(ax2)
    return
def update_nextplot_(h=None,d=None,ax2=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,d,ax2].count(None)+len(args)

    recursion=copy_(false)
    prop=char('nextplot')
    if (not recursion):
        try:
            recursion=copy_(true)
            set_(ax2,prop,get_(h,prop))
        finally:
            recursion=copy_(false)
    return
def update_position_(h=None,d=None,ax2=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,d,ax2].count(None)+len(args)

    recursion=copy_(false)
    if (not recursion):
        try:
            recursion=copy_(true)
            view=get_(h,char('view'))
            oldview=get_(ax2,char('view'))
            plotboxaspectratio=get_(h,char('plotboxaspectratio'))
            oldplotboxaspectratio=get_(ax2,char('plotboxaspectratio'))
            plotboxaspectratiomode=get_(h,char('plotboxaspectratiomode'))
            oldplotboxaspectratiomode=get_(ax2,char('plotboxaspectratiomode'))
            if (strcmp_(get_(h,char('activepositionproperty')),char('position'))):
                position=get_(h,char('position'))
                oldposition=get_(ax2,char('position'))
                if (not (isequal_(position,oldposition) and isequal_(view,oldview))):
                    set_(ax2,char('position'),position,char('view'),view)
            else:
                outerposition=get_(h,char('outerposition'))
                oldouterposition=get_(ax2,char('outerposition'))
                if (not (isequal_(outerposition,oldouterposition) and isequal_(view,oldview))):
                    set_(ax2,char('outerposition'),outerposition,char('view'),view)
            if (not (isequal_(plotboxaspectratio,oldplotboxaspectratio) and isequal_(plotboxaspectratiomode,oldplotboxaspectratiomode))):
                set_(ax2,char('plotboxaspectratio'),plotboxaspectratio)
                set_(ax2,char('plotboxaspectratiomode'),plotboxaspectratiomode)
        finally:
            recursion=copy_(false)
    return
def getcolor_(ax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[ax].count(None)+len(args)

    obj=get_(ax)
    if (isfield_(obj,char('color'))):
        color=obj.color
    else:
        if (isfield_(obj,char('facecolor')) and not ischar_(obj.facecolor)):
            color=obj.facecolor
        else:
            if (isfield_(obj,char('edgecolor')) and not ischar_(obj.edgecolor)):
                color=obj.edgecolor
            else:
                color=matlabarray([0,0,0])
    return color
def sombrero_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin > 2):
        print_usage_()
    else:
        if (n <= 1):
            error_(char('sombrero: number of grid lines N must be greater than 1'))
    xx,yy=meshgrid_(linspace_(- 8,8,n),nargout=2)
    r=sqrt_(xx ** 2 + yy ** 2) + eps
    zz=sin_(r) / r
    if (nargout == 0):
        surf_(xx,yy,zz)
    else:
        if (nargout == 1):
            x=copy_(zz)
        else:
            x=copy_(xx)
            y=copy_(yy)
            z=copy_(zz)
    return x,y,z
def peaks_(x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin == 0):
        x=y=linspace_(- 3,3,49)
    else:
        if (nargin == 1):
            if (length_(x) > 1):
                y=copy_(x)
            else:
                x=y=linspace_(- 3,3,x)
    if (isvector_(x) and isvector_(y)):
        X,Y=meshgrid_(x,y,nargout=2)
    else:
        X=copy_(x)
        Y=copy_(y)
    Z=3 * (1 - X) ** 2.dot(exp_(- X ** 2 - (Y + 1) ** 2)) - 10 * (X / 5 - X ** 3 - Y ** 5).dot(exp_(- X ** 2 - Y ** 2)) - 1 / 3 * exp_(- (X + 1) ** 2 - Y ** 2)
    if (nargout == 0):
        surf_(x,y,Z)
    else:
        if (nargout == 1):
            X_out=copy_(Z)
        else:
            X_out=copy_(X)
            Y_out=copy_(Y)
            Z_out=copy_(Z)
    return X_out,Y_out,Z_out
def pcolor_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('pcolor'),varargin[:],nargout=3)
    if (nargin == 1):
        c=varargin[1]
        nr,nc=size_(c,nargout=2)
        x=arange_(1,nc)
        y=arange_(1,nr)
        z=zeros_(nr,nc)
    else:
        if (nargin == 3):
            x=varargin[1]
            y=varargin[2]
            c=varargin[3]
            z=zeros_(size_(c))
        else:
            print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=surface_(x,y,z,c)
        set_(htmp,char('facecolor'),char('flat'))
        if (not ishold_()):
            set_(hax,char('view'),[0,90],char('box'),char('on'))
            meshgrid_fmt=copy_(true)
            if (isvector_(x)):
                xrng=x[isfinite_(x)]
            else:
                xrng=x[1,isfinite_(x[1,:])]
                if (all_(xrng == xrng[1])):
                    xrng=x[isfinite_(x[:,1]),1]
                    meshgrid_fmt=copy_(false)
            if (isvector_(y)):
                yrng=y[isfinite_(y)]
            else:
                if (meshgrid_fmt):
                    yrng=y[isfinite_(y[:,1]),1]
                else:
                    yrng=y[1,isfinite_(y[1,:])]
            if (all_(xrng == fix_(xrng))):
                xlim_([min_(xrng),max_(xrng)])
            if (all_(yrng == fix_(yrng))):
                ylim_([min_(yrng),max_(yrng)])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def shrinkfaces_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1 or nargin > 3 or nargout > 2):
        print_usage_()
    sf=0.3
    p=varargin[1]
    colors=matlabarray([])
    if (ishandle_(p) and nargin < 3):
        faces=get_(p,char('Faces'))
        vertices=get_(p,char('Vertices'))
        colors=get_(p,char('FaceVertexCData'))
        if (nargin == 2):
            sf=varargin[2]
    else:
        if (isstruct_(p) and nargin < 3):
            faces=p.faces
            vertices=p.vertices
            if (isfield_(p,char('facevertexcdata'))):
                colors=p.facevertexcdata
            if (nargin == 2):
                sf=varargin[2]
        else:
            if (ismatrix_(p) and nargin >= 2 and ismatrix_(varargin[2])):
                faces=copy_(p)
                vertices=varargin[2]
                if (nargin == 3):
                    sf=varargin[3]
            else:
                print_usage_()
    if (not isscalar_(sf) or sf <= 0):
        error_(char('shrinkfaces: scale factor must be a positive scalar'))
    n=columns_(vertices)
    if (n < 2 or n > 3):
        error_(char('shrinkfaces: only 2-D and 3-D patches are supported'))
    m=columns_(faces)
    if (m < 3):
        error_(char('shrinkfaces: faces must consist of at least 3 vertices'))
    v=vertices[faces.T(arange_()),:]
    if (isempty_(colors) or rows_(colors) == rows_(faces)):
        c=copy_(colors)
    else:
        if (rows_(colors) == rows_(vertices)):
            c=colors[faces.T(arange_()),:]
        else:
            c=matlabarray([])
    sv=rows_(v)
    midpoints=full_(kron_(speye_(sv / m),ones_(m,m) / m) * sparse_(v))
    v=sqrt_(sf) * (v - midpoints) + midpoints
    f=reshape_(arange_(1,sv),m,sv / m).T
    if 0 == (nargout):
        if (ishandle_(p)):
            set_(p,char('FaceVertexCData'),[],char('CData'),[])
            set_(p,char('Vertices'),v,char('Faces'),f,char('FaceVertexCData'),c)
        else:
            nf=struct_(char('faces'),f,char('vertices'),v,char('facevertexcdata'),c)
    else:
        if 1 == (nargout):
            nf=struct_(char('faces'),f,char('vertices'),v,char('facevertexcdata'),c)
        else:
            if 2 == (nargout):
                nf=copy_(f)
                nv=copy_(v)
    return nf,nv
def ezsurf_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    htmp,needusage=__ezplot___(char('surf'),varargin[:],nargout=2)
    if (needusage):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def area_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('area'),varargin[:],nargout=3)
    if (nargin == 0):
        print_usage_()
    x=y=matlabarray([])
    bv=0
    num_numeric=find_(cellfun_(char('isclass'),varargin,char('char')),1) - 1
    if (isempty_(num_numeric)):
        num_numeric=copy_(nargin)
    if 1 == (num_numeric):
        y=varargin[1]
    else:
        if 2 == (num_numeric):
            if (isscalar_(varargin[2])):
                y=varargin[1]
                bv=varargin[2]
            else:
                x=varargin[1]
                y=varargin[2]
        else:
            if 3 == (num_numeric):
                x=varargin[1]
                y=varargin[2]
                bv=varargin[3]
            else:
                print_usage_()
    if (not isreal_(x) or not isreal_(y)):
        error_(char('area: X and Y must be real vectors or matrices'))
    if (not isreal_(bv) or not isscalar_(bv)):
        error_(char('area: LVL must be a real scalar'))
    if (isvector_(y)):
        y=y[:]
    if (isempty_(x)):
        x=repmat_([arange_(1,rows_(y))].T,1,columns_(y))
    else:
        if (isvector_(x)):
            x=repmat_(x[:],1,columns_(y))
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=__area___(hax,x,y,bv,varargin[num_numeric + 1:end()])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def __area___(ax=None,x=None,y=None,bv=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[ax,x,y,bv].count(None)+len(args)

    y0=bv * ones_(1,rows_(y))
    y0=zeros_(1,rows_(y))
    retval=matlabarray([])
    for i in arange_(1,columns_(y)).reshape(-1):
        lc=__next_line_color___()
        hg=hggroup_()
        retval=matlabarray([[retval],[hg]])
        args=__add_datasource___(char('area'),hg,[char('x'),char('y')],varargin[:])
        x1=x[:,1].T
        y1=y[:,i].T
        addproperty_(char('xdata'),hg,char('data'),x1)
        addproperty_(char('ydata'),hg,char('data'),y1)
        addlistener_(hg,char('xdata'),update_data)
        addlistener_(hg,char('ydata'),update_data)
        if (i == 1):
            h=patch_(ax,[x1[1],x1,fliplr_(x1)],[bv,y1,bv * ones_(1,length_(y1))],lc,char('parent'),hg)
        else:
            y1=y0 + y1
            h=patch_(ax,[x1[1],x1,fliplr_(x1)],[y0[1],y1,fliplr_(y0)],lc,char('parent'),hg)
        y0=copy_(y1)
        addproperty_(char('basevalue'),hg,char('data'),bv)
        addlistener_(hg,char('basevalue'),move_baseline)
        addproperty_(char('edgecolor'),hg,char('patchedgecolor'),get_(h,char('edgecolor')))
        addproperty_(char('facecolor'),hg,char('patchfacecolor'),get_(h,char('facecolor')))
        addproperty_(char('linestyle'),hg,char('patchlinestyle'),get_(h,char('linestyle')))
        addproperty_(char('linewidth'),hg,char('patchlinewidth'),get_(h,char('linewidth')))
        addlistener_(hg,char('edgecolor'),update_props)
        addlistener_(hg,char('facecolor'),update_props)
        addlistener_(hg,char('linestyle'),update_props)
        addlistener_(hg,char('linewidth'),update_props)
        addproperty_(char('areagroup'),hg,char('data'))
        set_(retval,char('areagroup'),retval)
        addproperty_(char('hittestarea'),hg,char('radio'),char('on|{off}'),char('off'))
        if (not isempty_(args)):
            set_(hg,args[:])
    return retval
def update_props_(h=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,d].count(None)+len(args)

    kids=get_(h,char('children'))
    set_(kids,char('edgecolor'),get_(h,char('edgecolor')),char('facecolor'),get_(h,char('facecolor')),char('linestyle'),get_(h,char('linestyle')),char('linewidth'),get_(h,char('linewidth')))
    return
def move_baseline_(h=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,d].count(None)+len(args)

    recursion=copy_(false)
    if (not recursion):
        try:
            recursion=copy_(true)
            hlist=get_(h,char('areagroup'))
            b0=get_(h,char('basevalue'))
            for hh in hlist[:].T.reshape(-1):
                if (hh != h):
                    b1=get_(hh,char('basevalue'))
                    if (b1 != b0):
                        set_(hh,char('basevalue'),b0)
            update_data_(h,d)
        finally:
            recursion=copy_(false)
    return
def update_data_(h=None,d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,d].count(None)+len(args)

    hlist=get_(h,char('areagroup'))
    bv=get_(h,char('basevalue'))
    for i in arange_(1,length_(hlist)).reshape(-1):
        hh=hlist[i]
        x1=get_(hh,char('xdata'))(arange_())
        y1=get_(hh,char('ydata'))(arange_())
        set_(get_(hh,char('children')),char('xdata'),[[x1[1]],[x1],[flipud_(x1)]])
        if (i == 1):
            set_(get_(hh,char('children')),char('ydata'),[[bv],[y1],[bv * ones_(length_(y1),1)]])
        else:
            y1=y0 + y1
            set_(get_(hh,char('children')),char('ydata'),[[y0[1]],[y1],[flipud_(y0)]])
        y0=copy_(y1)
    return
def quiver3_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('quiver3'),varargin[:],nargout=3)
    if (nargin < 2):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=__quiver___(hax,true,varargin[:])
        if (not ishold_(hax)):
            set_(hax,char('view'),[- 37.5,30],char('box'),char('off'),char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def comet3_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('comet3'),varargin[:],nargout=3)
    if (nargin == 0 or nargin == 2 or nargin > 4):
        print_usage_()
    else:
        if (nargin == 1):
            z=varargin[1]
            x=y=arange_(1,numel_(z))
            p=0.1
        else:
            if (nargin == 3):
                x=varargin[1]
                y=varargin[2]
                z=varargin[3]
                p=0.1
            else:
                if (nargin == 4):
                    x=varargin[1]
                    y=varargin[2]
                    z=varargin[3]
                    p=varargin[4]
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        limits=matlabarray([min_(x),max_(x),min_(y),max_(y),min_(z),max_(z)])
        num=numel_(y)
        dn=round_(num / 10)
        hl=plot3_(x[1],y[1],z[1],char('color'),char('r'),char('marker'),char('none'),x[1],y[1],z[1],char('color'),char('g'),char('marker'),char('none'),x[1],y[1],z[1],char('color'),char('b'),char('marker'),char('o'))
        axis_(limits)
        for n in arange_(2,(num + dn)).reshape(-1):
            m=n - dn
            m=max_([m,1])
            k=min_([n,num])
            set_(hl[1],char('xdata'),x[1:m],char('ydata'),y[1:m],char('zdata'),z[1:m])
            set_(hl[2],char('xdata'),x[m:k],char('ydata'),y[m:k],char('zdata'),z[m:k])
            set_(hl[3],char('xdata'),x[k],char('ydata'),y[k],char('zdata'),z[k])
            drawnow_()
            pause_(p)
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    return
def triplot_(tri=None,x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[tri,x,y].count(None)+len(args)

    if (nargin < 3):
        print_usage_()
    idx=tri[:,[1,2,3,1]].T
    nt=rows_(tri)
    handle=plot_([[x[idx]],[NaN_(1,nt)]](arange_()),[[y[idx]],[NaN_(1,nt)]](arange_()),varargin[:])
    if (nargout > 0):
        h=copy_(handle)
    return h
def ezsurfc_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    htmp,needusage=__ezplot___(char('surfc'),varargin[:],nargout=2)
    if (needusage):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def cylinder_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,args,nargs=__plt_get_axis_arg___(char('cylinder'),varargin[:],nargout=3)
    if (nargs == 0):
        r=matlabarray([1,1])
        n=20
    else:
        if (nargs == 1):
            r=args[1]
            n=20
        else:
            if (nargs == 2):
                r=args[1]
                n=args[2]
            else:
                print_usage_()
    if (length_(r) < 2):
        error_(char('cylinder: length (R) must be larger than 2'))
    phi=linspace_(0,2 * pi,n + 1)
    idx=arange_(1,length_(r))
    phi,idx=meshgrid_(phi,idx,nargout=2)
    z=(idx - 1) / (length_(r) - 1)
    r=r[idx]
    x,y=pol2cart_(phi,r,nargout=2)
    if (nargout > 0):
        xx=copy_(x)
        yy=copy_(y)
        zz=copy_(z)
    else:
        oldfig=matlabarray([])
        if (not isempty_(hax)):
            oldfig=get_(0,char('currentfigure'))
        try:
            hax=newplot_(hax)
            surf_(x,y,z)
        finally:
            if (not isempty_(oldfig)):
                set_(0,char('currentfigure'),oldfig)
    return xx,yy,zz
def barh_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    varargout=cell_(nargout,1)
    varargout[:]=__bar___(false,char('barh'),varargin[:])
    return varargout
def stem3_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    htmp=__stem___(true,varargin[:])
    if (nargout > 0):
        h=copy_(htmp)
    return h
def bar_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    varargout=cell_(nargout,1)
    varargout[:]=__bar___(true,char('bar'),varargin[:])
    return varargout
def ezmeshc_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    htmp,needusage=__ezplot___(char('meshc'),varargin[:],nargout=2)
    if (needusage):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def waterfall_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    htmp=meshz_(varargin[:])
    set_(htmp,char('meshstyle'),char('row'))
    toolkit=get_(ancestor_(htmp,char('figure')),char('__graphics_toolkit__'))
    if (strcmp_(toolkit,char('gnuplot'))):
        warning_(char("waterfall: may not render correctly using toolkit '%s'"),toolkit)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def rectangle_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('rectangle'),varargin[:],nargout=2)
    if (isempty_(hax)):
        hax=gca_()
    else:
        hax=hax[1]
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        htmp=__rectangle___(hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def __rectangle___(hax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[hax].count(None)+len(args)

    iarg=1
    pos=matlabarray([0,0,1,1])
    curv2=matlabarray([0,0])
    ec=matlabarray([0,0,0])
    fc=char('none')
    parent=matlabarray([])
    while (iarg < length_(varargin)):

        arg=varargin[iarg]
        if (ischar_(arg)):
            if (strcmpi_(arg,char('position'))):
                pos=varargin[iarg + 1]
                varargin[iarg:iarg + 1]=[]
                if (not isvector_(pos) or numel_(pos) != 4):
                    error_(char('rectangle: position must be a 4 element vector'))
            else:
                if (strcmpi_(arg,char('curvature'))):
                    curv2=varargin[iarg + 1]
                    varargin[iarg:iarg + 1]=[]
                    if (not isnumeric_(curv2) or (numel_(curv2) != 1 and numel_(curv2) != 2)):
                        error_(char('rectangle: curvature must be a 2-element vector or a scalar'))
                    if (any_(curv2 < 0) or any_(curv2 > 1)):
                        error_(char('rectangle: curvature values must be between 0 and 1'))
                else:
                    if (strcmpi_(arg,char('edgecolor'))):
                        ec=varargin[iarg + 1]
                        varargin[iarg:iarg + 1]=[]
                    else:
                        if (strcmpi_(arg,char('facecolor'))):
                            fc=varargin[iarg + 1]
                            varargin[iarg:iarg + 1]=[]
                        else:
                            if (strcmpi_(arg,char('parent'))):
                                parent=varargin[iarg + 1]
                                varargin[iarg:iarg + 1]=[]
                            else:
                                iarg
        else:
            iarg

    if (numel_(curv2) == 1):
        a,ai=min_(pos[3:4],nargout=2)
        b,bi=max_(pos[3:4],nargout=2)
        if (ai < bi):
            curv=matlabarray([curv2,curv2.dot(a) / b])
        else:
            curv=matlabarray([curv2.dot(a) / b,curv2])
    else:
        curv=copy_(curv2)
    if (all_(curv < 0.01)):
        x=matlabarray([pos[1],pos[1] + pos[3],pos[1] + pos[3],pos[1],pos[1]])
        y=matlabarray([pos[2],pos[2],pos[2] + pos[4],pos[2] + pos[4],pos[2]])
    else:
        p=pi / 2 * [arange_(0,15)] / 15
        c=curv.dot(pos[3:4]) / 2
        cx=c[1] * sin_(p) - c[1]
        cy=c[2] * cos_(p) - c[2]
        x=matlabarray([pos[1] - fliplr_(cx),pos[1] + pos[3] + cx,pos[1] + pos[3] + fliplr_(cx),pos[1] - cx,pos[1]])
        y=matlabarray([pos[2] - fliplr_(cy),pos[2] - cy,pos[2] + pos[4] + fliplr_(cy),pos[2] + pos[4] + cy,pos[2] + c[2]])
    if (not isempty_(parent)):
        hg=hggroup_(char('parent'),parent)
    else:
        hg=hggroup_(char('parent'),hax)
    h=patch_(char('xdata'),x[:],char('ydata'),y[:],char('facecolor'),fc,char('edgecolor'),ec,char('parent'),hg,varargin[:])
    addproperty_(char('curvature'),hg,char('data'),curv2)
    addproperty_(char('position'),hg,char('data'),pos)
    addproperty_(char('edgecolor'),hg,char('patchedgecolor'),get_(h,char('edgecolor')))
    addproperty_(char('linewidth'),hg,char('patchlinewidth'),get_(h,char('linewidth')))
    addproperty_(char('linestyle'),hg,char('patchlinestyle'),get_(h,char('linestyle')))
    addproperty_(char('facecolor'),hg,char('patchfacecolor'),get_(h,char('facecolor')))
    addlistener_(hg,char('curvature'),update_data)
    addlistener_(hg,char('position'),update_data)
    addlistener_(hg,char('edgecolor'),update_props)
    addlistener_(hg,char('linewidth'),update_props)
    addlistener_(hg,char('linestyle'),update_props)
    addlistener_(hg,char('facecolor'),update_props)
    return hg
def update_data_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    recursion=copy_(false)
    if (not recursion):
        try:
            recursion=copy_(true)
            kids=get_(h,char('children'))
            pos=get_(h,char('position'))
            curv2=get_(h,char('curvature'))
            if (numel_(curv2) == 1):
                a,ai=min_(pos[3:4],nargout=2)
                b,bi=max_(pos[3:4],nargout=2)
                if (ai < bi):
                    curv=matlabarray([curv2,curv2.dot(a) / b])
                else:
                    curv=matlabarray([curv2.dot(a) / b,curv2])
            else:
                curv=copy_(curv2)
            if (all_(curv < 0.01)):
                x=matlabarray([pos[1],pos[1] + pos[3],pos[1] + pos[3],pos[1],pos[1]])
                y=matlabarray([pos[2],pos[2],pos[2] + pos[4],pos[2] + pos[4],pos[2]])
            else:
                p=pi / 2 * [arange_(0,15)] / 15
                c=curv.dot(pos[3:4]) / 2
                cx=c[1] * sin_(p) - c[1]
                cy=c[2] * cos_(p) - c[2]
                x=matlabarray([pos[1] - fliplr_(cx),pos[1] + pos[3] + cx,pos[1] + pos[3] + fliplr_(cx),pos[1] - cx,pos[1]])
                y=matlabarray([pos[2] - fliplr_(cy),pos[2] - cy,pos[2] + pos[4] + fliplr_(cy),pos[2] + pos[4] + cy,pos[2] + c[2]])
            set_(kids,char('xdata'),x,char('ydata'),y)
        finally:
            recursion=copy_(false)
    return
def update_props_(h=None,__=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,__].count(None)+len(args)

    kids=get_(h,char('children'))
    set_(kids,[char('edgecolor'),char('linewidth'),char('linestyle'),char('facecolor')],get_(h,[char('edgecolor'),char('linewidth'),char('linestyle'),char('facecolor')]))
    return
def plot_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargs=__plt_get_axis_arg___(char('plot'),varargin[:],nargout=3)
    if (nargs < 1):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=__plt___(char('plot'),hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def tetramesh_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    reg,prop=parseparams_(varargin,nargout=2)
    if (length_(reg) < 2 or length_(reg) > 3):
        print_usage_()
    T=reg[1]
    X=reg[2]
    if (not ismatrix_(T) or columns_(T) != 4):
        error_(char('tetramesh: T must be an n-by-4 matrix'))
    else:
        if (not ismatrix_(X) or columns_(X) != 3):
            error_(char('tetramesh: X must be an n-by-3 matrix'))
    size_T=rows_(T)
    cmap=colormap_()
    if (length_(reg) < 3):
        size_cmap=rows_(cmap)
        C=mod_((arange_(1,size_T)).T - 1,size_cmap) + 1
        if (size_T < size_cmap and size_T > 1):
            C=floor_((C - 1) * (size_cmap - 1) / (size_T - 1)) + 1
    else:
        C=reg[3]
        if (not isvector_(C) or size_T != length_(C)):
            error_(char('tetramesh: C must be a vector of the same length as T'))
    hax=newplot_()
    hvec=zeros_(size_T,1)
    if (strcmp_(graphics_toolkit_(),char('gnuplot'))):
        for i in arange_(1,size_T).reshape(-1):
            th,p=__shrink___([1,2,3,4],X[T[i,:],:],1 - 1e-07,nargout=2)
            hvec[i]=patch_(char('Faces'),th,char('Vertices'),p,char('FaceColor'),cmap[C[i],:],char('FaceAlpha'),0.9,prop[:])
    else:
        for i in arange_(1,size_T).reshape(-1):
            th=matlabarray([[1,2,3],[2,3,4],[3,4,1],[4,1,2]])
            hvec[i]=patch_(char('Faces'),th,char('Vertices'),X[T[i,:],:],char('FaceColor'),cmap[C[i],:],char('FaceAlpha'),1.0,prop[:])
    if (not ishold_()):
        set_(hax,char('view'),[- 37.5,30],char('box'),char('off'))
    if (nargout > 0):
        h=copy_(hvec)
    return h
def __shrink___(T=None,X=None,sf=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[T,X,sf].count(None)+len(args)

    midpoint=repmat_(sum_(X[T,:],1) / 4,12,1)
    p=matlabarray([[X[[1,2,3],:]],[X[[2,3,4],:]],[X[[3,4,1],:]],[X[[4,1,2],:]]])
    p=sf * (p - midpoint) + midpoint
    tri=reshape_(arange_(1,12),3,4).T
    return tri,p
def plotmatrix_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    bigax2,varargin,nargin=__plt_get_axis_arg___(char('plotmatrix'),varargin[:],nargout=3)
    if (nargin > 3 or nargin < 1):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(bigax2)):
        oldfig=get_(0,char('currentfigure'))
    try:
        bigax2=newplot_(bigax2)
        h2,ax2,p2,pax2=__plotmatrix___(bigax2,varargin[:],nargout=4)
        axes_(bigax2)
        ctext=text_(0,0,char(''),char('visible'),char('off'),char('handlevisibility'),char('off'),char('xliminclude'),char('off'),char('yliminclude'),char('off'),char('zliminclude'),char('off'),char('deletefcn'),[plotmatrixdelete,[[ax2],[pax2]]])
        set_(bigax2,char('visible'),char('off'))
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(h2)
        ax=copy_(ax2)
        bigax=copy_(bigax2)
        p=copy_(p2)
        pax=copy_(pax2)
    return h,ax,bigax,p,pax
def plotmatrixdelete_(h=None,d=None,ax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,d,ax].count(None)+len(args)

    for i in arange_(1,numel_(ax)).reshape(-1):
        hc=ax[i]
        if (isaxes_(hc) and strcmpi_(get_(hc,char('beingdeleted')),char('off'))):
            parent=get_(hc,char('parent'))
            if (ishandle_(parent) and strcmpi_(get_(parent,char('beingdeleted')),char('off'))):
                delete_(hc)
    return
def __plotmatrix___(bigax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[bigax].count(None)+len(args)

    have_line_spec=copy_(false)
    have_hist=copy_(false)
    parent=get_(bigax,char('parent'))
    for i in arange_(1,nargin - 1).reshape(-1):
        arg=varargin[i]
        if (ischar_(arg) or iscellstr_(arg)):
            linespec,valid=__pltopt___(char('plotmatrix'),varargin[i],false,nargout=2)
            if (valid):
                have_line_spec=copy_(true)
                linespec=varargin[i]
                varargin[i]=[]
                nargin=nargin - 1
                break
            else:
                print_usage_(char('plotmatrix'))
    if (nargin == 2):
        X=varargin[1]
        Y=copy_(X)
        have_hist=copy_(true)
    else:
        if (nargin == 3):
            X=varargin[1]
            Y=varargin[2]
        else:
            print_usage_(char('plotmatrix'))
    if (rows_(X) != rows_(Y)):
        error_(char('plotmatrix: dimension mismatch in the arguments'))
    dummy,m=size_(X,nargout=2)
    dummy,n=size_(Y,nargout=2)
    h=matlabarray([])
    ax=matlabarray([])
    p=matlabarray([])
    pax=matlabarray([])
    xsize=0.9 / m
    ysize=0.9 / n
    xoff=0.05
    yoff=0.05
    border=[0.13,0.11,0.225,0.185].dot([xsize,ysize,xsize,ysize])
    border[3:4]=- border[3:4] - border[1:2]
    for i in arange_(1,m).reshape(-1):
        for j in arange_(1,n).reshape(-1):
            pos=matlabarray([xsize * (i - 1) + xoff,ysize * (n - j) + yoff,xsize,ysize])
            tmp=axes_(char('outerposition'),pos,char('position'),pos + border,char('parent'),parent)
            if (i == j and have_hist):
                pax=matlabarray([[pax],[tmp]])
                nn,xx=hist_(X[:,i],nargout=2)
                tmp=bar_(xx,nn,1.0)
                p=matlabarray([[p],[tmp]])
            else:
                ax=matlabarray([[ax],[tmp]])
                if (have_line_spec):
                    tmp=plot_(X[:,i],Y[:,j],linespec)
                else:
                    tmp=plot_(X[:,i],Y[:,j],char('.'))
                h=matlabarray([[h],[tmp]])
    return h,ax,p,pax
def errorbar_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('errorbar'),varargin[:],nargout=2)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=__errcomm___(char('errorbar'),hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def isocolors_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    calc_rgb=copy_(false)
    if 2 == (nargin):
        c=varargin[1]
        vp=varargin[2]
        x=arange_(1,size_(c,2))
        y=arange_(1,size_(c,1))
        z=arange_(1,size_(c,3))
    else:
        if 4 == (nargin):
            calc_rgb=copy_(true)
            R=varargin[1]
            G=varargin[2]
            B=varargin[3]
            vp=varargin[4]
            x=arange_(1,size_(R,1))
            y=arange_(1,size_(R,2))
            z=arange_(1,size_(R,3))
        else:
            if 5 == (nargin):
                x=varargin[1]
                y=varargin[2]
                z=varargin[3]
                c=varargin[4]
                vp=varargin[5]
            else:
                if 7 == (nargin):
                    calc_rgb=copy_(true)
                    x=varargin[1]
                    y=varargin[2]
                    z=varargin[3]
                    R=varargin[4]
                    G=varargin[5]
                    B=varargin[6]
                    vp=varargin[7]
                else:
                    print_usage_()
    if (ismatrix_(vp) and columns_(vp) == 3):
        pa=matlabarray([])
        v=copy_(vp)
    else:
        if (ishandle_(vp)):
            pa=copy_(vp)
            v=get_(pa,char('Vertices'))
        else:
            error_(char('isocolors: last argument is not a vertex list or patch handle'))
    if (calc_rgb):
        new_col=zeros_(rows_(v),3)
        new_col[:,1]=__interp_cube___(x,y,z,R,v,char('values'))
        new_col[:,2]=__interp_cube___(x,y,z,G,v,char('values'))
        new_col[:,3]=__interp_cube___(x,y,z,B,v,char('values'))
    else:
        new_col=__interp_cube___(x,y,z,c,v,char('values'))
    if 0 == (nargout):
        if (not isempty_(pa)):
            set_(pa,char('FaceVertexCData'),new_col)
    else:
        if 1 == (nargout):
            varargout=[new_col]
        else:
            print_usage_()
    return varargout
def contourc_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1 or nargin > 4):
        print_usage_()
    if (nargin == 1):
        z=varargin[1]
        x=arange_(1,columns_(z))
        y=arange_(1,rows_(z))
        vn=10
    else:
        if (nargin == 2):
            z=varargin[1]
            x=arange_(1,columns_(z))
            y=arange_(1,rows_(z))
            vn=varargin[2]
        else:
            if (nargin == 3):
                x=varargin[1]
                y=varargin[2]
                z=varargin[3]
                vn=10
            else:
                if (nargin == 4):
                    x=varargin[1]
                    y=varargin[2]
                    z=varargin[3]
                    vn=varargin[4]
    if (not ismatrix_(z) or not ismatrix_(x) or not ismatrix_(y)):
        error_(char('contourc: X, Y, and Z must be matrices'))
    if (isscalar_(vn)):
        vv=linspace_(min_(z[:]),max_(z[:]),vn + 2)(arange_(2,end() - 1))
    else:
        vv=unique_(sort_(vn))
    if (isvector_(x) and isvector_(y)):
        cdat=__contourc___(x[:].T,y[:].T,z,vv)
    else:
        if (not any_(bsxfun_(minus,x,x[1,:])(arange_())) and not any_(bsxfun_(minus,y,y[:,1])(arange_()))):
            cdat=__contourc___(x[1,:],y[:,1].T,z,vv)
        else:
            nr,nc=size_(z,nargout=2)
            ii=arange_(1,nc)
            jj=arange_(1,nr)
            cdat=__contourc___(ii,jj,z,vv)
            i=1
            while (i < columns_(cdat)):

                clen=cdat[2,i]
                idx=i + (arange_(1,clen))
                ci=cdat[1,idx]
                cj=cdat[2,idx]
                ci=max_(ci,1)
                ci=min_(ci,nc)
                cj=max_(cj,1)
                cj=min_(cj,nr)
                cdat[1,idx]=interp2_(ii,jj,x,ci,cj)
                cdat[2,idx]=interp2_(ii,jj,y,ci,cj)
                i += clen + 1

    if (nargout > 0):
        c=copy_(cdat)
        lev=copy_(vv)
    return c,lev
def line_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('line'),varargin[:],nargout=2)
    if (isempty_(hax)):
        hax=gca_()
    htmp=__line___(hax,varargin[:])
    if (nargout > 0):
        h=copy_(htmp)
    return h
def polar_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargs=__plt_get_axis_arg___(char('polar'),varargin[:],nargout=3)
    if (nargs < 1):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        if (nargs == 3):
            if (not ischar_(varargin[3])):
                error_(char('polar: FMT argument must be a string'))
            htmp=__plr2___(hax,varargin[:])
            maxr=max_(varargin[2](arange_()))
        else:
            if (nargs == 2):
                if (ischar_(varargin[2])):
                    htmp=__plr1___(hax,varargin[:])
                    if (iscomplex_(varargin[1])):
                        maxr=max_(imag_(varargin[1])(arange_()))
                    else:
                        maxr=max_(varargin[1](arange_()))
                else:
                    fmt=char('')
                    htmp=__plr2___(hax,varargin[:],fmt)
                    maxr=max_(varargin[2](arange_()))
            else:
                if (nargs == 1):
                    fmt=char('')
                    htmp=__plr1___(hax,varargin[:],fmt)
                    if (iscomplex_(varargin[1])):
                        maxr=max_(imag_(varargin[1])(arange_()))
                    else:
                        maxr=max_(varargin[1](arange_()))
                else:
                    print_usage_()
        set_(hax,char('xlim'),[- maxr,maxr],char('ylim'),[- maxr,maxr],char('xaxislocation'),char('zero'),char('yaxislocation'),char('zero'),char('plotboxaspectratio'),[1,1,1])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def __plr1___(h=None,theta=None,fmt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,theta,fmt].count(None)+len(args)

    theta=theta[:]
    if (iscomplex_(theta)):
        rho=imag_(theta)
        theta=real_(theta)
    else:
        rho=copy_(theta)
        theta=(arange_(1,rows_(rho))).T
    retval=__plr2___(h,theta,rho,fmt)
    return retval
def __plr2___(h=None,theta=None,rho=None,fmt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[h,theta,rho,fmt].count(None)+len(args)

    if (ndims_(theta) > 2 or ndims_(rho) > 2):
        error_(char('polar: THETA and RHO must be 2-D objects'))
    theta=real_(theta)
    rho=real_(rho)
    if (isscalar_(theta)):
        if (isscalar_(rho)):
            x=rho * cos_(theta)
            y=rho * sin_(theta)
            retval=__plt___(char('polar'),h,x,y,fmt)
        else:
            error_(char("polar: Can't plot constant THETA with varying RHO"))
    else:
        if (isvector_(theta)):
            if (isvector_(rho)):
                if (length_(theta) != length_(rho)):
                    error_(char('polar: THETA and RHO vector lengths must match'))
                rho=rho[:]
                theta=theta[:]
                x=rho.dot(cos_(theta))
                y=rho.dot(sin_(theta))
                retval=__plt___(char('polar'),h,x,y,fmt)
            else:
                if (ismatrix_(rho)):
                    theta=theta[:]
                    t_nr=rows_(theta)
                    r_nr,r_nc=size_(rho,nargout=2)
                    if (t_nr != r_nr):
                        rho=rho.T
                        r_nr=copy_(r_nc)
                    if (t_nr != r_nr):
                        error_(char('polar: THETA vector and RHO matrix sizes must match'))
                    x=diag_(cos_(theta)) * rho
                    y=diag_(sin_(theta)) * rho
                    retval=__plt___(char('polar'),h,x,y,fmt)
                else:
                    error_(char('polar: invalid data for plotting'))
        else:
            if (ismatrix_(theta)):
                if (isvector_(rho)):
                    rho=rho[:]
                    r_nr=rows_(rho)
                    t_nr,t_nc=size_(theta,nargout=2)
                    if (r_nr != t_nr):
                        theta=theta.T
                        t_nr=copy_(t_nc)
                    if (r_nr != t_nr):
                        error_(char('polar: THETA matrix and RHO vector sizes must match'))
                    diag_r=diag_(rho)
                    x=diag_r * cos_(theta)
                    y=diag_r * sin_(theta)
                    retval=__plt___(char('polar'),h,x,y,fmt)
                else:
                    if (ismatrix_(rho)):
                        if (not size_equal_(rho,theta)):
                            error_(char('polar: THETA and RHO matrix dimensions must match'))
                        x=rho.dot(cos_(theta))
                        y=rho.dot(sin_(theta))
                        retval=__plt___(char('polar'),h,x,y,fmt)
                    else:
                        error_(char('polar: invalid data for plotting'))
            else:
                error_(char('polar: invalid data for plotting'))
    return retval
def trimesh_(tri=None,x=None,y=None,z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[tri,x,y,z].count(None)+len(args)

    if (nargin < 3):
        print_usage_()
    if (nargin == 3):
        htmp=triplot_(tri,x,y)
    else:
        if (ischar_(z)):
            htmp=triplot_(tri,x,y,z,varargin[:])
        else:
            if (nargin > 4 and isnumeric_(varargin[1])):
                c=varargin[1]
                varargin[1]=[]
                if (isvector_(c)):
                    if (numel_(c) != numel_(z)):
                        error_(char("trimesh: C must have 'numel (Z)' elements"))
                    c=c[:]
                else:
                    if (rows_(c) != numel_(z) or columns_(c) != 3):
                        error_(char("trimesh: TrueColor C matrix must be 'numel (Z)' rows by 3 columns"))
            else:
                c=z[:]
            hax=newplot_()
            htmp=patch_(char('Vertices'),[x[:],y[:],z[:]],char('Faces'),tri,char('FaceVertexCdata'),c,char('EdgeColor'),char('flat'),char('FaceColor'),char('w'),char('Tag'),char('trimesh'),varargin[:])
            if (not ishold_()):
                set_(hax,char('view'),[- 37.5,30],char('box'),char('off'),char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
    if (nargout > 0):
        h=copy_(htmp)
    return h
def mesh_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (not all_(cellfun_(char('isreal'),varargin))):
        error_(char('mesh: X, Y, Z, C arguments must be real'))
    hax,varargin,nargin=__plt_get_axis_arg___(char('mesh'),varargin[:],nargout=3)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=surface_(varargin[:])
        set_(htmp,char('facecolor'),char('w'))
        set_(htmp,char('edgecolor'),char('flat'))
        if (not ishold_()):
            set_(hax,char('view'),[- 37.5,30],char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def contourf_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('contour'),varargin[:],nargout=2)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        ctmp,htmp=__contour___(hax,char('none'),char('fill'),char('on'),char('linecolor'),char('black'),varargin[:],nargout=2)
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        c=copy_(ctmp)
        h=copy_(htmp)
    return c,h
def semilogx_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargs=__plt_get_axis_arg___(char('semilogx'),varargin[:],nargout=3)
    if (nargs < 1):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        set_(hax,char('xscale'),char('log'))
        if (not ishold_(hax)):
            set_(hax,char('xminortick'),char('on'))
        htmp=__plt___(char('semilogx'),hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def plot3_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargs=__plt_get_axis_arg___(char('plot3'),varargin[:],nargout=3)
    if (nargs < 1):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        x_set=0
        y_set=0
        z_set=0
        property_set=0
        fmt_set=0
        properties=[]
        tlgnd=[]
        hlgnd=matlabarray([])
        idx=0
        arg=0
        while (arg < nargs):

            new=varargin[arg]
            new_cell=varargin[arg]
            if (property_set):
                properties=matlabarray([properties,new_cell])
                property_set=0
                continue
            if (ischar_(new)):
                if (not z_set):
                    if (not y_set):
                        if (not x_set):
                            error_(char('plot3: needs X, [ Y, [ Z ] ]'))
                        else:
                            y=real_(x)
                            z=imag_(x)
                            y_set=1
                            z_set=1
                            if (rows_(x) > 1):
                                x=repmat_((arange_(1,rows_(x))).T,1,columns_(x))
                            else:
                                x=arange_(1,columns_(x))
                    else:
                        z=imag_(y)
                        y=real_(y)
                        z_set=1
                if (not fmt_set):
                    options,valid=__pltopt___(char('plot3'),new,false,nargout=2)
                    if (not valid):
                        properties=matlabarray([properties,new_cell])
                        property_set=1
                        continue
                    else:
                        fmt_set=1
                        while (arg < nargs and ischar_(varargin[arg + 1])):

                            if (nargs - arg < 2):
                                error_(char('plot3: properties must appear followed by a value'))
                            properties=matlabarray([properties,varargin[arg + 1:arg + 2]])
                            arg += 2

                else:
                    properties=matlabarray([properties,new_cell])
                    property_set=1
                    continue
                if (isvector_(x) and isvector_(y)):
                    if (isvector_(z)):
                        x=x[:]
                        y=y[:]
                        z=z[:]
                    else:
                        if (length_(x) == rows_(z) and length_(y) == columns_(z)):
                            x,y=meshgrid_(x,y,nargout=2)
                        else:
                            error_(char('plot3: [length(X), length(Y)] must match size (Z)'))
                if (not size_equal_(x,y,z)):
                    error_(char('plot3: X, Y, and Z must have the same shape'))
                else:
                    if (ndims_(x) > 2):
                        error_(char('plot3: X, Y, and Z must not have more than two dimensions'))
                for i in arange_(1,columns_(x)).reshape(-1):
                    linestyle=options.linestyle
                    marker=options.marker
                    if (isempty_(marker) and isempty_(linestyle)):
                        linestyle,marker=__next_line_style___(nargout=2)
                    color=options.color
                    if (isempty_(color)):
                        color=__next_line_color___()
                    htmp[++ idx]=line_(x[:,i],y[:,i],z[:,i],char('color'),color,char('linestyle'),linestyle,char('marker'),marker,properties[:])
                    key=options.key
                    if (not isempty_(key)):
                        hlgnd=matlabarray([hlgnd,htmp[idx]])
                        tlgnd=[tlgnd[:],key]
                x_set=0
                y_set=0
                z_set=0
                fmt_set=0
                properties=[]
            else:
                if (not x_set):
                    x=copy_(new)
                    x_set=1
                else:
                    if (not y_set):
                        y=copy_(new)
                        y_set=1
                    else:
                        if (not z_set):
                            z=copy_(new)
                            z_set=1
                        else:
                            if (isvector_(x) and isvector_(y)):
                                if (isvector_(z)):
                                    x=x[:]
                                    y=y[:]
                                    z=z[:]
                                else:
                                    if (length_(x) == rows_(z) and length_(y) == columns_(z)):
                                        x,y=meshgrid_(x,y,nargout=2)
                                    else:
                                        error_(char('plot3: [length(X), length(Y)] must match size (Z)'))
                            if (not size_equal_(x,y,z)):
                                error_(char('plot3: X, Y, and Z must have the same shape'))
                            else:
                                if (ndims_(x) > 2):
                                    error_(char('plot3: X, Y, and Z must not have more than two dimensions'))
                            options=__default_plot_options___()
                            for i in arange_(1,columns_(x)).reshape(-1):
                                linestyle=options.linestyle
                                marker=options.marker
                                if (isempty_(marker) and isempty_(linestyle)):
                                    linestyle,marker=__next_line_style___(nargout=2)
                                color=options.color
                                if (isempty_(color)):
                                    color=__next_line_color___()
                                htmp[++ idx]=line_(x[:,i],y[:,i],z[:,i],char('color'),color,char('linestyle'),linestyle,char('marker'),marker,properties[:])
                                key=options.key
                                if (not isempty_(key)):
                                    hlgnd=matlabarray([hlgnd,htmp[idx]])
                                    tlgnd=[tlgnd[:],key]
                            x=copy_(new)
                            y_set=0
                            z_set=0
                            fmt_set=0
                            properties=[]

        if (property_set):
            error_(char('plot3: properties must appear followed by a value'))
        if (x_set):
            if (y_set):
                if (not z_set):
                    z=imag_(y)
                    y=real_(y)
                    z_set=1
            else:
                y=real_(x)
                z=imag_(x)
                y_set=1
                z_set=1
                if (rows_(x) > 1):
                    x=repmat_((arange_(1,rows_(x))).T,1,columns_(x))
                else:
                    x=arange_(1,columns_(x))
            if (isvector_(x) and isvector_(y)):
                if (isvector_(z)):
                    x=x[:]
                    y=y[:]
                    z=z[:]
                else:
                    if (length_(x) == rows_(z) and length_(y) == columns_(z)):
                        x,y=meshgrid_(x,y,nargout=2)
                    else:
                        error_(char('plot3: [length(X), length(Y)] must match size (Z)'))
            if (not size_equal_(x,y,z)):
                error_(char('plot3: X, Y, and Z must have the same shape'))
            else:
                if (ndims_(x) > 2):
                    error_(char('plot3: X, Y, and Z must not have more than two dimensions'))
            options=__default_plot_options___()
            for i in arange_(1,columns_(x)).reshape(-1):
                linestyle=options.linestyle
                marker=options.marker
                if (isempty_(marker) and isempty_(linestyle)):
                    linestyle,marker=__next_line_style___(nargout=2)
                color=options.color
                if (isempty_(color)):
                    color=__next_line_color___()
                htmp[++ idx]=line_(x[:,i],y[:,i],z[:,i],char('color'),color,char('linestyle'),linestyle,char('marker'),marker,properties[:])
                key=options.key
                if (not isempty_(key)):
                    hlgnd=matlabarray([hlgnd,htmp[idx]])
                    tlgnd=[tlgnd[:],key]
        if (not isempty_(hlgnd)):
            legend_(hax,hlgnd,tlgnd)
        if (not ishold_()):
            set_(hax,char('view'),[- 37.5,30])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0 and idx > 0):
        retval=copy_(htmp)
    return retval
def hist_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('hist'),varargin[:],nargout=3)
    if (nargin < 1):
        print_usage_()
    y=varargin[1]
    varargin=varargin[2:end()]
    arg_is_vector=isvector_(y)
    if (arg_is_vector):
        y=y[:]
    if (not isreal_(y)):
        error_(char('hist: Y must be real valued'))
    max_val=max_(y[:])
    min_val=min_(y[:])
    iarg=1
    if (nargin == 1 or ischar_(varargin[iarg])):
        n=10
        x=[arange_(0.5,n)].T / n
        x=x * (max_val - min_val) + ones_(size_(x)) * min_val
    else:
        x=varargin[iarg]
        if (isscalar_(x)):
            n=copy_(x)
            if (n <= 0):
                error_(char('hist: number of bins NBINS must be positive'))
            x=[arange_(0.5,n)].T / n
            x=x * (max_val - min_val) + ones_(size_(x)) * min_val
        else:
            if (isreal_(x)):
                if (isvector_(x)):
                    x=x[:]
                xsort=sort_(x)
                if (any_(xsort != x)):
                    warning_(char('hist: bin values not sorted on input'))
                    x=copy_(xsort)
            else:
                error_(char('hist: second argument must be a scalar or a vector'))
    x=double_(x)
    y=double_(y)
    cutoff=(x[1:end() - 1,:] + x[2:end(),:]) / 2
    n=rows_(x)
    y_nc=columns_(y)
    if (n < 30 and columns_(x) == 1):
        chist=zeros_(n + 1,y_nc)
        for i in arange_(1,n - 1).reshape(-1):
            chist[i + 1,:]=sum_(y <= cutoff[i])
        chist[n + 1,:]=sum_(not isnan_(y))
    else:
        s,idx=sort_([[y],[repmat_(cutoff,1,y_nc)]],nargout=2)
        _len=rows_(y)
        chist=cumsum_(idx <= _len)
        chist=matlabarray([[(zeros_(1,y_nc))],[(reshape_(chist[idx > _len],rows_(cutoff),y_nc))],[(chist[end(),:] - sum_(isnan_(y)))]])
    freq=diff_(chist)
    if (nargin > 2 and not ischar_(varargin[iarg])):
        norm=varargin[iarg]
        freq=bsxfun_(times,freq,norm / sum_(not isnan_(y)))
    if (nargout > 0):
        if (arg_is_vector):
            nn=freq.T
            xx=x.T
        else:
            nn=copy_(freq)
            xx=copy_(x)
    else:
        if (isempty_(hax)):
            hax=gca_()
        bar_(hax,x,freq,char('hist'),varargin[iarg:end()])
    return nn,xx
def compass_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('compass'),varargin[:],nargout=3)
    if (nargin == 0 or nargin > 3):
        print_usage_()
    if (nargin == 1 or (nargin == 2 and not isnumeric_(varargin[2]))):
        z=varargin[1](arange_()).T
        u=real_(z)
        v=imag_(z)
        have_line_spec=(nargin == 2)
    else:
        if (nargin >= 2 and isnumeric_(varargin[2])):
            u=varargin[1](arange_()).T
            v=varargin[2](arange_()).T
            have_line_spec=(nargin == 3)
        else:
            print_usage_()
    arrowsize=0.2
    line_spec=char('-b')
    if (have_line_spec):
        arg=varargin[end()]
        if (ischar_(arg) or iscellstr_(arg)):
            __,valid=__pltopt___(char('compass'),arg,false,nargout=2)
            if (valid):
                line_spec=copy_(arg)
            else:
                error_(char('compass: invalid linestyle STYLE'))
        else:
            error_(char('compass: invalid linestyle STYLE'))
    n=length_(u)
    xend=copy_(u)
    xtmp=u.dot((1 - arrowsize))
    yend=copy_(v)
    ytmp=v.dot((1 - arrowsize))
    x=matlabarray([[zeros_(1,n)],[xend],[xtmp - v * arrowsize / 3],[xend],[xtmp + v * arrowsize / 3]])
    y=matlabarray([[zeros_(1,n)],[yend],[ytmp + u * arrowsize / 3],[yend],[ytmp - u * arrowsize / 3]])
    r,p=cart2pol_(x,y,nargout=2)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        hlist=polar_(r,p,line_spec)
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(hlist)
    return h
def ezpolar_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    htmp,needusage=__ezplot___(char('polar'),varargin[:],nargout=2)
    if (needusage):
        print_usage_()
    if (nargout > 0):
        h=copy_(htmp)
    return h
def ellipsoid_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('ellipsoid'),varargin[:],nargout=3)
    if (nargin != 6 and nargin != 7):
        print_usage_()
    xc=varargin[1]
    yc=varargin[2]
    zc=varargin[3]
    xr=varargin[4]
    yr=varargin[5]
    zr=varargin[6]
    if (nargin == 6):
        n=20
    else:
        n=varargin[7]
    theta=linspace_(0,2 * pi,n + 1)
    phi=linspace_(- pi / 2,pi / 2,n + 1)
    theta,phi=meshgrid_(theta,phi,nargout=2)
    x=xr.dot(cos_(phi)).dot(cos_(theta)) + xc
    y=yr.dot(cos_(phi)).dot(sin_(theta)) + yc
    z=zr.dot(sin_(phi)) + zc
    if (nargout > 0):
        xx=copy_(x)
        yy=copy_(y)
        zz=copy_(z)
    else:
        oldfig=matlabarray([])
        if (not isempty_(hax)):
            oldfig=get_(0,char('currentfigure'))
        try:
            hax=newplot_(hax)
            surf_(x,y,z)
        finally:
            if (not isempty_(oldfig)):
                set_(0,char('currentfigure'),oldfig)
    return xx,yy,zz
def rose_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('rose'),varargin[:],nargout=3)
    if (nargin < 1):
        print_usage_()
    th=varargin[1]
    th=atan2_(sin_(th),cos_(th)) + pi
    if (nargin > 1):
        x=varargin[2]
        if (isscalar_(x)):
            x=[arange_(0.5 / x,1,1 / x)] * 2 * pi
        else:
            x=atan2_(sin_(x),cos_(x)) + pi
    else:
        x=[arange_(1 / 40,1,1 / 20)] * 2 * pi
    nn,xx=hist_(th,x,nargout=2)
    xx=xx[:].T
    if (isvector_(nn)):
        nn=nn[:]
    x1=xx[1:end() - 1] + diff_(xx,1) / 2
    x1=[[x1],[x1],[x1],[x1]](arange_())
    th=matlabarray([[0],[0],[x1],[2 * pi],[2 * pi]])
    r=zeros_(4 * rows_(nn),columns_(nn))
    r[2:4:end(),:]=nn
    r[3:4:end(),:]=nn
    if (nargout < 2):
        oldfig=matlabarray([])
        if (not isempty_(hax)):
            oldfig=get_(0,char('currentfigure'))
        try:
            hax=newplot_(hax)
            htmp=polar_(th,r)
        finally:
            if (not isempty_(oldfig)):
                set_(0,char('currentfigure'),oldfig)
        if (nargout > 0):
            thout=copy_(htmp)
    else:
        thout=copy_(th)
        rout=copy_(r)
    return thout,rout
def quiver_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('quiver'),varargin[:],nargout=3)
    if (nargin < 2):
        print_usage_()
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        htmp=__quiver___(hax,false,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (nargout > 0):
        h=copy_(htmp)
    return h
def trisurf_(tri=None,x=None,y=None,z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[tri,x,y,z].count(None)+len(args)

    if (nargin < 4):
        print_usage_()
    if (nargin > 4 and isnumeric_(varargin[1])):
        c=varargin[1]
        varargin[1]=[]
        if (isvector_(c)):
            if (numel_(c) != numel_(z)):
                error_(char("trisurf: C must have 'numel (Z)' elements"))
            c=c[:]
        else:
            if (rows_(c) != numel_(z) or columns_(c) != 3):
                error_(char("trisurf: TrueColor C matrix must be 'numel (Z)' rows by 3 columns"))
    else:
        c=z[:]
    if (not any_(strcmpi_(varargin,char('FaceColor')))):
        nfc=numel_(varargin) + 1
        varargin[nfc + (arange_(0,1))]=[char('FaceColor'),char('flat')]
    else:
        nfc=find_(any_(strcmpi_(varargin,char('FaceColor'))),1)
    if (not any_(strcmpi_(varargin,char('EdgeColor'))) and strcmpi_(varargin[nfc + 1],char('interp'))):
        varargin[end() + (arange_(1,2))]=[char('EdgeColor'),char('none')]
    hax=newplot_()
    htmp=patch_(char('Faces'),tri,char('Vertices'),[x[:],y[:],z[:]],char('FaceVertexCData'),c,varargin[:])
    if (not ishold_()):
        set_(hax,char('view'),[- 37.5,30],char('box'),char('off'),char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
    if (nargout > 0):
        h=copy_(htmp)
    return h
def stemleaf_(x=None,caption=None,stem_sz=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,caption,stem_sz].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not isvector_(x)):
        error_(char('stemleaf: X must be a vector'))
    if (isinteger_(x)):
        x=single_(x)
    else:
        if (isfloat_(x)):
            xint=fix_(x)
            if (any_(x != xint)):
                warning_(char('stemleaf: X truncated to integer values'))
                x=copy_(xint)
        else:
            error_(char('stemleaf: X must be a numeric vector'))
    if (not ischar_(caption)):
        error_(char('stemleaf: CAPTION must be a character array'))
    if (nargin == 2):
        stem_step=10
    else:
        if (isscalar_(stem_sz) and stem_sz >= 0 and isreal_(stem_sz)):
            stem_sz=fix_(stem_sz)
            stem_step=10 ** (stem_sz + 1)
        else:
            error_(char('stemleaf: STEM_SZ must be a real integer >= 0'))
    nx=numel_(x)
    xs=sort_(x)
    mdidx=fix_((nx + 1) / 2)
    hlidx=fix_((mdidx + 1) / 2)
    huidx=fix_(nx + 1 - hlidx)
    md=xs[mdidx]
    hl=xs[hlidx]
    hu=xs[huidx]
    h_spread=hu - hl
    step=1.5 * h_spread
    i_fence_l=hl - step
    o_fence_l=hl - 2 * step
    i_fence_h=hu + step
    o_fence_h=hu + 2 * step
    n_out_l=sum_(x < i_fence_l) - sum_(x < o_fence_l)
    n_out_h=sum_(x > i_fence_h) - sum_(x > o_fence_h)
    n_far_l=sum_(x < o_fence_l)
    n_far_h=sum_(x > o_fence_h)
    plot_out=sprintf_(char('       Data: %s'),caption)
    plot_out=matlabarray([[plot_out],[sprintf_(char(' '))]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('         Fenced Letter Display'))]])
    plot_out=matlabarray([[plot_out],[sprintf_(char(' '))]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('     #%3d|___________________'),nx)]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('     M%3d|       %5d      |'),mdidx,md)]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('     H%3d|%5d        %5d|   %d'),hlidx,hl,hu,h_spread)]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('     1   |%5d        %5d|'),xs[1],xs[nx])]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('               _______'))]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('         ______|%5d|_______'),step)]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('        f|%5d        %5d|'),i_fence_l,i_fence_h)]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('         |%5d        %5d|  out'),n_out_l,n_out_h)]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('        F|%5d        %5g|'),o_fence_l,o_fence_h)]])
    plot_out=matlabarray([[plot_out],[sprintf_(char('         |%5d        %5d|  far'),n_far_l,n_far_h)]])
    plot_out=matlabarray([[plot_out],[char(' ')]])
    min_x=min_(x)
    max_x=max_(x)
    if (min_x > 0):
        stems=matlabarray([arange_(fix_(min_(x) / stem_step),(fix_(max_(x) / stem_step) + 1))])
    else:
        if (max_x < 0):
            stems=matlabarray([arange_((fix_(min_x / stem_step) - 1),fix_(max_x / stem_step))])
        else:
            if (min_x < 0 and max_x > 0):
                stems=matlabarray([arange_((fix_(min_x / stem_step) - 1),- 0),arange_(0,fix_(max_x / stem_step) + 1)])
            else:
                if (min_x == 0):
                    if (any_(x == 0 and signbit_(x))):
                        min_x=- 0
                    else:
                        min_x=+ 0
                if (max_x == 0):
                    if (any_(x == 0 and not signbit_(x))):
                        max_x=+ 0
                    else:
                        max_x=- 0
                stems=matlabarray([])
                if (signbit_(min_x)):
                    stems=matlabarray([arange_((fix_(min_x / stem_step) - 1),- 0)])
                if (not signbit_(max_x)):
                    stems=matlabarray([stems,arange_(0,fix_(max_x / stem_step) + 1)])
    new_line=1
    for kx in arange_(2,numel_(stems)).reshape(-1):
        stem_sign=signbit_(stems[kx])
        if (stems[kx] <= 0):
            idx=((x <= stems[kx] * stem_step) and (x > (stems[kx - 1] * stem_step)) and (signbit_(x) == stem_sign))
            xlf=abs_(x[idx] - stems[kx] * stem_step)
        else:
            idx=((x < stems[kx] * stem_step) and (x >= (stems[kx - 1] * stem_step)) and (signbit_(x) == stem_sign))
            xlf=abs_(x[idx] - stems[kx - 1] * stem_step)
        if (stem_step == 10):
            lf_str=sprintf_(char('%d'),xlf)
        else:
            lf_str=char('')
            if (not isempty_(xlf)):
                lf_str=sprintf_(char('%d'),xlf[1])
                if (numel_(xlf) > 1):
                    lf_str=matlabarray([lf_str,sprintf_(char(',%d'),xlf[2:end()])])
        if (stems[kx] == 0 and signbit_(stems[kx])):
            line=sprintf_(char('  -0 | %s'),lf_str)
        else:
            if (stems[kx] < 0):
                line=sprintf_(char('%4d | %s'),stems[kx],lf_str)
            else:
                if (stems[kx] > 0):
                    line=sprintf_(char('%4d | %s'),stems[kx - 1],lf_str)
                else:
                    line=char('')
        if (not isempty_(lf_str) or stems[kx] == 0 or stems[kx - 1] == 0):
            plot_out=matlabarray([[plot_out],[line]])
            new_line=1
        else:
            if (new_line == 1):
                plot_out=matlabarray([[plot_out],[char('     :')]])
                new_line=0
    if (nargout == 0):
        disp_(plot_out)
    else:
        plotstr=copy_(plot_out)
    return plotstr
def contour3_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('contour3'),varargin[:],nargout=3)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        hax=newplot_(hax)
        ctmp,htmp=__contour___(hax,char('auto'),varargin[:],nargout=2)
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    if (not ishold_()):
        set_(hax,char('view'),[- 37.5,30],char('box'),char('off'),char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
    if (nargout > 0):
        c=copy_(ctmp)
        h=copy_(htmp)
    return c,h
def subplot_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    align_axes=copy_(false)
    replace_axes=copy_(false)
    have_position=copy_(false)
    initial_args_decoded=copy_(false)
    if (nargin >= 3):
        arg1=varargin[1]
        arg2=varargin[2]
        arg3=varargin[3]
        if (isnumeric_(arg1) and isscalar_(arg1) and isnumeric_(arg2) and isscalar_(arg2) and isnumeric_(arg3)):
            rows=copy_(arg1)
            cols=copy_(arg2)
            index=copy_(arg3)
            varargin[1:3]=[]
            initial_args_decoded=copy_(true)
    if (not initial_args_decoded and nargin > 1):
        if (strcmpi_(varargin[1],char('position'))):
            arg=varargin[2]
            if (isnumeric_(arg) and numel_(arg) == 4):
                pos=copy_(arg)
                varargin[1:2]=[]
                have_position=copy_(true)
                initial_args_decoded=copy_(true)
            else:
                error_(char('subplot: POSITION must be a 4-element numeric array'))
    if (not initial_args_decoded and nargin > 0):
        arg=varargin[1]
        if (nargin == 1 and isaxes_(arg)):
            axes_(arg)
            cf=get_(0,char('currentfigure'))
            set_(cf,char('nextplot'),char('add'))
            return h
        else:
            if (isscalar_(arg) and arg >= 0):
                index=rem_(arg,10)
                arg=(arg - index) / 10
                cols=rem_(arg,10)
                arg=(arg - cols) / 10
                rows=rem_(arg,10)
                varargin[1]=[]
                initial_args_decoded=copy_(true)
            else:
                error_(char('subplot: expecting axes handle or RCN argument'))
    if (not initial_args_decoded):
        print_usage_()
    if (not have_position):
        cols=round_(cols)
        rows=round_(rows)
        index=round_(index)
        if (any_(index < 1) or any_(index > rows * cols)):
            error_(char('subplot: INDEX value must be >= 1 and <= ROWS*COLS'))
        if (rows < 1 or cols < 1 or index < 1):
            error_(char('subplot: ROWS, COLS, and INDEX must be be positive'))
    idx=strcmpi_(varargin,char('align'))
    if (any_(idx)):
        align_axes=copy_(true)
        varargin[idx]=[]
    idx=strcmpi_(varargin,char('replace'))
    if (any_(idx)):
        replace_axes=copy_(true)
        varargin[idx]=[]
    axesunits=get_(0,char('defaultaxesunits'))
    cf=gcf_()
    figureunits=get_(cf,char('units'))
    try:
        set_(0,char('defaultaxesunits'),char('normalized'))
        set_(cf,char('units'),char('pixels'))
        if (strcmp_(get_(cf,char('__graphics_toolkit__')),char('gnuplot'))):
            align_axes=copy_(true)
        if (not have_position):
            pos=subplot_position_(rows,cols,index,char('position'))
            outerpos=subplot_position_(rows,cols,index,char('outerposition'))
            box=matlabarray([pos[1:2],pos[1:2] + pos[3:4]])
            outerbox=matlabarray([outerpos[1:2],outerpos[1:2] + outerpos[3:4]])
            looseinset=matlabarray([box[1:2] - outerbox[1:2],outerbox[3:4] - box[3:4]])
            if (align_axes):
                activepositionproperty=char('position')
            else:
                activepositionproperty=char('outerposition')
            set_(cf,char('nextplot'),char('add'))
            found=copy_(false)
            kids=get_(cf,char('children'))
            for child in kids[:].T.reshape(-1):
                if (not ishandle_(child)):
                    continue
                if (strcmp_(get_(child,char('type')),char('axes'))):
                    if (any_(strcmp_(get_(child,char('tag')),[char('legend'),char('colorbar')]))):
                        continue
                    objpos=get_(child,char('outerposition'))
                    if (all_(abs_(objpos - outerpos) < eps) and not replace_axes):
                        found=copy_(true)
                        hsubplot=copy_(child)
                    else:
                        if (align_axes):
                            objpos=get_(child,char('position'))
                        x0=pos[1]
                        x1=x0 + pos[3]
                        y0=pos[2]
                        y1=y0 + pos[4]
                        objx0=objpos[1]
                        objx1=objx0 + objpos[3]
                        objy0=objpos[2]
                        objy1=objy0 + objpos[4]
                        if (not (x0 >= objx1 or x1 <= objx0 or y0 >= objy1 or y1 <= objy0)):
                            delete_(child)
            if (found):
                set_(cf,char('currentaxes'),hsubplot)
            else:
                hsubplot=axes_(char('box'),char('off'),char('position'),pos,char('looseinset'),looseinset,char('activepositionproperty'),activepositionproperty,varargin[:])
                addproperty_(char('subplot_align'),hsubplot,char('boolean'),true)
                addlistener_(hsubplot,char('position'),subplot_align)
                if (not align_axes):
                    set_(hsubplot,char('subplot_align'),false)
                    subplot_align_(hsubplot)
        else:
            if (align_axes):
                activepositionproperty=char('position')
            else:
                activepositionproperty=char('outerposition')
            set_(cf,char('nextplot'),char('add'))
            found=copy_(false)
            kids=get_(cf,char('children'))
            for child in kids[:].T.reshape(-1):
                if (not ishandle_(child)):
                    continue
                if (strcmp_(get_(child,char('type')),char('axes'))):
                    if (any_(strcmp_(get_(child,char('tag')),[char('legend'),char('colorbar')]))):
                        continue
                    objpos=get_(child,char('position'))
                    if (all_(abs_(objpos - pos) < eps) and not replace_axes):
                        found=copy_(true)
                        hsubplot=copy_(child)
                    else:
                        x0=pos[1]
                        x1=x0 + pos[3]
                        y0=pos[2]
                        y1=y0 + pos[4]
                        objx0=objpos[1]
                        objx1=objx0 + objpos[3]
                        objy0=objpos[2]
                        objy1=objy0 + objpos[4]
                        if (not (x0 >= objx1 or x1 <= objx0 or y0 >= objy1 or y1 <= objy0)):
                            delete_(child)
            if (found):
                set_(cf,char('currentaxes'),hsubplot)
            else:
                hsubplot=axes_(char('box'),char('off'),char('position'),pos,char('activepositionproperty'),activepositionproperty,varargin[:])
                addproperty_(char('subplot_align'),hsubplot,char('boolean'),true)
                addlistener_(hsubplot,char('position'),subplot_align)
                if (not align_axes):
                    set_(hsubplot,char('subplot_align'),false)
                    subplot_align_(hsubplot)
    finally:
        set_(0,char('defaultaxesunits'),axesunits)
        set_(cf,char('units'),figureunits)
    if (nargout > 0):
        h=copy_(hsubplot)
    return h
def subplot_position_(rows=None,cols=None,index=None,position_property=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[rows,cols,index,position_property].count(None)+len(args)

    if (rows == 1 and cols == 1):
        if (strcmpi_(position_property,char('position'))):
            pos=get_(0,char('defaultaxesposition'))
        else:
            pos=get_(0,char('defaultaxesouterposition'))
        return pos
    if (strcmp_(position_property,char('outerposition'))):
        margins.left=0.05
        margins.bottom=0.05
        margins.right=0.05
        margins.top=0.05
        margins.column=0.04 / cols
        margins.row=0.04 / rows
        width=1 - margins.left - margins.right - (cols - 1) * margins.column
        width=width / cols
        height=1 - margins.top - margins.bottom - (rows - 1) * margins.row
        height=height / rows
    else:
        defaultaxesposition=get_(0,char('defaultaxesposition'))
        margins.left=defaultaxesposition[1]
        margins.bottom=defaultaxesposition[2]
        margins.right=1.0 - margins.left - defaultaxesposition[3]
        margins.top=1.0 - margins.bottom - defaultaxesposition[4]
        pc=1 / [0.186,(margins.left + margins.right - 1)]
        margins.column=1 / polyval_(pc,cols)
        pr=1 / [0.2282,(margins.top + margins.bottom - 1)]
        margins.row=1 / polyval_(pr,rows)
        width=1 - margins.left - margins.right - (cols - 1) * margins.column
        width=width / cols
        height=1 - margins.top - margins.bottom - (rows - 1) * margins.row
        height=height / rows
    yi=fix_((index[:] - 1) / cols)
    xi=index[:] - yi * cols - 1
    yi=(rows - 1) - yi
    x0=xi.dot((width + margins.column)) + margins.left
    y0=yi.dot((height + margins.row)) + margins.bottom
    if (numel_(x0) > 1):
        x1=max_(x0[:]) + width
        y1=max_(y0[:]) + height
        x0=min_(x0[:])
        y0=min_(y0[:])
        pos=matlabarray([x0,y0,x1 - x0,y1 - y0])
    else:
        pos=matlabarray([x0,y0,width,height])
    return pos
def subplot_align_(h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[h].count(None)+len(args)

    updating=copy_(false)
    if (not updating):
        try:
            updating=copy_(true)
            hfig=ancestor_(h,char('figure'))
            hsubplots=findall_(hfig,char('type'),char('axes'),char('subplot_align'),char('off'))
            if (not isempty_(hsubplots)):
                tightinset=get_(hsubplots,char('tightinset'))
                if (iscell_(tightinset)):
                    tightinset=max_(cell2mat_(tightinset))
                looseinset=get_(hsubplots,char('looseinset'))
                if (iscell_(looseinset)):
                    looseinset=max_(cell2mat_(looseinset))
                looseinset=max_(tightinset,looseinset)
                set_(hsubplots,char('looseinset'),looseinset)
        finally:
            updating=copy_(false)
    return
def saveas_(h=None,filename=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,filename,fmt].count(None)+len(args)

    if ((nargin != 2) and (nargin != 3)):
        print_usage_()
    if (ishandle_(h)):
        if (isfigure_(h)):
            fig=copy_(h)
        else:
            fig=ancestor_(h,char('figure'))
    else:
        error_(char('saveas: first argument H must be a graphics handle'))
    if (not ischar_(filename)):
        error_(char('saveas: FILENAME must be a string'))
    if (nargin == 2):
        __,__,ext=fileparts_(filename,nargout=3)
        if (not isempty_(ext)):
            fmt=ext[2:end()]
    if (nargin == 3):
        if (not ischar_(filename)):
            error_(char('saveas: EXT must be a string'))
        __,__,ext=fileparts_(filename,nargout=3)
        if (isempty_(ext)):
            filename=strcat_(filename,char('.'),fmt)
    prt_opt=strcat_(char('-d'),tolower_(fmt))
    print_(fig,filename,prt_opt)
    return
def gcbf_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    __,fig=gcbo_(nargout=2)
    return fig
def __pltopt___(caller=None,opt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[caller,opt,err_on_invalid].count(None)+len(args)

    options=__default_plot_options___()
    valid=copy_(true)
    if (ischar_(opt)):
        opt=cellstr_(opt)
    else:
        if (not iscellstr_(opt)):
            error_(char('__pltopt__: argument must be a character string or cell array of character strings'))
    nel=numel_(opt)
    for i in arange_(nel,1,- 1).reshape(-1):
        options[i],valid=__pltopt1___(caller,opt[i],err_on_invalid,nargout=2)
        if (not err_on_invalid and not valid):
            return options,valid
    return options,valid
def __pltopt1___(caller=None,opt=None,err_on_invalid=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[caller,opt,err_on_invalid].count(None)+len(args)

    options=__default_plot_options___()
    valid=copy_(true)
    have_linestyle=copy_(false)
    have_marker=copy_(false)
    if (strcmp_(caller,char('__errplot__'))):
        if (strncmp_(opt,char('#~>'),3)):
            n=3
        else:
            if (strncmp_(opt,char('#~'),2) or strncmp_(opt,char('~>'),2)):
                n=2
            else:
                if (strncmp_(opt,char('~'),1) or strncmp_(opt,char('>'),1) or strncmp_(opt,char('#'),1)):
                    n=1
                else:
                    n=0
        options.errorstyle=opt[1:n]
        opt[1:n]=[]
    else:
        options.errorstyle=char('~')
    while (not isempty_(opt)):

        if (strncmp_(opt,char('--'),2) or strncmp_(opt,char('-.'),2)):
            options.linestyle=opt[1:2]
            have_linestyle=copy_(true)
            n=2
        else:
            topt=opt[1]
            n=1
            if (topt == char('-') or topt == char(':')):
                have_linestyle=copy_(true)
                options.linestyle=topt
            else:
                if (topt == char('+') or topt == char('o') or topt == char('*') or topt == char('.') or topt == char('x') or topt == char('s') or topt == char('d') or topt == char('^') or topt == char('v') or topt == char('>') or topt == char('<') or topt == char('p') or topt == char('h') or topt == char('@')):
                    have_marker=copy_(true)
                    if (any_(topt == char('sdhp'))):
                        if (strncmp_(opt,char('square'),6)):
                            n=6
                        else:
                            if (strncmp_(opt,char('diamond'),7)):
                                n=7
                            else:
                                if (strncmp_(opt,char('hexagram'),8)):
                                    n=8
                                else:
                                    if (strncmp_(opt,char('pentagram'),9)):
                                        n=9
                    if (topt == char('@')):
                        topt=char('+')
                    options.marker=topt
                else:
                    if (topt == char('k') or topt == char('0')):
                        options.color=[0,0,0]
                    else:
                        if (topt == char('r') or topt == char('1')):
                            options.color=[1,0,0]
                        else:
                            if (topt == char('g') or topt == char('2')):
                                options.color=[0,1,0]
                            else:
                                if (topt == char('b') or topt == char('3')):
                                    options.color=[0,0,1]
                                else:
                                    if (topt == char('y')):
                                        options.color=[1,1,0]
                                    else:
                                        if (topt == char('m') or topt == char('4')):
                                            options.color=[1,0,1]
                                        else:
                                            if (topt == char('c') or topt == char('5')):
                                                options.color=[0,1,1]
                                            else:
                                                if (topt == char('w') or topt == char('6')):
                                                    options.color=[1,1,1]
                                                else:
                                                    if (isspace_(topt)):
                                                        pass
                                                    else:
                                                        if (topt == char(';')):
                                                            t=index_(opt[2:end()],char(';'))
                                                            if (t):
                                                                options.key=opt[2:t]
                                                                n=t + 1
                                                            else:
                                                                if (err_on_invalid):
                                                                    error_(char('%s: unfinished key label'),caller)
                                                                else:
                                                                    valid=copy_(false)
                                                                    options=__default_plot_options___()
                                                                    return options,valid
                                                        else:
                                                            if (err_on_invalid):
                                                                error_(char("%s: unrecognized format character: '%s'"),caller,topt)
                                                            else:
                                                                valid=copy_(false)
                                                                options=__default_plot_options___()
                                                                return options,valid
        opt[1:n]=[]

    if (not have_linestyle and have_marker):
        options.linestyle=char('none')
    if (have_linestyle and not have_marker):
        options.marker=char('none')
    return options,valid
def allchild_(handles=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[handles].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    shh=get_(0,char('showhiddenhandles'))
    try:
        set_(0,char('showhiddenhandles'),char('on'))
        h=get_(handles,char('children'))
    finally:
        set_(0,char('showhiddenhandles'),shh)
    return h
def hggroup_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin=__plt_get_axis_arg___(char('hggroup'),varargin[:],nargout=2)
    if (isempty_(hax)):
        hax=gca_()
    htmp=__go_hggroup___(hax,varargin[:])
    if (nargout > 0):
        h=copy_(htmp)
    return h
def close_(arg1=None,arg2=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[arg1,arg2].count(None)+len(args)

    figs=matlabarray([])
    if (nargin > 2):
        print_usage_()
    else:
        if (nargin == 0):
            figs=get_(0,char('currentfigure'))
            if (figs == 0):
                figs=matlabarray([])
        else:
            if (nargin == 1):
                if (ischar_(arg1) and strcmpi_(arg1,char('all'))):
                    figs=(get_(0,char('children'))).T
                    figs=figs[isfigure_(figs)]
                else:
                    if (isfigure_(arg1)):
                        figs=copy_(arg1)
                    else:
                        if (isempty_(arg1)):
                            figs=matlabarray([])
                        else:
                            error_(char('close: first argument must be "all" or a figure handle'))
            else:
                if (ischar_(arg1) and strcmpi_(arg1,char('all')) and ischar_(arg2) and strcmpi_(arg2,char('hidden'))):
                    figs=(allchild_(0)).T
                    figs=figs[isfigure_(figs)]
                else:
                    error_(char('close: expecting argument to be "all hidden"'))
    for h in figs.reshape(-1):
        __go_execute_callback___(h,char('closerequestfcn'))
    if (nargout > 0):
        retval=1
    return retval
def ndgrid_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0):
        print_usage_()
    else:
        if (nargin == 1):
            nd=max_(nargout,1)
            varargin[1:nd]=varargin[1]
        else:
            if (nargin >= nargout):
                nd=max_(nargin,1)
            else:
                error_(char('ndgrid: wrong number of input arguments'))
    shape=zeros_(1,nd)
    for i in arange_(1,nd).reshape(-1):
        if (not isvector_(varargin[i]) and not isempty_(varargin[i])):
            error_(char('ndgrid: arguments must be vectors'))
        shape[i]=length_(varargin[i])
    if (nd == 1):
        varargout[1]=varargin[1](arange_())
    else:
        for i in arange_(1,nd).reshape(-1):
            r=ones_(1,nd + 1)
            r[i]=shape[i]
            s=copy_(shape)
            s[i]=1
            varargout[i]=repmat_(reshape_(varargin[i],r),s)
    return varargout
def gca_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0):
        h=get_(gcf_(),char('currentaxes'))
        if (isempty_(h)):
            h=axes_()
    else:
        print_usage_()
    return h
def __next_line_color___(reset=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[reset].count(None)+len(args)

    reset_colors=copy_(true)
    if (nargin == 1):
        reset_colors=copy_(reset)
    else:
        ca=gca_()
        colororder=get_(ca,char('colororder'))
        if (reset_colors):
            color_index=1
            reset_colors=copy_(false)
        else:
            n_kids=length_(get_(ca,char('children')))
            n_colors=rows_(colororder)
            color_index=mod_(n_kids,n_colors) + 1
        rgb=colororder[color_index,:]
    return rgb
def graphics_toolkit_(name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[name,hlist].count(None)+len(args)

    if (nargin > 2):
        print_usage_()
    if (nargout > 0 or nargin == 0):
        retval=get_(0,char('defaultfigure__graphics_toolkit__'))
    if (nargin == 0):
        return retval
    else:
        if (nargin == 1):
            if (all_(isfigure_(name))):
                hlist=copy_(name)
                retval=get_(hlist,char('__graphics_toolkit__'))
                return retval
            else:
                if (not ischar_(name)):
                    error_(char('graphics_toolkit: invalid graphics toolkit NAME'))
        else:
            if (nargin == 2):
                hlist,name=deal_(name,hlist,nargout=2)
                if (not all_(isfigure_(hlist))):
                    error_(char('graphics_toolkit: invalid figure handle list HLIST'))
                else:
                    if (not ischar_(name)):
                        error_(char('graphics_toolkit: invalid graphics toolkit NAME'))
    if (not any_(strcmp_(available_graphics_toolkits_(),name))):
        error_(char('graphics_toolkit: %s toolkit is not available'),name)
    if (not any_(strcmp_(loaded_graphics_toolkits_(),name))):
        feval_([char('__init_'),name,char('__')])
        if (not any_(strcmp_(loaded_graphics_toolkits_(),name))):
            error_(char('graphics_toolkit: %s toolkit was not correctly loaded'),name)
    if (isempty_(hlist)):
        set_(0,char('defaultfigure__graphics_toolkit__'),name)
    else:
        set_(hlist,char('__graphics_toolkit__'),name)
    return retval
def __plt_get_axis_arg___(caller=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[caller].count(None)+len(args)

    h=matlabarray([])
    parent=find_(strcmpi_(varargin,char('parent')),1)
    if (numel_(varargin) > 0 and numel_(varargin[1]) == 1 and ishandle_(varargin[1]) and varargin[1] != 0 and not isfigure_(varargin[1])):
        htmp=varargin[1]
        if (not isaxes_(htmp)):
            error_(char('%s: expecting first argument to be axes handle'),caller)
        if (not strcmp_(get_(htmp,char('tag')),char('legend'))):
            h=copy_(htmp)
            varargin[1]=[]
    else:
        if (numel_(varargin) > 1 and not isempty_(parent)):
            if (parent < numel_(varargin) and ishandle_(varargin[parent + 1])):
                htmp=varargin[parent + 1]
                if (isaxes_(htmp) and not strcmp_(get_(htmp,char('tag')),char('legend'))):
                    h=copy_(htmp)
                    varargin[parent:parent + 1]=[]
                else:
                    h=matlabarray([ancestor_(htmp,char('axes')),htmp])
            else:
                error_(char('%s: expecting parent value to be axes handle'),caller)
    narg=length_(varargin)
    return h,varargin,narg
def newplot_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[hsave].count(None)+len(args)

    if (nargin > 1):
        print_usage_()
    cf=matlabarray([])
    ca=matlabarray([])
    if (not isempty_(hsave)):
        ca=ancestor_(hsave,char('axes'),char('toplevel'))
        if (iscell_(ca)):
            ca=matlabarray([ca[:]])
        ca=ca[find_(ca,1)]
        hsave[hsave == ca]=[]
        if (not isempty_(ca)):
            cf=ancestor_(ca,char('figure'),char('toplevel'))
        else:
            cf=ancestor_(hsave,char('figure'),char('toplevel'))
            if (iscell_(cf)):
                cf=matlabarray([cf[:]])
            cf=cf[find_(cf,1)]
    if (isempty_(cf)):
        cf=gcf_()
    else:
        set_(0,char('currentfigure'),cf)
    fnp=get_(cf,char('nextplot'))
    if char('add') == (fnp):
        pass
    else:
        if char('new') == (fnp):
            if (isempty_(ca)):
                cf=figure_()
        else:
            if char('replacechildren') == (fnp):
                kids=get_(cf,char('children'))
                if (not isempty_(ca)):
                    kids[kids == ca]=[]
                delete_(kids)
            else:
                if char('replace') == (fnp):
                    kids=allchild_(cf)
                    if (not isempty_(ca)):
                        kids[kids == ca]=[]
                    delete_(kids)
                    reset_(cf)
    set_(cf,char('nextplot'),char('add'))
    if (isempty_(ca)):
        ca=gca_()
        deleteall=copy_(true)
    else:
        set_(cf,char('currentaxes'),ca)
        deleteall=copy_(false)
    if (strcmp_(get_(ca,char('__hold_all__')),char('off'))):
        __next_line_color___(true)
        __next_line_style___(true)
    else:
        __next_line_color___(false)
        __next_line_style___(false)
    anp=get_(ca,char('nextplot'))
    if char('add') == (anp):
        pass
    else:
        if char('replacechildren') == (anp):
            if (not deleteall and ca != hsave):
                kids=allchild_(ca)
                hkid=copy_(hsave)
                while (not any_(hkid == kids)):

                    hkid=get_(hkid,char('parent'))

                kids[kids == hkid]=[]
                delete_(kids)
            else:
                delete_(get_(ca,char('children')))
        else:
            if char('replace') == (anp):
                if (not deleteall and ca != hsave):
                    kids=allchild_(ca)
                    hkid=copy_(hsave)
                    while (not any_(hkid == kids)):

                        hkid=get_(hkid,char('parent'))

                    kids[kids == hkid]=[]
                    delete_(kids)
                else:
                    __go_axes_init___(ca,char('replace'))
                    __request_drawnow___()
    if (nargout > 0):
        hax=copy_(ca)
    return hax
def ginput_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin > 1):
        print_usage_()
    f=gcf_()
    a=gca_()
    drawnow_()
    toolkit=get_(f,char('__graphics_toolkit__'))
    varargout=cell_(1,nargout)
    if (nargin == 0):
        varargout[:]=feval_([char('__'),toolkit,char('_ginput__')],f)
    else:
        varargout[:]=feval_([char('__'),toolkit,char('_ginput__')],f,n)
    return varargout
def __go_draw_figure___(h=None,plot_stream=None,enhanced=None,mono=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[h,plot_stream,enhanced,mono].count(None)+len(args)

    htype=get_(h,char('type'))
    if (strcmp_(htype,char('figure'))):
        kids=allchild_(h)
        nkids=length_(kids)
        if (nkids > 0):
            fputs_(plot_stream,char('\nreset;\n'))
            fputs_(plot_stream,char('set autoscale keepfix;\n'))
            fputs_(plot_stream,char('set origin 0, 0\n'))
            fputs_(plot_stream,char('set size 1, 1\n'))
            bg=get_(h,char('color'))
            if (isnumeric_(bg)):
                fprintf_(plot_stream,char('set obj 1 rectangle from screen 0,0 to screen 1,1 behind fc rgb "#%02x%02x%02x"\n'),255 * bg)
                bg_is_set=copy_(true)
            else:
                bg_is_set=copy_(false)
            fg_was_set=copy_(false)
            for i in arange_(nkids,1,- 1).reshape(-1):
                _type=get_(kids[i],char('type'))
                if char('axes') == (_type):
                    if (strcmpi_(get_(kids[i],char('tag')),char('legend'))):
                        lh=getfield_(get_(kids[i],char('userdata')),char('handle'))
                        if (isscalar_(lh)):
                            continue
                        else:
                            ca=lh[1]
                            legend_axes_units=get_(kids[i],char('units'))
                            legend_axes_position=get_(kids[i],char('position'))
                            legend_axes_outerposition=get_(kids[i],char('outerposition'))
                            legend_axes_box=get_(kids[i],char('box'))
                            legend_axes_ylim=get_(kids[i],char('ylim'))
                            orig_axes_units=get_(ca,char('units'))
                            hlgnd=get_(kids[i])
                            try:
                                set_(ca,char('units'),char('normalized'))
                                set_(kids[i],char('units'),char('normalized'),char('box'),char('off'),char('ylim'),[- 2,- 1],char('position'),get_(ca[1],char('position')),char('outerposition'),get_(ca[1],char('outerposition')))
                                toberm=matlabarray([])
                                hobj=get_(kids[i],char('children'))
                                for j in arange_(numel_(hobj),1,- 1).reshape(-1):
                                    if (not strcmp_(get_(hobj[j],char('type')),char('text'))):
                                        continue
                                    displayname=get_(hobj[j],char('string'))
                                    ll=matlabarray([])
                                    lm=matlabarray([])
                                    for k in arange_(numel_(hobj),1,- 1).reshape(-1):
                                        if (not strcmp_(get_(hobj[k],char('type')),char('line'))):
                                            continue
                                        if (get_(hobj[j],char('userdata')) != get_(hobj[k],char('userdata'))):
                                            continue
                                        if (not strcmp_(get_(hobj[k],char('linestyle')),char('none'))):
                                            ll=hobj[k]
                                        if (not strcmp_(get_(hobj[k],char('marker')),char('none'))):
                                            lm=hobj[k]
                                    if (not isempty_(ll)):
                                        if (not isempty_(lm)):
                                            toberm=matlabarray([toberm,line_(char('xdata'),[0,0],char('ydata'),[0,0],char('color'),get_(lm,char('color')),char('linestyle'),get_(ll,char('linestyle')),char('marker'),get_(lm,char('marker')),char('markeredgecolor'),get_(lm,char('markeredgecolor')),char('markerfacecolor'),get_(lm,char('markerfacecolor')),char('markersize'),get_(lm,char('markersize')),char('displayname'),displayname,char('parent'),kids[i])])
                                        else:
                                            toberm=matlabarray([toberm,line_(char('xdata'),[0,0],char('ydata'),[0,0],char('color'),get_(ll,char('color')),char('linestyle'),get_(ll,char('linestyle')),char('marker'),char('none'),char('displayname'),displayname,char('parent'),kids[i])])
                                    else:
                                        if (not isempty_(lm)):
                                            toberm=matlabarray([toberm,line_(char('xdata'),[0,0],char('ydata'),[0,0],char('color'),get_(lm,char('color')),char('linestyle'),char('none'),char('marker'),get_(lm,char('marker')),char('markeredgecolor'),get_(lm,char('markeredgecolor')),char('markerfacecolor'),get_(lm,char('markerfacecolor')),char('markersize'),get_(lm,char('markersize')),char('displayname'),displayname,char('parent'),kids[i])])
                                if (bg_is_set):
                                    fprintf_(plot_stream,char('set border linecolor rgb "#%02x%02x%02x"\n'),255 * (1 - bg))
                                __go_draw_axes___(kids[i],plot_stream,enhanced,mono,bg_is_set,false,hlgnd)
                            finally:
                                set_(ca,char('units'),orig_axes_units)
                                set_(kids_(i),char('units'),legend_axes_units,char('box'),legend_axes_box,char('ylim'),legend_axes_ylim,char('position'),legend_axes_position,char('outerposition'),legend_axes_outerposition)
                                delete_(toberm)
                                bg_is_set=copy_(false)
                    else:
                        orig_axes_units=get_(kids[i],char('units'))
                        orig_axes_position=get_(kids[i],char('position'))
                        try:
                            set_(kids[i],char('units'),char('normalized'))
                            fg=get_(kids[i],char('color'))
                            if (isnumeric_(fg) and strcmp_(get_(kids[i],char('visible')),char('on'))):
                                fprintf_(plot_stream,char('set obj 2 rectangle from graph 0,0 to graph 1,1 behind fc rgb "#%02x%02x%02x"\n'),255 * fg)
                                fg_is_set=copy_(true)
                                fg_was_set=copy_(true)
                            else:
                                if (fg_was_set):
                                    fprintf_(plot_stream,char('unset obj 2\n'))
                                    fg_is_set=copy_(false)
                                    fg_was_set=copy_(false)
                                else:
                                    fg_is_set=copy_(false)
                            if (bg_is_set):
                                fprintf_(plot_stream,char('set border linecolor rgb "#%02x%02x%02x"\n'),255 * (1 - bg))
                            hlegend=matlabarray([])
                            fkids=get_(h,char('children'))
                            for j in arange_(1,numel_(fkids)).reshape(-1):
                                if (ishandle_(fkids[j]) and strcmp_(get_(fkids[j],char('type')),char('axes')) and (strcmp_(get_(fkids[j],char('tag')),char('legend')))):
                                    udata=get_(fkids[j],char('userdata'))
                                    if (isscalar_(udata.handle) and not isempty_(intersect_(udata.handle,kids[i]))):
                                        hlegend=get_(fkids[j])
                                        break
                            __go_draw_axes___(kids[i],plot_stream,enhanced,mono,bg_is_set,fg_is_set,hlegend)
                        finally:
                            set_(kids_(i),char('units'),orig_axes_units)
                            set_(kids_(i),char('position'),orig_axes_position)
                            bg_is_set=copy_(false)
                            fg_is_set=copy_(false)
                else:
                    if char('uimenu') == (_type):
                        kids[i]=[]
                    else:
                        error_(char('__go_draw_figure__: unknown object class, %s'),_type)
            if (isempty_(kids)):
                fputs_(plot_stream,char('\nreset; clear;\n'))
                fflush_(plot_stream)
            else:
                fputs_(plot_stream,char('\nunset multiplot;\n'))
        else:
            fputs_(plot_stream,char('\nreset; clear;\n'))
            fflush_(plot_stream)
    else:
        error_(char("__go_draw_figure__: expecting figure object, found '%s'"),htype)
    return
def __gnuplot_version___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    __version__=char('')
    if (isempty_(__version__)):
        status,output=system_(sprintf_(char('"%s" --version'),gnuplot_binary_()),nargout=2)
        if (status != 0):
            error_(char("you must have gnuplot installed to display graphics; if you have gnuplot installed in a non-standard location, see the 'gnuplot_binary' function\n"))
        output=strrep_(output,char('gnuplot'),char(''))
        output=strrep_(output,char('patchlevel'),char('.'))
        output=strrep_(output,char('\n'),char(''))
        output=strrep_(output,char('\r'),char(''))
        __version__=strrep_(output,char(' '),char(''))
    version=copy_(__version__)
    return version
def __gnuplot_has_terminal___(term=None,plot_stream=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[term,plot_stream].count(None)+len(args)

    term=strtrim_(term)
    term=lower_(strtok_(term,char(' ')))
    if (__gnuplot_has_feature___(char('variable_GPVAL_TERMINALS'))):
        if (nargin < 2):
            plot_stream=__gnuplot_open_stream___(2)
        available_terminals=__gnuplot_get_var___(plot_stream,char('GPVAL_TERMINALS'))
        available_terminals=regexp_(available_terminals,char('\\w+'),char('match'))
        if (nargin < 2 and not isempty_(plot_stream)):
            pclose_(plot_stream[1])
            if (numel_(plot_stream) > 1):
                pclose_(plot_stream[2])
            if (numel_(plot_stream) > 2):
                waitpid_(plot_stream[3])
    else:
        available_terminals=[char('aifm'),char('aqua'),char('canvas'),char('cgm'),char('corel'),char('dumb'),char('dxf'),char('eepic'),char('emf'),char('epslatex'),char('epson_180dpi'),char('fig'),char('gif'),char('gnugraph'),char('gpic'),char('hp2623A'),char('hp2648'),char('hp500c'),char('hpgl'),char('hpljii'),char('hppj'),char('imagen'),char('jpeg'),char('latex'),char('mf'),char('mif'),char('mp'),char('pbm'),char('pdf'),char('pm'),char('png'),char('postscript'),char('pslatex'),char('pstex'),char('pstricks'),char('qms'),char('regis'),char('rgip'),char('svg'),char('texdraw'),char('tgif'),char('tkcanvas'),char('tpic'),char('windows'),char('x11'),char('xlib'),char('xterm')]
    gnuplot_supports_term=any_(strcmp_(term,available_terminals))
    return gnuplot_supports_term
def __gnuplot_get_var___(h=None,gp_var_name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,gp_var_name,fmt].count(None)+len(args)

    if (numel_(h) == 1 and isfigure_(h)):
        if (isempty_(get_(h,char('__plot_stream__')))):
            ostream=__gnuplot_open_stream___(2,h)
        else:
            ostream=get_(h,char('__plot_stream__'))
    else:
        ostream=copy_(h)
    if (numel_(ostream) < 1):
        error_(char('__gnuplot_get_var__: stream to gnuplot not open'))
    else:
        if (ispc_()):
            if (numel_(ostream) == 1):
                error_(char('__gnuplot_get_var__: Need mkfifo that is not implemented under Windows'))
            use_mkfifo=copy_(false)
            istream=ostream[2]
            ostream=ostream[1]
        else:
            use_mkfifo=copy_(true)
            ostream=ostream[1]
    if (use_mkfifo):
        gpin_name=tmpnam_()
        err,msg=mkfifo_(gpin_name,6 * 8 * 8,nargout=2)
        if (err):
            error_(char('__gnuplot_get_var__: Can not make FIFO (%s)'),msg)
    gp_var_name=strtrim_(gp_var_name)
    n=min_(strfind_(gp_var_name,char(' ')),strfind_(gp_var_name,char(','))) - 1
    if (isempty_(n)):
        n=numel_(gp_var_name)
    try:
        if (use_mkfifo):
            fprintf_(ostream,char('\nset print "%s";\n'),gpin_name)
            fflush_(ostream)
            gpin,err=fopen_(gpin_name,char('r'),nargout=2)
            if (err):
                gpin,err=fopen_(gpin_name,char('r'),nargout=2)
            if (err):
                error_(char('__gnuplot_get_var__: can not open FIFO'))
            gp_cmd=sprintf_(char('\nif (exists("%s")) print %s; else print NaN\n'),gp_var_name[1:n],gp_var_name)
            fputs_(ostream,gp_cmd)
            fputs_(ostream,char('set print;\n'))
            fflush_(ostream)
            reading=copy_(true)
            _str=[]
            while (reading):

                _str[end() + 1]=fgets_(gpin)
                if (isnumeric_(_str[end()]) and (_str[end()] == - 1)):
                    reading=copy_(false)
                    _str=_str[1:(end() - 1)]

            _str=strcat_(_str[:])
            fclose_(gpin)
        else:
            fprintf_(ostream,char('set print "-";\n'))
            fflush_(ostream)
            gp_cmd=sprintf_(char('\nif (exists("%s")) print "OCTAVE: ", %s; else print NaN\n'),gp_var_name[1:n],gp_var_name)
            fputs_(ostream,gp_cmd)
            fflush_(ostream)
            fputs_(ostream,char('set print;\n'))
            fflush_(ostream)
            _str=[]
            while (isempty_(_str)):

                _str=fread_(istream,char('*char')).T
                if (isempty_(_str)):
                    sleep_(0.05)
                else:
                    _str=regexp_(_str,char('OCTAVE:.*'),char('match'))
                    _str=_str[end()](arange_(8,end()))
                fclear_(istream)

        _str[_str == char('\n') or _str == char('\r')]=char('')
        n_continue=strfind_(_str,char(' \\ '))
        if (not isempty_(n_continue)):
            _str[n_continue + 1]=char('')
        if (isempty_(fmt)):
            gp_var_value=strtrim_(_str)
        else:
            gp_var_value=sscanf_(_str,fmt)
    finally:
        if (use_mkfifo):
            unlink_(gpin_name)
    return gp_var_value
def __gnuplot_open_stream___(npipes=None,h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[npipes,h].count(None)+len(args)

    prog,args=gnuplot_binary_(nargout=2)
    if (npipes > 1):
        plot_stream_(1),plot_stream[2],pid=popen2_(prog,args[:],nargout=3)
        if (pid < 0):
            error_(char('__gnuplot_open_stream__: failed to open connection to gnuplot'))
        else:
            plot_stream[3]=pid
    else:
        plot_stream=popen_(sprintf_(char('%s '),prog,args[:]),char('w'))
        if (plot_stream < 0):
            error_(char('__gnuplot_open_stream__: failed to open connection to gnuplot'))
    if (nargin > 1):
        set_(h,char('__plot_stream__'),plot_stream)
    return plot_stream
def __tight_eps_bbox___(opts=None,eps_file_name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[opts,eps_file_name].count(None)+len(args)

    box_string=char('%%BoundingBox:')
    cmd=sprintf_(char('"%s" "%s" 2>&1'),char('head'),eps_file_name)
    status,output=system_(cmd,nargout=2)
    if (status == 0):
        orig_bbox_line=get_bbox_(output)
    else:
        error_(char('print:noboundingbox'),char("print.m: no bounding box found in '%s'"),eps_file_name)
    ghostscript_options=char('-q -dBATCH -dSAFER -dNOPAUSE -dTextAlphaBits=4 -sDEVICE=bbox')
    cmd=sprintf_(char('"%s" %s "%s" 2>&1'),opts.ghostscript.binary,ghostscript_options,eps_file_name)
    status,output=system_(cmd,nargout=2)
    if (status == 0):
        tight_bbox_line=get_bbox_(output)
    else:
        warning_(char('print:nogsboundingbox'),char("print.m: ghostscript failed to determine the bounding for '%s'"),eps_file_name)
    fid=fopen_(eps_file_name,char('r+'))
    try:
        bbox_replaced=copy_(false)
        looking_for_bbox=copy_(true)
        while (looking_for_bbox):

            current_line=fgetl_(fid)
            if (strncmpi_(current_line,box_string,length_(box_string))):
                line_length=numel_(current_line)
                num_spaces=line_length - numel_(tight_bbox_line)
                if (numel_(current_line) >= numel_(tight_bbox_line)):
                    new_line=copy_(tight_bbox_line)
                    new_line[end() + 1:numel_(current_line)]=char(' ')
                    bbox_replaced=copy_(true)
                    if (ispc_()):
                        fseek_(fid,- line_length - 2,char('cof'))
                    else:
                        fseek_(fid,- line_length - 1,char('cof'))
                    count=fprintf_(fid,char('%s'),new_line)
                looking_for_bbox=copy_(false)
            else:
                if (not ischar_(current_line)):
                    looking_for_bbox=copy_(false)

    finally:
        fclose_(fid)
    if (not bbox_replaced):
        fid=fopen_(eps_file_name,char('r'))
        try:
            data=char_(fread_(fid,Inf)).T
        finally:
            fclose_(fid)
        n=strfind_(data,box_string)
        if (numel_(n) > 1):
            n=n[1]
        else:
            if (isempty_(n)):
                error_(char('print:noboundingbox'),char("print.m: no bounding box found in '%s'."),eps_file_name)
        m=numel_(orig_bbox_line)
        data=horzcat_(data[1:(n - 1)],tight_bbox_line,data[(n + m):end()])
        fid=fopen_(eps_file_name,char('w'))
        try:
            fprintf_(fid,char('%s'),data)
        finally:
            fclose_(fid)
    return bb
def get_bbox_(lines=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[lines].count(None)+len(args)

    box_string=char('%%BoundingBox:')
    pattern=strcat_(box_string,char('[^%]*'))
    pattern=pattern[1:find_(double_(pattern) > 32,1,char('last'))]
    bbox_line=regexp_(lines,pattern,char('match'))
    if (iscell_(bbox_line)):
        bbox_line=bbox_line[1]
    bbox_line[double_(bbox_line) < 32]=char('')
    return bbox_line
def __add_default_menu___(fig=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[fig].count(None)+len(args)

    if (not strcmp_(get_(fig,char('__graphics_toolkit__')),char('fltk'))):
        return
    obj=findall_(fig,char('-depth'),1,char('tag'),char('__default_menu__'),char('label'),char('&File'))
    if (isempty_(obj)):
        menubar_state=get_(fig,char('menubar'))
        set_(fig,char('menubar'),char('figure'))
        __f=uimenu_(fig,char('label'),char('&File'),char('handlevisibility'),char('off'),char('tag'),char('__default_menu__'))
        uimenu_(__f,char('label'),char('Save &As'),char('callback'),save_cb)
        uimenu_(__f,char('label'),char('&Save'),char('callback'),save_cb)
        uimenu_(__f,char('label'),char('&Close'),char('callback'),char('close (gcf)'))
        __e=uimenu_(fig,char('label'),char('&Edit'),char('handlevisibility'),char('off'),char('tag'),char('__default_menu__'))
        uimenu_(__e,char('label'),char('&Grid'),char('callback'),grid_cb)
        uimenu_(__e,char('label'),char('Auto&scale'),char('callback'),autoscale_cb)
        gm=uimenu_(__e,char('label'),char('GUI &Mode'))
        uimenu_(gm,char('label'),char('Pan+Zoom'),char('callback'),guimode_cb)
        uimenu_(gm,char('label'),char('Rotate+Zoom'),char('callback'),guimode_cb)
        uimenu_(gm,char('label'),char('None+Zoom'),char('callback'),guimode_cb)
        drawnow_()
        set_(fig,char('menubar'),menubar_state)
    return
def save_cb_(h=None,e=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,e].count(None)+len(args)

    lbl=get_(gcbo,char('label'))
    if (strcmp_(lbl,char('&Save'))):
        fname=get_(gcbo,char('userdata'))
        if (isempty_(fname)):
            __save_as___(gcbo)
        else:
            saveas_(gcbo,fname)
    else:
        if (strcmp_(lbl,char('Save &As'))):
            __save_as___(gcbo)
    return
def __save_as___(caller=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[caller].count(None)+len(args)

    filename,filedir=uiputfile_([char('*.pdf;*.ps;*.gif;*.png;*.jpg'),char('Supported Graphic Formats')],char('Save Figure'),pwd,nargout=2)
    if (filename != 0):
        fname=matlabarray([filedir,filesep_(),filename])
        obj=findall_(gcbf,char('label'),char('&Save'))
        if (not isempty_(obj)):
            set_(obj[1],char('userdata'),fname)
        saveas_(caller,fname)
    return
def grid_cb_(h=None,e=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,e].count(None)+len(args)

    grid
    return
def autoscale_cb_(h=None,e=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,e].count(None)+len(args)

    axis_(char('auto'))
    return
def guimode_cb_(h=None,e=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,e].count(None)+len(args)

    lbl=get_(h,char('label'))
    if char('Pan+Zoom') == (lbl):
        gui_mode_(char('2D'))
    else:
        if char('Rotate+Zoom') == (lbl):
            gui_mode_(char('3D'))
        else:
            if char('None') == (lbl):
                gui_mode_(char('None'))
    return
def __fltk_print___(opts=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[opts].count(None)+len(args)

    dos_shell=(ispc_() and not isunix_())
    set_(0,char('currentfigure'),opts.figure)
    drawnow_(char('expose'))
    __fltk_redraw___()
    if (not isempty_(opts.fig2dev_binary)):
        fig2dev_devices=[char('pstex'),char('mf'),char('emf')]
    else:
        fig2dev_devices=[char('pstex'),char('mf')]
    gl2ps_device=[]
    pipeline=[]
    if [char('eps'),char('eps2'),char('epsc'),char('epsc2')] == (lower_________(opts.devopt)):
        gl2ps_device=[char('eps')]
        pipeline=[opts.epstool_cmd(opts,char('-'),opts.name)]
    else:
        if [char('epslatex'),char('pslatex'),char('pdflatex'),char('epslatexstandalone'),char('pslatexstandalone'),char('pdflatexstandalone')] == (lower_________(opts.devopt)):
            n=find_(opts.devopt == char('l'),1)
            suffix=opts.devopt(arange_(1,n - 1))
            dot=find_(opts.name == char('.'),1,char('last'))
            if ((not isempty_(dot)) and any_(strcmpi_(opts.name(arange_(dot,end())),[strcat_(char('.'),suffix),char('.tex'),char('.')]))):
                name=opts.name(arange_(1,dot - 1))
                if (dot < numel_(opts.name) and any_(strcmpi_(opts.name(arange_(dot + 1,end())),[char('eps'),char('ps'),char('pdf')]))):
                    suffix=opts.name(arange_(dot + 1,end()))
            else:
                error_(char('print:invalid-suffix'),char("invalid suffix '%s' for device '%s'."),opts.name(arange_(dot,end())),lower_(opts.devopt))
            gl2ps_device=[sprintf_(char('%snotxt'),lower_(suffix))]
            gl2ps_device[2]=char('tex')
            if (dos_shell):
                pipeline=[sprintf_(char('cat > %s-inc.%s'),name,suffix)]
                pipeline[2]=sprintf_(char('cat > %s.tex'),name)
            else:
                pipeline=[sprintf_(char('cat > %s-inc.%s'),name,suffix)]
                pipeline[2]=sprintf_(char('cat > %s.tex'),name)
        else:
            if char('tikz') == (lower_________(opts.devopt)):
                gl2ps_device=[char('pgf')]
                pipeline=[sprintf_(char('cat > %s'),opts.name)]
            else:
                if char('svg') == (lower_________(opts.devopt)):
                    gl2ps_device=[char('svg')]
                    pipeline=[sprintf_(char('cat > %s'),opts.name)]
                else:
                    if fig2dev_devices == (lower_________(opts.devopt)):
                        cmd_pstoedit=opts.pstoedit_cmd(opts,char('fig'))
                        cmd_fig2dev=opts.fig2dev_cmd(opts,opts.devopt)
                        if (strcmp_(opts.devopt,char('pstex'))):
                            __,__,ext=fileparts_(opts.name,nargout=3)
                            if (any_(strcmpi_(ext,[char('.ps'),char('.tex'),char('.')]))):
                                opts.name=opts.name(arange_(1,end() - numel_(ext)))
                            opts.name=strcat_(opts.name,char('.ps'))
                            cmd=sprintf_(char('%s | %s > %s'),cmd_pstoedit,cmd_fig2dev,opts.name)
                            gl2ps_device=[char('eps')]
                            pipeline=[cmd]
                            cmd_fig2dev=opts.fig2dev_cmd(opts,char('pstex_t'))
                            gl2ps_device[2]=char('eps')
                            pipeline[2]=sprintf_(char('%s | %s > %s'),cmd_pstoedit,cmd_fig2dev,strrep_(opts.name,char('.ps'),char('.tex')))
                        else:
                            cmd=sprintf_(char('%s | %s > %s'),cmd_pstoedit,cmd_fig2dev,opts.name)
                            gl2ps_device=[char('eps')]
                            pipeline=[cmd]
                    else:
                        if char('aifm') == (lower_________(opts.devopt)):
                            cmd=opts.pstoedit_cmd(opts,char('ps2ai'))
                            gl2ps_device=[char('eps')]
                            pipeline=[sprintf_(char('%s > %s'),cmd,opts.name)]
                        else:
                            if [char('dxf'),char('emf'),char('fig'),char('hpgl')] == (lower_________(opts.devopt)):
                                cmd=opts.pstoedit_cmd(opts)
                                gl2ps_device=[char('eps')]
                                pipeline=[sprintf_(char('%s > %s'),cmd,opts.name)]
                            else:
                                if [char('corel'),char('gif')] == (lower_________(opts.devopt)):
                                    error_(char('print:unsupporteddevice'),char('print.m: %s output is not available for the FLTK graphics toolkit'),upper_(opts.devopt))
                                else:
                                    if opts.ghostscript.device == (lower_________(opts.devopt)):
                                        opts.ghostscript.source=char('-')
                                        opts.ghostscript.output=opts.name
                                        if (opts.send_to_printer):
                                            opts.unlink[strcmp_(opts.unlink,opts.ghostscript.output)]=[]
                                            opts.ghostscript.output=char('-')
                                        cmd_gs,cmd_cleanup=__ghostscript___(opts.ghostscript,nargout=2)
                                        if (opts.send_to_printer or isempty_(opts.name)):
                                            cmd_lpr=opts.lpr_cmd(opts)
                                            cmd=sprintf_(char('%s | %s'),cmd_gs,cmd_lpr)
                                        else:
                                            cmd=sprintf_(char('%s'),cmd_gs)
                                        if (not isempty_(cmd_cleanup)):
                                            gl2ps_device=[char('eps')]
                                            if (dos_shell):
                                                pipeline=[sprintf_(char('%s & %s'),cmd,cmd_cleanup)]
                                            else:
                                                pipeline=[sprintf_(char('%s ; %s'),cmd,cmd_cleanup)]
                                        else:
                                            gl2ps_device=[char('eps')]
                                            pipeline=[cmd]
                                    else:
                                        error_(sprintf_(char('print:no%soutput'),opts.devopt),char('print.m: %s output is not available for GL2PS output'),upper_(opts.devopt))
    opts.pipeline=pipeline
    haxes=findall_(opts.figure,char('type'),char('axes'))
    vw=get_(haxes,char('view'))
    if (iscell_(vw)):
        vw=vertcat_(vw[:])
    is2D=all_(abs_(vw[:,2]) == 90)
    if (is2D):
        gl2ps_device[end()]=[gl2ps_device[end()],char('is2D')]
    for n in arange_(1,numel_(pipeline)).reshape(-1):
        if (opts.debug):
            fprintf_(char("fltk-pipeline: '%s'\n"),pipeline[n])
        drawnow_(gl2ps_device[n],strcat_(char('|'),pipeline[n]))
    if (not isempty_(strfind_(opts.devopt,char('standalone')))):
        opts.latex_standalone(opts)
    return opts
def __gnuplot_ginput___(f=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,n].count(None)+len(args)

    if (compare_versions_(__gnuplot_version___(),char('4.0'),char('<='))):
        error_(char('ginput: version %s of gnuplot not supported'),gnuplot_version_())
    ostream=get_(f,char('__plot_stream__'))
    if (numel_(ostream) < 1):
        error_(char('ginput: stream to gnuplot not open'))
    else:
        if (ispc_()):
            if (numel_(ostream) == 1):
                error_(char('ginput: Need mkfifo that is not implemented under Windows'))
            use_mkfifo=copy_(false)
            istream=ostream[2]
            ostream=ostream[1]
        else:
            use_mkfifo=copy_(true)
            ostream=ostream[1]
    if (nargin == 1):
        x=zeros_(100,1)
        y=zeros_(100,1)
        button=zeros_(100,1)
    else:
        x=zeros_(n,1)
        y=zeros_(n,1)
        button=zeros_(n,1)
    if (use_mkfifo):
        gpin_name=tmpnam_()
        err,msg=mkfifo_(gpin_name,6 * 8 * 8,nargout=2)
        if (err):
            error_(char('ginput: Can not open fifo (%s)'),msg)
    try:
        k=0
        while (true):

            k
            if (use_mkfifo):
                fprintf_(ostream,char('set print "%s";\n'),gpin_name)
                fflush_(ostream)
                gpin,err=fopen_(gpin_name,char('r'),nargout=2)
                if (err):
                    error_(char('ginput: Can not open FIFO (%s)'),msg)
                fputs_(ostream,char('pause mouse any;\n\n'))
                fputs_(ostream,char('\nif (exists("MOUSE_KEY") && exists("MOUSE_X")) print MOUSE_X, MOUSE_Y, MOUSE_KEY; else print "0 0 -1"\n'))
                fputs_(ostream,char('set print;\n'))
                fflush_(ostream)
                x[k],y[k],button[k],count=fscanf_(gpin,char('%f %f %d'),char('C'),nargout=4)
                fclose_(gpin)
            else:
                fputs_(ostream,char('set print "-";\n'))
                fflush_(ostream)
                fputs_(ostream,char('pause mouse any;\n\n'))
                fputs_(ostream,char('\nif (exists("MOUSE_KEY") && exists("MOUSE_X")) key = (MOUSE_KEY==1063 ? 1 : MOUSE_KEY); print "OCTAVE: ", MOUSE_X, MOUSE_Y, key; else print "0 0 -1"\n'))
                fputs_(ostream,char('set print;\n'))
                fflush_(ostream)
                _str=[]
                while (isempty_(_str)):

                    _str=fread_(istream,char('*char')).T
                    if (isempty_(_str)):
                        sleep_(0.05)
                    else:
                        _str=regexp_(_str,char('OCTAVE:\\s+[-+.\\d]+\\s+[-+.\\d]+\\s+\\d*'),char('match'))
                    fclear_(istream)

                x[k],y[k],button[k],count=sscanf_(_str[end()](arange_(8,end())),char('%f %f %d'),char('C'),nargout=4)
            if ([x[k],y[k],button[k]] == [0,0,- 1]):
                break
            if (button[k] == 13 or button[k] == 10):
                x[k:end()]=[]
                y[k:end()]=[]
                button[k:end()]=[]
                break
            if (nargin > 1 and k == n):
                break

    finally:
        if (use_mkfifo):
            unlink_(gpin_name)
    return x,y,button
def __gnuplot_has_feature___(feature=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[feature].count(None)+len(args)

    features=[char('x11_figure_position'),char('wxt_figure_size'),char('transparent_patches'),char('transparent_surface'),char('epslatex_implies_eps_filesuffix'),char('epslatexstandalone_terminal'),char('screen_coordinates_for_{lrtb}margin'),char('variable_GPVAL_TERMINALS'),char('key_has_font_properties'),char('windows_figure_position'),char('has_termoption_dashed')]
    has_features
    if (isempty_(has_features)):
        try:
            gnuplot_version=__gnuplot_version___()
        finally:
            pass
        versions=[char('4.2.5'),char('4.4'),char('4.4'),char('4.4'),char('4.2'),char('4.2'),char('4.4'),char('4.4'),char('4.4'),char('4.4'),char('4.3')]
        operators=[char('>='),char('>='),char('>='),char('>='),char('>='),char('>='),char('>='),char('>='),char('>='),char('>='),char('>=')]
        have_features=false_(size_(features))
        for n in arange_(1,numel_(have_features)).reshape(-1):
            has_features[n]=compare_versions_(gnuplot_version,versions[n],operators[n])
    n=find_(strcmpi_(feature,features))
    if (isempty_(n)):
        res=copy_(NaN)
    else:
        res=has_features[n]
    return res
def gnuplot_binary_(new_prog=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[new_prog].count(None)+len(args)

    gp_binary=char('gnuplot')
    gp_args=[]
    if (nargout > 0 or nargin == 0):
        prog=copy_(gp_binary)
        args=copy_(gp_args)
    if (nargin == 1):
        if (not ischar_(new_prog) or isempty_(new_prog)):
            error_(char('gnuplot_binary: NEW_PROG must be a non-empty string'))
        gp_binary=copy_(new_prog)
    if (nargin > 1):
        if (not iscellstr_(varargin)):
            error_(char('gnuplot_binary: arguments must be character strings'))
        gp_args=copy_(varargin)
    return prog,args
def ancestor_(h=None,type=None,toplevel=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[h,_type,toplevel].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (ischar_(_type)):
        _type=[_type]
    else:
        if (not iscellstr_(_type)):
            error_(char('ancestor: TYPE must be a string or cell array of strings'))
    find_first=copy_(true)
    if (nargin == 3):
        if (ischar_(toplevel) and strcmpi_(toplevel,char('toplevel'))):
            find_first=copy_(false)
        else:
            error_(char('ancestor: third argument must be "toplevel"'))
    if (isempty_(h)):
        p=matlabarray([])
    else:
        p=cell_(numel_(h),1)
        h=num2cell_(h)
        for nh in arange_(1,numel_(h)).reshape(-1):
            while (true):

                if (isempty_(h[nh]) or not ishandle_(h[nh])):
                    break
                if (any_(strcmpi_(get_(h[nh],char('type')),_type))):
                    p[nh]=h[nh]
                    if (find_first):
                        break
                h[nh]=get_(h[nh],char('parent'))

        if (nh == 1):
            p=p[1]
    return p
def isprop_(h=None,prop=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,prop].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not all_(ishandle_(h))):
        error_(char('isprop: H must be a graphics handle or vector of handles'))
    else:
        if (not ischar_(prop)):
            error_(char('isprop: PROP name must be a string'))
    res=false_(size_(h))
    for i in arange_(1,numel_(res)).reshape(-1):
        try:
            v=get_(h[i],prop)
            res[i]=true
        finally:
            pass
    return res
def ishold_(h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[h].count(None)+len(args)

    if (nargin > 1):
        print_usage_()
    if (nargin == 0):
        fig=gcf_()
        ax=get_(fig,char('currentaxes'))
    else:
        if (ishandle_(h)):
            if (strcmp_(get_(h,char('type')),char('figure'))):
                fig=copy_(h)
                ax=get_(fig,char('currentaxes'))
            else:
                if (strcmp_(get_(h,char('type')),char('axes'))):
                    ax=copy_(h)
                    fig=get_(ax,char('parent'))
                else:
                    error_(char('ishold: H must be an axes or figure graphics handle'))
        else:
            error_(char('ishold: H must be an axes or figure graphics handle'))
    retval=(strcmp_(get_(fig,char('nextplot')),char('add')) and not isempty_(ax) and strcmp_(get_(ax,char('nextplot')),char('add')))
    return retval
def colstyle_(style=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[style].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not ischar_(style)):
        error_(char('colstyle: STYLE must be a string'))
    try:
        opt=__pltopt___(char('colstyle'),style)
        l=opt.linestyle
        c=opt.color
        m=opt.marker
        msg=matlabarray([])
        if [0,0,0] == (c):
            c=char('k')
        else:
            if [1,0,0] == (c):
                c=char('r')
            else:
                if [0,1,0] == (c):
                    c=char('g')
                else:
                    if [0,0,1] == (c):
                        c=char('b')
                    else:
                        if [1,1,0] == (c):
                            c=char('y')
                        else:
                            if [1,0,1] == (c):
                                c=char('m')
                            else:
                                if [0,1,1] == (c):
                                    c=char('c')
                                else:
                                    if [0,1,1] == (c):
                                        c=char('w')
    finally:
        pass
    return l,c,m,msg
def __default_plot_options___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    options.key=char('')
    options.color=[]
    options.linestyle=[]
    options.marker=[]
    options.errorstyle=[]
    return options
def isaxes_(h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[h].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    hlist=ishandle_(h)
    retval=copy_(hlist)
    if (any_(hlist)):
        retval[hlist]=strcmp_(get_(h[hlist],char('type')),char('axes'))
    return retval
def printd_(obj=None,filename=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[obj,filename].count(None)+len(args)

    if ((sufix=rindex_(filename,char('.'))) <= 0):
        error_(char('The output filename: %s requires a suffix.\nOptions are: pdf ps eps txt jpg jpeg'),filename)
    opt=substr_(filename,sufix + 1)
    pf,tempf,mag=mkstemp_(char('oct-XXXXXX'),1,nargout=3)
    fprintf_(pf,char('%s'),disp_(obj))
    frewind_(pf)
    opt=lower_(opt)
    if char('pdf') == (opt):
        enscr=sprintf_(char('enscript --no-header -o %s.ps %s ; ps2pdf %s.ps %s.pdf; mv %s.pdf %s;exit'),tempf,tempf,tempf,tempf,tempf,filename)
        system_(enscr)
        delete_([tempf,char('.ps')])
    else:
        if char('ps') == (opt):
            enscr=sprintf_(char('enscript --no-header -o %s %s ; exit'),filename,tempf)
            system_(enscr)
        else:
            if char('eps') == (opt):
                enscr=sprintf_(char('enscript --no-header -o %s.ps %s ; ps2eps --ignoreBB %s.ps; mv %s.eps %s; exit'),tempf,tempf,tempf,tempf,filename)
                system_(enscr)
                delete_([tempf,char('.ps')])
            else:
                if char('txt') == (opt):
                    enscr=sprintf_(char('cp %s %s'),tempf,filename)
                    system_(enscr)
                else:
                    if [char('jpg'),char('jpeg')] == (opt):
                        enscr=sprintf_(char('convert -trim txt:%s  jpg:%s'),tempf,filename)
                        system_(enscr)
                    else:
                        fclose_(pf)
                        delete_(tempf)
                        error_(char('Unknown conversion type: %s.\nOptions are: pdf ps eps txt jpg jpeg'),opt)
    fclose_(pf)
    delete_(tempf)
    pr_out=sprintf_(char('%s file %s written\n'),opt,filename)
    return pr_out
def shg_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin != 0):
        warning_(char('shg: ignoring extra arguments'))
    drawnow_()
    return
def hold_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin > 0 and isscalar_(varargin[1]) and isaxes_(varargin[1])):
        hax=varargin[1]
        varargin[1]=[]
        nargs=numel_(varargin)
        hfig=get_(hax,char('parent'))
    else:
        if (nargin > 0 and numel_(varargin[1]) > 1 and ishandle_(varargin[1])):
            print_usage_()
        else:
            hax=gca_()
            hfig=gcf_()
            nargs=numel_(varargin)
    hold_all=copy_(false)
    if (nargs == 0):
        turn_hold_off=ishold_(hax)
    else:
        if (nargs == 1):
            state=tolower_(varargin[1])
            if char('off') == (state):
                turn_hold_off=copy_(true)
            else:
                if char('all') == (state):
                    turn_hold_off=copy_(false)
                    hold_all=copy_(true)
                else:
                    if char('on') == (state):
                        turn_hold_off=copy_(false)
                    else:
                        error_(char('hold: invalid hold STATE'))
        else:
            print_usage_()
    if (turn_hold_off):
        set_(hax,char('nextplot'),char('replace'))
    else:
        set_(hax,char('nextplot'),char('add'))
        set_(hfig,char('nextplot'),char('add'))
    set_(hax,char('__hold_all__'),hold_all)
    return
def gco_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h=get_(get_(0,char('currentfigure')),char('currentobject'))
    return h
def findall_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    try:
        shh=get_(0,char('showhiddenhandles'))
        set_(0,char('showhiddenhandles'),char('on'))
        h=findobj_(varargin[:])
    finally:
        set_(0,char('showhiddenhandles'),shh)
    return h
def closereq_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin != 0):
        print_usage_()
    cf=gcbf_()
    if (isempty_(cf)):
        warning_(char("closereq: calling closereq from octave prompt is not supported, use 'close' instead"))
        cf=get_(0,char('currentfigure'))
    if (not isempty_(cf) and isfigure_(cf)):
        delete_(cf)
    return
def isfigure_(h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[h].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    hlist=ishandle_(h)
    if (any_(hlist)):
        retval[hlist]=strcmp_(get_(h[hlist],char('type')),char('figure'))
    else:
        retval=copy_(hlist)
    return retval
def linkprop_(h=None,prop=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,prop].count(None)+len(args)

    if (ischar_(prop)):
        prop=[prop]
    else:
        if (not iscellstr_(prop)):
            error_(char('linkprop: properties must be a string or cell string array'))
    for i in arange_(1,numel_(h)).reshape(-1):
        for j in arange_(1,numel_(prop)).reshape(-1):
            addlistener_(h[i],prop[j],[update_prop,h,prop[j]])
    hlink=hggroup_()
    set_(hlink,char('deletefcn'),[delete_prop,h,prop])
    return hlink
def update_prop_(h=None,d=None,hlist=None,prop=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[h,d,hlist,prop].count(None)+len(args)

    recursion=copy_(false)
    if (not recursion):
        try:
            recursion=copy_(true)
            val=get_(h,prop)
            for hh in hlist[:].T.reshape(-1):
                if (hh != h):
                    oldval=get_(hh,prop)
                    if (not isequal_(val,oldval)):
                        set_(hh,prop,val)
        finally:
            recursion=copy_(false)
    return
def delete_prop_(h=None,d=None,hlist=None,prop=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[h,d,hlist,prop].count(None)+len(args)

    warn=copy_(false)
    for h in hlist[:].T.reshape(-1):
        if (ishandle_(h) and not strcmpi_(get_(h,char('beingdeleted')),char('on'))):
            warn=copy_(true)
            break
    if (warn):
        warning_(char('linkprop: can not remove linked properties'))
    return
def __gnuplot_drawnow___(h=None,term=None,file=None,debug_file=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[h,term,_file,mono,debug_file].count(None)+len(args)

    if (nargin < 1 or nargin > 5 or nargin == 2):
        print_usage_()
    if (nargin >= 3 and nargin <= 5):
        plot_stream=matlabarray([])
        fid=matlabarray([])
        default_plot_stream=get_(h,char('__plot_stream__'))
        try:
            plot_stream=__gnuplot_open_stream___(2,h)
            gnuplot_supports_term=__gnuplot_has_terminal___(term,plot_stream)
            if (gnuplot_supports_term):
                enhanced=gnuplot_set_term_(plot_stream[1],true,h,term,_file)
                __go_draw_figure___(h,plot_stream[1],enhanced,mono)
                if (nargin == 5):
                    fid=fopen_(debug_file,char('wb'))
                    enhanced=gnuplot_set_term_(fid,true,h,term,_file)
                    __go_draw_figure___(h,fid,enhanced,mono)
            else:
                error_(char('__gnuplot_drawnow__: the gnuplot terminal, "%s", is not available'),gnuplot_trim_term_(term))
        finally:
            set_(h,char('__plot_stream__'),default_plot_stream)
            if (not isempty_(plot_stream)):
                pclose_(plot_stream_(1))
                if (numel_(plot_stream) > 1):
                    pclose_(plot_stream_(2))
                if (numel_(plot_stream) > 2):
                    waitpid_(plot_stream_(3))
            if (not isempty_(fid)):
                fclose_(fid)
    else:
        plot_stream=get_(h,char('__plot_stream__'))
        if (isempty_(plot_stream)):
            plot_stream=__gnuplot_open_stream___(2,h)
            new_stream=copy_(true)
        else:
            new_stream=copy_(false)
        term=gnuplot_default_term_(plot_stream)
        if (strcmp_(term,char('dumb'))):
            dumb_tmp_file=tmpnam_()
            enhanced=gnuplot_set_term_(plot_stream[1],new_stream,h,term,dumb_tmp_file)
        else:
            enhanced=gnuplot_set_term_(plot_stream[1],new_stream,h,term)
        __go_draw_figure___(h,plot_stream[1],enhanced,mono)
        fflush_(plot_stream[1])
        if (strcmp_(term,char('dumb'))):
            fid=- 1
            while (fid < 0):

                pause_(0.1)
                fid=fopen_(dumb_tmp_file,char('r'))

            a,count=fscanf_(fid,char('%c'),Inf,nargout=2)
            fclose_(fid)
            if (count > 0):
                if (a[1] == 12):
                    a=a[2:end()]
                puts_(a)
            unlink_(dumb_tmp_file)
    return
def gnuplot_set_term_(plot_stream=None,new_stream=None,h=None,term=None,file=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[plot_stream,new_stream,h,term,_file].count(None)+len(args)

    if (nargin < 4):
        term=gnuplot_default_term_(plot_stream)
        opts_str=char('')
    else:
        term,opts_str=gnuplot_trim_term_(term,nargout=2)
        term=lower_(term)
        if (strcmp_(term,char('lua'))):
            term=char('tikz')
            opts_str=strrep_(opts_str,char('tikz'),char(''))
    if (strfind_(opts_str,char('noenhanced'))):
        enhanced=copy_(false)
    else:
        enhanced=gnuplot_is_enhanced_term_(plot_stream,term)
    if (not isempty_(term)):
        if (enhanced):
            enh_str=char('enhanced')
        else:
            enh_str=char('')
        if (not isempty_(h) and isfigure_(h)):
            if (output_to_screen_(term) and not strcmp_(term,char('dumb'))):
                fig.numbertitle=get_(h,char('numbertitle'))
                fig.name=strrep_(get_(h,char('name')),char('"'),char('\\"'))
                if (strcmp_(get_(h,char('numbertitle')),char('on'))):
                    title_str=sprintf_(char('Figure %d'),h)
                else:
                    title_str=char('')
                if (not isempty_(fig.name) and not isempty_(title_str)):
                    title_str=sprintf_(char('%s: %s'),title_str,fig.name)
                else:
                    if (not isempty_(fig.name) and isempty_(title_str)):
                        title_str=fig.name
                if (not isempty_(title_str)):
                    title_str=sprintf_(char('title "%s"'),title_str)
                if (strcmp_(term,char('aqua'))):
                    opts_str=sprintf_(char('%s font "%s,%d"'),opts_str,get_(0,char('defaultaxesfontname')),get_(0,char('defaultaxesfontsize')) / 1.5)
            else:
                title_str=char('')
            if (not (any_(strfind_(opts_str,char(' size ')) > 0) or any_(strfind_(opts_str,char('size ')) == 1))):
                units=get_(h,char('units'))
                try:
                    set_(h,char('units'),char('pixels'))
                    position_in_pixels=get_(h,char('position'))
                finally:
                    set_(h,char('units'),units)
                gnuplot_pos=position_in_pixels[1:2]
                gnuplot_size=position_in_pixels[3:4]
                if (not (output_to_screen_(term) or any_(strcmp_(term,[char('canvas'),char('emf'),char('gif'),char('jpeg'),char('pbm'),char('png'),char('pngcairo'),char('svg')])))):
                    gnuplot_pos=gnuplot_pos / 72
                    gnuplot_size=gnuplot_size / 72
                if (all_(gnuplot_size > 0)):
                    terminals_with_size=[char('canvas'),char('emf'),char('epslatex'),char('fig'),char('gif'),char('jpeg'),char('latex'),char('pbm'),char('pdf'),char('pdfcairo'),char('postscript'),char('png'),char('pngcairo'),char('pstex'),char('pslatex'),char('svg'),char('tikz')]
                    if (__gnuplot_has_feature___(char('windows_figure_position'))):
                        terminals_with_size[end() + 1]=char('windows')
                    if (__gnuplot_has_feature___(char('x11_figure_position'))):
                        terminals_with_size[end() + 1]=char('x11')
                    if (__gnuplot_has_feature___(char('wxt_figure_size'))):
                        terminals_with_size[end() + 1]=char('wxt')
                    if terminals_with_size == (term):
                        size_str=sprintf_(char('size %.12g,%.12g'),gnuplot_size)
                    else:
                        if char('tikz') == (term):
                            size_str=sprintf_(char('size %gin,%gin'),gnuplot_size)
                        else:
                            if char('dumb') == (term):
                                new_stream=1
                                if (not isempty_(getenv_(char('COLUMNS'))) and not isempty_(getenv_(char('LINES')))):
                                    n=sprintf_(char('%i'),- 2 - length_(find_(sprintf_(char('%s'),PS1) == char('\n'))))
                                    size_str=matlabarray([char('size '),getenv_(char('COLUMNS')),char(','),getenv_(char('LINES')),n])
                                else:
                                    size_str=char('')
                            else:
                                if [char('aqua'),char('fig'),char('corel')] == (term):
                                    size_str=sprintf_(char('size %g %g'),gnuplot_size)
                                else:
                                    if char('dxf') == (term):
                                        size_str=char('')
                                    else:
                                        size_str=char('')
                    if ((strcmp_(term,char('x11')) and __gnuplot_has_feature___(char('x11_figure_position'))) or (strcmpi_(term,char('windows')) and __gnuplot_has_feature___(char('windows_figure_position')))):
                        units=get_(0,char('units'))
                        try:
                            set_(0,char('units'),char('pixels'))
                            screen_size=get_(0,char('screensize'))(arange_(3,4))
                        finally:
                            set_(0,char('units'),units)
                        if (all_(screen_size > 0)):
                            gnuplot_pos[2]=screen_size[2] - gnuplot_pos[2] - gnuplot_size[2]
                            gnuplot_pos=max_(gnuplot_pos,1)
                            size_str=sprintf_(char('%s position %d,%d'),size_str,gnuplot_pos[1],gnuplot_pos[2])
                else:
                    size_str=char('')
                    warning_(char('gnuplot_set_term: size is zero'))
            else:
                size_str=char('')
        else:
            if (isempty_(h)):
                disp_(char('gnuplot_set_term: figure handle is empty'))
            else:
                if (not isfigure_(h)):
                    disp_(char('gnuplot_set_term: not a figure handle'))
            title_str=char('')
            size_str=char('')
        term_str=matlabarray([char('set terminal '),term])
        if (not isempty_(enh_str)):
            term_str=matlabarray([term_str,char(' '),enh_str])
        if (not isempty_(title_str)):
            term_str=matlabarray([term_str,char(' '),title_str])
        if (isempty_(strfind_(term,char('corel')))):
            if (not isempty_(size_str) and new_stream):
                term_str=matlabarray([term_str,char(' '),size_str])
            if (nargin > 3 and ischar_(opts_str)):
                term_str=matlabarray([term_str,char(' '),opts_str])
        else:
            if (nargin > 3 and ischar_(opts_str)):
                term_str=matlabarray([term_str,char(' '),opts_str])
            if (not isempty_(size_str) and new_stream):
                term_str=matlabarray([term_str,char(' '),size_str])
        if (not __gnuplot_has_feature___(char('has_termoption_dashed'))):
            if (any_(strcmp_(term,[char('aqua'),char('cgm'),char('eepic'),char('emf'),char('epslatex'),char('fig'),char('pcl5'),char('mp'),char('next'),char('openstep'),char('pdf'),char('pdfcairo'),char('pngcairo'),char('postscript'),char('pslatex'),char('pstext'),char('svg'),char('tgif'),char('x11')]))):
                term_str=matlabarray([term_str,char(' dashed')])
        if (any_(strcmp_(term,[char('aqua'),char('wxt')]))):
            term_str=matlabarray([term_str,char(' '),char('dashlength 1')])
        else:
            if (any_(strcmp_(term,[char('epslatex'),char('postscript'),char('pslatex')]))):
                term_str=matlabarray([term_str,char(' '),char('dashlength 2')])
        fputs_(plot_stream,char('unset multiplot;\n'))
        flickering_terms=[char('x11'),char('windows'),char('wxt'),char('dumb')]
        if (not any_(strcmp_(term,flickering_terms)) or have_non_legend_axes_(h) or numel_(findall_(h,char('type'),char('image'))) > 0):
            fprintf_(plot_stream,char('%s\n'),term_str)
            if (nargin == 5):
                if (not isempty_(_file)):
                    fprintf_(plot_stream,char("set output '%s';\n"),_file)
            fputs_(plot_stream,char('set multiplot;\n'))
        else:
            if (any_(strcmp_(term,flickering_terms))):
                fprintf_(plot_stream,char('%s\n'),term_str)
                if (nargin == 5):
                    if (not isempty_(_file)):
                        fprintf_(plot_stream,char("set output '%s';\n"),_file)
        if (__gnuplot_has_feature___(char('has_termoption_dashed'))):
            fprintf_(plot_stream,char('set termoption dashed\n'))
    return enhanced
def gnuplot_default_term_(plot_stream=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[plot_stream].count(None)+len(args)

    term=lower_(getenv_(char('GNUTERM')))
    if (isempty_(term) or not __gnuplot_has_terminal___(term,plot_stream)):
        if (isguirunning_() and __gnuplot_has_terminal___(char('qt'),plot_stream)):
            term=char('qt')
        else:
            if (ismac_()):
                term=char('aqua')
            else:
                if (not isunix_()):
                    term=char('windows')
                else:
                    if (not isempty_(getenv_(char('DISPLAY')))):
                        term=char('x11')
                    else:
                        term=char('dumb')
    return term
def gnuplot_trim_term_(string=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[string].count(None)+len(args)

    string=strtrim_(string)
    term,opts=strtok_(string,char(' '),nargout=2)
    if (not isempty_(opts)):
        opts[1]=char('')
    return term,opts
def gnuplot_is_enhanced_term_(plot_stream=None,term=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[plot_stream,term].count(None)+len(args)

    enhanced_terminals=[char('aqua'),char('canvas'),char('dumb'),char('emf'),char('gif'),char('jpeg'),char('pdf'),char('pdfcairo'),char('pm'),char('png'),char('pngcairo'),char('postscript'),char('qt'),char('svg'),char('windows'),char('wxt'),char('x11')]
    if (nargin < 2):
        term=gnuplot_default_term_(plot_stream)
    have_enhanced=any_(strcmp_(term,enhanced_terminals))
    return have_enhanced
def output_to_screen_(term=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[term].count(None)+len(args)

    ret=any_(strcmpi_(term,[char('aqua'),char('dumb'),char('pm'),char('qt'),char('windows'),char('wxt'),char('x11')]))
    return ret
def have_non_legend_axes_(h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[h].count(None)+len(args)

    retval=copy_(false)
    all_axes=findall_(h,char('type'),char('axes'))
    if (not isempty_(all_axes)):
        n_all_axes=numel_(all_axes)
        all_axes_tags=get_(all_axes,char('tag'))
        legend_axes=strcmp_(all_axes_tags,char('legend'))
        if (not isempty_(legend_axes)):
            n_legend_axes=sum_(legend_axes)
            retval=(n_all_axes - n_legend_axes) > 1
    return retval
def ishghandle_(h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[h].count(None)+len(args)

    retval=ishandle_(h)
    return retval
def axes_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0 or nargin > 1):
        idx=find_(strcmpi_(varargin[1:2:end()],char('parent')),1,char('first'))
        if (not isempty_(idx) and length_(varargin) >= 2 * idx):
            cf=varargin[2 * idx]
            varargin[[2 * idx - 1,2 * idx]]=[]
        else:
            cf=gcf_()
        htmp=__go_axes___(cf,varargin[:])
        if (__is_handle_visible___(htmp)):
            set_(ancestor_(cf,char('figure')),char('currentaxes'),htmp)
    else:
        htmp=varargin[1]
        if (isscalar_(htmp) and isaxes_(htmp)):
            if (__is_handle_visible___(htmp)):
                parent=ancestor_(htmp,char('figure'))
                set_(0,char('currentfigure'),parent)
                set_(parent,char('currentaxes'),htmp)
                ch=get_(parent,char('children'))(arange_())
                idx=(ch == htmp)
                ch=matlabarray([[ch[idx]],[ch[not idx]]])
                set_(parent,char('children'),ch)
        else:
            error_(char('axes: H must be a scalar axes handle'))
    if (nargout > 0):
        h=copy_(htmp)
    return h
def clf_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin > 2):
        print_usage_()
    else:
        if (nargin == 0):
            hfig=copy_(gcf)
            do_reset=copy_(false)
        else:
            if (nargin == 1):
                if (isscalar_(varargin[1]) and isfigure_(varargin[1])):
                    hfig=varargin[1]
                    do_reset=copy_(false)
                else:
                    if (ischar_(varargin[1]) and strcmpi_(varargin[1],char('reset'))):
                        hfig=copy_(gcf)
                        do_reset=copy_(true)
                    else:
                        print_usage_()
            else:
                if (isscalar_(varargin[1]) and isfigure_(varargin[1]) and ischar_(varargin[2]) and strcmpi_(varargin[2],char('reset'))):
                    hfig=varargin[1]
                    do_reset=copy_(true)
                else:
                    print_usage_()
    if (do_reset):
        delete_(allchild_(hfig))
        reset_(hfig)
    else:
        delete_(get_(hfig,char('children')))
    if (nargout > 0):
        h=copy_(hfig)
    return h
def refresh_(h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[h].count(None)+len(args)

    if (nargin > 1):
        print_usage_()
    else:
        if (nargin == 1):
            if (not isfigure_(h)):
                error_(char('refresh: H must be a valid figure handle'))
        else:
            h=gcf_()
    set_(h,char('__modified__'),char('on'))
    drawnow_()
    return
def cla_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin > 2):
        print_usage_()
    else:
        if (nargin == 0):
            hax=copy_(gca)
            do_reset=copy_(false)
        else:
            if (nargin == 1):
                if (isscalar_(varargin[1]) and isaxes_(varargin[1])):
                    hax=varargin[1]
                    do_reset=copy_(false)
                else:
                    if (ischar_(varargin[1]) and strcmpi_(varargin[1],char('reset'))):
                        hax=copy_(gca)
                        do_reset=copy_(true)
                    else:
                        print_usage_()
            else:
                if (isscalar_(varargin[1]) and isaxes_(varargin[1]) and ischar_(varargin[2]) and strcmpi_(varargin[2],char('reset'))):
                    hax=varargin[1]
                    do_reset=copy_(true)
                else:
                    print_usage_()
    if (not do_reset):
        delete_(get_(hax,char('children')))
    else:
        __go_axes_init___(hax,char('replace'))
        __request_drawnow___()
    return
def copyobj_(horig=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[horig,hparent].count(None)+len(args)

    partypes=[char('root'),char('figure'),char('axes'),char('hggroup')]
    othertypes=[char('line'),char('patch'),char('surface'),char('image'),char('text')]
    alltypes=matlabarray([partypes,othertypes])
    if (not ishandle_(horig) or nargin > 2):
        print_usage_()
    else:
        if (not ishandle_(hparent)):
            hparent=figure_(fix_(hparent))
        else:
            if (not any_(strcmpi_(get_(hparent).type,partypes))):
                print_usage_()
    cf=gcf_()
    ca=gca_()
    kididx=find_(strcmp_(alltypes,get_(horig).type))
    paridx=find_(strcmp_(alltypes,get_(hparent).type))
    if (kididx <= paridx):
        error_(char("copyobj: %s object can't be children to %s."),alltypes[kididx],alltypes[paridx])
    else:
        if (nargin == 1):
            _str=hdl2struct_(horig)
            hnew=struct2hdl_(_str)
        else:
            _str=hdl2struct_(horig)
            hnew=struct2hdl_(_str,hparent)
    set_(0,char('currentfigure'),cf)
    if (get_(hnew,char('parent')) == cf):
        set_(cf,char('currentaxes'),ca)
    return hnew
def meshgrid_(x=None,y=None,z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,z].count(None)+len(args)

    if (nargin == 0 or nargin > 3):
        print_usage_()
    if (nargin < 2):
        y=copy_(x)
    if (nargout < 3):
        if (not (isvector_(x) and isvector_(y))):
            error_(char('meshgrid: X and Y must be vectors'))
        xx=repmat_(x[:].T,length_(y),1)
        yy=repmat_(y[:],1,length_(x))
    else:
        if (nargin < 3):
            z=copy_(y)
        if (not (isvector_(x) and isvector_(y) and isvector_(z))):
            error_(char('meshgrid: X, Y, and Z must be vectors'))
        lenx=length_(x)
        leny=length_(y)
        lenz=length_(z)
        xx=repmat_(repmat_(x[:].T,leny,1),[1,1,lenz])
        yy=repmat_(repmat_(y[:],1,lenx),[1,1,lenz])
        zz=reshape_(repmat_(z[:].T,lenx * leny,1)(arange_()),leny,lenx,lenz)
    return xx,yy,zz
def __next_line_style___(reset=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[reset].count(None)+len(args)

    reset_style=copy_(true)
    if (nargin == 1):
        reset_style=copy_(reset)
    else:
        ca=gca_()
        style_rotation=get_(ca,char('linestyleorder'))
        if (ischar_(style_rotation)):
            style_rotation=strsplit_(style_rotation,char('|'))
        nStyles=length_(style_rotation)
        if (reset_style or (nStyles < 2)):
            style_index=1
            reset_style=copy_(false)
        else:
            nChildren=length_(get_(ca,char('Children')))
            nColors=rows_(get_(ca,char('ColorOrder')))
            style_index=mod_(floor_(nChildren / nColors),nStyles) + 1
        options=__pltopt___(char('__next_line_style__'),style_rotation[style_index])
        linestyle=options.linestyle
        marker=options.marker
    return linestyle,marker
def figure_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    nargs=copy_(nargin)
    if (mod_(nargs,2) == 0):
        f=copy_(NaN)
        init_new_figure=copy_(true)
    else:
        arg=varargin[1]
        if (ischar_(arg)):
            arg=str2double_(arg)
        if (isscalar_(arg) and isfigure_(arg)):
            f=copy_(arg)
            init_new_figure=copy_(false)
            varargin[1]=[]
            nargs
        else:
            if (isscalar_(arg) and isnumeric_(arg) and arg > 0 and arg == fix_(arg)):
                f=copy_(arg)
                init_new_figure=copy_(true)
                varargin[1]=[]
                nargs
            else:
                error_(char('figure: N must be figure handle or figure number'))
    if (rem_(nargs,2) == 1):
        error_(char('figure: PROPERTY/VALUE arguments must be in pairs'))
    cf=get_(0,char('currentfigure'))
    if (not isempty_(cf) and cf != 0):
        if (init_new_figure or cf != f):
            drawnow_()
    if (init_new_figure):
        if (ismac_() and strcmp_(graphics_toolkit_(),char('fltk'))):
            f=__go_figure___(f)
            drawnow_()
            if (not isempty_(varargin)):
                set_(f,varargin[:])
        else:
            f=__go_figure___(f,varargin[:])
        __add_default_menu___(f)
    else:
        if (nargs > 0):
            set_(f,varargin[:])
    set_(0,char('currentfigure'),f)
    if (not init_new_figure and not any_(strcmpi_(varargin[1:2:end()],char('visible')) and strcmpi_(varargin[2:2:end()],char('off')))):
        set_(f,char('visible'),char('on'))
    if (nargout > 0):
        h=copy_(f)
    return h
def findfigs_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hfigs=allchild_(0)
    units=get_(0,char('units'))
    try:
        set_(0,char('units'),char('pixels'))
        screensize=get_(0,char('screensize'))
    finally:
        set_(0,char('units'),units)
    margin=30
    screensize[1:2] += margin
    screensize[3:4] -= margin
    hfigs=hfigs[strcmp_(get_(hfigs,char('visible')),char('on'))]
    for hf in hfigs.T.reshape(-1):
        units=get_(hf,char('units'))
        try:
            set_(hf,char('units'),char('pixels'))
            pos=get_(hf,char('position'))
            if (pos[1] > screensize[3] or pos[2] > screensize[4] or pos[1] + pos[3] < screensize[1] or pos[2] + pos[4] < screensize[2]):
                pos[1]=screensize[1]
                pos[2]=screensize[2]
                set_(hf,char('position'),pos)
        finally:
            set_(hf,char('units'),units)
    return
def __actual_axis_position___(h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[h].count(None)+len(args)

    if (ishandle_(h)):
        axis_obj=get_(h)
    else:
        if (isstruct_(h)):
            axis_obj=copy_(h)
            h=axis_obj.__cbar_hax__
    orig_fig_units=get_(axis_obj.parent,char('units'))
    orig_fig_position=get_(axis_obj.parent,char('position'))
    try:
        set_(axis_obj.parent,char('units'),char('pixels'))
        fig_position=get_(axis_obj.parent,char('position'))
    finally:
        set_(axis_obj.parent,char('units'),orig_fig_units)
        set_(axis_obj.parent,char('position'),orig_fig_position)
    if (strcmp_(get_(axis_obj.parent,char('__graphics_toolkit__')),char('gnuplot')) and strcmp_(axis_obj.activepositionproperty,char('outerposition'))):
        pos_in_pixels=axis_obj.outerposition.dot(fig_position[[3,4,3,4]])
    else:
        pos_in_pixels=axis_obj.position.dot(fig_position[[3,4,3,4]])
    nd=__calc_dimensions___(h)
    if (strcmp_(axis_obj.plotboxaspectratiomode,char('manual')) or strcmp_(axis_obj.dataaspectratiomode,char('manual'))):
        if (nd == 2 or all_(mod_(axis_obj.view,90) == 0)):
            aspect_ratio_2d=axis_obj.plotboxaspectratio(arange_(1,2))
        else:
            aspect_ratio_2d=matlabarray([max_(axis_obj.plotboxaspectratio(arange_(1,2))),axis_obj.plotboxaspectratio(3) / sqrt_(2)])
        orig_aspect_ratio_2d=pos_in_pixels[3:4]
        rel_aspect_ratio_2d=aspect_ratio_2d / orig_aspect_ratio_2d
        rel_aspect_ratio_2d=rel_aspect_ratio_2d / max_(rel_aspect_ratio_2d)
        if (rel_aspect_ratio_2d[1] < rel_aspect_ratio_2d[2]):
            dx=(1.0 - rel_aspect_ratio_2d[1]) * pos_in_pixels[3]
            pos_in_pixels=pos_in_pixels + dx * [0.5,0.0,- 1.0,0.0]
        else:
            if (rel_aspect_ratio_2d[1] > rel_aspect_ratio_2d[2]):
                dy=(1.0 - rel_aspect_ratio_2d[2]) * pos_in_pixels[4]
                pos_in_pixels=pos_in_pixels + dy * [0.0,0.5,0.0,- 1.0]
        pos=pos_in_pixels / fig_position[[3,4,3,4]]
    else:
        if (strcmp_(get_(axis_obj.parent,char('__graphics_toolkit__')),char('gnuplot')) and strcmp_(axis_obj.activepositionproperty,char('outerposition'))):
            pos=axis_obj.outerposition
        else:
            pos=axis_obj.position
    return pos
def gcf_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0):
        h=get_(0,char('currentfigure'))
        if (isempty_(h) or h == 0):
            h=figure_()
    else:
        print_usage_()
    return h
def gcbo_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h=get_(0,char('callbackobject'))
    fig=matlabarray([])
    if (not isempty_(h) and nargout > 1):
        fig=ancestor_(h,char('figure'))
    return h,fig
def pbaspect_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin > 0):
        if (isscalar_(varargin[1]) and isaxes_(varargin[1])):
            hax=varargin[1]
            varargin=varargin[2:end()]
        else:
            hax=gca_()
    else:
        hax=gca_()
    nargin=numel_(varargin)
    if (nargin > 1):
        print_usage_()
    if (nargin == 0):
        pbratio=get_(hax,char('plotboxaspectratio'))
    else:
        arg=varargin[1]
        if (isnumeric_(arg)):
            if (numel_(arg) == 2):
                set_(hax,char('plotboxaspectratio'),[arg,1])
            else:
                if (numel_(arg) == 3):
                    set_(hax,char('plotboxaspectratio'),arg)
                else:
                    error_(char('pbaspect: PLOT_BOX_ASPECT_RATIO must be a 2 or 3 element vector'))
        else:
            if (ischar_(arg)):
                arg=tolower_(arg)
                if char('auto') == (arg):
                    set_(hax,char('plotboxaspectratiomode'),char('auto'))
                else:
                    if char('manual') == (arg):
                        set_(hax,char('plotboxaspectratiomode'),char('manual'))
                    else:
                        if char('mode') == (arg):
                            pbratio=get_(hax,char('plotboxaspectratiomode'))
                        else:
                            error_(char('pbaspect: Invalid mode <%s>'),arg)
            else:
                print_usage_()
    return pbratio
def ylim_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    ret=__axis_limits___(char('ylim'),varargin[:])
    if (not isempty_(ret)):
        retval=copy_(ret)
    return retval
def box_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargs=__plt_get_axis_arg___(char('box'),varargin[:],nargout=3)
    if (isempty_(hax)):
        hax=gca_()
    if (nargs == 0):
        box_state=get_(hax,char('box'))
        if (strcmp_(box_state,char('on'))):
            box_state=char('off')
        else:
            box_state=char('on')
    else:
        if (nargs == 1):
            state=varargin[1]
            if (ischar_(state)):
                if (strcmpi_(state,char('off'))):
                    box_state=char('off')
                else:
                    if (strcmpi_(state,char('on'))):
                        box_state=char('on')
                    else:
                        error_(char('box: argument must be "on" or "off"'))
            else:
                error_(char('box: argument must be "on" or "off"'))
        else:
            print_usage_()
    set_(hax,char('box'),box_state)
    return
def axis_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('axis'),varargin[:],nargout=3)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        if (isempty_(hax)):
            hax=gca_()
        if (nargin == 0):
            limits=__axis___(hax,varargin[:])
        else:
            __axis___(hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    return limits
def __axis___(ca=None,ax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[ca,ax].count(None)+len(args)

    if (nargin == 1):
        if (nargout == 0):
            set_(ca,char('xlimmode'),char('auto'),char('ylimmode'),char('auto'),char('zlimmode'),char('auto'))
        else:
            xlim=get_(ca,char('xlim'))
            ylim=get_(ca,char('ylim'))
            view=get_(ca,char('view'))
            if (view[2] == 90):
                limits=matlabarray([xlim,ylim])
            else:
                zlim=get_(ca,char('zlim'))
                limits=matlabarray([xlim,ylim,zlim])
    else:
        if (ischar_(ax)):
            _len=length_(ax)
            if (strcmpi_(ax,char('ij'))):
                set_(ca,char('ydir'),char('reverse'))
            else:
                if (strcmpi_(ax,char('xy'))):
                    set_(ca,char('ydir'),char('normal'))
                else:
                    if (strcmpi_(ax,char('image'))):
                        __axis___(ca,char('equal'))
                        set_(ca,char('plotboxaspectratiomode'),char('auto'))
                        __do_tight_option___(ca)
                    else:
                        if (strcmpi_(ax,char('square'))):
                            set_(ca,char('dataaspectratiomode'),char('auto'),char('plotboxaspectratio'),[1,1,1])
                        else:
                            if (strcmp_(ax,char('equal'))):
                                if (strcmp_(get_(get_(ca,char('parent')),char('__graphics_toolkit__')),char('gnuplot'))):
                                    set_(ca,char('activepositionproperty'),char('position'))
                                    set_(ca,char('dataaspectratiomode'),char('auto'))
                                set_(ca,char('dataaspectratio'),[1,1,1],char('plotboxaspectratio'),[5,4,4])
                            else:
                                if (strcmpi_(ax,char('normal'))):
                                    set_(ca,char('plotboxaspectratio'),[3,2,1])
                                    set_(ca,char('plotboxaspectratiomode'),char('auto'),char('dataaspectratiomode'),char('auto'))
                                else:
                                    if (_len >= 4 and strcmpi_(ax[1:4],char('auto'))):
                                        if (_len > 4):
                                            if (any_(ax == char('x'))):
                                                set_(ca,char('xlimmode'),char('auto'))
                                            if (any_(ax == char('y'))):
                                                set_(ca,char('ylimmode'),char('auto'))
                                            if (any_(ax == char('z'))):
                                                set_(ca,char('zlimmode'),char('auto'))
                                        else:
                                            set_(ca,char('xlimmode'),char('auto'),char('ylimmode'),char('auto'),char('zlimmode'),char('auto'))
                                    else:
                                        if (strcmpi_(ax,char('manual'))):
                                            set_(ca,char('xlimmode'),char('manual'),char('ylimmode'),char('manual'),char('zlimmode'),char('manual'))
                                        else:
                                            if (strcmpi_(ax,char('tight'))):
                                                __do_tight_option___(ca)
                                            else:
                                                if (strcmpi_(ax,char('on')) or strcmpi_(ax,char('tic'))):
                                                    set_(ca,char('xtickmode'),char('auto'),char('ytickmode'),char('auto'),char('ztickmode'),char('auto'))
                                                    if (strcmpi_(ax,char('on'))):
                                                        set_(ca,char('xticklabelmode'),char('auto'),char('yticklabelmode'),char('auto'),char('zticklabelmode'),char('auto'))
                                                    set_(ca,char('visible'),char('on'))
                                                else:
                                                    if (strcmpi_(ax,char('off'))):
                                                        set_(ca,char('xtick'),[],char('ytick'),[],char('ztick'),[])
                                                        set_(ca,char('visible'),char('off'))
                                                    else:
                                                        if (_len > 3 and strcmpi_(ax[1:3],char('tic'))):
                                                            if (any_(ax == char('x'))):
                                                                set_(ca,char('xtickmode'),char('auto'))
                                                            else:
                                                                set_(ca,char('xtick'),[])
                                                            if (any_(ax == char('y'))):
                                                                set_(ca,char('ytickmode'),char('auto'))
                                                            else:
                                                                set_(ca,char('ytick'),[])
                                                            if (any_(ax == char('z'))):
                                                                set_(ca,char('ztickmode'),char('auto'))
                                                            else:
                                                                set_(ca,char('ztick'),[])
                                                        else:
                                                            if (strcmpi_(ax,char('label'))):
                                                                set_(ca,char('xticklabelmode'),char('auto'),char('yticklabelmode'),char('auto'),char('zticklabelmode'),char('auto'))
                                                            else:
                                                                if (strcmpi_(ax,char('nolabel'))):
                                                                    set_(ca,char('xticklabel'),char(''),char('yticklabel'),char(''),char('zticklabel'),char(''))
                                                                else:
                                                                    if (_len > 5 and strcmpi_(ax[1:5],char('label'))):
                                                                        if (any_(ax == char('x'))):
                                                                            set_(ca,char('xticklabelmode'),char('auto'))
                                                                        else:
                                                                            set_(ca,char('xticklabel'),char(''))
                                                                        if (any_(ax == char('y'))):
                                                                            set_(ca,char('yticklabelmode'),char('auto'))
                                                                        else:
                                                                            set_(ca,char('yticklabel'),char(''))
                                                                        if (any_(ax == char('z'))):
                                                                            set_(ca,char('zticklabelmode'),char('auto'))
                                                                        else:
                                                                            set_(ca,char('zticklabel'),char(''))
                                                                    else:
                                                                        warning_(char("unknown axis option '%s'"),ax)
        else:
            if (isvector_(ax)):
                _len=length_(ax)
                if (_len != 2 and _len != 4 and _len != 6):
                    error_(char('axis: expecting vector with 2, 4, or 6 elements'))
                for i in arange_(1,_len,2).reshape(-1):
                    if (ax[i] >= ax[i + 1]):
                        error_(char('axis: limits(%d) must be less than limits(%d)'),i,i + 1)
                if (_len > 1):
                    set_(ca,char('xlim'),[ax[1],ax[2]])
                if (_len > 3):
                    set_(ca,char('ylim'),[ax[3],ax[4]])
                if (_len > 5):
                    set_(ca,char('zlim'),[ax[5],ax[6]])
            else:
                error_(char('axis: expecting no args, or a vector with 2, 4, or 6 elements'))
    if (not isempty_(varargin)):
        __axis___(ca,varargin[:])
    return limits
def __get_tight_lims___(ca=None,ax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[ca,ax].count(None)+len(args)

    kids=findobj_(ca,char('-property'),strcat_(ax,char('data')))
    hg_kids=findobj_(kids,char('type'),char('hggroup'))
    kids=setdiff_(kids,hg_kids)
    if (isempty_(kids)):
        lims=get_(ca,strcat_(ax,char('lim')))
    else:
        data=get_(kids,strcat_(ax,char('data')))
        types=get_(kids,char('type'))
        scale=get_(ca,strcat_(ax,char('scale')))
        if (not iscell_(data)):
            data=[data]
        idx=strcmp_(types,char('image'))
        if (any_(idx) and (ax == char('x') or ax == char('y'))):
            imdata=data[idx]
            px=arrayfun_(__image_pixel_size__,kids[idx],char('uniformoutput'),false)
            ipx=ifelse_(ax == char('x'),1,2)
            imdata=cellfun_(lambda x,dx: [(min_(x) - dx[ipx]),(max_(x) + dx[ipx])],imdata,px,char('uniformoutput'),false)
            data[idx]=imdata
        if (strcmp_(scale,char('log'))):
            tmp=copy_(data)
            data=cellfun_(lambda x: x[x > 0],tmp,char('uniformoutput'),false)
            n=cellfun_(char('isempty'),data)
            data[n]=cellfun_(lambda x: x[x < 0],tmp[n],char('uniformoutput'),false)
        data=cellfun_(lambda x: x[isfinite_(x)],data,char('uniformoutput'),false)
        data=data[not cellfun_(char('isempty'),data)]
        if (not isempty_(data)):
            data=cat_(1,cellindexmat_(data,char(':'))[:])
            lims=matlabarray([min_(data),max_(data)])
        else:
            lims=matlabarray([0,1])
    return lims
def __do_tight_option___(ca=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[ca].count(None)+len(args)

    xlim=__get_tight_lims___(ca,char('x'))
    if (all_(xlim == 0)):
        xlim=eps_() * [- 1,1]
    else:
        if (diff_(xlim == 0)):
            xlim=xlim.dot((1 + eps_() * [- 1,1]))
    ylim=__get_tight_lims___(ca,char('y'))
    if (all_(ylim == 0)):
        ylim=eps_() * [- 1,1]
    else:
        if (diff_(ylim == 0)):
            ylim=ylim.dot((1 + eps_() * [- 1,1]))
    set_(ca,char('xlim'),xlim,char('ylim'),ylim)
    nd=__calc_dimensions___(ca)
    is3dview=(get_(ca,char('view'))(2) != 90)
    if (nd > 2 and is3dview):
        zlim=__get_tight_lims___(ca,char('z'))
        if (all_(zlim == 0)):
            zlim=eps_() * [- 1,1]
        else:
            if (diff_(zlim == 0)):
                zlim=zlim.dot((1 + eps_() * [- 1,1]))
        set_(ca,char('zlim'),zlim)
    return
def zlabel_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('zlabel'),varargin[:],nargout=3)
    if (isempty_(hax)):
        hax=gca_()
    if (rem_(nargin,2) != 1):
        print_usage_()
    htmp=__axis_label___(hax,char('zlabel'),varargin[1],char('color'),get_(hax,char('zcolor')),varargin[2:end()])
    if (nargout > 0):
        h=copy_(htmp)
    return h
def xlim_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    ret=__axis_limits___(char('xlim'),varargin[:])
    if (not isempty_(ret)):
        retval=copy_(ret)
    return retval
def view_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('view'),varargin[:],nargout=3)
    if (isempty_(hax)):
        hax=gca_()
    if (nargin > 3):
        print_usage_()
    if (nargin == 0):
        x=get_(hax,char('view'))
        az=x[1]
        el=x[2]
    else:
        if (length_(varargin) == 1):
            x=varargin[1]
            if (length_(x) == 2):
                az=x[1]
                el=x[2]
            else:
                if (length_(x) == 3):
                    az,el=cart2sph_(x[1],x[2],x[3],nargout=2)
                    az *= 180 / pi
                    az += 90
                    el *= 180 / pi
                else:
                    if (x == 2):
                        az=0
                        el=90
                    else:
                        if (x == 3):
                            az=- 37.5
                            el=30
                        else:
                            print_usage_()
        else:
            if (length_(varargin) == 2):
                az=varargin[1]
                el=varargin[2]
    if (nargin > 0):
        set_(hax,char('view'),[az,el])
    else:
        if (nargout == 1):
            azimuth=matlabarray([az,el])
        else:
            if (nargout == 2):
                azimuth=copy_(az)
                elevation=copy_(el)
    return azimuth,elevation
def __axis_limits___(fcn=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[fcn].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(fcn,varargin[:],nargout=3)
    if (isempty_(hax)):
        hax=gca_()
    if (nargin == 0):
        retval=get_(hax,fcn)
    else:
        retval=matlabarray([])
        fcnmode=matlabarray([fcn,char('mode')])
        arg=varargin[1]
        if (ischar_(arg)):
            if (strcmpi_(arg,char('mode'))):
                retval=get_(hax,fcnmode)
            else:
                if (any_(strcmpi_(arg,[char('auto'),char('manual')]))):
                    set_(hax,fcnmode,arg)
        else:
            if (not isnumeric_(arg) and any_(size_(arg[:]) != [2,1])):
                error_(char('%s: LIMITS must be a 2-element vector'),fcn)
            else:
                if (arg[1] >= arg[2]):
                    error_(char('%s: axis limits must be increasing'),fcn)
                else:
                    set_(hax,fcn,arg[:])
    return retval
def __axis_label___(hax=None,caller=None,txt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[hax,caller,txt].count(None)+len(args)

    h=get_(hax,caller)
    set_(h,char('fontangle'),get_(hax,char('fontangle')),char('fontname'),get_(hax,char('fontname')),char('fontunits'),get_(hax,char('fontunits')),char('fontsize'),get_(hax,char('fontsize')),char('fontweight'),get_(hax,char('fontweight')),char('string'),txt,varargin[:])
    if (nargout > 0):
        retval=copy_(h)
    return retval
def shading_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('shading'),varargin[:],nargout=3)
    if (nargin != 1):
        print_usage_()
    mode=varargin[1]
    if (isempty_(hax)):
        hax=gca_()
    hlist=matlabarray([])
    kids=get_(hax,char('children'))
    while (not isempty_(kids)):

        types=get_(kids,char('type'))
        hlist=matlabarray([[hlist],[kids[strcmp_(types,char('patch'))]]])
        hlist=matlabarray([[hlist],[kids[strcmp_(types,char('surface'))]]])
        parents=kids[strcmp_(types,char('axes'))]
        hglist=kids[strcmp_(types,char('hggroup'))]
        for i in arange_(1,numel_(hglist)).reshape(-1):
            props=get_(hglist[i])
            if (not isfield_(props,char('levelstep'))):
                parents[end() + 1]=hglist[i]
        kids=get_(parents,char('children'))

    if char('flat') == (lower___(mode)):
        set_(hlist,char('facecolor'),char('flat'))
        set_(hlist,char('edgecolor'),char('none'))
    else:
        if char('interp') == (lower___(mode)):
            set_(hlist,char('facecolor'),char('interp'))
            set_(hlist,char('edgecolor'),char('none'))
        else:
            if char('faceted') == (lower___(mode)):
                set_(hlist,char('facecolor'),char('flat'))
                set_(hlist,char('edgecolor'),[0,0,0])
            else:
                error_(char('shading: Invalid MODE "%s"'),mode)
    return
def caxis_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('caxis'),varargin[:],nargout=3)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    try:
        if (isempty_(hax)):
            hax=gca_()
        if (nargin == 0):
            limits=__caxis___(hax)
        else:
            __caxis___(hax,varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    return limits
def __caxis___(ca=None,ax=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[ca,ax].count(None)+len(args)

    if (nargin == 1):
        limits=get_(ca,char('clim'))
    else:
        if (ischar_(ax)):
            if (strcmpi_(ax,char('auto'))):
                set_(ca,char('climmode'),char('auto'))
            else:
                if (strcmpi_(ax,char('manual'))):
                    set_(ca,char('climmode'),char('manual'))
        else:
            if (isvector_(ax)):
                _len=length_(ax)
                if (_len != 2):
                    error_(char('caxis: expecting vector with 2 elements'))
                set_(ca,char('clim'),[ax[1],ax[2]])
            else:
                error_(char('caxis: expecting no args, a string, or a 2 element vector'))
    if (nargin > 2):
        __caxis___(ca,varargin[:]).T
    return limits
def specular_(sx=None,sy=None,sz=None,lv=None,vv=None,se=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[sx,sy,sz,lv,vv,se].count(None)+len(args)

    if (nargin < 5 or nargin > 6):
        print_usage_()
    if (nargin < 6):
        se=10
    else:
        if (not isnumeric_(se) or numel_(se) != 1 or se <= 0):
            error_(char('specular: exponent must be positive scalar'))
    if (not size_equal_(sx,sy,sz)):
        error_(char('specular: SX, SY, and SZ must have same size'))
    if (length_(lv) < 2 or length_(lv) > 3):
        error_(char('specular: light vector LV must be a 2- or 3-element vector'))
    else:
        if (length_(lv) == 2):
            lv[1],lv[2],lv[3]=sph2cart_(lv[1] * pi / 180,lv[2] * pi / 180,1.0,nargout=3)
    if (length_(vv) < 2 or length_(lv) > 3):
        error_(char('specular: view vector VV must be a 2- or 3-element vector'))
    else:
        if (length_(vv) == 2):
            vv[1],vv[2],vv[3]=sph2cart_(vv[1] * pi / 180,vv[2] * pi / 180,1.0,nargout=3)
    if (sum_(abs_(lv)) > 0):
        lv /= norm_(lv)
    if (sum_(abs_(vv)) > 0):
        vv /= norm_(vv)
    ns=sqrt_(sx ** 2 + sy ** 2 + sz ** 2)
    l_dot_n=(sx * lv[1] + sy * lv[2] + sz * lv[3]) / ns
    v_dot_n=(sx * vv[1] + sy * vv[2] + sz * vv[3]) / ns
    retval=2 * l_dot_n.dot(v_dot_n) - dot_(lv,vv)
    retval[l_dot_n < 0]=0
    retval[retval < 0]=0
    retval=retval ** se
    return retval
def gtext_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (not (ischar_(s) or iscellstr_(s))):
        error_(char('gtext: S must be a string or cell array of strings'))
    htmp=- 1
    if (not isempty_(s)):
        if (ischar_(s) or isrow_(s)):
            x,y=ginput_(1,nargout=2)
            htmp=text_(x,y,s,varargin[:])
        else:
            for i in arange_(1,numel_(s)).reshape(-1):
                x,y=ginput_(1,nargout=2)
                htmp=text_(x,y,s[i],varargin[:])
    if (nargout > 0):
        h=copy_(htmp)
    return h
def grid_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargs=__plt_get_axis_arg___(char('grid'),varargin[:],nargout=3)
    if (isempty_(hax)):
        hax=gca_()
    if (nargs > 2):
        print_usage_()
    grid_on=(strcmp_(get_(hax,char('xgrid')),char('on')) and strcmp_(get_(hax,char('ygrid')),char('on')) and strcmp_(get_(hax,char('zgrid')),char('on')))
    minor_on=(strcmp_(get_(hax,char('xminorgrid')),char('on')) and strcmp_(get_(hax,char('yminorgrid')),char('on')) and strcmp_(get_(hax,char('zminorgrid')),char('on')))
    minor_auto=copy_(true)
    if (nargs == 0):
        grid_on=not grid_on
    else:
        arg1=varargin[1]
        if (not ischar_(arg1)):
            error_(char('grid: argument 1 must be an axis handle or a string'))
        if (strcmpi_(arg1,char('off'))):
            grid_on=copy_(false)
        else:
            if (strcmpi_(arg1,char('on'))):
                grid_on=copy_(true)
            else:
                if (strcmpi_(arg1,char('minor'))):
                    minor_auto=copy_(false)
                    if (nargs == 2):
                        arg2=varargin[2]
                        if (strcmpi_(arg2,char('on'))):
                            minor_on=copy_(true)
                            grid_on=copy_(true)
                        else:
                            if (strcmpi_(arg2,char('off'))):
                                minor_on=copy_(false)
                            else:
                                print_usage_()
                    else:
                        minor_on=not minor_on
                        if (minor_on):
                            grid_on=copy_(true)
                else:
                    print_usage_()
    if (grid_on):
        set_(hax,char('xgrid'),char('on'),char('ygrid'),char('on'),char('zgrid'),char('on'))
        if (minor_on):
            set_(hax,char('xminorgrid'),char('on'),char('yminorgrid'),char('on'),char('zminorgrid'),char('on'))
        else:
            if (minor_auto):
                xmg=ifelse_(strcmp_(get_(hax,char('xscale')),char('log')),char('on'),char('off'))
                ymg=ifelse_(strcmp_(get_(hax,char('yscale')),char('log')),char('on'),char('off'))
                zmg=ifelse_(strcmp_(get_(hax,char('zscale')),char('log')),char('on'),char('off'))
                set_(hax,char('xminorgrid'),xmg,char('yminorgrid'),ymg,char('zminorgrid'),zmg)
            else:
                set_(hax,char('xminorgrid'),char('off'),char('yminorgrid'),char('off'),char('zminorgrid'),char('off'))
    else:
        set_(hax,char('xgrid'),char('off'),char('ygrid'),char('off'),char('zgrid'),char('off'),char('xminorgrid'),char('off'),char('yminorgrid'),char('off'),char('zminorgrid'),char('off'))
    return
def orient_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    nargs=copy_(nargin)
    if (nargs > 0 and numel_(varargin[1]) == 1 and isfigure_(varargin[1])):
        cf=varargin[1]
        varargin[1]=[]
        nargs
    else:
        cf=gcf_()
    if (nargs > 1):
        print_usage_()
    paperunits=get_(cf,char('paperunits'))
    try:
        set_(cf,char('paperunits'),char('inches'))
        if (nargs == 0):
            retval=get_(cf,char('paperorientation'))
            if (strcmp_(retval,char('portrait'))):
                papersize=get_(cf,char('papersize'))
                paperposition=get_(cf,char('paperposition'))
                if (paperposition == [0.25,0.25(papersize - 0.5)]):
                    retval=char('tall')
        else:
            orientation=varargin[1]
            if (strcmpi_(orientation,char('landscape')) or strcmpi_(orientation,char('portrait'))):
                if (not strcmpi_(get_(cf,char('paperorientation')),orientation)):
                    papersize=get_(cf,char('papersize'))
                    paperposition=get_(cf,char('paperposition'))
                    set_(cf,char('paperorientation'),orientation)
                    set_(cf,char('papersize'),papersize[[2,1]])
                    set_(cf,char('paperposition'),paperposition[[2,1,4,3]])
                if (strcmpi_(orientation,char('portrait'))):
                    set_(cf,char('paperposition'),char('factory'))
                else:
                    papersize=get_(cf,char('papersize'))
                    set_(cf,char('paperposition'),[0.25,0.25,(papersize - 0.5)])
            else:
                if (strcmpi_(varargin[1],char('tall'))):
                    orient_(char('portrait'))
                    papersize=get_(cf,char('papersize'))
                    set_(cf,char('paperposition'),[0.25,0.25,(papersize - 0.5)])
                else:
                    error_(char('orient: unknown ORIENTATION'))
    finally:
        set_(cf,char('paperunits'),paperunits)
    return retval
def datetick_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('datetick'),varargin[:],nargout=3)
    oldfig=matlabarray([])
    if (not isempty_(hax)):
        oldfig=get_(0,char('currentfigure'))
    if (isempty_(hax)):
        hax=gca_()
    try:
        axes_(hax)
        __datetick___(varargin[:])
    finally:
        if (not isempty_(oldfig)):
            set_(0,char('currentfigure'),oldfig)
    return
def __datetick___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    keeplimits=copy_(false)
    idx=strcmpi_(varargin,char('keeplimits'))
    if (any_(idx)):
        keeplimits=copy_(true)
        varargin=varargin[not idx]
    keepticks=copy_(false)
    idx=strcmpi_(varargin,char('keepticks'))
    if (any_(idx)):
        keepticks=copy_(true)
        varargin=varargin[not idx]
    nargin=numel_(varargin)
    form=matlabarray([])
    ax=char('x')
    if (nargin != 0):
        arg=varargin[1]
        if (ischar_(arg) and any_(strcmpi_(arg,[char('x'),char('y'),char('z')]))):
            ax=tolower_(arg)
            if (nargin > 1):
                form=varargin[2]
                varargin[1:2]=[]
            else:
                varargin[1]=[]
        else:
            form=copy_(arg)
            varargin[1]=[]
    if (length_(varargin) > 0):
        startdate=varargin[1]
    else:
        startdate=matlabarray([])
    if (not isempty_(form)):
        if (isnumeric_(form)):
            if (not isscalar_(form) or form < 0 or form != fix_(form)):
                error_(char('datetick: expecting FORM argument to be a positive integer'))
        else:
            if (not ischar_(form)):
                error_(char('datetick: expecting valid date format string'))
    if (keepticks):
        ticks=get_(gca_(),[ax,char('tick')])
    else:
        objs=findall_(gca_())
        xmax=copy_(NaN)
        xmin=copy_(NaN)
        for i in arange_(1,length_(objs)).reshape(-1):
            fld=get_(objs[i])
            if (isfield_(fld,[ax,char('data')])):
                xdata=getfield_(fld,[ax,char('data')])(arange_())
                xmin=min_(xmin,min_(xdata))
                xmax=max_(xmax,max_(xdata))
        if (isnan_(xmin) or isnan_(xmax)):
            xmin=0
            xmax=1
        else:
            if (xmin == xmax):
                xmax=xmin + 1
        N=3
        if (xmax - xmin < N):
            if (xmax - xmin < N / 24 / 60 / 60):
                scl=1 / 24 / 60 / 60
            else:
                if (xmax - xmin < N / 24 / 60):
                    scl=1 / 24 / 60
                else:
                    scl=1 / 24
            sep=__calc_tick_sep___(xmin / scl,xmax / scl)
            xmin=sep * floor_(xmin / scl / sep)
            xmax=sep * ceil_(xmax / scl / sep)
            nticks=(xmax - xmin) / sep + 1
            xmin *= scl
            xmax *= scl
        else:
            ymin,mmin,dmin=datevec_(xmin,nargout=3)
            ymax,mmax,dmax=datevec_(xmax,nargout=3)
            minyear=ymin + (mmin - 1) / 12 + (dmin - 1) / 12 / 30
            maxyear=ymax + (mmax - 1) / 12 + (dmax - 1) / 12 / 30
            minmonth=mmin + (dmin - 1) / 30
            maxmonth=(ymax - ymin) * 12 + mmax + (dmax - 1) / 30
            if (maxmonth - minmonth < N):
                sep=__calc_tick_sep___(xmin,xmax)
                xmin=sep * floor_(xmin / sep)
                xmax=sep * ceil_(xmax / sep)
                nticks=(xmax - xmin) / sep + 1
            else:
                if (maxyear - minyear < N):
                    sep=__calc_tick_sep___(minmonth,maxmonth)
                    xmin=datenum_(ymin,sep * floor_(minmonth / sep),1)
                    xmax=datenum_(ymax,sep * ceil_(maxmonth / sep),1)
                    nticks=ceil_(maxmonth / sep) - floor_(minmonth / sep) + 1
                else:
                    sep=__calc_tick_sep___(minyear,maxyear)
                    xmin=datenum_(sep * floor_(minyear / sep),1,1)
                    xmax=datenum_(sep * ceil_(maxyear / sep),1,1)
                    nticks=ceil_(maxyear / sep) - floor_(minyear / sep) + 1
        ticks=xmin + [arange_(0,nticks - 1)] / (nticks - 1) * (xmax - xmin)
    if (isempty_(form)):
        r=max_(ticks) - min_(ticks)
        if (r < 10 / 60 / 24):
            form=13
        else:
            if (r < 2):
                form=15
            else:
                if (r < 15):
                    form=8
                else:
                    if (r < 365):
                        form=6
                    else:
                        if (r < 90 * 12):
                            form=27
                        else:
                            form=10
    if (length_(ticks) == 6):
        if (not isempty_(startdate)):
            sticks=strvcat_(datestr_(ticks[1:end() - 1] - ticks[1] + startdate,form),datestr_(ticks[end()] - ticks[1] + startdate,form))
        else:
            sticks=strvcat_(datestr_(ticks[1:end() - 1],form),datestr_(ticks[end()],form))
    else:
        if (not isempty_(startdate)):
            sticks=datestr_(ticks - ticks[1] + startdate,form)
        else:
            sticks=datestr_(ticks,form)
    sticks=mat2cell_(sticks,ones_(rows_(sticks),1),columns_(sticks))
    if (keepticks):
        if (keeplimits):
            set_(gca_(),[ax,char('ticklabel')],sticks)
        else:
            set_(gca_(),[ax,char('ticklabel')],sticks,[ax,char('lim')],[min_(ticks),max_(ticks)])
    else:
        if (keeplimits):
            set_(gca_(),[ax,char('tick')],ticks,[ax,char('ticklabel')],sticks)
        else:
            set_(gca_(),[ax,char('tick')],ticks,[ax,char('ticklabel')],sticks,[ax,char('lim')],[min_(ticks),max_(ticks)])
    return
def __magform___(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (x == 0):
        a=0
        b=0
    else:
        l=log10_(abs_(x))
        r=fmod_(l,1)
        a=10 ** r
        b=fix_(l - r)
        if (a < 1):
            a *= 10
            b -= 1
        if (x < 0):
            a=- a
    return a,b
def __calc_tick_sep___(lo=None,hi=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[lo,hi].count(None)+len(args)

    sqrt_2=sqrt_(2.0)
    sqrt_10=sqrt_(10.0)
    sqrt_50=sqrt_(50.0)
    ticint=5
    a,b=__magform___((hi - lo) / ticint,nargout=2)
    if (a < sqrt_2):
        x=1
    else:
        if (a < sqrt_10):
            x=2
        else:
            if (a < sqrt_50):
                x=5
            else:
                x=10
    sep=x * 10 ** b
    return sep
def zlim_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    ret=__axis_limits___(char('zlim'),varargin[:])
    if (not isempty_(ret)):
        retval=copy_(ret)
    return retval
def __clabel___(c=None,v=None,hparent=None,label_spacing=None,z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[c,v,hparent,label_spacing,z].count(None)+len(args)

    hax=ancestor_(hparent,char('axes'))
    units=get_(hax,char('units'))
    set_(hax,char('units'),char('points'))
    axpos=get_(hax,char('position'))
    set_(hax,char('units'),units)
    lims=axis_()
    xspacing=axpos[3] / (lims[2] - lims[1])
    yspacing=axpos[4] / (lims[4] - lims[3])
    if (isscalar_(hparent) and ishandle_(hparent) and strcmp_(get_(hparent,char('type')),char('hggroup'))):
        x=get_(hparent,char('xdata'))
        xmin=min_(x[:])
        xmax=max_(x[:])
        y=get_(hparent,char('ydata'))
        ymin=min_(y[:])
        ymax=max_(y[:])
    else:
        xmin=xmax=ymin=ymax=copy_(NaN)
        i=1
        while (i < length_(c)):

            clen=c[2,i]
            data=c[:,i + (arange_(1,clen))]
            xmin=min_([xmin,data[1,:]])
            xmax=max_([xmax,data[1,:]])
            ymin=min_([ymin,data[2,:]])
            ymax=max_([ymax,data[2,:]])
            i += clen + 1

    h=matlabarray([])
    i=1
    while (i < length_(c)):

        clev=c[1,i]
        clen=c[2,i]
        if (not isempty_(v) and not any_(v == clev)):
            i += clen + 1
            continue
        p=bsxfun_(times,c[:,i + (arange_(1,clen))],[[xspacing],[yspacing]])
        d=sqrt_(sumsq_(diff_(p,1,2)))
        cumd=cumsum_(d)
        td=cumd[end()]
        ntag=ceil_(td / label_spacing)
        if (all_(c[:,i + 1] == c[:,i + clen])):
            spacing=td / ntag
            pos=spacing / 2 + spacing * [arange_(0,ntag - 1)]
        else:
            pos=zeros_(1,ntag)
            pos[1]=(td - label_spacing * (ntag - 1)) / 2
            pos[2:ntag]=pos[1] + label_spacing * [arange_(1,ntag - 1)]
        tlabel=sprintf_(char('%.5g'),clev)
        for tagpos in pos.reshape(-1):
            j=find_(cumd > tagpos,1)
            if (isempty_(j)):
                j=copy_(clen)
            tpos=sum_(c[:,i + j - 1:i + j],2) / 2
            if (tpos[1] != xmin and tpos[1] != xmax and tpos[2] != ymin and tpos[2] != ymax):
                trot=180 / pi * atan2_(diff_(c[2,i + j - 1:i + j]),diff_(c[1,i + j - 1:i + j]))
                if (abs_(trot) > 90):
                    trot += 180
                if (ischar_(z)):
                    ht=text_(tpos[1],tpos[2],clev,tlabel,char('rotation'),trot,char('horizontalalignment'),char('center'),char('userdata'),clev,char('parent'),hparent,varargin[:])
                else:
                    if (not isempty_(z)):
                        ht=text_(tpos[1],tpos[2],z,tlabel,char('rotation'),trot,char('horizontalalignment'),char('center'),char('userdata'),clev,char('parent'),hparent,varargin[:])
                    else:
                        ht=text_(tpos[1],tpos[2],tlabel,char('rotation'),trot,char('horizontalalignment'),char('center'),char('userdata'),clev,char('parent'),hparent,varargin[:])
                h=matlabarray([[h],[ht]])
        i += clen + 1

    return h
def daspect_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin > 0):
        if (isscalar_(varargin[1]) and isaxes_(varargin[1])):
            hax=varargin[1]
            varargin=varargin[2:end()]
        else:
            hax=gca_()
    else:
        hax=gca_()
    nargin=numel_(varargin)
    if (nargin > 1):
        print_usage_()
    if (nargin == 0):
        daratio=get_(hax,char('dataaspectratio'))
    else:
        arg=varargin[1]
        if (isnumeric_(arg)):
            if (numel_(arg) == 2):
                set_(hax,char('dataaspectratio'),[arg,1])
            else:
                if (numel_(arg) == 3):
                    set_(hax,char('dataaspectratio'),arg)
                else:
                    error_(char('daspect: DATA_ASPECT_RATIO must be a 2 or 3 element vector'))
        else:
            if (ischar_(arg)):
                arg=tolower_(arg)
                if char('auto') == (arg):
                    set_(hax,char('dataaspectratiomode'),char('auto'))
                else:
                    if char('manual') == (arg):
                        set_(hax,char('dataaspectratiomode'),char('manual'))
                    else:
                        if char('mode') == (arg):
                            daratio=get_(hax,char('dataaspectratiomode'))
                        else:
                            error_(char('daspect: Invalid mode <%s>'),arg)
            else:
                print_usage_()
    return daratio
def __getlegenddata___(hlegend=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[hlegend].count(None)+len(args)

    hplots=matlabarray([])
    text_strings=[]
    ca=getfield_(get_(hlegend,char('userdata')),char('handle'))
    if (numel_(ca) == 1):
        kids=get_(ca,char('children'))
    else:
        kids=matlabarray([get_(kids,char('children'))[:]])
    for i in arange_(numel_(kids),1,- 1).reshape(-1):
        typ=get_(kids[i],char('type'))
        if (any_(strcmp_(typ,[char('line'),char('patch'),char('surface'),char('hggroup')]))):
            if (strcmp_(typ,char('hggroup'))):
                hgkids=get_(kids[i],char('children'))
                for j in arange_(1,length_(hgkids)).reshape(-1):
                    try:
                        dname=get_(hgkids[j],char('DisplayName'))
                        if (not isempty_(dname)):
                            hplots[end() + 1]=hgkids[j]
                            text_strings[end() + 1]=dname
                            break
                    finally:
                        pass
            else:
                dname=get_(kids[i],char('DisplayName'))
                if (not isempty_(dname)):
                    hplots[end() + 1]=kids[i]
                    text_strings[end() + 1]=dname
    return hplots,text_strings
def diffuse_(sx=None,sy=None,sz=None,lv=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[sx,sy,sz,lv].count(None)+len(args)

    if (nargin != 4):
        print_usage_()
    if (not size_equal_(sx,sy,sz)):
        error_(char('diffuse: SX, SY, and SZ must have same size'))
    if (length_(lv) < 2 or length_(lv) > 3):
        error_(char('diffuse: light vector LV must be a 2- or 3-element vector'))
    else:
        if (length_(lv) == 2):
            lv[1],lv[2],lv[3]=sph2cart_(lv[1] * pi / 180,lv[2] * pi / 180,1.0,nargout=3)
    if (sum_(abs_(lv)) > 0):
        lv /= norm_(lv)
    ns=sqrt_(sx ** 2 + sy ** 2 + sz ** 2)
    retval=(sx * lv[1] + sy * lv[2] + sz * lv[3]) / ns
    retval[retval < 0]=0
    return retval
def ylabel_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('ylabel'),varargin[:],nargout=3)
    if (isempty_(hax)):
        hax=gca_()
    if (rem_(nargin,2) != 1):
        print_usage_()
    htmp=__axis_label___(hax,char('ylabel'),varargin[1],char('color'),get_(hax,char('ycolor')),varargin[2:end()])
    if (nargout > 0):
        h=copy_(htmp)
    return h
def xlabel_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('xlabel'),varargin[:],nargout=3)
    if (isempty_(hax)):
        hax=gca_()
    if (rem_(nargin,2) != 1):
        print_usage_()
    htmp=__axis_label___(hax,char('xlabel'),varargin[1],char('color'),get_(hax,char('xcolor')),varargin[2:end()])
    if (nargout > 0):
        h=copy_(htmp)
    return h
def hidden_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[mode].count(None)+len(args)

    if (nargin > 2):
        print_usage_()
    else:
        if (nargin == 1):
            if (not ischar_(mode)):
                error_(char('hidden: expecting MODE to be a string'))
            else:
                if (not any_(strcmpi_(mode,[char('on'),char('off')]))):
                    error_(char('hidden: MODE must be "on" or "off"'))
    for h in (get_(gca_(),char('children'))).T.reshape(-1):
        htype=get_(h,char('type'))
        htag=get_(h,char('tag'))
        if (strcmp_(htype,char('surface')) or strcmp_(htag,char('trimesh'))):
            fc=get_(h,char('facecolor'))
            if ((not ischar_(fc) and is_white_(fc)) or (ischar_(fc) and strcmp_(fc,char('none')))):
                if char('on') == (mode):
                    set_(h,char('facecolor'),char('w'))
                else:
                    if char('off') == (mode):
                        set_(h,char('facecolor'),char('none'))
                    else:
                        if char('toggle') == (mode):
                            if (ischar_(fc)):
                                set_(h,char('facecolor'),char('w'))
                                mode=char('on')
                            else:
                                set_(h,char('facecolor'),char('none'))
                                mode=char('off')
    if (nargout > 0):
        state=copy_(mode)
    return state
def is_white_(color=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[color].count(None)+len(args)

    retval=all_(color == 1)
    return retval
def title_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    hax,varargin,nargin=__plt_get_axis_arg___(char('title'),varargin[:],nargout=3)
    if (isempty_(hax)):
        hax=gca_()
    if (rem_(nargin,2) != 1):
        print_usage_()
    htmp=__axis_label___(hax,char('title'),varargin[:])
    if (nargout > 0):
        h=copy_(htmp)
    return h
def text_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    nargs=copy_(nargin)
    offset=0
    if (nargs > 2 and isnumeric_(varargin[1]) and isnumeric_(varargin[2])):
        x=varargin[1]
        y=varargin[2]
        if (nargin > 3 and isnumeric_(varargin[3])):
            z=varargin[3]
            offset=4
        else:
            z=zeros_(size_(x))
            offset=3
        string=varargin[offset]
        varargin[1:offset]=[]
        nx=numel_(x)
        ny=numel_(y)
        nz=numel_(z)
        if (ischar_(string)):
            do_keyword_repl=copy_(true)
            nt=rows_(string)
            if (nx == 1 and nt == 1):
                string=[string]
            else:
                if (nx == 1 and nt > 1):
                    do_keyword_repl=copy_(false)
                    string=[string]
                else:
                    if (nx > 1 and nt == nx):
                        string=cellstr_(string)
                    else:
                        string=repmat_([string],[nx,1])
                        nt=copy_(nx)
            if (do_keyword_repl):
                string=regexprep_(string,char('^(default|factory)$'),char('\\\\$1'))
        else:
            if (iscell_(string)):
                nt=numel_(string)
                if (nx == 1):
                    string=[string]
                    nt=1
                else:
                    if (nx > 1 and nt == nx):
                        pass
                    else:
                        string=repmat_([string],[nx,1])
                        nt=copy_(nx)
            else:
                error_(char('text: STRING must be a character string or cell array of character strings'))
    else:
        x=y=z=0
        nx=ny=nz=1
        string=[char('')]
        nt=1
    if (rem_(numel_(varargin),2) != 0):
        print_usage_()
    hax,varargin=__plt_get_axis_arg___(char('text'),varargin[:],nargout=2)
    if (isempty_(hax)):
        hax=gca_()
    idx=find_(strcmpi_(varargin,char('position')),1)
    if (idx):
        pos=varargin[idx + 1]
        varargin[idx:idx + 1]=[]
    else:
        pos=matlabarray([x[:],y[:],z[:]])
    if (nx == ny and nx == nz and (nt == nx or nt == 1 or nx == 1)):
        htmp=zeros_(nt,1)
        if (nx == 1):
            htmp=__go_text___(hax,char('string'),string[1],varargin[:],char('position'),pos)
        else:
            if (nx == nt):
                for n in arange_(1,nt).reshape(-1):
                    htmp[n]=__go_text___(hax,char('string'),string[n],varargin[:],char('position'),pos[n,:])
                __request_drawnow___()
            else:
                error_(char('text: dimension mismatch for coordinates and STRING'))
    else:
        if (nt == nx or nt == 1 or nx == 1):
            error_(char('text: dimension mismatch for coordinates'))
        else:
            error_(char('text: dimension mismatch between coordinates and strings'))
    if (nargout > 0):
        h=copy_(htmp)
    return h
def clabel_(c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[c].count(None)+len(args)

    have_hg=copy_(false)
    have_labelspacing=copy_(false)
    label_spacing=144
    if (nargin < 1):
        print_usage_()
    else:
        if (nargin == 1):
            hparent=gca_()
        else:
            arg=varargin[1]
            if (isscalar_(arg) and ishandle_(arg) and strcmp_(get_(arg,char('type')),char('hggroup'))):
                try:
                    get_(arg,char('contourmatrix'))
                finally:
                    pass
                have_hg=copy_(true)
                hg=copy_(arg)
                varargin[1]=[]
            else:
                hparent=gca_()
    if (length_(varargin) > 0 and isnumeric_(varargin[1])):
        v=varargin[1](arange_())
        varargin[1]=[]
    else:
        v=matlabarray([])
    idx=strcmpi_(varargin[1:2:end()],char('manual'))
    if (any_(idx)):
        error_(char('clabel: "manual" contour mode is not supported'))
    idx=find_(strcmpi_(varargin[1:2:end()],char('labelspacing')),1)
    if (not isempty_(idx)):
        have_labelspacing=copy_(true)
        label_spacing=varargin[2 * idx]
        varargin[2 * idx + (arange_(- 1,0))]=[]
    if (have_hg):
        if (not isempty_(v)):
            if (have_labelspacing):
                set_(hg,char('textlistmode'),char('manual'),char('textlist'),v,char('labelspacing'),label_spacing,char('showtext'),char('on'))
            else:
                set_(hg,char('textlistmode'),char('manual'),char('textlist'),v,char('showtext'),char('on'))
        else:
            if (have_labelspacing):
                set_(hg,char('showtext'),char('on'),char('labelspacing'),label_spacing)
            else:
                set_(hg,char('showtext'),char('on'))
        htmp=findobj_(hg,char('type'),char('text'))
        if (not isempty_(varargin)):
            set_(htmp,varargin[:])
    else:
        htmp=__clabel___(c,v,hparent,label_spacing,[],varargin[:])
    if (nargout > 0):
        h=copy_(htmp)
    return h
def whitebg_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h=0
    color=copy_(NaN)
    if (nargin > 0 and nargin < 3):
        if (ishandle_(varargin[1])):
            h=varargin[1]
            if (nargin == 2):
                color=varargin[2]
        else:
            if (nargin == 1):
                color=varargin[1]
            else:
                print_usage_()
    else:
        if (nargin != 0):
            print_usage_()
    typ=get_(h,char('type'))
    if (strcmp_(typ,char('root'))):
        isroot=copy_(true)
        fig=gcf_()
    else:
        if (strcmp_(typ,char('figure'))):
            isroot=copy_(false)
            fig=copy_(h)
        else:
            error_(char('expecting a figure handle'))
    axes=findall_(fig,char('type'),char('axes'))
    if (isnan_(color)):
        if (isroot):
            fac=get_(0,char('factory'))
            fields=fieldnames_(fac)
            fieldindex=intersect_(find_(not cellfun_(char('isempty'),regexp_(fields,char('color')))),union_(find_(not cellfun_(char('isempty'),regexp_(fields,char('factoryaxes.*')))),find_(not cellfun_(char('isempty'),regexp_(fields,char('factoryfigure.*'))))))
            for nf in arange_(1,numel_(fieldindex)).reshape(-1):
                defaultfield=strrep_(fields[fieldindex[nf]],char('factory'),char('default'))
                try:
                    defaultvalue=1 - get_(0,defaultfield[n])
                finally:
                    pass
                set_(0,defaultfield,defaultvalue)
        handles=copy_(fig)
        h=copy_(fig)
        while (numel_(handles)):

            children=matlabarray([])
            for n in arange_(1,numel_(handles)).reshape(-1):
                children=union_(children,get_(handles[n],char('children')))
            handles=copy_(children)
            h=union_(h,children)

        for nh in arange_(1,numel_(h)).reshape(-1):
            p=get_(h[nh])
            fields=fieldnames_(p)
            fieldindex=find_(not cellfun_(char('isempty'),regexp_(fields,char('color'))))
            if (numel_(fieldindex)):
                for nf in arange_(1,numel_(fieldindex)).reshape(-1):
                    field=fields[fieldindex[nf]]
                    c=subsref_(p,struct_(char('type'),char('.'),char('subs'),field))
                    if (not ischar_(c) and columns_(c) == 3):
                        set_(h[nh],field,1 - c)
            typ=subsref_(p,struct_(char('type'),char('.'),char('subs'),char('type')))
            if (strcmp_(typ,char('axes')) or strcmp_(typ,char('figure'))):
                _def=get_(h[nh],char('default'))
                fields=fieldnames_(_def)
                if (not isempty_(fields)):
                    fieldindex=find_(not cellfun_(char('isempty'),regexp_(fields,char('color'))))
                    for nf in arange_(1,numel_(fieldindex)).reshape(-1):
                        defaultfield=fields[fieldindex[nf]]
                        defaultvalue=1 - subsref_(_def,struct_(char('type'),char('.'),char('subs'),defaultfield))
                        set_(h[nh],defaultfield,defaultvalue)
    else:
        set_(findall_(fig,char('type'),char('axes')),char('color'),color)
        if (isroot):
            defs=get_(0,char('default'))
            if (isfield_(defs,char('defaultaxescolor')) and strcmp_(defs.defaultaxescolor,char('none'))):
                set_(0,char('defaultaxescolor'),color)
    return
def close_(f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[f].count(None)+len(args)

    __ftp_close___(f.curlhandle)
    return
def ftp_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[host,username,password].count(None)+len(args)

    if (nargin == 1 and isa_(host,char('ftp'))):
        obj=copy_(host)
    else:
        p.host=host
        p.username=username
        p.password=password
        p.curlhandle=tmpnam_(char('ftp-'))
        if (nargin > 0):
            p.curlhandle=__ftp___(host,username,password)
        obj=class_(p,char('ftp'))
    return obj
def dir_(f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[f].count(None)+len(args)

    if (nargout == 0):
        __ftp_dir___(f.curlhandle)
    else:
        lst=__ftp_dir___(f.curlhandle)
    return lst
def loadobj_(a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[a].count(None)+len(args)

    b=copy_(a)
    if (isfield_(b,char('jobject'))):
        b=rmfield_(b,char('jobject'))
    b.curlhandle=__ftp___(b.host,b.username,b.password)
    if (isfield_(b,char('dir'))):
        if (not isempty_(b.dir)):
            __ftp_cwd___(b.curlhandle,b.dir)
        b=rmfield_(b,char('dir'))
    else:
        if (isfield_(b,char('remotePwd'))):
            warning_(char('can not change remote directory in loaded FTP object'))
            b=rmfield_(b,char('remotePwd'))
    return b
def delete_(f=None,file=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,_file].count(None)+len(args)

    __ftp_delete___(f.curlhandle,_file)
    return
def mkdir_(f=None,path=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,path].count(None)+len(args)

    __ftp_mkdir___(f.curlhandle,path)
    return
def saveobj_(a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[a].count(None)+len(args)

    b=copy_(a)
    b=rmfield_(b,char('curlhandle'))
    b.dir=__ftp_pwd___(a.curlhandle)
    return b
def ascii_(f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[f].count(None)+len(args)

    __ftp_ascii___(f.curlhandle)
    return
def rmdir_(f=None,path=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,path].count(None)+len(args)

    __ftp_rmdir___(f.curlhandle,path)
    return
def display_(obj=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[obj].count(None)+len(args)

    printf_(char('FTP Object\n'))
    printf_(char(' host: %s\n'),obj.host)
    printf_(char(' user: %s\n'),obj.username)
    printf_(char('  dir: %s\n'),__ftp_pwd___(obj.curlhandle))
    printf_(char(' mode: %s\n'),__ftp_mode___(obj.curlhandle))
    return
def mget_(f=None,file=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,_file].count(None)+len(args)

    __ftp_mget___(f.curlhandle,_file)
    return
def binary_(f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[f].count(None)+len(args)

    __ftp_binary___(f.curlhandle)
    return
def cd_(f=None,path=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,path].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (nargin == 2):
        __ftp_cwd___(f.curlhandle,path)
    path=__ftp_pwd___(f.curlhandle)
    return path
def rename_(f=None,oldname=None,newname=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[f,oldname,newname].count(None)+len(args)

    __ftp_rename___(f.curlhandle,oldname,newname)
    return
def mput_(f=None,file=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[f,_file].count(None)+len(args)

    if (nargout == 0):
        __ftp_mput___(f.curlhandle,_file)
    else:
        retval=__ftp_mput___(f.curlhandle,_file)
    return retval
def preferences_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (isguirunning_()):
        __octave_link_show_preferences___()
    else:
        warning_(char('preferences: GUI must be running to use preferences dialog'))
    return
def prefdir_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    folder=getenv_(char('HOME'))
    return folder
def loadprefs_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    _file=prefsfile_()
    s=stat_(_file)
    if (isstruct_(s) and S_ISREG_(s.mode)):
        tmp=load_(_file)
        retval=tmp.prefs
    else:
        retval=matlabarray([])
    return retval
def saveprefs_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    prefs=copy_(s)
    save_(prefsfile_(),char('prefs'))
    return retval
def prefsfile_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    retval=matlabarray([prefdir_(),filesep_(),char('.octave_prefs')])
    return retval
def guidata_(h=None,data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,data].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (not ishandle_(h)):
        error_(char('guidata: H must be a valid object handle'))
    h=ancestor_(h,char('figure'))
    if (isempty_(h)):
        error_(char('guidata: no ancestor figure of H found'))
    if (nargin == 1):
        dataout=get_(h,char('__guidata__'))
    else:
        set_(h,char('__guidata__'),data)
        if (nargout == 1):
            dataout=copy_(data)
    return dataout
def uiputfile_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (not __octave_link_enabled___()):
        defaulttoolkit=get_(0,char('defaultfigure__graphics_toolkit__'))
        funcname=matlabarray([char('__uiputfile_'),defaulttoolkit,char('__')])
        functype=exist_(funcname)
        if (not __is_function___(funcname)):
            funcname=char('__uiputfile_fltk__')
            if (not __is_function___(funcname)):
                error_(char('uiputfile: fltk graphics toolkit required'))
            else:
                if (not strcmp_(defaulttoolkit,char('gnuplot'))):
                    warning_(char("uiputfile: no implementation for toolkit '%s', using 'fltk' instead"),defaulttoolkit)
    if (nargin > 3):
        print_usage_()
    defaultvals=[cell_(0,2),char('Save File'),char(''),[240,120],char('create'),pwd]
    outargs=cell_(6,1)
    for i in arange_(1,6).reshape(-1):
        outargs[i]=defaultvals[i]
    if (nargin > 0):
        file_filter=varargin[1]
        outargs[1],outargs[3],defdir=__file_filter___(file_filter,nargout=3)
        if (length_(defdir) > 0):
            outargs[6]=defdir
    else:
        outargs[1]=__file_filter___(outargs[1])
    if (nargin > 1):
        if (ischar_(varargin[2])):
            outargs[2]=varargin[2]
        else:
            if (not isempty_(varargin[2])):
                print_usage_()
    if (nargin > 2):
        if (ischar_(varargin[3])):
            fdir,fname,fext=fileparts_(varargin[3],nargout=3)
            if (not isempty_(fdir)):
                outargs[6]=fdir
            if (not isempty_(fname) or not isempty_(fext)):
                outargs[3]=strcat_(fname,fext)
        else:
            if (not isempty_(varargin[3])):
                print_usage_()
    if (__octave_link_enabled___()):
        retfile,retpath,retindex=__octave_link_file_dialog___(outargs[:],nargout=3)
    else:
        retfile,retpath,retindex=feval_(funcname,outargs[:],nargout=3)
    return retfile,retpath,retindex
def errordlg_(msg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[msg,title].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    retval=message_dialog_(char('errdlg'),msg,title,char('error'))
    return retval
def questdlg_(msg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[msg,title].count(None)+len(args)

    if (nargin < 1 or nargin > 6):
        print_usage_()
    if (not ischar_(msg)):
        if (iscell_(msg)):
            msg=sprintf_(char('%s\n'),msg[:])
            msg[end()]=char('')
        else:
            error_(char('questdlg: MSG must be a character string or cellstr array'))
    if (not ischar_(title)):
        error_(char('questdlg: TITLES must be a character string'))
    options[1]=char('Yes')
    options[2]=char('No')
    options[3]=char('Cancel')
    options[4]=char('Yes')
    defbtn_error_msg=char('questdlg: DEFAULT must match one of the button options')
    if 0 == (numel____(varargin)):
        pass
    else:
        if 1 == (numel____(varargin)):
            options[4]=varargin[1]
            if (not any_(strcmp_(options[4],options[1:3]))):
                error_(defbtn_error_msg)
        else:
            if 3 == (numel____(varargin)):
                options[1]=varargin[1]
                options[2]=char('')
                options[3]=varargin[2]
                options[4]=varargin[3]
                if (not any_(strcmp_(options[4],options[[1,3]]))):
                    error_(defbtn_error_msg)
            else:
                if 4 == (numel____(varargin)):
                    options[1]=varargin[1]
                    options[2]=varargin[2]
                    options[3]=varargin[3]
                    options[4]=varargin[4]
                    if (not any_(strcmp_(options[4],options[1:3]))):
                        error_(defbtn_error_msg)
                else:
                    print_usage_()
    if (__octave_link_enabled___()):
        btn=__octave_link_question_dialog___(msg,title,options[1],options[2],options[3],options[4])
    else:
        if (__have_feature___(char('JAVA'))):
            btn=javaMethod_(char('questdlg'),char('org.octave.JDialogBox'),msg,title,options)
        else:
            error_(char('questdlg is not available in this version of Octave'))
    return btn
def uiresume_(h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[h].count(None)+len(args)

    if (not isfigure_(h)):
        error_(char('uiresume: invalid figure handle H'))
    try:
        uiwait_state=get_(h,char('__uiwait_state__'))
        if (strcmp_(uiwait_state,char('active'))):
            set_(h,char('__uiwait_state__'),char('triggered'))
    finally:
        pass
    return
def listdlg_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    listcell=[char('')]
    selmode=char('Multiple')
    listsize=matlabarray([160,300])
    initialvalue=1
    name=char('')
    prompt=[]
    okstring=char('OK')
    cancelstring=char('Cancel')
    for i in arange_(1,nargin - 1,2).reshape(-1):
        if (strcmpi_(varargin[i],char('ListString'))):
            listcell=varargin[i + 1]
        else:
            if (strcmpi_(varargin[i],char('SelectionMode'))):
                selmode=varargin[i + 1]
            else:
                if (strcmpi_(varargin[i],char('ListSize'))):
                    listsize=varargin[i + 1]
                else:
                    if (strcmpi_(varargin[i],char('InitialValue'))):
                        initialvalue=varargin[i + 1]
                    else:
                        if (strcmpi_(varargin[i],char('Name'))):
                            name=varargin[i + 1]
                        else:
                            if (strcmpi_(varargin[i],char('PromptString'))):
                                prompt=varargin[i + 1]
                            else:
                                if (strcmpi_(varargin[i],char('OKString'))):
                                    okstring=varargin[i + 1]
                                else:
                                    if (strcmpi_(varargin[i],char('CancelString'))):
                                        cancelstring=varargin[i + 1]
    if (not iscell_(prompt)):
        prompt=[prompt]
    if (not iscell_(listcell)):
        listcell=[listcell]
    if (not strcmp_(selmode,char('Multiple')) and not strcmp_(selmode,char('Single'))):
        error_(char('invalid SelectionMode'))
    if (__octave_link_enabled___()):
        sel,ok=__octave_link_list_dialog___(listcell,selmode,listsize,initialvalue,name,prompt,okstring,cancelstring,nargout=2)
    else:
        if (__have_feature___(char('JAVA'))):
            listsize=[num2str_(listsize[2]),num2str_(listsize[1])]
            initialvalue=arrayfun_(num2str,initialvalue,char('UniformOutput'),false)
            if (isempty_(prompt)):
                prompt=[char('')]
            ret=javaMethod_(char('listdlg'),char('org.octave.JDialogBox'),listcell,selmode,listsize,initialvalue,name,prompt,okstring,cancelstring)
            if (numel_(ret) > 0):
                sel=zeros_(1,numel_(ret))
                for i in arange_(1,numel_(ret)).reshape(-1):
                    sel[i]=ret[i]
                ok=1
            else:
                sel=matlabarray([])
                ok=0
        else:
            error_(char('listdlg is not available in this version of Octave'))
    return sel,ok
def uiwait_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h=matlabarray([])
    timeout=matlabarray([])
    if (nargin == 0):
        h=get_(0,char('currentfigure'))
    else:
        h=varargin[1]
        if (not isfigure_(h)):
            error_(char('uiwait: invalid figure handle H'))
        if (nargin > 1):
            timeout=varargin[2]
    if (not isempty_(h)):
        try:
            try:
                addproperty_(char('__uiwait_state__'),h,char('radio'),char('none|{active}|triggered'))
            finally:
                pass
            waitfor_args=[h,char('__uiwait_state__'),char('triggered')]
            if (not isempty_(timeout)):
                waitfor_args[end() + 1:end() + 2]=[char('timeout'),timeout]
            waitfor_(waitfor_args[:])
        finally:
            if (ishandle_(h) and isprop_(h,char('__uiwait_state__'))):
                set_(h,char('__uiwait_state__'),char('none'))
    return
def waitforbuttonpress_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin != 0 or nargout > 1):
        print_usage_()
    x,y,k=ginput_(1,nargout=3)
    if (nargout == 1):
        if (k <= 5):
            b=0
        else:
            b=1
    return b
def uipanel_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h,args=__uiobject_split_args___(char('uipanel'),varargin,[char('figure'),char('uipanel'),char('uibuttongroup')],nargout=2)
    handle=__go_uipanel___(h,args[:])
    return handle
def uigetfile_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (not __octave_link_enabled___()):
        defaulttoolkit=get_(0,char('defaultfigure__graphics_toolkit__'))
        funcname=matlabarray([char('__uigetfile_'),defaulttoolkit,char('__')])
        functype=exist_(funcname)
        if (not __is_function___(funcname)):
            funcname=char('__uigetfile_fltk__')
            if (not __is_function___(funcname)):
                error_(char('uigetfile: fltk graphics toolkit required'))
            else:
                if (not strcmp_(defaulttoolkit,char('gnuplot'))):
                    warning_(char("uigetfile: no implementation for toolkit '%s', using 'fltk' instead"),defaulttoolkit)
    if (nargin > 7):
        error_(char('uigetfile: number of input arguments must be less than eight'))
    defaultvals=[cell_(0,2),char('Open File'),char(''),[240,120],char('off'),pwd]
    outargs=cell_(6,1)
    for i in arange_(1,6).reshape(-1):
        outargs[i]=defaultvals[i]
    idx1=idx2=matlabarray([])
    if (length_(varargin) > 0):
        for i in arange_(1,length_(varargin)).reshape(-1):
            val=varargin[i]
            if (ischar_(val)):
                val=tolower_(val)
                if (strcmp_(val,char('multiselect'))):
                    idx1=copy_(i)
                else:
                    if (strcmp_(val,char('position'))):
                        idx2=copy_(i)
    stridx=matlabarray([idx1,idx2,0])
    if (length_(stridx) > 1):
        stridx=min_(stridx[1:end() - 1])
    args=copy_(varargin)
    if (stridx):
        args=varargin[1:stridx - 1]
    _len=length_(args)
    if (_len > 0):
        file_filter=args[1]
        outargs[1],outargs[3],defdir=__file_filter___(file_filter,nargout=3)
        if (length_(defdir) > 0):
            outargs[6]=defdir
    else:
        outargs[1]=__file_filter___(outargs[1])
    if (_len > 1):
        if (ischar_(args[2])):
            if (length_(args[2]) > 0):
                outargs[2]=args[2]
        else:
            if (not isempty_(args[2])):
                print_usage_()
    if (_len > 2):
        if (ischar_(args[3])):
            fdir,fname,fext=fileparts_(args[3],nargout=3)
            if (length_(fdir) > 0):
                outargs[6]=fdir
            if (length_(fname) > 0 or length_(fext) > 0):
                outargs[3]=strcat_(fname,fext)
        else:
            if (not isempty_(args[3])):
                print_usage_()
    if (stridx):
        if (rem_(nargin - stridx + 1,2)):
            error_(char('uigetfile: expecting property/value pairs'))
        for i in arange_(stridx,nargin,2).reshape(-1):
            prop=varargin[i]
            val=varargin[i + 1]
            if (strcmpi_(prop,char('position'))):
                if (ismatrix_(val) and length_(val) == 2):
                    outargs[4]=val
                else:
                    error_(char('uigetfile: expecting 2-element vector for position argument'))
            else:
                if (strcmpi_(prop,char('multiselect'))):
                    if (ischar_(val)):
                        outargs[5]=tolower_(val)
                    else:
                        error_(char('uigetfile: expecting string argument (on/off) for multiselect'))
                else:
                    error_(char('uigetfile: unknown argument'))
    if (__octave_link_enabled___()):
        retfile,retpath,retindex=__octave_link_file_dialog___(outargs[:],nargout=3)
    else:
        retfile,retpath,retindex=feval_(funcname,outargs[:],nargout=3)
    return retfile,retpath,retindex
def __uiputfile_fltk___(filters=None,title=None,defval=None,position=None,tag=None,defdir=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[filters,title,defval,position,tag,defdir].count(None)+len(args)

    if (exist_(char('__fltk_uigetfile__')) != 3):
        error_(char('uiputfile: fltk graphics toolkit required'))
    filters=__fltk_file_filter___(filters)
    if (length_(defdir) > 0):
        defval=fullfile_(defdir,defval)
    retval,retpath,retindex=__fltk_uigetfile___(filters,title,defval,position,tag,nargout=3)
    return retval,retpath,retindex
def __uigetfile_fltk___(filters=None,title=None,defval=None,position=None,multiselect=None,defdir=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[filters,title,defval,position,multiselect,defdir].count(None)+len(args)

    if (exist_(char('__fltk_uigetfile__')) != 3):
        error_(char('uigetfile: fltk graphics toolkit required'))
    filters=__fltk_file_filter___(filters)
    if (length_(defdir) > 0):
        defval=fullfile_(defdir,defval)
    retval,retpath,retindex=__fltk_uigetfile___(filters,title,defval,position,multiselect,nargout=3)
    return retval,retpath,retindex
def __file_filter___(file_filter=None,name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[file_filter,name].count(None)+len(args)

    revtal=[]
    defname=char('')
    defdir=char('')
    if (iscell_(file_filter)):
        r,c=size_(file_filter,nargout=2)
        if (c != 1 and c != 2):
            error_(char('%s: invalid filter specification'),name)
        if (c == 1):
            retval=cell_(r,2)
            for i in arange_(1,r).reshape(-1):
                retval[i,1]=file_filter[i]
                retval[i,2]=__default_filtername___(file_filter[i])
        else:
            retval=copy_(file_filter)
            for i in arange_(1,r).reshape(-1):
                if (isempty_(retval[i,2])):
                    retval[i,2]=__default_filtername___(retval[i,1])
    else:
        if (ischar_(file_filter)):
            defdir,fname,fext=fileparts_(file_filter,nargout=3)
            if (not strcmp_(fname,char('*'))):
                defname=strcat_(fname,fext)
            if (length_(fext) > 0):
                fext=strcat_(char('*'),fext)
                retval=[fext,__default_filtername___(fext)]
    retval[end() + 1,:]=[char('*'),__default_filtername___(char('*'))]
    return retval,defname,defdir
def __default_filtername___(filterext=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[filterext].count(None)+len(args)

    name=char('')
    if char('*') == (filterext):
        name=char('All Files')
    else:
        if char('*.m') == (filterext):
            name=char('Octave Source Files')
        else:
            if char('*.c') == (filterext):
                name=char('C Source Files')
            else:
                if [char('*.cc'),char('*.c++'),char('*.cpp')] == (filterext):
                    name=char('C++ Source Files')
                else:
                    if char('*.oct') == (filterext):
                        name=char('Octave Compiled Files')
    if (isempty_(name)):
        extlist=ostrsplit_(filterext,char(';'))
        extlist=strrep_(extlist,char('*.'),char(''))
        extlist=toupper_(extlist)
        extlist[end() + 1,:]=repmat_([char(',')],1,length_(extlist))
        extlist=strcat_(extlist[:])
        extlist=extlist[1:end() - 1]
        name=strcat_(extlist,char('-Files'))
    return name
def message_dialog_(caller=None,msg=None,icon=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[caller,msg,title,icon].count(None)+len(args)

    if (not ischar_(msg)):
        if (iscell_(msg)):
            msg=sprintf_(char('%s\n'),msg[:])
            msg[end()]=char('')
        else:
            error_(char('%s: MSG must be a character string or cellstr array'),caller)
    if (not ischar_(title)):
        error_(char('%s: TITLE must be a character string'),caller)
    dlg=char('emptydlg')
    if (nargin == 4):
        if char('error') == (icon):
            dlg=char('errordlg')
        else:
            if char('help') == (icon):
                dlg=char('helpdlg')
            else:
                if char('warn') == (icon):
                    dlg=char('warndlg')
                else:
                    if char('none') == (icon):
                        dlg=char('emptydlg')
                    else:
                        error_(char('%s: ICON is not a valid type'),caller)
    else:
        icon=char('none')
    if (__octave_link_enabled___()):
        retval=__octave_link_message_dialog___(icon,msg,title)
    else:
        if (__have_feature___(char('JAVA'))):
            retval=javaMethod_(dlg,char('org.octave.JDialogBox'),msg,title)
        else:
            error_(char('%s is not available in this version of Octave'),dlg)
    return retval
def __uigetdir_fltk___(start_path=None,dialog_title=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[start_path,dialog_title].count(None)+len(args)

    if (exist_(char('__fltk_uigetfile__')) != 3):
        error_(char('uigetdir: fltk graphics toolkit required'))
    dirname=__fltk_uigetfile___(char(''),dialog_title,start_path,[240,120],char('dir'))
    return dirname
def __fltk_file_filter___(file_filter=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[file_filter].count(None)+len(args)

    retval=char('')
    r,c=size_(file_filter,nargout=2)
    if ((c == 0) or (c > 2)):
        error_(char('expecting 1 or to 2 columns for file filter cell'))
    fltk_str=char('')
    for idx in arange_(1,r).reshape(-1):
        curr_ext=file_filter[idx,1]
        curr_ext=ostrsplit_(curr_ext,char(';'))
        if (length_(curr_ext) > 1):
            curr_ext=regexprep_(curr_ext,char('\\*\\.'),char(','))
            curr_ext=strcat_(curr_ext[:])(arange_(2,end()))
            curr_ext=strcat_(char('*.{'),curr_ext,char('}'))
        else:
            curr_ext=curr_ext[:]
        curr_desc=strcat_(curr_ext[3:end()],char('-Files'))
        if (c == 2):
            curr_desc=file_filter[idx,2]
            curr_desc=regexprep_(curr_desc,char('\\('),char('<'))
            curr_desc=regexprep_(curr_desc,char('\\)'),char('>'))
        if (length_(fltk_str) > 0):
            fltk_str=strcat_(fltk_str,char('\t'),curr_desc,char(' ('),curr_ext,char(')'))
        else:
            fltk_str=strcat_(curr_desc,char(' ('),curr_ext,char(')'))
    retval=copy_(fltk_str)
    return retval
def __uiobject_split_args___(who=None,in_args=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[who,in_args,parent_type,use_gcf].count(None)+len(args)

    parent=matlabarray([])
    args=[]
    offset=1
    if (not isempty_(in_args)):
        if (ishandle_(in_args[1])):
            parent=in_args[1]
            offset=2
        else:
            if (not ischar_(in_args[1])):
                error_(char('%s: invalid parent handle.'),who)
        args=in_args[offset:end()]
    if (rem_(length_(args),2)):
        error_(char('%s: expecting PROPERTY/VALUE pairs'),who)
    if (not isempty_(args)):
        i=find_(strcmpi_(args[1:2:end()],char('parent')),1,char('first'))
        if (not isempty_(i) and length_(args) >= 2 * i):
            parent=args[2 * i]
            if (not ishandle_(parent)):
                error_(char('%s: invalid parent handle.'),who)
            args[[2 * i - 1,2 * i]]=[]
    if (not isempty_(parent)):
        if (not isempty_(parent_type) and isempty_(find_(strcmpi_(get_(parent,char('type')),parent_type)))):
            error_(char('%s: invalid parent, the parent type must be: %s'),who,sprintf_(char('%s, '),parent_type[:])(arange_(1,end() - 2)))
    else:
        if (use_gcf):
            parent=gcf_()
    return parent,args
def __is_function___(func=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[func].count(None)+len(args)

    existval=exist_(func)
    result=(existval == 2 or existval == 3 or existval == 5 or existval == 6)
    return result
def helpdlg_(msg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[msg,title].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    retval=message_dialog_(char('helpdlg'),msg,title,char('help'))
    return retval
def uitoolbar_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h,args=__uiobject_split_args___(char('uitoolbar'),varargin,[char('figure')],nargout=2)
    handle=__go_uitoolbar___(h,args[:])
    return handle
def uigetdir_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[init_path,dialog_name].count(None)+len(args)

    if (not __octave_link_enabled___()):
        defaulttoolkit=get_(0,char('defaultfigure__graphics_toolkit__'))
        funcname=matlabarray([char('__uigetdir_'),defaulttoolkit,char('__')])
        functype=exist_(funcname)
        if (not __is_function___(funcname)):
            funcname=char('__uigetdir_fltk__')
            if (not __is_function___(funcname)):
                error_(char('uigetdir: fltk graphics toolkit required'))
            else:
                if (not strcmp_(defaulttoolkit,char('gnuplot'))):
                    warning_(char("uigetdir: no implementation for toolkit '%s', using 'fltk' instead"),defaulttoolkit)
    if (nargin > 2):
        print_usage_()
    if (not ischar_(init_path) or not ischar_(dialog_name)):
        error_(char('uigetdir: INIT_PATH and DIALOG_NAME must be string arguments'))
    if (not isdir_(init_path)):
        init_path=fileparts_(init_path)
    if (__octave_link_enabled___()):
        file_filter=cell_(0,2)
        default_file_name=char('')
        dialog_position=matlabarray([240,120])
        dialog_mode=char('dir')
        filename,dirname,filterindex=__octave_link_file_dialog___(file_filter,dialog_name,default_file_name,dialog_position,dialog_mode,init_path,nargout=3)
    else:
        dirname=feval_(funcname,init_path,dialog_name)
    return dirname
def warndlg_(msg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[msg,title].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    retval=message_dialog_(char('warndlg'),msg,title,char('warn'))
    return retval
def uitoggletool_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h,args=__uiobject_split_args___(char('uitoggletool'),varargin,[char('uitoolbar')],0,nargout=2)
    if (isempty_(h)):
        h=findobj_(gcf,char('-depth'),1,char('type'),char('uitoolbar'))
        if (isempty_(h)):
            h=uitoolbar_()
        else:
            h=h[1]
    handle=__go_uitoggletool___(h,args[:])
    return handle
def uicontextmenu_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h,args=__uiobject_split_args___(char('uicontextmenu'),varargin,[char('figure')],nargout=2)
    handle=__go_uicontextmenu___(h,args[:])
    return handle
def waitbar_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    curr_waitbar
    if (nargin < 1):
        print_usage_()
    frac=varargin[1]
    varargin[1]=[]
    if (not (isnumeric_(frac) and isscalar_(frac) and frac >= 0 and frac <= 1)):
        error_(char('waitbar: FRAC must be between 0 and 1'))
    if (nargin == 1 and ishandle_(curr_waitbar)):
        hf=copy_(curr_waitbar)
    else:
        hf=copy_(false)
    if (not isempty_(varargin) and isnumeric_(varargin[1])):
        hf=varargin[1]
        varargin[1]=[]
        if (not isfigure_(hf) or not strcmp_(get_(hf,char('tag')),char('waitbar'))):
            error_(char('waitbar: H must be a handle to a waitbar object'))
    msg=copy_(false)
    if (not isempty_(varargin)):
        msg=varargin[1]
        varargin[1]=[]
        if (not (ischar_(msg) or iscellstr_(msg))):
            error_(char('waitbar: MSG must be a character string or cell array of strings'))
    if (rem_(numel_(varargin),2) != 0):
        error_(char('waitbar: invalid number of property/value pairs'))
    if (hf):
        gd=get_(hf,char('__guidata__'))
        ax=gd[1]
        hp=gd[2]
        set_(hp,char('xdata'),[[0],[frac],[frac],[0]])
        if (ischar_(msg) or iscellstr_(msg)):
            th=get_(ax,char('title'))
            curr_msg=get_(th,char('string'))
            if (iscellstr_(msg)):
                msg=msg[:]
            _cmp=strcmp_(msg,curr_msg)
            if (not all_(_cmp[:])):
                set_(th,char('string'),msg)
    else:
        cf=get_(0,char('currentfigure'))
        hf=figure_(char('position'),[250,500,400,100],char('numbertitle'),char('off'),char('menubar'),char('none'),char('toolbar'),char('none'),char('integerhandle'),char('off'),char('handlevisibility'),char('callback'),char('tag'),char('waitbar'),varargin[:])
        ax=axes_(char('parent'),hf,char('xtick'),[],char('ytick'),[],char('xlim'),[0,1],char('ylim'),[0,1],char('position'),[0.1,0.3,0.8,0.2])
        hp=patch_(ax,[[0],[frac],[frac],[0]],[[0],[0],[1],[1]],[0,0.35,0.75])
        set_(hf,char('__guidata__'),[ax,hp])
        if (not (ischar_(msg) or iscellstr_(msg))):
            msg=char('Please wait...')
        title_(ax,msg)
        set_(0,char('currentfigure'),cf)
    drawnow_()
    if (nargout > 0):
        h=copy_(hf)
    curr_waitbar=copy_(hf)
    return h
def uicontrol_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 1 and ishandle_(varargin[1]) and strcmpi_(get_(varargin[1],char('type')),char('uicontrol'))):
        error_(char('uicontrol focusing not implemented yet.'))
    else:
        h,args=__uiobject_split_args___(char('uicontrol'),varargin,[char('figure'),char('uipanel'),char('uibuttongroup')],nargout=2)
        handle=__go_uicontrol___(h,args[:])
    return handle
def uimenu_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h,args=__uiobject_split_args___(char('uimenu'),varargin,[char('figure'),char('uicontextmenu'),char('uimenu')],nargout=2)
    tmp=__go_uimenu___(h,args[:])
    if (nargout > 0):
        hui=copy_(tmp)
    return hui
def inputdlg_(prompt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[prompt,title].count(None)+len(args)

    if (nargin < 1 or nargin > 4):
        print_usage_()
    if (iscell_(prompt)):
        prompt=prompt[cellfun_(char('isclass'),prompt,char('char'))]
    else:
        if (ischar_(prompt)):
            prompt=[prompt]
        else:
            error_(char('inputdlg: PROMPT must be a character string or cellstr array'))
    if (not ischar_(title)):
        error_(char('inputdlg: TITLE must be a character string'))
    if 0 == (numel___(varargin)):
        linespec=1
        defaults=cellstr_(cell_(size_(prompt)))
    else:
        if 1 == (numel___(varargin)):
            linespec=varargin[1]
            defaults=cellstr_(cell_(size_(prompt)))
        else:
            if 2 == (numel___(varargin)):
                linespec=varargin[1]
                defaults=varargin[2]
    if (isscalar_(linespec)):
        rowscols=zeros_(columns_(prompt),2)
        rowscols[:,2]=25
        rowscols[:,1]=linespec
    else:
        if (isvector_(linespec)):
            rowscols=zeros_(columns_(prompt),2)
            rowscols[:,2]=25
            rowscols[:,1]=linespec[:]
        else:
            if (ismatrix_(linespec)):
                if (rows_(linespec) == columns_(prompt) and columns_(linespec) == 2):
                    rowscols=copy_(linespec)
                else:
                    error_(char('inputdlg: ROWSCOLS matrix does not match size of PROMPT'))
            else:
                error_(char('inputdlg: unknown form of ROWSCOLS argument'))
    rowscols=ceil_(rowscols)
    defs=cellfun_(num2str,defaults,char('UniformOutput'),false)
    rc=arrayfun_(num2str,rowscols,char('UniformOutput'),false)
    if (__octave_link_enabled___()):
        cstr=__octave_link_input_dialog___(prompt,title,rowscols,defs)
    else:
        if (__have_feature___(char('JAVA'))):
            user_inputs=javaMethod_(char('inputdlg'),char('org.octave.JDialogBox'),prompt,title,rc,defs)
            if (isempty_(user_inputs)):
                cstr=[]
            else:
                cstr=cellstr_(user_inputs)
        else:
            error_(char('inputdlg is not available in this version of Octave'))
    return cstr
def msgbox_(msg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[msg,title].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    retval=message_dialog_(char('msgbox'),msg,title,varargin[:])
    return retval
def uipushtool_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h,args=__uiobject_split_args___(char('uipushtool'),varargin,[char('uitoolbar')],0,nargout=2)
    if (isempty_(h)):
        h=findobj_(gcf,char('-depth'),1,char('type'),char('uitoolbar'))
        if (isempty_(h)):
            h=uitoolbar_()
        else:
            h=h[1]
    handle=__go_uipushtool___(h,args[:])
    return handle
def findstr_(s=None,t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[s,t,overlap].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (all_(size_(s) > 1) or all_(size_(t) > 1)):
        error_(char('findstr: arguments must have only one non-singleton dimension'))
    if (length_(s) < length_(t)):
        s,t=deal_(t,s,nargout=2)
    l_s=length_(s)
    l_t=length_(t)
    if (l_t == 0):
        v=matlabarray([])
    else:
        if (l_t == 1):
            v=find_(s == t)
        else:
            if (l_t == 2):
                v=find_(s[1:l_s - 1] == t[1] and s[2:l_s] == t[2])
            else:
                limit=l_s - l_t + 1
                v=find_(s[1:limit] == t[1] and s[2:limit + 1] == t[2] and s[3:limit + 2] == t[3])
    if (l_t >= 3 or (not overlap and l_t > 1 and any_(t[1] == t[2:l_t]))):
        if (all_(size_(s) != size_(t))):
            t=t.T
        keep=zeros_(size_(v))
        ind=arange_(0,l_t - 1)
        if (overlap):
            for idx in arange_(1,length_(v)).reshape(-1):
                keep[idx]=all_(s[v[idx] + ind] == t)
        else:
            _next=1
            for idx in arange_(1,length_(v)).reshape(-1):
                if (v[idx] >= _next and s[v[idx] + ind] == t):
                    keep[idx]=1
                    _next=v[idx] + l_t
                else:
                    keep[idx]=0
        if (not isempty_(v)):
            v=v[find_(keep)]
    if (isempty_(v)):
        v=matlabarray([])
    if (iscolumn_(v)):
        v=v.T
    return v
def deblank_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (ischar_(s)):
        k=find_(not isspace_(s) and s != char('\x00'))
        if (isempty_(s) or isempty_(k)):
            s=char('')
        else:
            s=s[:,1:ceil_(max_(k) / rows_(s))]
    else:
        if (iscell_(s)):
            char_idx=cellfun_(char('isclass'),s,char('char'))
            cell_idx=cellfun_(char('isclass'),s,char('cell'))
            if (not all_(char_idx or cell_idx)):
                error_(char('deblank: S argument must be a string or cellstring'))
            s[char_idx]=regexprep_(s[char_idx],char('[\\s\x0b\\0]+$'),char(''))
            s[cell_idx]=cellfun_(char('deblank'),s[cell_idx],char('UniformOutput'),false)
        else:
            error_(char('deblank: S argument must be a string or cellstring'))
    return s
def base2dec_(s=None,base=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[s,base].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (iscellstr_(s)):
        s=char_(s)
    else:
        if (not ischar_(s)):
            error_(char('base2dec: S must be a string or cellstring'))
    symbols=char('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ')
    if (ischar_(base)):
        symbols=copy_(base)
        base=length_(symbols)
        if (length_(unique_(symbols)) != base):
            error_(char('base2dec: symbols representing digits must be unique'))
        if (any_(isspace_(symbols))):
            error_(char('base2dec: whitespace characters are not valid symbols'))
    else:
        if (not isscalar_(base)):
            error_(char('base2dec: cannot convert from several bases at once'))
        else:
            if (base < 2 or base > length_(symbols)):
                error_(char('base2dec: BASE must be between 2 and 36, or a string of symbols'))
            else:
                s=toupper_(s)
    nr,nc=size_(s,nargout=2)
    if (nc > 1):
        s=s.T
        nonbl=s != char(' ')
        num_nonbl=sum_(nonbl)
        nc=max_(num_nonbl)
        num_blank=nc - num_nonbl
        R=repmat_([[1,2],[0,0]],1,nr)
        R[2,1:2:2 * nr]=num_blank
        R[2,2:2:2 * nr]=num_nonbl
        idx=repelems_([false,true],R)
        idx=reshape_(idx,nc,nr)
        s2=repmat_(char(' '),nc,nr)
        s2[idx]=s[nonbl]
        s=s2.T
    table=NaN_(1,256)
    table[toascii_(symbols[1:base])]=arange_(0,base - 1)
    table[toascii_(char(' '))]=0
    s=reshape_(table[toascii_(s)],size_(s))
    out=s * (base ** (arange_(columns_(s) - 1,0,- 1)).T)
    return out
def strcat_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0):
        print_usage_()
    if (nargin == 1):
        st=varargin[1]
    else:
        uo=char('uniformoutput')
        reals=cellfun_(char('isreal'),varargin)
        if (any_(reals)):
            varargin[reals]=cellfun_(char('char'),varargin[reals],uo,false)
        chars=cellfun_(char('isclass'),varargin,char('char'))
        allchar=all_(chars)
        varargin[chars]=cellfun_(char('cellstr'),varargin[chars],uo,false)
        if (not all_(cellfun_(char('isclass'),varargin,char('cell')))):
            error_(char('strcat: inputs must be strings or cells of strings'))
        err=common_size_(varargin[:])
        if (err):
            error_(char('strcat: arguments must be the same size, or be scalars'))
        st=cellfun_(char('horzcat'),varargin[:],uo,false)
        if (allchar):
            st=char_(st)
    return st
def dec2hex_(d=None,len=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[d,_len].count(None)+len(args)

    if (nargin == 1):
        h=dec2base_(d,16)
    else:
        if (nargin == 2):
            h=dec2base_(d,16,_len)
        else:
            print_usage_()
    return h
def strtrunc_(s=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[s,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    n=fix_(n)
    if (not isscalar_(n) or n < 0):
        error_(char('strtrunc: length N must be a positive integer (N >= 0)'))
    if (ischar_(s)):
        if (n < columns_(s)):
            s=s[:,1:n]
    else:
        if (iscellstr_(s)):
            idx=cellfun_(char('size'),s,2) > n
            rows=cellfun_(char('size'),s[idx],1)
            if (not isempty_(rows)):
                s[idx]=mat2cell_(char_(s[idx])(arange_(),arange_(1,n)),rows)
        else:
            error_(char('strtrunc: S must be a character string or a cell array of strings'))
    return s
def strchr_(str=None,chars=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[_str,chars].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    else:
        if (not ischar_(_str)):
            error_(char('strchr: STR argument must be a string or string array'))
        else:
            if (not ischar_(chars)):
                error_(char('strchr: CHARS argument must be a string'))
    if (isempty_(chars)):
        mask=false_(size_(_str))
    else:
        if (length_(chars) <= 4):
            mask=_str == chars[1]
            for i in arange_(2,length_(chars)).reshape(-1):
                mask |= _str == chars[i]
        else:
            f=false_(256,1)
            f[uint8_(chars) + 1]=true
            si=uint32_(_str)
            ++ si
            mask=reshape_(f[si],size_(_str))
    varargout=cell_(1,nargout)
    varargout[1]=[]
    varargout[:]=find_(mask,varargin[:])
    return varargout
def strjust_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[s,pos].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    else:
        if (not ischar_(s) or ndims_(s) > 2):
            error_(char('strjust: S must be a string or 2-D character matrix'))
    if (isempty_(s)):
        y=copy_(s)
        return y
    nr,nc=size_(s,nargout=2)
    nonbl=s != char(' ') and s != char('\x00')
    idx,jdx=find_(nonbl,nargout=2)
    if (strcmpi_(pos,char('right'))):
        maxs=repmat_(nc,[nr,1])
        maxs[idx]=jdx
        shift=nc - maxs
    else:
        if (strcmpi_(pos,char('left'))):
            mins=ones_(nr,1)
            mins[flipud_(idx[:])]=flipud_(jdx[:])
            shift=1 - mins
        else:
            mins=ones_(nr,1)
            mins[flipud_(idx[:])]=flipud_(jdx[:])
            maxs=repmat_(nc,[nr,1])
            maxs[idx]=jdx
            shift=floor_((nc + 1 - maxs - mins) / 2)
    jdx += shift[idx]
    y=repmat_(char(' '),nr,nc)
    y[sub2ind_([nr,nc],idx,jdx)]=s[nonbl]
    return y
def strjoin_(cstr=None,delimiter=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[cstr,delimiter].count(None)+len(args)

    if (nargin == 1):
        delimiter=char(' ')
    else:
        if (nargin < 1 or nargin > 2):
            print_usage_()
        else:
            if (not (iscellstr_(cstr) and (ischar_(delimiter) or iscellstr_(delimiter)))):
                print_usage_()
    if (numel_(cstr) == 1):
        rval=cstr[1]
        return rval
    if (ischar_(delimiter)):
        delimiter=do_string_escapes_(delimiter)
        delimiter=[delimiter]
    num=numel_(cstr)
    if (numel_(delimiter) == 1 and num > 1):
        delimiter=repmat_(delimiter,1,num)
        delimiter[end()]=[char('')]
    else:
        if (num > 0 and numel_(delimiter) != num - 1):
            error_(char('strjoin:cellstring_delimiter_mismatch'),char('strjoin: the number of delimiters does not match the number of strings'))
        else:
            delimiter[end() + 1]=[char('')]
    if (num == 0):
        rval=char('')
    else:
        rval=matlabarray([[[cstr[:].T],[delimiter[:].T]][:]])
    return rval
def dec2bin_(d=None,len=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[d,_len].count(None)+len(args)

    if (nargin == 1):
        b=dec2base_(d,2)
    else:
        if (nargin == 2):
            b=dec2base_(d,2,_len)
        else:
            print_usage_()
    return b
def cstrcat_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    else:
        if (not iscellstr_(varargin)):
            error_(char('cstrcat: expecting arguments to character strings'))
    st=matlabarray([varargin[:]])
    return st
def regexptranslate_(op=None,s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[op,s].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not ischar_(op)):
        error_(char('regexptranslate: operation OP must be a string'))
    op=tolower_(op)
    if (strcmp_(char('wildcard'),op)):
        y=regexprep_(regexprep_(regexprep_(s,char('\\.'),char('\\.')),char('\\*'),char('.*')),char('\\?'),char('.'))
    else:
        if (strcmp_(char('escape'),op)):
            y=regexprep_(s,char('([^\\w])'),char('\\\\$1'))
        else:
            error_(char('regexptranslate: invalid operation OP'))
    return y
def strtok_(str=None,delim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[_str,delim].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    else:
        if (not (ischar_(_str) or iscellstr_(_str))):
            error_(char('strtok: STR must be a string or cell array of strings.'))
        else:
            if (ischar_(_str) and not isvector_(_str) and not isempty_(_str)):
                error_(char('strtok: STR cannot be a 2-D character array.'))
    if (nargin < 2 or isempty_(delim)):
        ws_delim=copy_(true)
    else:
        ws_delim=copy_(false)
    if (isempty_(_str)):
        tok=rem=char('')
    else:
        if (ischar_(_str)):
            if (ws_delim):
                idx=isspace_(_str)
            else:
                if (length_(delim) <= 7):
                    idx=_str == delim[1]
                    for i in arange_(2,length_(delim)).reshape(-1):
                        idx |= _str == delim[i]
                else:
                    f=false_(256,1)
                    f[uint8_(delim) + 1]=true
                    si=uint32_(_str)
                    ++ si
                    idx=f[si]
            idx_dlim=find_(idx,1)
            idx_nodlim=find_(not idx,1)
            if (isempty_(idx_dlim)):
                tok=copy_(_str)
                rem=char('')
            else:
                if (idx_dlim > idx_nodlim):
                    tok=_str[1:idx_dlim - 1]
                    rem=_str[idx_dlim:end()]
                else:
                    idx_dlim=find_(idx[idx_nodlim + 1:end()],1)
                    if (isempty_(idx_dlim)):
                        tok=_str[idx_nodlim:end()]
                        rem=char('')
                    else:
                        tok=_str[idx_nodlim:(idx_dlim + idx_nodlim - 1)]
                        rem=_str[(idx_dlim + idx_nodlim):end()]
        else:
            if (ws_delim):
                delim=char('\\s')
            ptn=matlabarray([char('^['),delim,char(']*'),char('([^'),delim,char(']+)'),char('(['),delim,char('].*)$')])
            matches=regexp_(_str,ptn,char('tokens'))
            eidx=cellfun_(char('isempty'),matches)
            midx=not eidx
            tok=cell_(size_(_str))
            tok[eidx]=regexprep_(_str[eidx],[char('^['),delim,char(']+')],char(''))
            tmp=matlabarray([matches[midx]])
            if (not isempty_(tmp)):
                tmp=matlabarray([tmp[:]])
            tok[midx]=tmp[1:2:end()]
            if (isargout_(2)):
                rem=cell_(size_(_str))
                rem[eidx]=[char('')]
                rem[midx]=tmp[2:2:end()]
    return tok,rem
def blanks_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    else:
        if (not (isscalar_(n) and n == fix_(n) and n >= 0)):
            error_(char('blanks: N must be a non-negative integer'))
    s[1:n]=char(' ')
    return s
def validatestring_(str=None,strarray=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[_str,strarray].count(None)+len(args)

    if (nargin < 2 or nargin > 5):
        print_usage_()
    position=0
    if (not isempty_(varargin) and isnumeric_(varargin[end()])):
        position=varargin[end()]
        varargin[end()]=[]
    funcname=varname=char('')
    char_idx=cellfun_(char('isclass'),varargin,char('char'))
    n_chararg=sum_(char_idx)
    if (n_chararg > 2):
        error_(char('validatestring: invalid number of character inputs (3)'))
    else:
        if (n_chararg == 2):
            funcname,varname=deal_(varargin[char_idx],nargout=2)
        else:
            if (n_chararg == 1):
                funcname=varargin[char_idx]
    if (not ischar_(_str)):
        error_(char('validatestring: STR must be a character string'))
    else:
        if (not isrow_(_str)):
            error_(char('validatestring: STR must be a single row vector'))
        else:
            if (not iscellstr_(strarray)):
                error_(char('validatestring: STRARRAY must be a cellstr'))
            else:
                if (not isempty_(funcname) and not isrow_(funcname)):
                    error_(char('validatestring: FUNCNAME must be a single row vector'))
                else:
                    if (not isempty_(varname) and not isrow_(varname)):
                        error_(char('validatestring: VARNAME must be a single row vector'))
                    else:
                        if (position < 0):
                            error_(char('validatestring: POSITION must be >= 0'))
    errstr=char('')
    if (not isempty_(funcname)):
        errstr=sprintf_(char('Function: %s '),funcname)
    if (not isempty_(varname)):
        errstr=sprintf_(char('%sVariable: %s '),errstr,varname)
    if (position > 0):
        errstr=sprintf_(char('%sArgument position %d '),errstr,position)
    if (not isempty_(errstr)):
        errstr[end():end() + 1]=char(':\n')
    matches=strncmpi_(_str,strarray[:],length_(_str))
    nmatches=sum_(matches)
    if (nmatches == 0):
        error_(char("validatestring: %s'%s' does not match any of\n%s"),errstr,_str,sprintf_(char('%s, '),strarray[:])(arange_(1,end() - 2)))
    else:
        if (nmatches == 1):
            _str=strarray[matches]
        else:
            match_idx=find_(matches)
            match_len=cellfun_(char('length'),strarray[match_idx])
            min_len,min_idx=min_(match_len,nargout=2)
            short_str=strarray[match_idx[min_idx]]
            submatch=strncmpi_(short_str,strarray[match_idx],min_len)
            if (all_(submatch)):
                _str=copy_(short_str)
            else:
                error_(char("validatestring: %smultiple unique matches were found for '%s':\n%s"),errstr,_str,sprintf_(char('%s, '),strarray[match_idx])(arange_(1,end() - 2)))
    return _str
def bin2dec_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    d=base2dec_(s,2)
    return d
def isstrprop_(str=None,prop=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[_str,prop].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if char('alpha') == (prop):
        retval=isalpha_(_str)
    else:
        if [char('alnum'),char('alphanum')] == (prop):
            retval=isalnum_(_str)
        else:
            if char('ascii') == (prop):
                retval=isascii_(_str)
            else:
                if char('cntrl') == (prop):
                    retval=iscntrl_(_str)
                else:
                    if char('digit') == (prop):
                        retval=isdigit_(_str)
                    else:
                        if [char('graph'),char('graphic')] == (prop):
                            retval=isgraph_(_str)
                        else:
                            if char('lower') == (prop):
                                retval=islower_(_str)
                            else:
                                if char('print') == (prop):
                                    retval=isprint_(_str)
                                else:
                                    if char('punct') == (prop):
                                        retval=ispunct_(_str)
                                    else:
                                        if [char('space'),char('wspace')] == (prop):
                                            retval=isspace_(_str)
                                        else:
                                            if char('upper') == (prop):
                                                retval=isupper_(_str)
                                            else:
                                                if char('xdigit') == (prop):
                                                    retval=isxdigit_(_str)
                                                else:
                                                    error_(char('isstrprop: invalid string property'))
    return retval
def dec2base_(d=None,base=None,len=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[d,base,_len].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (iscell_(d)):
        d=cell2mat_(d)
    if (not iscolumn_(d)):
        d=d[:]
    if (islogical_(d)):
        d=double_(d)
    else:
        if (not isnumeric_(d) or iscomplex_(d) or any_(d < 0 or d != fix_(d))):
            error_(char('dec2base: input must be real non-negative integers'))
    symbols=char('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ')
    if (ischar_(base)):
        symbols=copy_(base)
        base=length_(symbols)
        if (length_(unique_(symbols)) != base):
            error_(char('dec2base: symbols representing digits must be unique'))
        if (any_(isspace_(symbols))):
            error_(char('dec2base: whitespace characters are not valid symbols'))
    else:
        if (not isscalar_(base)):
            error_(char('dec2base: cannot convert from several bases at once'))
        else:
            if (base < 2 or base > length_(symbols)):
                error_(char('dec2base: BASE must be between 2 and 36, or a string of symbols'))
    max_len=round_(log_(max_(max_(d[:]),1)) / log_(base)) + 1
    if (nargin == 3):
        max_len=max_(max_len,_len)
    digits=zeros_(length_(d),max_len)
    for k in arange_(max_len,1,- 1).reshape(-1):
        digits[:,k]=mod_(d,base)
        d=round_((d - digits[:,k]) / base)
    retval=reshape_(symbols[digits + 1],size_(digits))
    if ((nargin == 2 or (nargin == 3 and max_len > _len)) and length_(retval) != 1 and not any_(retval[:,1] != symbols[1])):
        retval=retval[:,2:end()]
    return retval
def untabify_(t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[t,tw,dblank].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    else:
        if (not (ischar_(t) or iscellstr_(t))):
            error_(char('untabify: T must be a string or cellstring'))
    if (ischar_(t)):
        s=replace_tabs_(t,tw)
    else:
        s=cellfun_(replace_tabs,t,[tw],char('uniformoutput'),false)
    if (dblank):
        s=deblank_(s)
    return s
def replace_tabs_(t=None,tw=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[t,tw].count(None)+len(args)

    if (ndims_(t) != 2):
        error_(char('untabify: character strings to untabify must have 2 dimensions'))
    if (isempty_(t)):
        s=copy_(t)
    else:
        nr=rows_(t)
        sc=cell_(nr,1)
        for j in arange_(1,nr).reshape(-1):
            n=arange_(1,numel_(t[j,:]))
            m=find_(t[j,:] == char('\t'))
            t[j,m]=char(' ')
            for i in arange_(1,numel_(m)).reshape(-1):
                k=tw * ceil_(n[m[i]] / tw)
                dn=k - n[m[i]]
                n[m[i]:end()] += dn
            sc[j]=blanks_(n[end()])
            sc[j][n]=t[j,:]
        s=char_(sc)
    return s
def str2num_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    else:
        if (not ischar_(s)):
            error_(char('str2num: S must be a string or string array'))
    s[:,end() + 1]=char(';')
    s=sprintf_(char('m = [%s];'),reshape_(s.T,1,numel_(s)))
    state=copy_(true)
    eval_(s,char('m = []; state = false;'))
    if (ischar_(m)):
        m=matlabarray([])
        state=copy_(false)
    return m,state
def substr_(s=None,offset=None,len=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[s,offset,_len].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not ischar_(s)):
        error_(char('substr: S must be a string or string array'))
    else:
        if (not isscalar_(offset) or (nargin == 3 and not isscalar_(_len))):
            error_(char('substr: OFFSET and LEN must be scalar integers'))
    offset=fix_(offset)
    nc=columns_(s)
    if (abs_(offset) > nc or offset == 0):
        error_(char('substr: OFFSET = %d out of range'),offset)
    if (offset <= 0):
        offset += nc + 1
    if (nargin == 2):
        eos=copy_(nc)
    else:
        _len=fix_(_len)
        if (_len < 0):
            eos=nc + _len
        else:
            eos=offset + _len - 1
    if (eos > nc):
        error_(char('substr: length LEN = %d out of range'),_len)
    else:
        if (offset > eos and _len != 0):
            error_(char('substr: No overlap with chosen values of OFFSET and LEN'))
    t=s[:,offset:eos]
    return t
def strmatch_(s=None,A=None,exact=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[s,A,exact].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not ischar_(s) or (not isempty_(s) and not isvector_(s))):
        error_(char('strmatch: S must be a string'))
    else:
        if (not (ischar_(A) or iscellstr_(A))):
            error_(char('strmatch: A must be a string or cell array of strings'))
    s=regexprep_(s,char('[ \\0]+$'),char(''))
    _len=length_(s)
    exact=nargin == 3 and ischar_(exact) and strcmp_(exact,char('exact'))
    if (ischar_(A)):
        nr,nc=size_(A,nargout=2)
        if (_len > nc):
            idx=matlabarray([])
        else:
            match=all_(bsxfun_(eq,A[:,1:_len],s),2)
            if (exact):
                AA=A[:,_len + 1:nc]
                match &= all_(AA == char(' ') or AA == char('\x00'),2)
            idx=find_(match)
    else:
        if (_len > 0):
            idx=find_(strncmp_(s,A,_len))
        else:
            idx=find_(strcmp_(s,A))
        if (exact):
            B=regexprep_(A[idx],char('[ \\0]+$'),char(''))
            idx=idx[strcmp_(s,B)]
    return idx
def rindex_(s=None,t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[s,t].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    n=index_(s,t,char('last'))
    return n
def mat2str_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,n,cls].count(None)+len(args)

    if (nargin < 1 or nargin > 3 or not (isnumeric_(x) or islogical_(x))):
        print_usage_()
    else:
        if (ndims_(x) > 2):
            error_(char('mat2str: X must be two dimensional'))
    if (nargin == 2 and ischar_(n)):
        cls=copy_(n)
        n=15
    else:
        if (isempty_(n)):
            n=15
    x_islogical=islogical_(x)
    x_iscomplex=iscomplex_(x)
    if (x_iscomplex):
        if (isscalar_(n)):
            n=matlabarray([n,n])
        fmt=sprintf_(char('%%.%dg%%+.%dgi'),n[1],n[2])
    else:
        if (x_islogical):
            v=[char('false'),char('true')]
            fmt=char('%s')
        else:
            fmt=sprintf_(char('%%.%dg'),n[1])
    nel=numel_(x)
    if (nel == 0):
        s=char('[]')
    else:
        if (nel == 1):
            if (x_iscomplex):
                s=sprintf_(fmt,real_(x),imag_(x))
            else:
                if (x_islogical):
                    s=v[x + 1]
                else:
                    s=sprintf_(fmt,x)
        else:
            fmt=matlabarray([fmt,char(' ')])
            if (x_iscomplex):
                t=x.T
                s=sprintf_(fmt,[[real_(t[:]).T],[imag_(t[:]).T]])
            else:
                if (x_islogical):
                    t=v[x + 1]
                    s=cstrcat_(sprintf_(fmt,t[:]))
                else:
                    s=sprintf_(fmt,x.T)
            s=matlabarray([char('['),s])
            s[end()]=char(']')
            idx=strfind_(s,char(' '))
            nc=columns_(x)
            s[idx[nc:nc:end()]]=char(';')
    if (strcmp_(char('class'),cls)):
        s=matlabarray([class_(x),char('('),s,char(')')])
    return s
def strtrim_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (ischar_(s)):
        k=find_(not isspace_(s))
        if (isempty_(s) or isempty_(k)):
            s=char('')
        else:
            s=s[:,ceil_(min_(k) / rows_(s)):ceil_(max_(k) / rows_(s))]
    else:
        if (iscell_(s)):
            char_idx=cellfun_(char('isclass'),s,char('char'))
            cell_idx=cellfun_(char('isclass'),s,char('cell'))
            if (not all_(char_idx or cell_idx)):
                error_(char('strtrim: S argument must be a string or cellstring'))
            s[char_idx]=regexprep_(s[char_idx],char('^[\\s\x0b]+|[\\s\x0b]+$'),char(''))
            s[cell_idx]=cellfun_(char('strtrim'),s[cell_idx],char('UniformOutput'),false)
        else:
            error_(char('strtrim: S argument must be a string or cellstring'))
    return s
def hex2dec_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    d=base2dec_(s,16)
    return d
def ostrsplit_(s=None,sep=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[s,sep,strip_empty].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    else:
        if (not ischar_(s) or not ischar_(sep)):
            error_(char('ostrsplit: S and SEP must be string values'))
        else:
            if (not isscalar_(strip_empty)):
                error_(char('ostrsplit: STRIP_EMPTY must be a scalar value'))
    if (isempty_(s)):
        cstr=cell_(size_(s))
    else:
        if (rows_(s) > 1):
            s[:,end() + 1]=sep[1]
            s=reshape_(s.T,1,numel_(s))
            s[end()]=[]
        if (isscalar_(sep)):
            idx=find_(s == sep)
        else:
            idx=strchr_(s,sep)
        if (isempty_(idx)):
            strlens=length_(s)
        else:
            strlens=matlabarray([idx[1] - 1,diff_(idx) - 1,numel_(s) - idx[end()]])
        s[idx]=[]
        if (strip_empty):
            strlens=strlens[strlens != 0]
        cstr=mat2cell_(s,1,strlens)
    return cstr
def isletter_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    retval=isalpha_(s)
    return retval
def index_(s=None,t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[s,t,direction].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (ischar_(s)):
        if (not isrow_(s)):
            s=cellstr_(s)
    else:
        if (not iscellstr_(s)):
            error_(char('index: S must be a string, string array, or cellstr'))
    f=strfind_(s,t)
    if (isempty_(f)):
        f=0
    else:
        if (iscell_(f)):
            f[cellfun_(char('isempty'),f)]=[0]
    direction=tolower_(direction)
    if (strcmp_(direction,char('first'))):
        if (iscell_(f)):
            n=cellfun_(char('min'),f)
        else:
            n=f[1]
    else:
        if (strcmp_(direction,char('last'))):
            if (iscell_(f)):
                n=cellfun_(char('max'),f)
            else:
                n=f[end()]
        else:
            error_(char('index: DIRECTION must be either "first" or "last"'))
    return n
def type_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0):
        print_usage_()
    else:
        if (not iscellstr_(varargin)):
            error_(char('type: input arguments must be strings'))
    quiet=copy_(false)
    idx=strcmpi_(varargin,char('-q')) or strcmpi_(varargin,char('-quiet'))
    if (any_(idx)):
        quiet=copy_(true)
        varargin[idx]=[]
    if (nargout > 0):
        text=cell_(size_(varargin))
    for n in arange_(1,length_(varargin)).reshape(-1):
        name=varargin[n]
        txt=char('')
        cmd=sprintf_(char("exist ('%s')"),name)
        e=evalin_(char('caller'),cmd)
        if (e == 1):
            cmd=sprintf_(char('disp (%s);'),name)
            desc=evalin_(char('caller'),cmd)
            if (quiet):
                txt=copy_(desc)
            else:
                txt=sprintf_(char('%s is a variable\n%s'),name,desc)
        else:
            if (e == 2):
                _file=which_(name)
                if (length_(_file) > 2):
                    ext=_file[end() - 1:end()]
                if (isempty_(_file) or not strcmpi_(ext,char('.m'))):
                    _file=file_in_loadpath_(name)
                    quiet=copy_(true)
                fid=fopen_(_file,char('r'))
                if (fid < 0):
                    error_(char("type: couldn't open '%s' for reading"),_file)
                contents=char_(fread_(fid).T)
                fclose_(fid)
                if (quiet):
                    txt=copy_(contents)
                else:
                    txt=sprintf_(char('%s is the user-defined function defined from: %s\n\n%s'),name,_file,contents)
            else:
                if (e == 3):
                    txt=sprintf_(char('%s is a dynamically-linked function'),name)
                else:
                    if (e == 5):
                        txt=sprintf_(char('%s is a built-in function'),name)
                    else:
                        if (any_(strcmp_(__operators___(),name))):
                            txt=sprintf_(char('%s is an operator'),name)
                        else:
                            if (any_(strcmp_(__keywords___(),name))):
                                txt=sprintf_(char('%s is a keyword'),name)
                            else:
                                error_(char("type: '%s' undefined\n"),name)
        if (nargout == 0):
            disp_(txt)
        else:
            text[n]=txt
    return text
def help_(name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[name].count(None)+len(args)

    if (nargin == 0):
        text=char('\n  For help with individual commands and functions type\n\n    help NAME\n\n  (replace NAME with the name of the command or function you would\n  like to learn more about).\n\n  For a more detailed introduction to GNU Octave, please consult the\n  manual.  To read the manual from the prompt type\n\n    doc\n\n  GNU Octave is supported and developed by its user community.\n  For more information visit http://www.octave.org.\n\n')
        if (nargout == 0):
            puts_(text)
        else:
            retval=copy_(text)
    else:
        if (nargin == 1 and ischar_(name)):
            if (strcmp_(name,char('--list'))):
                tmp=do_list_functions_()
                if (nargout == 0):
                    printf_(char('%s'),tmp)
                else:
                    retval=copy_(tmp)
                return retval
            if (strcmp_(name,char('.'))):
                tmp=do_list_operators_()
                if (nargout == 0):
                    printf_(char('%s'),tmp)
                else:
                    retval=copy_(tmp)
                return retval
            text,_format=get_help_text_(name,nargout=2)
            if char('plain text') == (lower_____(_format)):
                status=0
            else:
                if char('texinfo') == (lower_____(_format)):
                    text,status=__makeinfo___(text,char('plain text'),nargout=2)
                else:
                    if char('html') == (lower_____(_format)):
                        text,status=strip_html_tags_(text,nargout=2)
                    else:
                        if char('not documented') == (lower_____(_format)):
                            error_(char("help: '%s' is not documented\n"),name)
                        else:
                            if char('not found') == (lower_____(_format)):
                                do_contents_(name)
                                return retval
                            else:
                                error_(char("help: internal error: unsupported help text format: '%s'\n"),_format)
            if (status != 0):
                warning_(char('help: Texinfo formatting filter exited abnormally; raw Texinfo source of help text follows...\n'))
            if (nargout == 0):
                which_(name)
                printf_(char('\n%s\n%s'),text,__additional_help_message___())
            else:
                retval=copy_(text)
        else:
            error_(char('help: invalid input\n'))
    return retval
def do_list_operators_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    retval=sprintf_(char('*** operators:\n\n%s\n\n'),list_in_columns_(__operators___()))
    return retval
def do_list_functions_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    operators=do_list_operators_()
    keywords=sprintf_(char('*** keywords:\n\n%s\n\n'),list_in_columns_(__keywords___()))
    builtins=sprintf_(char('*** builtins:\n\n%s\n\n'),list_in_columns_(__builtins___()))
    dirs=ostrsplit_(path,pathsep)
    flist=char('')
    for i in arange_(2,numel_(dirs)).reshape(-1):
        files=sort_([dir_(fullfile_(dirs[i],char('*.m'))).name,dir_(fullfile_(dirs[i],char('*.oct'))).name,dir_(fullfile_(dirs[i],char('*.mex'))).name])
        if (not isempty_(files)):
            flist=sprintf_(char('%s*** functions in %s:\n\n%s\n\n'),flist,dirs[i],list_in_columns_(files))
    retval=matlabarray([operators,keywords,builtins,flist])
    return retval
def do_contents_(name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[name].count(None)+len(args)

    found=copy_(false)
    dlist=find_dir_in_path_(name,char('all'))
    for i in arange_(1,numel_(dlist)).reshape(-1):
        fname=make_absolute_filename_(fullfile_(dlist[i],char('Contents.m')))
        text,_format=get_help_text_from_file_(fname,nargout=2)
        if char('plain text') == (lower___(_format)):
            status=0
        else:
            if char('texinfo') == (lower___(_format)):
                text,status=__makeinfo___(text,char('plain text'),nargout=2)
            else:
                if char('html') == (lower___(_format)):
                    text,status=strip_html_tags_(text,nargout=2)
        if (not isempty_(text)):
            found=copy_(true)
            if (status != 0):
                warning_(char('help: Texinfo formatting filter exited abnormally; raw Texinfo source of help text follows...\n'))
            printf_(char('%s:\n\n%s\n'),fname,text)
    if (found):
        puts_(__additional_help_message___())
    else:
        msg=feval_(missing_function_hook,name)
        if (isempty_(msg)):
            msg=sprintf_(char("'%s' not found"),name)
        error_(char('help: %s\n'),msg)
    return
def __makeinfo___(text=None,fsee_also=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[text,output_type,fsee_also].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not ischar_(text)):
        error_(char('__makeinfo__: first input argument must be a string'))
    if (not ischar_(output_type)):
        error_(char('__makeinfo__: second input argument must be a string'))
    if (nargin < 3):
        if (strcmpi_(output_type,char('plain text'))):
            fsee_also=lambda T: strcat_(char('\nSee also:'),sprintf_(char(' %s,'),T[:])(arange_(1,end() - 1)),char('\n'))
        else:
            fsee_also=lambda T: strcat_(char('\nSee also:'),sprintf_(char(' @ref{%s},'),T[:])(arange_(1,end() - 1)),char('\n'))
    if (not isa_(fsee_also,char('function_handle'))):
        error_(char('__makeinfo__: third input argument must be a function handle'))
    if (text[2] == char(' ')):
        text=strrep_(text,char('\n '),char('\n'))
    text=regexprep_(text,char('^ +@end tex'),char('@end tex'),char('lineanchors'))
    _file=texi_macros_file_()
    fid=fopen_(_file,char('r'))
    if (fid < 0):
        error_(char('unable to open %s for reading'),_file)
    else:
        macros_text=fread_(fid,Inf,char('*char')).T
        text=matlabarray([macros_text,text])
    fclose_(fid)
    if (strcmpi_(output_type,char('texinfo'))):
        status=0
        retval=copy_(text)
        return retval,status
    text=sprintf_(char('\\input texinfo\n\n%s\n\n@bye\n'),text)
    try:
        template=char('octave-help-XXXXXX')
        fid,name=mkstemp_(fullfile_(tempdir,template),true,nargout=2)
        if (fid < 0):
            error_(char('__makeinfo__: could not create temporary file'))
        fprintf_(fid,char('%s'),text)
        fclose_(fid)
        if char('plain text') == (lower__(output_type)):
            cmd=sprintf_(char('%s --no-headers --no-warn --force --no-validate --output=- %s'),makeinfo_program_(),name)
        else:
            if char('html') == (lower__(output_type)):
                cmd=sprintf_(char('%s --no-headers --html --no-warn --no-validate --force --output=- %s'),makeinfo_program_(),name)
            else:
                error_(char("__makeinfo__: unsupported output type: '%s'"),output_type)
        status,retval=system_(cmd,nargout=2)
    finally:
        if (exist_(name,char('file'))):
            delete_(name)
    return retval,status
def print_usage_(name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[name].count(None)+len(args)

    x=dbstack_()
    if (nargin == 0):
        if (numel_(x) > 1):
            name=x[2].name
        else:
            error_(char('Octave:invalid-context'),char('print_usage: invalid function\n'))
        fullpath=evalin_(char('caller'),char('mfilename ("fullpath")'))
        if (strcmp_(fullpath[end() - length_(name) + 1:end()],name)):
            fullname=matlabarray([fullpath,char('.m')])
    else:
        if (not ischar_(name)):
            error_(char('Octave:invalid-input-arg'),char('print_usage: input argument must be a string'))
        else:
            fullname=copy_(name)
    at_toplev=length_(x) < 2 or (length_(x) == 2 and strcmp_(x[2].name,name))
    text,_format=get_help_text_(fullname,nargout=2)
    max_len=80
    if char('plain text') == (lower_____(_format)):
        usage_string,status=get_usage_plain_text_(text,max_len,nargout=2)
    else:
        if char('texinfo') == (lower_____(_format)):
            usage_string,status=get_usage_texinfo_(text,max_len,nargout=2)
        else:
            if char('html') == (lower_____(_format)):
                usage_string,status=get_usage_html_(text,max_len,nargout=2)
            else:
                if char('not documented') == (lower_____(_format)):
                    error_(char("print_usage: '%s' is not documented\n"),name)
                else:
                    if char('not found') == (lower_____(_format)):
                        error_(char("print_usage: '%s' not found\n"),name)
                    else:
                        error_(char("print_usage: internal error: unsupported help text format: '%s'\n"),_format)
    if (status != 0):
        warning_(char('print_usage: Texinfo formatting filter exited abnormally'))
        warning_(char('print_usage: raw Texinfo source of help text follows...\n'))
    if (at_toplev):
        error_(char('Octave:invalid-fun-call'),char('Invalid call to %s.  Correct usage is:\n\n%s\n%s'),name,usage_string,__additional_help_message___())
    else:
        msg=sprintf_(char('Invalid call to %s.  Correct usage is:\n\n%s'),name,usage_string)
        if (msg[end()] == char('\n')):
            msg[end()]=char(' ')
        error_(char('Octave:invalid-fun-call'),msg)
    return
def get_usage_plain_text_(help_text=None,max_len=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[help_text,max_len].count(None)+len(args)

    line_end_idx=strfind_(help_text,char('\n\n'))
    retval=help_text[1:min_([line_end_idx,max_len,length_(help_text)])]
    status=0
    return retval,status
def get_usage_texinfo_(help_text=None,max_len=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[help_text,max_len].count(None)+len(args)

    help_text=strrep_(help_text,char('@\n'),char(' '))
    def_idx=strfind_(help_text,char('@def'))
    if (not isempty_(def_idx)):
        endf_idx=strfind_(help_text,char('@end def'))
        def_idx=sort_([def_idx,endf_idx])
        endl_idx=find_(help_text == char('\n'))
        _buffer=char('')
        for k in arange_(1,length_(def_idx)).reshape(-1):
            endl=endl_idx[find_(endl_idx > def_idx[k],1)]
            if (isempty_(endl)):
                _buffer=strcat_(_buffer,help_text[def_idx[k]:end()],char('\n'))
            else:
                _buffer=strcat_(_buffer,help_text[def_idx[k]:endl])
    else:
        retval,status=get_usage_plain_text_(help_text,max_len,nargout=2)
    retval,status=__makeinfo___(_buffer,char('plain text'),nargout=2)
    return retval,status
def get_usage_html_(help_text=None,max_len=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[help_text,max_len].count(None)+len(args)

    help_text,status=strip_html_tags_(help_text,nargout=2)
    retval=get_usage_plain_text_(help_text,max_len)
    return retval,status
def lookfor_(str=None,arg2=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[_str,arg2].count(None)+len(args)

    if (strcmpi_(_str,char('-all'))):
        _str=copy_(arg2)
        search_type=2
    else:
        search_type=3
    _str=lower_(_str)
    cache_file=doc_cache_file_()
    if (exist_(cache_file,char('file'))):
        fun,help_text=search_cache_(_str,cache_file,search_type,nargout=2)
        had_core_cache=copy_(true)
    else:
        fun=help_text=[]
        had_core_cache=copy_(false)
    orig_path=ostrsplit_(__pathorig___(),pathsep_())
    new_path=ostrsplit_(path_(),pathsep_())
    if (had_core_cache):
        new_path=setdiff_(new_path,orig_path)
    for n in arange_(1,numel_(new_path)).reshape(-1):
        elt=new_path[n]
        cache_file=fullfile_(elt,char('doc-cache'))
        if (exist_(cache_file,char('file'))):
            funs,hts=search_cache_(_str,cache_file,search_type,nargout=2)
            fun[end() + 1:end() + length_(funs)]=funs
            help_text[end() + 1:end() + length_(hts)]=hts
        else:
            funs_in_f=__list_functions___(elt)
            for m in arange_(1,length_(funs_in_f)).reshape(-1):
                fn=funs_in_f[m]
                if (length_(fn) > 2 and strcmp_(fn[1:2],char('__'))):
                    continue
                try:
                    warn_state=warning_()
                    try:
                        warning_(char('off'))
                        first_sentence=get_first_help_sentence_(fn,1024)
                        status=0
                    finally:
                        warning_(warn_state)
                finally:
                    pass
                if (search_type == 2):
                    try:
                        warn_state=warning_()
                        try:
                            warning_(char('off'))
                            text,fmt=get_help_text_(fn,nargout=2)
                            status=0
                        finally:
                            warning_(warn_state)
                    finally:
                        pass
                    if char('plain text') == (lower___(fmt)):
                        status=0
                    else:
                        if char('texinfo') == (lower___(fmt)):
                            text,status=__makeinfo___(text,char('plain text'),nargout=2)
                        else:
                            if char('html') == (lower___(fmt)):
                                text,status=strip_html_tags_(text,nargout=2)
                            else:
                                status=1
                else:
                    if (status == 0):
                        text=copy_(first_sentence)
                if (status == 0 and not isempty_(strfind_(lower_(text),_str))):
                    fun[end() + 1]=fn
                    help_text[end() + 1]=first_sentence
    if (nargout == 0):
        indent=20
        term_width=(terminal_size_())(2)
        desc_width=term_width - indent - 2
        indent_space=blanks_(indent)
        for k in arange_(1,length_(fun)).reshape(-1):
            f=fun[k]
            f[end() + 1:indent - 1]=char(' ')
            puts_([f,char(' ')])
            lf=length_(f)
            desc=strtrim_(strrep_(help_text[k],char('\n'),char(' ')))
            ldesc=length_(desc)
            printf_(char('%s\n'),desc[1:min_(ldesc,desc_width - (lf - indent))])
            for start in arange_((desc_width - (lf - indent) + 1),ldesc,desc_width).reshape(-1):
                stop=min_(start + desc_width,ldesc)
                printf_(char('%s%s\n'),indent_space,strtrim_(desc[start:stop]))
    else:
        out_fun=copy_(fun)
        out_help_text=copy_(help_text)
    return out_fun,out_help_text
def search_cache_(str=None,cache_file=None,search_type=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[_str,cache_file,search_type].count(None)+len(args)

    load_(cache_file)
    if (not isempty_(cache)):
        t1=strfind_(lower_(cache_(1,arange_())),_str)
        t2=strfind_(lower_(cache_(search_type,arange_())),_str)
        cache_idx=find_(not (cellfun_(char('isempty'),t1) and cellfun_(char('isempty'),t2)))
        funs=cache_(1,cache_idx)
        help_texts=cache_(3,cache_idx)
    else:
        funs=help_texts=[]
    return funs,help_texts
def __additional_help_message___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (suppress_verbose_help_message_()):
        msg=char('')
    else:
        msg=char("Additional help for built-in functions and operators is\navailable in the online version of the manual.  Use the command\n'doc <topic>' to search the manual index.\n\nHelp and information about Octave is also available on the WWW\nat http://www.octave.org and via the help@octave.org\nmailing list.\n")
    return msg
def doc_cache_create_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[out_file,directory].count(None)+len(args)

    if (not ischar_(out_file)):
        print_usage_()
    if (isempty_(directory)):
        cache=gen_builtin_cache_()
    else:
        if (iscell_(directory)):
            if (all_(cellfun_(char('isclass'),directory,char('char')))):
                cache=gen_doc_cache_in_dir_(directory)
            else:
                error_(char('doc_cache_create: cell must contain only strings'))
        else:
            if (ischar_(directory)):
                cache=gen_doc_cache_in_dir_(directory)
            else:
                error_(char('doc_cache_create: second input argument must be a string or a cell of strings'))
    if (not isempty_(cache)):
        save_(char('-text'),out_file,char('cache'))
    return
def handle_function_(f=None,text=None,format=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[f,text,_format].count(None)+len(args)

    first_sentence=char('')
    if (length_(f) > 2 and all_(f[1:2] == char('_'))):
        status=1
        return text,first_sentence,status
    if char('plain text') == (lower___(_format)):
        status=0
    else:
        if char('texinfo') == (lower___(_format)):
            text,status=__makeinfo___(text,char('plain text'),nargout=2)
        else:
            if char('html') == (lower___(_format)):
                text,status=strip_html_tags_(text,nargout=2)
            else:
                status=1
    if (status != 0 or isempty_(text)):
        warning_(char("doc_cache_create: unusable help text found in file '%s'"),f)
        return text,first_sentence,status
    first_sentence=get_first_help_sentence_(f)
    return text,first_sentence,status
def create_cache_(list=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[_list].count(None)+len(args)

    cache=[]
    for n in arange_(1,length_(_list)).reshape(-1):
        f=_list[n]
        text,_format=get_help_text_(f,nargout=2)
        text,first_sentence,status=handle_function_(f,text,_format,nargout=3)
        if (status != 0):
            continue
        cache[1,end() + 1]=f
        cache[2,end()]=text
        cache[3,end()]=first_sentence
    return cache
def gen_doc_cache_in_dir_(directory=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[directory].count(None)+len(args)

    dir_in_path=ismember_(directory,ostrsplit_(path_(),pathsep_()))
    if (not iscell_(directory)):
        directory=[directory]
    dirs_notpath=[directory[not dir_in_path]]
    if (not isempty_(dirs_notpath)):
        addpath_(dirs_notpath[:])
    func=lambda s_: create_cache_(__list_functions___(s_))
    cache=cellfun_(func,directory,char('UniformOutput'),false)
    cache=matlabarray([cache[:]])
    if (not isempty_(dirs_notpath)):
        rmpath_(dirs_notpath[:])
    return cache
def gen_builtin_cache_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    operators=__operators___()
    keywords=__keywords___()
    builtins=__builtins___()
    _list=[operators[:],keywords[:],builtins[:]]
    cache=create_cache_(_list)
    return cache
def doc_(fname=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[fname].count(None)+len(args)

    if (nargin == 0 or nargin == 1):
        ftype=0
        if (nargin == 1):
            if (ischar_(fname)):
                ftype=exist_(fname)
            else:
                error_(char('doc: expecting argument to be a character string'))
        else:
            fname=char('')
        if isguirunning_():
            __octave_link_show_doc___(fname)
        else:
            if (ftype == 2 or ftype == 3):
                ffile=which_(fname)
            else:
                ffile=char('')
            if (isempty_(ffile)):
                info_dir=octave_config_info_(char('infodir'))
            else:
                info_dir=fileparts_(ffile)
            info_file_name=fullfile_(info_dir,char('doc.info'))
            stat_info,err=stat_(info_file_name,nargout=2)
            if (err < 0):
                info_file_name=info_file_()
                if (not exist_(info_file_name,char('file')) and not exist_([info_file_name,char('.gz')],char('file'))):
                    __gripe_missing_component___(char('doc'),char('info-file'))
            cmd=sprintf_(char('"%s" --file "%s" --directory "%s"'),info_program_(),info_file_name,info_dir)
            have_fname=not isempty_(fname)
            if (have_fname):
                status=system_(sprintf_(char('%s --index-search "%s"'),cmd,fname))
            if (not (have_fname and status == 0)):
                status=system_(cmd)
                if (status == 127):
                    warning_(char("unable to find info program '%s'"),info_program_())
            if (nargout > 0):
                retval=copy_(status)
    else:
        print_usage_()
    return retval
def __gripe_missing_component___(caller=None,component=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[caller,component].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    msg=char('')
    fcn=missing_component_hook_()
    ftype=exist_(fcn)
    if (ftype == 2 or ftype == 3 or ftype == 5 or ftype == 103):
        msg=feval_(fcn,component)
    if (isempty_(msg)):
        if char('info-file') == (component):
            msg=char('unable to find the Octave info manual, Octave installation is incomplete')
        else:
            if char('mkoctfile') == (component):
                msg=char('unable to find the mkoctfile command, Octave installation is incomplete')
            else:
                if char('octave') == (component):
                    msg=char('unable to find the octave executable, Octave installation is incomplete')
                else:
                    if char('octave-config') == (component):
                        msg=char('unable to find the octave-config command, Octave installation is incomplete')
                    else:
                        msg=matlabarray([char('unable to find required Octave component "'),component,char('"')])
    error_(char('%s: %s\n'),caller,msg)
    return
def which_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin > 0 and iscellstr_(varargin)):
        m=__which___(varargin[:])
        if (nargout == 0):
            for i in arange_(1,nargin).reshape(-1):
                if (isempty_(m[i].file)):
                    if (not isempty_(m[i].type)):
                        printf_(char("'%s' is a %s\n"),m[i].name,m[i].type)
                else:
                    if (isempty_(m[i].type)):
                        printf_(char("'%s' is the file %s\n"),m[i].name,m[i].file)
                    else:
                        printf_(char("'%s' is a %s from the file %s\n"),m[i].name,m[i].type,m[i].file)
        else:
            varargout=[m.file]
    else:
        print_usage_()
    return varargout
def get_first_help_sentence_(name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[name,max_len].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (not ischar_(name)):
        error_(char('get_first_help_sentence: NAME must be a string'))
    if (not isnumeric_(max_len) or max_len <= 0 or max_len != fix_(max_len)):
        error_(char('get_first_help_sentence: MAX_LEN must be positive integer'))
    help_text,_format=get_help_text_(name,nargout=2)
    if char('plain text') == (lower_____(_format)):
        text,status=first_sentence_plain_text_(help_text,max_len,nargout=2)
    else:
        if char('texinfo') == (lower_____(_format)):
            text,status=first_sentence_texinfo_(help_text,max_len,nargout=2)
        else:
            if char('html') == (lower_____(_format)):
                text,status=first_sentence_html_(help_text,max_len,nargout=2)
            else:
                if char('not documented') == (lower_____(_format)):
                    error_(char("get_first_help_sentence: '%s' is not documented\n"),name)
                else:
                    if char('not found') == (lower_____(_format)):
                        error_(char("get_first_help_sentence: '%s' not found\n"),name)
                    else:
                        error_(char("get_first_help_sentence: internal error: unsupported help text format: '%s'\n"),_format)
    if (nargout <= 1 and status != 0):
        warning_(char("get_first_help_sentence: couldn't run makeinfo on '%s'"),name)
    return text,status
def first_sentence_plain_text_(help_text=None,max_len=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[help_text,max_len].count(None)+len(args)

    period_idx=regexp_(help_text,char('\\.\\s'),char('once'))
    line_end_idx=regexp_(help_text,char('\n\n'),char('once')) - 1
    text=help_text[1:min_([[period_idx],[line_end_idx],[max_len],[length_(help_text)]])]
    status=0
    return text,status
def first_sentence_texinfo_(help_text=None,max_len=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[help_text,max_len].count(None)+len(args)

    help_text=strrep_(help_text,char('@\n'),char(' '))
    keep=true_(size_(help_text))
    def_idx=strfind_(help_text,char('@def'))
    if (not isempty_(def_idx)):
        endl_idx=find_(help_text == char('\n'))
        for k in arange_(1,length_(def_idx)).reshape(-1):
            endl=endl_idx[find_(endl_idx > def_idx[k],1)]
            if (isempty_(endl)):
                endl=numel_(keep)
            keep[def_idx[k]:endl]=false
        def1=def_idx[1]
        space_idx=find_(help_text == char(' '))
        space_idx=space_idx[find_(space_idx > def1,1)]
        bracket_idx=find_(help_text == char('{') or help_text == char('}'))
        bracket_idx=bracket_idx[find_(bracket_idx > def1,1)]
        if (isempty_(space_idx) and isempty_(bracket_idx)):
            error_(char("get_first_help_sentence: couldn't parse texinfo"))
        sep_idx=min_(space_idx,bracket_idx)
        def_type=help_text[def1 + 1:sep_idx - 1]
        end_idx=strfind_(help_text,sprintf_(char('@end %s'),def_type))
        if (isempty_(end_idx)):
            error_(char("get_first_help_sentence: couldn't parse texinfo"))
        keep[end_idx[1]:end()]=false
        help_text=help_text[keep]
    help_text,status=__makeinfo___(help_text,char('plain text'),nargout=2)
    text=first_sentence_plain_text_(help_text,max_len)
    return text,status
def first_sentence_html_(help_text=None,max_len=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[help_text,max_len].count(None)+len(args)

    help_text,status=strip_html_tags_(help_text,nargout=2)
    text=first_sentence_plain_text_(help_text,max_len)
    return text,status
def __unimplemented___(fcn=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[fcn].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    is_matlab_function=copy_(true)
    if [char('avifile'),char('aviinfo'),char('aviread')] == (fcn):
        txt=matlabarray([char('Basic video file support is provided in the video package.  '),char('See @url{http://octave.sf.net/video/}.')])
    else:
        if char('exifread') == (fcn):
            txt=matlabarray([char('exifread is deprecated.  '),char('The functionality is available in the imfinfo function.')])
        else:
            if char('gsvd') == (fcn):
                txt=matlabarray([char('gsvd is not currently part of core Octave.  '),char('See the linear-algebra package at '),char('@url{http://octave.sourceforge.net/linear-algebra/}.')])
            else:
                if char('funm') == (fcn):
                    txt=matlabarray([char('funm is not currently part of core Octave.  '),char('See the linear-algebra package at '),char('@url{http://octave.sourceforge.net/linear-algebra/}.')])
                else:
                    if char('griddedInterpolant') == (fcn):
                        txt=matlabarray([char('griddedInterpolant is not implemented.  '),char('Consider using griddata.')])
                    else:
                        if char('integral') == (fcn):
                            txt=matlabarray([char('Octave provides many routines for 1-D numerical integration.  '),char('Consider quadcc, quad, quadv, quadl, quadgk.')])
                        else:
                            if char('integral2') == (fcn):
                                txt=matlabarray([char('integral2 is not implemented.  Consider using dblquad.')])
                            else:
                                if char('integral3') == (fcn):
                                    txt=matlabarray([char('integral3 is not implemented.  Consider using triplequad')])
                                else:
                                    if char('linprog') == (fcn):
                                        txt=matlabarray([char('Octave does not currently provide linprog.  '),char('Linear programming problems may be solved using @code{glpk}.  '),char('Try @code{help glpk} for more info.')])
                                    else:
                                        if char('matlabrc') == (fcn):
                                            txt=matlabarray([char('matlabrc is not implemented.  '),char('Octave uses the file ".octaverc" instead.')])
                                        else:
                                            if [char('ode113'),char('ode15i'),char('ode15s'),char('ode23'),char('ode23s'),char('ode23t'),char('ode23tb'),char('ode45'),char('odeget'),char('odeset')] == (fcn):
                                                txt=matlabarray([char('Octave provides lsode for solving differential equations.  '),char('For more information try @code{help lsode}.  '),char('Matlab-compatible ODE functions are provided by the odepkg '),char('package.  See @url{http://octave.sourceforge.net/odepkg/}.')])
                                            else:
                                                if char('startup') == (fcn):
                                                    txt=matlabarray([char('startup is not implemented.  '),char('Octave uses the file ".octaverc" instead.')])
                                                else:
                                                    if char('quad2d') == (fcn):
                                                        txt=matlabarray([char('quad2d is not implemented.  Consider using dblquad.')])
                                                    else:
                                                        if [char('xlsread'),char('xlsfinfo'),char('xlswrite'),char('wk1read'),char('wk1finfo'),char('wk1write')] == (fcn):
                                                            txt=matlabarray([char('Functions for spreadsheet style I/O '),char('(.xls .xlsx .sxc .ods .dbf .wk1 etc.) '),char('are provided in the io package. '),char('See @url{http://octave.sf.net/io/}.')])
                                                        else:
                                                            if [char('absorbDelay'),char('allmargin'),char('append'),char('augstate'),char('balreal'),char('balred'),char('balredOptions'),char('bandwidth'),char('bdschur'),char('bode'),char('bodemag'),char('bodeoptions'),char('bodeplot'),char('c2d'),char('c2dOptions'),char('canon'),char('care'),char('chgFreqUnit'),char('chgTimeUnit'),char('connect'),char('connectOptions'),char('covar'),char('ctrb'),char('ctrbf'),char('ctrlpref'),char('d2c'),char('d2cOptions'),char('d2d'),char('d2dOptions'),char('damp'),char('dare'),char('db2mag'),char('dcgain'),char('delay2z'),char('delayss'),char('dlqr'),char('dlyap'),char('dlyapchol'),char('drss'),char('dsort'),char('dss'),char('dssdata'),char('esort'),char('estim'),char('evalfr'),char('feedback'),char('filt'),char('frd'),char('frdata'),char('freqresp'),char('gcare'),char('gdare'),char('genfrd'),char('genmat'),char('gensig'),char('genss'),char('get'),char('getBlockValue'),char('getDelayModel'),char('getGainCrossover'),char('getIOTransfer'),char('getLFTModel'),char('getLoopTransfer'),char('getNominal'),char('getoptions'),char('getPeakGain'),char('getSwitches'),char('getValue'),char('gram'),char('hasdelay'),char('hasInternalDelay'),char('hsvd'),char('hsvdOptions'),char('hsvoptions'),char('hsvplot'),char('imp2exp'),char('impulse'),char('impulseplot'),char('initial'),char('initialplot'),char('iopzmap'),char('iopzplot'),char('isct'),char('isdt'),char('isempty'),char('isfinite'),char('isParametric'),char('isproper'),char('isreal'),char('issiso'),char('isstable'),char('isstatic'),char('kalman'),char('kalmd'),char('lft'),char('loopswitch'),char('lqg'),char('lqgreg'),char('lqgtrack'),char('lqi'),char('lqr'),char('lqrd'),char('lqry'),char('lsim'),char('lsiminfo'),char('lsimplot'),char('ltiview'),char('lyap'),char('lyapchol'),char('mag2db'),char('margin'),char('minreal'),char('modred'),char('modsep'),char('nblocks'),char('ndims'),char('ngrid'),char('nichols'),char('nicholsoptions'),char('nicholsplot'),char('nmodels'),char('norm'),char('nyquist'),char('nyquistoptions'),char('nyquistplot'),char('obsv'),char('obsvf'),char('order'),char('pade'),char('parallel'),char('permute'),char('pid'),char('piddata'),char('pidstd'),char('pidstddata'),char('pidtool'),char('pidtune'),char('pidtuneOptions'),char('place'),char('pole'),char('prescale'),char('pzmap'),char('pzoptions'),char('pzplot'),char('realp'),char('reg'),char('replaceBlock'),char('repsys'),char('reshape'),char('rlocus'),char('rlocusplot'),char('rss'),char('series'),char('set'),char('setBlockValue'),char('setDelayModel'),char('setoptions'),char('setValue'),char('sgrid'),char('showBlockValue'),char('showTunable'),char('sigma'),char('sigmaoptions'),char('sigmaplot'),char('sisoinit'),char('sisotool'),char('size'),char('sminreal'),char('ss'),char('ss2ss'),char('ssdata'),char('stabsep'),char('stabsepOptions'),char('stack'),char('step'),char('stepDataOptions'),char('stepinfo'),char('stepplot'),char('sumblk'),char('tf'),char('tfdata'),char('thiran'),char('timeoptions'),char('totaldelay'),char('tzero'),char('updateSystem'),char('upsample'),char('xperm'),char('zero'),char('zgrid'),char('zpk'),char('zpkdata')] == (fcn):
                                                                txt=check_package_(fcn,char('control'))
                                                            else:
                                                                if [char('algdeintrlv'),char('algintrlv'),char('alignsignals'),char('amdemod'),char('ammod'),char('arithdeco'),char('arithenco'),char('awgn'),char('bchdec'),char('bchenc'),char('bchgenpoly'),char('bchnumerr'),char('berawgn'),char('bercoding'),char('berconfint'),char('berfading'),char('berfit'),char('bersync'),char('bertool'),char('bi2de'),char('bin2gray'),char('biterr'),char('bsc'),char('cma'),char('commscope'),char('compand'),char('convdeintrlv'),char('convenc'),char('convintrlv'),char('convmtx'),char('cosets'),char('cyclgen'),char('cyclpoly'),char('de2bi'),char('decode'),char('deintrlv'),char('dfe'),char('dftmtx'),char('distspec'),char('doppler'),char('dpcmdeco'),char('dpcmenco'),char('dpcmopt'),char('dpskdemod'),char('dpskmod'),char('dvbs2ldpc'),char('encode'),char('equalize'),char('eyediagram'),char('EyeScope'),char('finddelay'),char('fmdemod'),char('fmmod'),char('fskdemod'),char('fskmod'),char('gaussdesign'),char('gen2par'),char('genqamdemod'),char('genqammod'),char('gf'),char('gfadd'),char('gfconv'),char('gfcosets'),char('gfdeconv'),char('gfdiv'),char('gffilter'),char('gflineq'),char('gfminpol'),char('gfmul'),char('gfpretty'),char('gfprimck'),char('gfprimdf'),char('gfprimfd'),char('gfrank'),char('gfrepcov'),char('gfroots'),char('gfsub'),char('gftable'),char('gftrunc'),char('gftuple'),char('gfweight'),char('gray2bin'),char('hammgen'),char('heldeintrlv'),char('helintrlv'),char('helscandeintrlv'),char('helscanintrlv'),char('huffmandeco'),char('huffmandict'),char('huffmanenco'),char('intdump'),char('intrlv'),char('iscatastrophic'),char('isprimitive'),char('istrellis'),char('legacychannelsim'),char('lineareq'),char('lloyds'),char('lms'),char('log'),char('lteZadoffChuSeq'),char('marcumq'),char('mask2shift'),char('matdeintrlv'),char('matintrlv'),char('minpol'),char('mldivide'),char('mlseeq'),char('modnorm'),char('muxdeintrlv'),char('muxintrlv'),char('noisebw'),char('normlms'),char('oct2dec'),char('oqpskdemod'),char('oqpskmod'),char('pamdemod'),char('pammod'),char('pmdemod'),char('pmmod'),char('poly2trellis'),char('primpoly'),char('pskdemod'),char('pskmod'),char('qamdemod'),char('qammod'),char('qfunc'),char('qfuncinv'),char('quantiz'),char('randdeintrlv'),char('randerr'),char('randintrlv'),char('randsrc'),char('rayleighchan'),char('rcosdesign'),char('rectpulse'),char('reset'),char('ricianchan'),char('rls'),char('rsdec'),char('rsenc'),char('rsgenpoly'),char('rsgenpolycoeffs'),char('scatterplot'),char('sdrexamples'),char('sdrfgensysace'),char('sdrfroot'),char('sdrinfo'),char('sdrload'),char('sdrsetup'),char('semianalytic'),char('shift2mask'),char('signlms'),char('ssbdemod'),char('ssbmod'),char('stdchan'),char('supportPackageInstaller'),char('symerr'),char('syndtable'),char('varlms'),char('vec2mat'),char('vitdec'),char('wgn')] == (fcn):
                                                                    txt=check_package_(fcn,char('communications'))
                                                                else:
                                                                    if [char('abs2active'),char('accrfrac'),char('acrubond'),char('acrudisc'),char('active2abs'),char('addEquality'),char('addEquality'),char('addEquality'),char('addGroupRatio'),char('addGroupRatio'),char('addGroupRatio'),char('addGroups'),char('addGroups'),char('addGroups'),char('addInequality'),char('addInequality'),char('addInequality'),char('adline'),char('adosc'),char('amortize'),char('annurate'),char('annuterm'),char('arith2geom'),char('ascii2fts'),char('beytbill'),char('binprice'),char('blkimpv'),char('blkprice'),char('blsdelta'),char('blsgamma'),char('blsimpv'),char('blslambda'),char('blsprice'),char('blsrho'),char('blstheta'),char('blsvega'),char('bndconvp'),char('bndconvy'),char('bnddurp'),char('bnddury'),char('bndkrdur'),char('bndprice'),char('bndspread'),char('bndtotalreturn'),char('bndyield'),char('bolling'),char('bollinger'),char('boxcox'),char('busdate'),char('busdays'),char('candle'),char('cdai'),char('cdprice'),char('cdyield'),char('cfamounts'),char('cfbyzero'),char('cfconv'),char('cfdates'),char('cfdur'),char('cfplot'),char('cfport'),char('cfprice'),char('cfspread'),char('cftimes'),char('cfyield'),char('chaikosc'),char('chaikvolat'),char('chartfts'),char('checkFeasibility'),char('checkFeasibility'),char('checkFeasibility'),char('chfield'),char('convert2sur'),char('convertto'),char('corr2cov'),char('cov2corr'),char('cpncount'),char('cpndaten'),char('cpndatenq'),char('cpndatep'),char('cpndaysp'),char('cpnpersz'),char('createholidays'),char('cumsum'),char('cur2frac'),char('cur2str'),char('date2time'),char('dateaxis'),char('datedisp'),char('datefind'),char('datemnth'),char('datewrkdy'),char('day'),char('days360'),char('days360e'),char('days360isda'),char('days360psa'),char('days365'),char('daysact'),char('daysadd'),char('daysdif'),char('dec2thirtytwo'),char('depfixdb'),char('depgendb'),char('deprdv'),char('depsoyd'),char('depstln'),char('diff'),char('disc2zero'),char('discrate'),char('ecmmvnrfish'),char('ecmmvnrmle'),char('ecmmvnrobj'),char('ecmmvnrstd'),char('ecmnfish'),char('ecmnhess'),char('ecmninit'),char('ecmnmle'),char('ecmnobj'),char('ecmnstd'),char('effrr'),char('elpm'),char('emaxdrawdown'),char('end'),char('eomdate'),char('estimateAssetMoments'),char('estimateBounds'),char('estimateBounds'),char('estimateBounds'),char('estimateFrontier'),char('estimateFrontier'),char('estimateFrontier'),char('estimateFrontierByReturn'),char('estimateFrontierByReturn'),char('estimateFrontierByReturn'),char('estimateFrontierByRisk'),char('estimateFrontierByRisk'),char('estimateFrontierByRisk'),char('estimateFrontierLimits'),char('estimateFrontierLimits'),char('estimateFrontierLimits'),char('estimateMaxSharpeRatio'),char('estimatePortMoments'),char('estimatePortReturn'),char('estimatePortReturn'),char('estimatePortReturn'),char('estimatePortRisk'),char('estimatePortRisk'),char('estimatePortRisk'),char('estimatePortStd'),char('estimatePortStd'),char('estimatePortVaR'),char('estimateScenarioMoments'),char('estimateScenarioMoments'),char('ewstats'),char('exp'),char('extfield'),char('fbusdate'),char('fetch'),char('fieldnames'),char('fillts'),char('fints'),char('floatdiscmargin'),char('floatmargin'),char('fpctkd'),char('frac2cur'),char('freqnum'),char('freqstr'),char('frontcon'),char('frontier'),char('fts2ascii'),char('fts2mat'),char('ftsbound'),char('ftsgui'),char('ftsinfo'),char('ftstool'),char('ftsuniq'),char('fvdisc'),char('fvfix'),char('fvvar'),char('fwd2zero'),char('geom2arith'),char('getAssetMoments'),char('getBounds'),char('getBounds'),char('getBounds'),char('getBudget'),char('getBudget'),char('getBudget'),char('getCosts'),char('getCosts'),char('getCosts'),char('getEquality'),char('getEquality'),char('getEquality'),char('getGroupRatio'),char('getGroupRatio'),char('getGroupRatio'),char('getGroups'),char('getGroups'),char('getGroups'),char('getInequality'),char('getInequality'),char('getInequality'),char('getnameidx'),char('getOneWayTurnover'),char('getOneWayTurnover'),char('getOneWayTurnover'),char('getScenarios'),char('getScenarios'),char('hhigh'),char('highlow'),char('holdings2weights'),char('holidays'),char('horzcat'),char('hour'),char('inforatio'),char('irr'),char('isbusday'),char('iscompatible'),char('isempty'),char('isfield'),char('issorted'),char('kagi'),char('lagts'),char('lbusdate'),char('leadts'),char('length'),char('linebreak'),char('llow'),char('log'),char('log10'),char('log2'),char('lpm'),char('lweekdate'),char('m2xdate'),char('macd'),char('maxdrawdown'),char('medprice'),char('merge'),char('minus'),char('minute'),char('mirr'),char('month'),char('months'),char('movavg'),char('mrdivide'),char('mtimes'),char('mvnrfish'),char('mvnrmle'),char('mvnrobj'),char('mvnrstd'),char('nancov'),char('nanmax'),char('nanmean'),char('nanmedian'),char('nanmin'),char('nanstd'),char('nansum'),char('nanvar'),char('negvolidx'),char('nomrr'),char('nweekdate'),char('nyseclosures'),char('onbalvol'),char('opprofit'),char('payadv'),char('payodd'),char('payper'),char('payuni'),char('pcalims'),char('pcgcomp'),char('pcglims'),char('pcpval'),char('peravg'),char('periodicreturns'),char('plotFrontier'),char('plotFrontier'),char('plotFrontier'),char('plus'),char('pointfig'),char('portalloc'),char('portalpha'),char('portcons'),char('Portfolio'),char('PortfolioCVaR'),char('PortfolioMAD'),char('portopt'),char('portrand'),char('portror'),char('portsim'),char('portstats'),char('portvar'),char('portvrisk'),char('posvolidx'),char('power'),char('prbyzero'),char('prcroc'),char('prdisc'),char('priceandvol'),char('prmat'),char('prtbill'),char('pvfix'),char('pvtrend'),char('pvvar'),char('pyld2zero'),char('rdivide'),char('renko'),char('resamplets'),char('ret2tick'),char('rmfield'),char('rsindex'),char('selectreturn'),char('setAssetList'),char('setAssetList'),char('setAssetList'),char('setAssetMoments'),char('setBounds'),char('setBounds'),char('setBounds'),char('setBudget'),char('setBudget'),char('setBudget'),char('setCosts'),char('setCosts'),char('setCosts'),char('setDefaultConstraints'),char('setDefaultConstraints'),char('setDefaultConstraints'),char('setEquality'),char('setEquality'),char('setEquality'),char('setGroupRatio'),char('setGroupRatio'),char('setGroupRatio'),char('setGroups'),char('setGroups'),char('setGroups'),char('setInequality'),char('setInequality'),char('setInequality'),char('setInitPort'),char('setInitPort'),char('setInitPort'),char('setOneWayTurnover'),char('setOneWayTurnover'),char('setOneWayTurnover'),char('setProbabilityLevel'),char('setScenarios'),char('setScenarios'),char('setSolver'),char('setSolver'),char('setSolver'),char('setTurnover'),char('setTurnover'),char('setTurnover'),char('sharpe'),char('simulateNormalScenariosByData'),char('simulateNormalScenariosByData'),char('simulateNormalScenariosByMoments'),char('simulateNormalScenariosByMoments'),char('size'),char('smoothts'),char('sortfts'),char('spctkd'),char('stochosc'),char('subsasgn'),char('subsref'),char('targetreturn'),char('taxedrr'),char('tbilldisc2yield'),char('tbillprice'),char('tbillrepo'),char('tbillval01'),char('tbillyield'),char('tbillyield2disc'),char('tbl2bond'),char('thirdwednesday'),char('thirtytwo2dec'),char('tick2ret'),char('time2date'),char('times'),char('toannual'),char('todaily'),char('today'),char('todecimal'),char('tomonthly'),char('toquarterly'),char('toquoted'),char('tosemi'),char('totalreturnprice'),char('toweekly'),char('tr2bonds'),char('transprob'),char('transprobbytotals'),char('transprobfromthresholds'),char('transprobgrouptotals'),char('transprobprep'),char('transprobtothresholds'),char('tsaccel'),char('tsmom'),char('tsmovavg'),char('typprice'),char('ugarch'),char('ugarchllf'),char('ugarchpred'),char('ugarchsim'),char('uicalendar'),char('uminus'),char('uplus'),char('vertcat'),char('volarea'),char('volroc'),char('wclose'),char('weeknum'),char('weights2holdings'),char('willad'),char('willpctr'),char('wrkdydif'),char('x2mdate'),char('xirr'),char('year'),char('yeardays'),char('yearfrac'),char('ylddisc'),char('yldmat'),char('yldtbill'),char('zbtprice'),char('zbtyield'),char('zero2disc'),char('zero2fwd'),char('zero2pyld')] == (fcn):
                                                                        txt=check_package_(fcn,char('financial'))
                                                                    else:
                                                                        if [char('activecontour'),char('adapthisteq'),char('affine2d'),char('affine3d'),char('analyze75info'),char('analyze75read'),char('applycform'),char('applylut'),char('axes2pix'),char('bestblk'),char('blockproc'),char('bwarea'),char('bwareaopen'),char('bwboundaries'),char('bwconncomp'),char('bwconvhull'),char('bwdist'),char('bwdistgeodesic'),char('bweuler'),char('bwhitmiss'),char('bwlabel'),char('bwlabeln'),char('bwlookup'),char('bwmorph'),char('bwpack'),char('bwperim'),char('bwselect'),char('bwtraceboundary'),char('bwulterode'),char('bwunpack'),char('checkerboard'),char('col2im'),char('colfilt'),char('conndef'),char('convmtx2'),char('corner'),char('cornermetric'),char('corr2'),char('cp2tform'),char('cpcorr'),char('cpselect'),char('cpstruct2pairs'),char('dct2'),char('dctmtx'),char('deconvblind'),char('deconvlucy'),char('deconvreg'),char('deconvwnr'),char('decorrstretch'),char('demosaic'),char('dicomanon'),char('dicomdict'),char('dicominfo'),char('dicomlookup'),char('dicomread'),char('dicomuid'),char('dicomwrite'),char('edge'),char('edgetaper'),char('entropy'),char('entropyfilt'),char('fan2para'),char('fanbeam'),char('findbounds'),char('fitgeotrans'),char('fliptform'),char('freqz2'),char('fsamp2'),char('fspecial'),char('ftrans2'),char('fwind1'),char('fwind2'),char('getheight'),char('getimage'),char('getimagemodel'),char('getline'),char('getneighbors'),char('getnhood'),char('getpts'),char('getrect'),char('getsequence'),char('graycomatrix'),char('graycoprops'),char('graydist'),char('grayslice'),char('graythresh'),char('hdrread'),char('hdrwrite'),char('histeq'),char('hough'),char('houghlines'),char('houghpeaks'),char('iccfind'),char('iccread'),char('iccroot'),char('iccwrite'),char('idct2'),char('ifanbeam'),char('im2bw'),char('im2col'),char('im2double'),char('im2int16'),char('im2java2d'),char('im2single'),char('im2uint16'),char('im2uint8'),char('imabsdiff'),char('imadd'),char('imadjust'),char('ImageAdapter'),char('imageinfo'),char('imapplymatrix'),char('imapprox'),char('imattributes'),char('imbothat'),char('imclearborder'),char('imclose'),char('imcolormaptool'),char('imcomplement'),char('imcontour'),char('imcontrast'),char('imcrop'),char('imdilate'),char('imdisplayrange'),char('imdistline'),char('imdivide'),char('imellipse'),char('imerode'),char('imextendedmax'),char('imextendedmin'),char('imfill'),char('imfilter'),char('imfindcircles'),char('imfreehand'),char('imfuse'),char('imgca'),char('imgcf'),char('imgetfile'),char('imgradient'),char('imgradientxy'),char('imhandles'),char('imhist'),char('imhistmatch'),char('imhmax'),char('imhmin'),char('imimposemin'),char('imlincomb'),char('imline'),char('immagbox'),char('immovie'),char('immultiply'),char('imnoise'),char('imopen'),char('imoverview'),char('imoverviewpanel'),char('impixel'),char('impixelinfo'),char('impixelinfoval'),char('impixelregion'),char('impixelregionpanel'),char('implay'),char('impoint'),char('impoly'),char('improfile'),char('impyramid'),char('imquantize'),char('imreconstruct'),char('imrect'),char('imref2d'),char('imref3d'),char('imregconfig'),char('imregionalmax'),char('imregionalmin'),char('imregister'),char('imregtform'),char('imresize'),char('imroi'),char('imrotate'),char('imsave'),char('imscrollpanel'),char('imsharpen'),char('imshowpair'),char('imsubtract'),char('imtool'),char('imtophat'),char('imtransform'),char('imwarp'),char('interfileinfo'),char('interfileread'),char('intlut'),char('iptaddcallback'),char('iptcheckconn'),char('iptcheckhandle'),char('iptgetapi'),char('iptGetPointerBehavior'),char('iptgetpref'),char('ipticondir'),char('iptPointerManager'),char('iptprefs'),char('iptremovecallback'),char('iptSetPointerBehavior'),char('iptsetpref'),char('iptwindowalign'),char('iradon'),char('isflat'),char('isicc'),char('isrset'),char('lab2double'),char('lab2uint16'),char('lab2uint8'),char('label2rgb'),char('labelmatrix'),char('makecform'),char('makeConstrainToRectFcn'),char('makehdr'),char('makelut'),char('makeresampler'),char('maketform'),char('mat2gray'),char('mean2'),char('medfilt2'),char('montage'),char('multithresh'),char('nitfinfo'),char('nitfread'),char('nlfilter'),char('normxcorr2'),char('openrset'),char('ordfilt2'),char('otf2psf'),char('padarray'),char('para2fan'),char('phantom'),char('poly2mask'),char('projective2d'),char('psf2otf'),char('qtdecomp'),char('qtgetblk'),char('qtsetblk'),char('radon'),char('rangefilt'),char('reflect'),char('regionprops'),char('rgb2gray'),char('rgb2ycbcr'),char('roicolor'),char('roifill'),char('roifilt2'),char('roipoly'),char('rsetwrite'),char('std2'),char('stdfilt'),char('strel'),char('stretchlim'),char('subimage'),char('tformarray'),char('tformfwd'),char('tforminv'),char('tonemap'),char('translate'),char('truesize'),char('viscircles'),char('warp'),char('watershed'),char('whitepoint'),char('wiener2'),char('xyz2double'),char('xyz2uint16'),char('ycbcr2rgb')] == (fcn):
                                                                            txt=check_package_(fcn,char('image'))
                                                                        else:
                                                                            if [char('ac2poly'),char('ac2rc'),char('angle'),char('arburg'),char('arcov'),char('armcov'),char('aryule'),char('bandpower'),char('barthannwin'),char('besselap'),char('besself'),char('bilinear'),char('bitrevorder'),char('blackmanharris'),char('bohmanwin'),char('buffer'),char('buttap'),char('butter'),char('buttord'),char('cceps'),char('cconv'),char('cell2sos'),char('cfirpm'),char('cheb1ap'),char('cheb1ord'),char('cheb2ap'),char('cheb2ord'),char('chebwin'),char('cheby1'),char('cheby2'),char('chirp'),char('convmtx'),char('corrmtx'),char('cpsd'),char('czt'),char('db'),char('db2mag'),char('db2pow'),char('dct'),char('decimate'),char('demod'),char('design'),char('designmethods'),char('designopts'),char('dfilt'),char('dftmtx'),char('digitrevorder'),char('diric'),char('downsample'),char('dpss'),char('dpssclear'),char('dpssdir'),char('dpssload'),char('dspdata'),char('dspfwiz'),char('dutycycle'),char('ellip'),char('ellipap'),char('ellipord'),char('enbw'),char('equiripple'),char('falltime'),char('fdatool'),char('fdesign'),char('filt2block'),char('filterbuilder'),char('filternorm'),char('filtfilt'),char('filtic'),char('filtord'),char('findpeaks'),char('fir1'),char('fir2'),char('fircls'),char('fircls1'),char('firls'),char('firpm'),char('firpmord'),char('firrcos'),char('firtype'),char('flattopwin'),char('freqs'),char('freqsamp'),char('fvtool'),char('fwht'),char('gauspuls'),char('gaussdesign'),char('gaussfir'),char('gausswin'),char('gmonopuls'),char('goertzel'),char('grpdelay'),char('hann'),char('hilbert'),char('icceps'),char('idct'),char('ifwht'),char('impinvar'),char('impz'),char('impzlength'),char('interp'),char('intfilt'),char('invfreqs'),char('invfreqz'),char('is2rc'),char('isallpass'),char('islinphase'),char('ismaxphase'),char('isminphase'),char('isstable'),char('kaiser'),char('kaiserord'),char('kaiserwin'),char('lar2rc'),char('latc2tf'),char('latcfilt'),char('levinson'),char('lp2bp'),char('lp2bs'),char('lp2hp'),char('lp2lp'),char('lpc'),char('lsf2poly'),char('mag2db'),char('marcumq'),char('maxflat'),char('medfilt1'),char('midcross'),char('modulate'),char('mscohere'),char('nuttallwin'),char('overshoot'),char('parzenwin'),char('pburg'),char('pcov'),char('peak2peak'),char('peak2rms'),char('peig'),char('phasedelay'),char('phasez'),char('pmcov'),char('pmtm'),char('pmusic'),char('poly2ac'),char('poly2lsf'),char('poly2rc'),char('polyscale'),char('polystab'),char('pow2db'),char('prony'),char('pulseperiod'),char('pulsesep'),char('pulsewidth'),char('pulstran'),char('pwelch'),char('pyulear'),char('rc2ac'),char('rc2is'),char('rc2lar'),char('rc2poly'),char('rceps'),char('rcosdesign'),char('realizemdl'),char('rectpuls'),char('rectwin'),char('resample'),char('residuez'),char('risetime'),char('rlevinson'),char('rms'),char('rooteig'),char('rootmusic'),char('rssq'),char('sawtooth'),char('schurrc'),char('seqperiod'),char('setspecs'),char('settlingtime'),char('sfdr'),char('sgolay'),char('sgolayfilt'),char('shiftdata'),char('sigwin'),char('sinad'),char('slewrate'),char('snr'),char('sos2cell'),char('sos2ss'),char('sos2tf'),char('sos2zp'),char('sosfilt'),char('spectrogram'),char('spectrum'),char('sptool'),char('square'),char('ss2sos'),char('ss2tf'),char('ss2zp'),char('statelevels'),char('stepz'),char('stmcb'),char('strips'),char('taylorwin'),char('tf2latc'),char('tf2sos'),char('tf2ss'),char('tf2zp'),char('tf2zpk'),char('tfestimate'),char('thd'),char('toi'),char('triang'),char('tripuls'),char('tukeywin'),char('udecode'),char('uencode'),char('undershoot'),char('unshiftdata'),char('upfirdn'),char('upsample'),char('validstructures'),char('vco'),char('window'),char('wintool'),char('wvtool'),char('xcorr'),char('xcorr2'),char('xcov'),char('yulewalk'),char('zerophase'),char('zp2sos'),char('zp2ss'),char('zp2tf'),char('zplane')] == (fcn):
                                                                                txt=check_package_(fcn,char('signal'))
                                                                            else:
                                                                                if [char('addedvarplot'),char('addlevels'),char('addTerms'),char('addTerms'),char('adtest'),char('andrewsplot'),char('anova1'),char('anova2'),char('anovan'),char('ansaribradley'),char('aoctool'),char('barttest'),char('bbdesign'),char('betafit'),char('betalike'),char('betastat'),char('binofit'),char('binostat'),char('biplot'),char('bootci'),char('bootstrp'),char('boxplot'),char('candexch'),char('candgen'),char('canoncorr'),char('capability'),char('capaplot'),char('caseread'),char('casewrite'),char('ccdesign'),char('cdf'),char('cdf'),char('cdfplot'),char('cell2dataset'),char('chi2gof'),char('chi2stat'),char('cholcov'),char('ClassificationBaggedEnsemble'),char('ClassificationDiscriminant'),char('ClassificationEnsemble'),char('ClassificationKNN'),char('ClassificationPartitionedEnsemble'),char('ClassificationPartitionedModel'),char('ClassificationTree'),char('classify'),char('classregtree'),char('cluster'),char('clusterdata'),char('cmdscale'),char('coefCI'),char('coefCI'),char('coefCI'),char('coefCI'),char('coefTest'),char('coefTest'),char('coefTest'),char('coefTest'),char('combnk'),char('compact'),char('CompactClassificationDiscriminant'),char('CompactClassificationEnsemble'),char('CompactClassificationTree'),char('CompactRegressionEnsemble'),char('CompactRegressionTree'),char('CompactTreeBagger'),char('compare'),char('confusionmat'),char('controlchart'),char('controlrules'),char('cophenet'),char('copulacdf'),char('copulafit'),char('copulaparam'),char('copulapdf'),char('copularnd'),char('copulastat'),char('cordexch'),char('corrcov'),char('covarianceParameters'),char('coxphfit'),char('createns'),char('crosstab'),char('crossval'),char('cvpartition'),char('datasample'),char('dataset'),char('dataset2cell'),char('dataset2struct'),char('dataset2table'),char('datasetfun'),char('daugment'),char('dcovary'),char('dendrogram'),char('designMatrix'),char('devianceTest'),char('dfittool'),char('disp'),char('disp'),char('disp'),char('disp'),char('disttool'),char('droplevels'),char('dummyvar'),char('dwtest'),char('dwtest'),char('ecdf'),char('ecdfhist'),char('evalclusters'),char('evcdf'),char('evfit'),char('evinv'),char('evlike'),char('evpdf'),char('evrnd'),char('evstat'),char('ExhaustiveSearcher'),char('expfit'),char('explike'),char('export'),char('expstat'),char('factoran'),char('feval'),char('feval'),char('feval'),char('ff2n'),char('fitdist'),char('fitensemble'),char('fitglm'),char('fitlm'),char('fitlme'),char('fitlmematrix'),char('fitnlm'),char('fitted'),char('fixedEffects'),char('fracfact'),char('fracfactgen'),char('friedman'),char('fsurfht'),char('fullfact'),char('gagerr'),char('gamfit'),char('gamlike'),char('gamstat'),char('GeneralizedLinearModel'),char('geomean'),char('geostat'),char('getlabels'),char('getlevels'),char('gevcdf'),char('gevfit'),char('gevinv'),char('gevlike'),char('gevpdf'),char('gevrnd'),char('gevstat'),char('gline'),char('glmfit'),char('glmval'),char('glyphplot'),char('gmdistribution'),char('gname'),char('gpcdf'),char('gpfit'),char('gpinv'),char('gplike'),char('gplotmatrix'),char('gppdf'),char('gprnd'),char('gpstat'),char('grp2idx'),char('grpstats'),char('gscatter'),char('haltonset'),char('harmmean'),char('hist3'),char('histfit'),char('hmmdecode'),char('hmmestimate'),char('hmmgenerate'),char('hmmtrain'),char('hmmviterbi'),char('hougen'),char('hygestat'),char('icdf'),char('icdf'),char('inconsistent'),char('interactionplot'),char('invpred'),char('islevel'),char('ismissing'),char('isundefined'),char('iwishrnd'),char('jackknife'),char('jbtest'),char('johnsrnd'),char('join'),char('KDTreeSearcher'),char('kmeans'),char('knnsearch'),char('kruskalwallis'),char('ksdensity'),char('kstest'),char('kstest2'),char('labels'),char('lasso'),char('lassoglm'),char('lassoPlot'),char('levelcounts'),char('leverage'),char('lhsdesign'),char('lhsnorm'),char('lillietest'),char('LinearMixedModel'),char('LinearModel'),char('linhyptest'),char('linkage'),char('lognfit'),char('lognlike'),char('lognstat'),char('lsline'),char('mad'),char('mahal'),char('maineffectsplot'),char('makedist'),char('manova1'),char('manovacluster'),char('mat2dataset'),char('mdscale'),char('mergelevels'),char('mhsample'),char('mle'),char('mlecov'),char('mnpdf'),char('mnrfit'),char('mnrnd'),char('mnrval'),char('multcompare'),char('multivarichart'),char('mvncdf'),char('mvnpdf'),char('mvnrnd'),char('mvregress'),char('mvregresslike'),char('mvtcdf'),char('mvtpdf'),char('mvtrnd'),char('NaiveBayes'),char('nancov'),char('nanmax'),char('nanmean'),char('nanmedian'),char('nanmin'),char('nanstd'),char('nansum'),char('nanvar'),char('nbinfit'),char('nbinstat'),char('ncfcdf'),char('ncfinv'),char('ncfpdf'),char('ncfrnd'),char('ncfstat'),char('nctcdf'),char('nctinv'),char('nctpdf'),char('nctrnd'),char('nctstat'),char('ncx2cdf'),char('ncx2inv'),char('ncx2pdf'),char('ncx2rnd'),char('ncx2stat'),char('negloglik'),char('negloglik'),char('nlinfit'),char('nlintool'),char('nlmefit'),char('nlmefitsa'),char('nlparci'),char('nlpredci'),char('nnmf'),char('nominal'),char('NonLinearModel'),char('normfit'),char('normlike'),char('normplot'),char('normspec'),char('normstat'),char('optimalleaforder'),char('ordinal'),char('parallelcoords'),char('paramci'),char('paretotails'),char('partialcorr'),char('partialcorri'),char('pca'),char('pcacov'),char('pcares'),char('pdf'),char('pdf'),char('pdist'),char('pdist2'),char('pearsrnd'),char('perfcurve'),char('plotAdded'),char('plotAdjustedResponse'),char('plotDiagnostics'),char('plotDiagnostics'),char('plotDiagnostics'),char('plotEffects'),char('plotInteraction'),char('plotResiduals'),char('plotResiduals'),char('plotResiduals'),char('plotResiduals'),char('plotSlice'),char('plotSlice'),char('plotSlice'),char('plsregress'),char('poissfit'),char('poisstat'),char('polyconf'),char('polytool'),char('ppca'),char('predict'),char('predict'),char('predict'),char('predict'),char('predict'),char('predict'),char('predict'),char('predict'),char('princomp'),char('ProbDistUnivKernel'),char('ProbDistUnivParam'),char('probplot'),char('procrustes'),char('proflik'),char('qrandset'),char('qrandstream'),char('random'),char('random'),char('random'),char('random'),char('random'),char('random'),char('randomEffects'),char('randsample'),char('randtool'),char('rangesearch'),char('ranksum'),char('raylcdf'),char('raylfit'),char('raylinv'),char('raylpdf'),char('raylrnd'),char('raylstat'),char('rcoplot'),char('refcurve'),char('refline'),char('regress'),char('RegressionBaggedEnsemble'),char('RegressionEnsemble'),char('RegressionPartitionedEnsemble'),char('RegressionPartitionedModel'),char('RegressionTree'),char('regstats'),char('relieff'),char('removeTerms'),char('removeTerms'),char('residuals'),char('response'),char('ridge'),char('robustdemo'),char('robustfit'),char('rotatefactors'),char('rowexch'),char('rsmdemo'),char('rstool'),char('runstest'),char('sampsizepwr'),char('scatterhist'),char('sequentialfs'),char('setlabels'),char('signrank'),char('signtest'),char('silhouette'),char('slicesample'),char('sobolset'),char('squareform'),char('statget'),char('statset'),char('step'),char('step'),char('stepwise'),char('stepwisefit'),char('stepwiseglm'),char('stepwiselm'),char('struct2dataset'),char('surfht'),char('svmclassify'),char('svmtrain'),char('table2dataset'),char('tabulate'),char('tblread'),char('tblwrite'),char('tdfread'),char('tiedrank'),char('TreeBagger'),char('trimmean'),char('truncate'),char('tstat'),char('ttest'),char('ttest2'),char('unidstat'),char('unifit'),char('unifstat'),char('vartest'),char('vartest2'),char('vartestn'),char('wblfit'),char('wbllike'),char('wblplot'),char('wblstat'),char('wishrnd'),char('x2fx'),char('xlsread'),char('xptread'),char('ztest')] == (fcn):
                                                                                    txt=check_package_(fcn,char('statistics'))
                                                                                else:
                                                                                    if [char('bintprog'),char('color'),char('fgoalattain'),char('fmincon'),char('fminimax'),char('fminsearch'),char('fseminf'),char('fzmult'),char('gangstr'),char('ktrlink'),char('linprog'),char('lsqcurvefit'),char('lsqlin'),char('lsqnonlin'),char('optimoptions'),char('optimtool'),char('quadprog')] == (fcn):
                                                                                        txt=check_package_(fcn,char('optim'))
                                                                                    else:
                                                                                        if (ismember_(fcn,missing_functions_())):
                                                                                            txt=matlabarray([char("the '"),fcn,char("' function is not yet implemented in Octave")])
                                                                                        else:
                                                                                            is_matlab_function=copy_(false)
                                                                                            txt=char('')
    if (is_matlab_function):
        txt=matlabarray([txt,char('\n\n@noindent\nPlease read '),char('@url{http://www.octave.org/missing.html} to learn how '),char('you can contribute missing functionality.')])
        txt=__makeinfo___(txt)
    if (nargout == 0):
        warning_(char('Octave:missing-function'),char('%s'),txt)
    return txt
def check_package_(fcn=None,name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[fcn,name].count(None)+len(args)

    txt=sprintf_(char("the '%s' function belongs to the %s package from Octave Forge"),fcn,name)
    __,status=pkg_(char('describe'),name,nargout=2)
    if char('loaded') == (tolower__(status[1])):
        txt=sprintf_(char('%s but has not yet been implemented.'),txt)
    else:
        if char('not loaded') == (tolower__(status[1])):
            txt=sprintf_([char('%s which you have installed but not loaded. To '),char("load the package, run `pkg load %s' from the "),char('Octave prompt.')],txt,name)
        else:
            txt=sprintf_(char('%s which seems to not be installed in your system.'),txt)
    return txt
def missing_functions_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    _list=[char('MException'),char('RandStream'),char('Tiff'),char('VideoReader'),char('VideoWriter'),char('align'),char('alim'),char('alpha'),char('alphamap'),char('annotation'),char('audiodevinfo'),char('audioinfo'),char('audioplayer'),char('audioread'),char('audiorecorder'),char('audiowrite'),char('bar3'),char('bar3h'),char('bench'),char('bicgstabl'),char('brush'),char('builddocsearchdb'),char('bvp4c'),char('bvp5c'),char('bvpget'),char('bvpinit'),char('bvpset'),char('bvpxtend'),char('callSoapService'),char('calllib'),char('camdolly'),char('cameratoolbar'),char('camlight'),char('camlookat'),char('camorbit'),char('campan'),char('campos'),char('camproj'),char('camroll'),char('camtarget'),char('camup'),char('camva'),char('camzoom'),char('cdf2rdf'),char('cdfepoch'),char('cdfinfo'),char('cdfread'),char('cdfwrite'),char('cellplot'),char('checkin'),char('checkcode'),char('checkout'),char('cholinc'),char('clearvars'),char('clipboard'),char('cmopts'),char('colordef'),char('colormapeditor'),char('commandhistory'),char('commandwindow'),char('condeig'),char('coneplot'),char('containers.Map'),char('contourslice'),char('createClassFromWsdl'),char('createSoapMessage'),char('customverctrl'),char('datacursormode'),char('dbmex'),char('dde23'),char('ddeget'),char('ddensd'),char('ddesd'),char('ddeset'),char('decic'),char('delaunayTriangulation'),char('depdir'),char('depfun'),char('deval'),char('dialog'),char('dither'),char('docsearch'),char('dragrect'),char('dynamicprops'),char('echodemo'),char('evalc'),char('export2wsdlg'),char('figurepalette'),char('filebrowser'),char('fill3'),char('fitsdisp'),char('fitsinfo'),char('fitsread'),char('fitswrite'),char('flow'),char('frame2im'),char('freqspace'),char('funm'),char('gammaincinv'),char('getframe'),char('getpixelposition'),char('gobjects'),char('grabcode'),char('graymon'),char('griddedInterpolant'),char('gsvd'),char('guidata'),char('guide'),char('guihandles'),char('handle'),char('h5create'),char('h5disp'),char('h5info'),char('h5read'),char('h5readatt'),char('h5write'),char('h5writeatt'),char('hdfinfo'),char('hdfread'),char('hgexport'),char('hgload'),char('hgsave'),char('hgsetget'),char('hgtransform'),char('ichol'),char('ilu'),char('im2frame'),char('im2java'),char('imapprox'),char('import'),char('inmem'),char('inputParser'),char('inspect'),char('instrcallback'),char('instrfind'),char('instrfindall'),char('integral'),char('integral2'),char('integral3'),char('interpstreamspeed'),char('iscom'),char('isinterface'),char('isjava'),char('isocaps'),char('isstudent'),char('javachk'),char('ldl'),char('libfunctions'),char('libfunctionsview'),char('libisloaded'),char('libpointer'),char('libstruct'),char('light'),char('lightangle'),char('lighting'),char('linkaxes'),char('linkdata'),char('listfonts'),char('loadlibrary'),char('lscov'),char('lsqr'),char('makehgtform'),char('material'),char('matfile'),char('matlabrc'),char('memmapfile'),char('memory'),char('metaclass'),char('methodsview'),char('minres'),char('mlintrpt'),char('mmfileinfo'),char('movegui'),char('movie'),char('movie2avi'),char('multibandread'),char('multibandwrite'),char('native2unicode'),char('nccreate'),char('ncdisp'),char('ncinfo'),char('ncread'),char('ncreadatt'),char('ncwrite'),char('ncwriteatt'),char('ncwriteschema'),char('noanimate'),char('notebook'),char('ode113'),char('ode15i'),char('ode15s'),char('ode23'),char('ode23s'),char('ode23t'),char('ode23tb'),char('ode45'),char('odeget'),char('odeset'),char('odextend'),char('open'),char('openfig'),char('opengl'),char('openvar'),char('ordeig'),char('ordqz'),char('ordschur'),char('padecoef'),char('pan'),char('parseSoapResponse'),char('pathtool'),char('pcode'),char('pdepe'),char('pdeval'),char('plotbrowser'),char('plotedit'),char('plottools'),char('printdlg'),char('printopt'),char('printpreview'),char('profsave'),char('propedit'),char('propertyeditor'),char('psi'),char('publish'),char('qmr'),char('quad2d'),char('rbbox'),char('reducepatch'),char('reducevolume'),char('readasync'),char('rng'),char('rotate'),char('rotate3d'),char('scatteredInterpolant'),char('selectmoveresize'),char('sendmail'),char('serial'),char('serialbreak'),char('setpixelposition'),char('showplottool'),char('smooth3'),char('snapnow'),char('sound'),char('soundsc'),char('ss2tf'),char('startup'),char('stopasync'),char('stream2'),char('stream3'),char('streamline'),char('streamparticles'),char('streamribbon'),char('streamslice'),char('streamtube'),char('strings'),char('subvolume'),char('superclasses'),char('surf2patch'),char('symmlq'),char('syntax'),char('texlabel'),char('textwrap'),char('tfqmr'),char('timer'),char('timeseries'),char('todatenum'),char('toolboxdir'),char('triangulation'),char('tscollection'),char('tstool'),char('uibuttongroup'),char('uicontextmenu'),char('uicontrol'),char('uigetpref'),char('uiimport'),char('uiopen'),char('uipanel'),char('uipushtool'),char('uiresume'),char('uisave'),char('uisetcolor'),char('uisetfont'),char('uisetpref'),char('uistack'),char('uitable'),char('uitoggletool'),char('uitoolbar'),char('uiwait'),char('undocheckout'),char('unicode2native'),char('unloadlibrary'),char('unmesh'),char('userpath'),char('validateattributes'),char('verctrl'),char('verLessThan'),char('viewmtx'),char('visdiff'),char('volumebounds'),char('web'),char('whatsnew'),char('winopen'),char('winqueryreg'),char('workspace'),char('xmlread'),char('xmlwrite'),char('xslt'),char('zoom')]
    return _list
def logm_(A=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,opt_iters].count(None)+len(args)

    if (nargin == 0 or nargin > 2):
        print_usage_()
    if (not issquare_(A)):
        error_(char('logm: A must be a square matrix'))
    if (isscalar_(A)):
        s=log_(A)
        return s,iters
    else:
        if (strfind_(typeinfo_(A),char('diagonal matrix'))):
            s=diag_(log_(diag_(A)))
            return s,iters
    u,s=schur_(A,nargout=2)
    if (isreal_(A)):
        u,s=rsf2csf_(u,s,nargout=2)
    eigv=diag_(s)
    if (any_(eigv < 0)):
        warning_(char('Octave:logm:non-principal'),char('logm: principal matrix logarithm is not defined for matrices with negative eigenvalues; computing non-principal logarithm'))
    real_eig=all_(eigv >= 0)
    k=0
    theta=matlabarray([0,0,0.0161,0.0538,0.113,0.186,0.264296083111])
    p=0
    m=7
    while (k < opt_iters):

        tau=norm_(s - eye_(size_(s)),1)
        if (tau <= theta[7]):
            p=p + 1
            j[1]=find_(tau <= theta,1)
            j[2]=find_(tau / 2 <= theta,1)
            if (j[1] - j[2] <= 1 or p == 2):
                m=j[1]
                break
        k=k + 1
        s=sqrtm_(s)

    if (k >= opt_iters):
        warning_(char('logm: maximum number of square roots exceeded; results may still be accurate'))
    s=s - eye_(size_(s))
    if (m > 1):
        s=logm_pade_pf_(s,m)
    s=2 ** k * u * s * u.T
    if (real_eig and isreal_(A)):
        s=real_(s)
    if (nargout == 2):
        iters=copy_(k)
    return s,iters
def logm_pade_pf_(A=None,m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,m].count(None)+len(args)

    nodes,wts=gauss_legendre_(m,nargout=2)
    nodes=(nodes + 1) / 2
    wts=wts / 2
    n=length_(A)
    s=zeros_(n)
    for j in arange_(1,m).reshape(-1):
        s += wts[j] * (A / (eye_(n) + nodes[j] * A))
    return s
def gauss_legendre_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    i=arange_(1,n - 1)
    v=i / sqrt_((2 * i) ** 2 - 1)
    V,D=eig_(diag_(v,- 1) + diag_(v,1),nargout=2)
    x=diag_(D)
    w=2 * (V[1,:].T ** 2)
    return x,w
def null_(A=None,tol=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,tol].count(None)+len(args)

    if (isempty_(A)):
        retval=matlabarray([])
    else:
        U,S,V=svd_(A,nargout=3)
        rows,cols=size_(A,nargout=2)
        S_nr,S_nc=size_(S,nargout=2)
        if (S_nr == 1 or S_nc == 1):
            s=S[1]
        else:
            s=diag_(S)
        if (nargin == 1):
            if (isa_(A,char('single'))):
                tol=max_(size_(A)) * s[1] * eps_(char('single'))
            else:
                tol=max_(size_(A)) * s[1] * eps
        else:
            if (nargin != 2):
                print_usage_()
        rank=sum_(s > tol)
        if (rank < cols):
            retval=V[:,rank + 1:cols]
            if (isa_(A,char('single'))):
                retval[abs_(retval) < eps_(char('single'))]=0
            else:
                retval[abs_(retval) < eps]=0
        else:
            retval=zeros_(cols,0)
    return retval
def subspace_(A=None,B=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,B].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    else:
        if (ndims_(A) != 2 or ndims_(B) != 2):
            error_(char('subspace: expecting A and B to be 2-dimensional arrays'))
        else:
            if (rows_(A) != rows_(B)):
                error_(char('subspace: column dimensions of A and B must match'))
    A=orth_(A)
    B=orth_(B)
    c=A.T * B
    scos=min_(svd_(c))
    if (scos ** 2 > 1 / 2):
        if (columns_(A) >= columns_(B)):
            c=B - A * c
        else:
            c=A - B * c.T
        ssin=max_(svd_(c))
        ang=asin_(min_(ssin,1))
    else:
        ang=acos_(scos)
    return ang
def rank_(A=None,tol=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,tol].count(None)+len(args)

    if (nargin == 1):
        sigma=svd_(A)
        if (isempty_(sigma)):
            tolerance=0
        else:
            if (isa_(A,char('single'))):
                tolerance=max_(size_(A)) * sigma[1] * eps_(char('single'))
            else:
                tolerance=max_(size_(A)) * sigma[1] * eps
    else:
        if (nargin == 2):
            sigma=svd_(A)
            tolerance=copy_(tol)
        else:
            print_usage_()
    retval=sum_(sigma > tolerance)
    return retval
def krylov_(A=None,V=None,k=None,eps1=None,pflg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[A,V,k,eps1,pflg].count(None)+len(args)

    if (isa_(A,char('single')) or isa_(V,char('single'))):
        defeps=1e-06
    else:
        defeps=1e-12
    if (nargin < 3 or nargin > 5):
        print_usage_()
    else:
        if (nargin < 5):
            pflg=0
    if (nargin < 4):
        eps1=copy_(defeps)
    if (isempty_(eps1)):
        eps1=copy_(defeps)
    if (not issquare_(A) or isempty_(A)):
        error_(char('krylov: A(%d x %d) must be a non-empty square matrix'),rows_(A),columns_(A))
    na=rows_(A)
    m,kb=size_(V,nargout=2)
    if (m != na):
        error_(char('krylov: A(%d x %d), V(%d x %d): argument dimensions do not match'),na,na,m,kb)
    if (not isscalar_(k)):
        error_(char('krylov: K must be a scalar integer'))
    Vnrm=norm_(V,Inf)
    if (Vnrm == 0):
        Uret=matlabarray([])
        H=matlabarray([])
        nu=0
        return Uret,H,nu
    abm=max_(abs_([A,V].T))
    zidx=find_(abm == 0)
    pivot_vec=arange_(1,na)
    _iter=0
    alpha=matlabarray([])
    nh=0
    while (length_(alpha) < na) and (columns_(V) > 0) and (_iter < k):

        _iter
        jj=1
        while (jj <= columns_(V) and length_(alpha) < na):

            nu=length_(alpha) + 1
            short_pv=pivot_vec[nu:na]
            q=V[:,jj]
            short_q=q[short_pv]
            if (norm_(short_q) < eps1):
                nv=columns_(V)
                if (jj != nv):
                    V[:,jj],V[:,nv]=swap_(V[:,jj],V[:,nv],nargout=2)
                V=V[:,1:(nv - 1)]
                nu
            else:
                if (pflg):
                    asq=abs_(short_q)
                    maxv=max_(asq)
                    maxidx=find_(asq == maxv,1)
                    pivot_idx=short_pv[maxidx]
                    if (pivot_idx != pivot_vec[nu]):
                        swapidx=maxidx + (nu - 1)
                        pivot_vec[nu],pivot_vec[swapidx]=swap_(pivot_vec[nu],pivot_vec[swapidx],nargout=2)
                idx=pivot_vec[nu:na]
                jdx=pivot_vec[1:nu]
                hv,av,z=housh_(q[idx],1,0,nargout=3)
                alpha[nu]=av
                U[idx,nu]=hv
                V[idx,:]=V[idx,:] - av * hv * (hv.T * V[idx,:])
                if (_iter > 1):
                    H[nu,nu - 1]=V[pivot_vec[nu],jj]
                jj

        if ((columns_(V) > na) and (length_(alpha) == na)):
            V=V[:,1:na]
        else:
            if (columns_(V) > na):
                krylov_V=copy_(V)
                krylov_na=copy_(na)
                krylov_length_alpha=length_(alpha)
                error_(char('krylov: this case should never happen; submit a bug report'))
        if (columns_(V) > 0):
            Q=zeros_(size_(V))
            for kk in arange_(1,columns_(Q)).reshape(-1):
                Q[pivot_vec[nu - columns_(Q) + kk],kk]=1
            for ii in arange_(nu,1,- 1).reshape(-1):
                idx=pivot_vec[ii:na]
                hv=U[idx,ii]
                av=alpha[ii]
                Q[idx,:]=Q[idx,:] - av * hv * (hv.T * Q[idx,:])
        V=A * Q
        nu=length_(alpha)
        for i in arange_(1,nu).reshape(-1):
            hv=U[:,i]
            av=alpha[i]
            V=V - av * hv * (hv.T * V)
            H[i,nu - columns_(V) + (arange_(1,columns_(V)))]=V[pivot_vec[i],:]

    j1=columns_(U)
    for i in arange_(j1,1,- 1).reshape(-1):
        idx=pivot_vec[i:na]
        hv=U[idx,i]
        av=alpha[i]
        U[:,i]=zeros_(na,1)
        U[idx[1],i]=1
        U[idx,i:j1]=U[idx,i:j1] - av * hv * (hv.T * U[idx,i:j1])
    nu=length_(alpha)
    Uret=copy_(U)
    if (max_(max_(abs_(Uret[zidx,:]))) > 0):
        warning_(char('krylov: trivial null space corrupted; set pflg = 1 or eps1 > %e'),eps1)
    return Uret,H,nu
def swap_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    a1=copy_(b)
    b1=copy_(a)
    return a1,b1
def trace_(A=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[A].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (ndims_(A) > 2):
        error_(char('trace: only valid on 2-D objects'))
    else:
        if (isempty_(A)):
            y=0
        else:
            if (isvector_(A)):
                y=A[1]
            else:
                y=sum_(diag_(A))
    return y
def onenormest_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1 or nargin > 4):
        print_usage_()
    default_t=5
    itmax=10
    if (ismatrix_(varargin[1])):
        n,nc=size_(varargin[1],nargout=2)
        if (n != nc):
            error_(char('onenormest: matrix must be square'))
        _apply=lambda x: varargin[1] * x
        apply_t=lambda x: varargin[1].T * x
        if (nargin > 1):
            t=varargin[2]
        else:
            t=min_(n,default_t)
        issing=isa_(varargin[1],char('single'))
    else:
        if (nargin < 3):
            print_usage_()
        _apply=varargin[1]
        apply_t=varargin[2]
        n=varargin[3]
        if (nargin > 3):
            t=varargin[4]
        else:
            t=copy_(default_t)
        issing=isa_(n,char('single'))
    X=rand_(n,t)
    X=X / (ones_(n,1) * sum_(abs_(X),1))
    been_there=zeros_(n,1)
    est_old=0
    S=zeros_(n,t)
    if (issing):
        myeps=eps_(char('single'))
        X=single_(X)
    else:
        myeps=copy_(eps)
    for _iter in arange_(1,itmax + 1).reshape(-1):
        Y=feval_(_apply,X)
        est,ind_best=max_(sum_(abs_(Y),1),nargout=2)
        if (est > est_old or _iter == 2):
            w=Y[:,ind_best]
        if (_iter >= 2 and est < est_old):
            est=copy_(est_old)
            break
        est_old=copy_(est)
        S_old=copy_(S)
        if (_iter > itmax):
            break
        S=sign_(Y)
        partest=any_(abs_(S_old.T * S - n) < 4 * eps * n)
        if (all_(partest)):
            break
        if (any_(partest)):
            numpar=sum_(partest)
            replacements=2 * (rand_(n,numpar) < 0.5) - 1
            S[:,partest]=replacements
        partest=any_((S.T * S - eye_(t)) == n)
        if (any_(partest)):
            numpar=sum_(partest)
            replacements=2 * (rand_(n,numpar) < 0.5) - 1
            S[:,partest]=replacements
        Z=feval_(apply_t,S)
        h=max_(abs_(Z),2)
        mh,mhi=max_(h,nargout=2)
        if (_iter >= 2 and mhi == ind_best):
            break
        h,ind=sort_(h,char('descend'),nargout=2)
        if (t > 1):
            firstind=ind[1:t]
            if (all_(been_there[firstind])):
                break
            ind=ind[not been_there[ind]]
            if (length_(ind) < t):
                break
        X=zeros_(n,t)
        for zz in arange_(1,t).reshape(-1):
            X[ind[zz],zz]=1
        been_there[ind[1:t]]=1
    v=zeros_(n,1)
    v[ind_best]=1
    return est,v,w,_iter
def condest_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1 or nargin > 6):
        print_usage_()
    default_t=5
    have_A=copy_(false)
    have_t=copy_(false)
    have_solve=copy_(false)
    if (ismatrix_(varargin[1])):
        A=varargin[1]
        if (not issquare_(A)):
            error_(char('condest: matrix must be square'))
        n=rows_(A)
        have_A=copy_(true)
        if (nargin > 1):
            if (not is_function_handle_(varargin[2])):
                t=varargin[2]
                have_t=copy_(true)
            else:
                if (nargin > 2):
                    solve=varargin[2]
                    solve_t=varargin[3]
                    have_solve=copy_(true)
                    if (nargin > 3):
                        t=varargin[4]
                        have_t=copy_(true)
                else:
                    error_(char('condest: must supply both SOLVE and SOLVE_T'))
    else:
        if (nargin > 4):
            _apply=varargin[1]
            apply_t=varargin[2]
            solve=varargin[3]
            solve_t=varargin[4]
            have_solve=copy_(true)
            n=varargin[5]
            if (not isscalar_(n)):
                error_(char('condest: dimension argument of implicit form must be scalar'))
            if (nargin > 5):
                t=varargin[6]
                have_t=copy_(true)
        else:
            error_(char('condest: implicit form of condest requires at least 5 arguments'))
    if (not have_t):
        t=min_(n,default_t)
    if (not have_solve):
        if (issparse_(A)):
            L,U,P,Pc=lu_(A,nargout=4)
            solve=lambda x: Pc.T * (numpy.linalg.solve(U,(numpy.linalg.solve(L,(P * x)))))
            solve_t=lambda x: P.T * (numpy.linalg.solve(L.T,(numpy.linalg.solve(U.T,(Pc * x)))))
        else:
            L,U,P=lu_(A,nargout=3)
            solve=lambda x: numpy.linalg.solve(U,(numpy.linalg.solve(L,(P * x))))
            solve_t=lambda x: P.T * (numpy.linalg.solve(L.T,(numpy.linalg.solve(U.T,x))))
    if (have_A):
        Anorm=norm_(A,1)
    else:
        Anorm=onenormest_(_apply,apply_t,n,t)
    Ainv_norm,v,w=onenormest_(solve,solve_t,n,t,nargout=3)
    est=Anorm * Ainv_norm
    v=w / norm_(w,1)
    return est,v
def vech_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not issquare_(x)):
        error_(char('vech: X must be square'))
    n=rows_(x)
    slices=cellslices_(x[:],(arange_(1,n)) + n * (arange_(0,n - 1)),n * (arange_(1,n)))
    v=vertcat_(slices[:])
    return v
def normest_(A=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,tol].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (not (isnumeric_(A) and ndims_(A) == 2)):
        error_(char('normest: A must be a numeric 2-D matrix'))
    if (not (isscalar_(tol) and isreal_(tol))):
        error_(char('normest: TOL must be a real scalar'))
    if (not isfloat_(A)):
        A=double_(A)
    tol=max_(tol,eps_(class_(A)))
    v=rand_(char('state'))
    rand_(char('state'),trace_(A))
    ncols=columns_(A)
    y=rand_(ncols,1)
    c=0
    n=0
    do
    n0=copy_(n)
    x=A * y
    normx=norm_(x)
    if (normx == 0):
        x=rand_(ncols,1)
    else:
        x=x / normx
    y=A.T * x
    n=norm_(y)
    c += 1
    until_(abs_(n - n0) <= tol * n)
    rand_(char('state'),v)
    return n,c
def isdefinite_(x=None,tol=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,tol].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (not isfloat_(x)):
        x=double_(x)
    if (nargin == 1):
        tol=100 * eps_(class_(x)) * norm_(x,char('fro'))
    if (not ishermitian_(x,tol)):
        error_(char('isdefinite: X must be a Hermitian matrix'))
    e=tol * eye_(rows_(x))
    r,p=chol_(x - e,nargout=2)
    if (p == 0):
        retval=1
    else:
        r,p=chol_(x + e,nargout=2)
        if (p == 0):
            retval=0
        else:
            retval=- 1
    return retval
def cond_(A=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,p].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (ndims_(A) > 2):
        error_(char('cond: A must be a 2-D matrix'))
    if (p == 2):
        if (isempty_(A)):
            retval=0.0
        else:
            if (any_(not isfinite_(A[:]))):
                error_(char('cond: A must not contain Inf or NaN values'))
            else:
                sigma=svd_(A)
                sigma_1=sigma[1]
                sigma_n=sigma[end()]
                if (sigma_1 == 0 or sigma_n == 0):
                    retval=copy_(Inf)
                else:
                    retval=sigma_1 / sigma_n
    else:
        retval=norm_(A,p) * norm_(inv_(A),p)
    return retval
def planerot_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    G=givens_(x[1],x[2])
    y=G * x[:]
    return G,y
def commutation_matrix_(m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[m,n].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    else:
        if (not (isscalar_(m) and m == fix_(m) and m > 0)):
            error_(char('commutation_matrix: M must be a positive integer'))
        if (nargin == 1):
            n=copy_(m)
        else:
            if (not (isscalar_(n) and n == fix_(n) and n > 0)):
                error_(char('commutation_matrix: N must be a positive integer'))
    k=zeros_(m * n,m * n)
    for i in arange_(1,m).reshape(-1):
        for j in arange_(1,n).reshape(-1):
            k[(i - 1) * n + j,(j - 1) * m + i]=1
    return k
def qzhess_(A=None,B=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,B].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    na,ma=size_(A,nargout=2)
    nb,mb=size_(B,nargout=2)
    if (na != ma or na != nb or nb != mb):
        error_(char('qzhess: incompatible dimensions'))
    q,bb=qr_(B,nargout=2)
    aa=q.T * A
    q=q.T
    z=eye_(na)
    for j in arange_(1,(na - 2)).reshape(-1):
        for i in arange_(na,(j + 2),- 1).reshape(-1):
            rot=givens_(aa[i - 1,j],aa[i,j])
            aa[(i - 1):i,:]=rot * aa[(i - 1):i,:]
            bb[(i - 1):i,:]=rot * bb[(i - 1):i,:]
            q[(i - 1):i,:]=rot * q[(i - 1):i,:]
            rot=givens_(bb[i,i],bb[i,i - 1]).T
            bb[:,(i - 1):i]=bb[:,(i - 1):i] * rot.T
            aa[:,(i - 1):i]=aa[:,(i - 1):i] * rot.T
            z[:,(i - 1):i]=z[:,(i - 1):i] * rot.T
    bb[2,1]=0.0
    for i in arange_(3,na).reshape(-1):
        bb[i,1:(i - 1)]=zeros_(1,i - 1)
        aa[i,1:(i - 2)]=zeros_(1,i - 2)
    return aa,bb,q,z
def orth_(A=None,tol=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,tol].count(None)+len(args)

    if (nargin == 1 or nargin == 2):
        if (isempty_(A)):
            retval=matlabarray([])
            return retval
        U,S,V=svd_(A,nargout=3)
        rows,cols=size_(A,nargout=2)
        S_nr,S_nc=size_(S,nargout=2)
        if (S_nr == 1 or S_nc == 1):
            s=S[1]
        else:
            s=diag_(S)
        if (nargin == 1):
            if (isa_(A,char('single'))):
                tol=max_(size_(A)) * s[1] * eps_(char('single'))
            else:
                tol=max_(size_(A)) * s[1] * eps
        rank=sum_(s > tol)
        if (rank > 0):
            retval=- U[:,1:rank]
        else:
            retval=zeros_(rows,0)
    else:
        print_usage_()
    return retval
def rref_(A=None,tol=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,tol].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (ndims_(A) > 2):
        error_(char('rref: expecting matrix argument'))
    rows,cols=size_(A,nargout=2)
    if (nargin < 2):
        if (isa_(A,char('single'))):
            tol=eps_(char('single')) * max_(rows,cols) * norm_(A,inf_(char('single')))
        else:
            tol=eps * max_(rows,cols) * norm_(A,inf)
    used=zeros_(1,cols)
    r=1
    for c in arange_(1,cols).reshape(-1):
        m,pivot=max_(abs_(A[r:rows,c]),nargout=2)
        pivot=r + pivot - 1
        if (m <= tol):
            A[r:rows,c]=zeros_(rows - r + 1,1)
        else:
            used[1,c]=1
            A[[pivot,r],c:cols]=A[[r,pivot],c:cols]
            A[r,c:cols]=A[r,c:cols] / A[r,c]
            ridx=matlabarray([arange_(1,r - 1),arange_(r + 1,rows)])
            A[ridx,c:cols]=A[ridx,c:cols] - A[ridx,c] * A[r,c:cols]
            if (r == rows):
                break
    k=find_(used)
    return A,k
def linsolve_(A=None,b=None,opts=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[A,b,opts].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not (isnumeric_(A) and isnumeric_(b))):
        error_(char('linsolve: A and B must be numeric'))
    if (nargin > 2):
        if (not isstruct_(opts)):
            error_(char('linsolve: OPTS must be a structure'))
        trans_A=copy_(false)
        if (isfield_(opts,char('TRANSA')) and opts.TRANSA):
            trans_A=copy_(true)
            A=A.T
        if (isfield_(opts,char('POSDEF')) and opts.POSDEF):
            A=matrix_type_(A,char('positive definite'))
        if (isfield_(opts,char('LT')) and opts.LT):
            if (trans_A):
                A=matrix_type_(A,char('upper'))
            else:
                A=matrix_type_(A,char('lower'))
        if (isfield_(opts,char('UT')) and opts.UT):
            if (trans_A):
                A=matrix_type_(A,char('lower'))
            else:
                A=matrix_type_(A,char('upper'))
    x=numpy.linalg.solve(A,b)
    if (nargout > 1):
        if (issquare_(A)):
            R=rcond_(A)
        else:
            R=0
    return x,R
def housh_(x=None,j=None,z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,j,z].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isvector_(x) and not isscalar_(x)):
        error_(char('housh: first input must be a vector'))
    else:
        if (not isscalar_(j)):
            error_(char('housh: second argment must be an integer scalar'))
        else:
            housv=copy_(x)
            m=max_(abs_(housv))
            if (m != 0.0):
                housv=housv / m
                alpha=norm_(housv)
                if (alpha > z):
                    beta=1.0 / (alpha * (alpha + abs_(housv[j])))
                    sg=sign_(housv[j])
                    if (sg == 0):
                        sg=1
                    housv[j]=housv[j] + alpha * sg
                else:
                    beta=0.0
            else:
                beta=0.0
            zer=(beta == 0)
    return housv,beta,zer
def duplication_matrix_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (isscalar_(n) and n > 0 and n == fix_(n))):
        error_(char('duplication_matrix: N must be a positive integer'))
    d=zeros_(n * n,n * (n + 1) / 2)
    count=0
    for j in arange_(1,n).reshape(-1):
        d[(j - 1) * n + j,count + j]=1
        for i in arange_((j + 1),n).reshape(-1):
            d[(j - 1) * n + i,count + i]=1
            d[(i - 1) * n + j,count + i]=1
        count=count + n - j
    return d
def issymmetric_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,tol].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    retval=isnumeric_(x) and issquare_(x)
    if (retval):
        if (tol == 0):
            retval=all_((x == x.T)(arange_()))
        else:
            norm_x=norm_(x,inf)
            retval=norm_x == 0 or norm_(x - x.T,inf) / norm_x <= tol
    return retval
def cross_(x=None,y=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,dim].count(None)+len(args)

    if (nargin != 2 and nargin != 3):
        print_usage_()
    if (ndims_(x) < 3 and ndims_(y) < 3 and nargin < 3):
        if (columns_(x) == 1 and rows_(y) == 1):
            warning_(char('cross: taking cross product of column by row'))
            y=y.T
        else:
            if (rows_(x) == 1 and columns_(y) == 1):
                warning_(char('cross: taking cross product of row by column'))
                x=x.T
    if (nargin == 2):
        dim=find_(size_(x) == 3,1)
        if (isempty_(dim)):
            error_(char('cross: must have at least one dimension with 3 elements'))
    else:
        if (size_(x,dim) != 3):
            error_(char('cross: dimension DIM must have 3 elements'))
    nd=ndims_(x)
    sz=size_(x)
    idx2=idx3=idx1=[char(':')](ones_(1,nd))
    idx1[dim]=1
    idx2[dim]=2
    idx3[dim]=3
    if (size_equal_(x,y)):
        x1=x[idx1[:]]
        x2=x[idx2[:]]
        x3=x[idx3[:]]
        y1=y[idx1[:]]
        y2=y[idx2[:]]
        y3=y[idx3[:]]
        z=cat_(dim,(x2.dot(y3) - x3.dot(y2)),(x3.dot(y1) - x1.dot(y3)),(x1.dot(y2) - x2.dot(y1)))
    else:
        error_(char('cross: X and Y must have the same dimensions'))
    return z
def ishermitian_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,tol].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    retval=isnumeric_(x) and issquare_(x)
    if (retval):
        if (tol == 0):
            retval=all_((x == x.T)(arange_()))
        else:
            norm_x=norm_(x,inf)
            retval=norm_x == 0 or norm_(x - x.T,inf) / norm_x <= tol
    return retval
def pascal_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,t].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    else:
        if (not (isscalar_(n) and isscalar_(t))):
            error_(char('pascal: N and T must be scalars'))
        else:
            if (not any_(t == [- 1,0,1,2])):
                error_(char('pascal: expecting T to be -1, 0, 1, or 2, found %d'),t)
    retval=zeros_(n)
    if (n > 0):
        retval[:,1]=1
    if (t == - 1):
        for j in arange_(2,n).reshape(-1):
            retval[j:n,j]=cumsum_(retval[j - 1:n - 1,j - 1])
    else:
        for j in arange_(2,n).reshape(-1):
            retval[j:n,j]=- cumsum_(retval[j - 1:n - 1,j - 1])
    if (t == 0):
        retval=retval * retval.T
    else:
        if (t == 2):
            retval=rot90_(retval,3)
            if (rem_(n,2) != 1):
                retval *= - 1
    return retval
def wilkinson_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (isscalar_(n) and n >= 0 and (n == fix_(n)))):
        error_(char('wilkinson: N must be a non-negative integer'))
    side=ones_(n - 1,1)
    center=abs_(arange_(- (n - 1) / 2,(n - 1) / 2))
    retval=diag_(side,- 1) + diag_(center) + diag_(side,1)
    return retval
def vander_(c=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[c,n].count(None)+len(args)

    if (nargin == 1):
        n=length_(c)
    else:
        if (nargin != 2):
            print_usage_()
    if (not isvector_(c)):
        error_(char('vander: polynomial C must be a vector'))
    retval=zeros_(length_(c),n,class_(c))
    d=1
    c=c[:]
    for i in arange_(n,1,- 1).reshape(-1):
        retval[:,i]=d
        d .*= c
    return retval
def magic_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (n != fix_(n) or n < 0 or n == 2):
        error_(char('magic: N must be a positive integer not equal to 2'))
    if (n == 0):
        A=matlabarray([])
    else:
        if (mod_(n,2) == 1):
            shift=floor_((arange_(0,n * n - 1)) / n)
            c=mod_([arange_(1,n * n)] - shift + (n - 3) / 2,n)
            r=mod_([arange_(n * n,1,- 1)] + 2 * shift,n)
            A[c * n + r + 1]=arange_(1,n * n)
            A=reshape_(A,n,n)
        else:
            if (mod_(n,4) == 0):
                A=reshape_(arange_(1,n * n),n,n).T
                I=matlabarray([arange_(1,n,4),arange_(4,n,4)])
                J=fliplr_(I)
                A[I,I]=A[J,J]
                I=matlabarray([arange_(2,n,4),arange_(3,n,4)])
                J=fliplr_(I)
                A[I,I]=A[J,J]
            else:
                if (mod_(n,4) == 2):
                    m=n / 2
                    A=magic_(m)
                    A=matlabarray([[A,A + 2 * m * m],[A + 3 * m * m,A + m * m]])
                    k=(m - 1) / 2
                    if (k > 1):
                        I=arange_(1,m)
                        J=matlabarray([arange_(2,k),arange_(n - k + 2,n)])
                        A[[I,I + m],J]=A[[I + m,I],J]
                    I=matlabarray([arange_(1,k),arange_(k + 2,m)])
                    A[[I,I + m],1]=A[[I + m,I],1]
                    I=k + 1
                    A[[I,I + m],I]=A[[I + m,I],I]
    return A
def gallery_(name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[name].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    else:
        if (not ischar_(name)):
            error_(char('gallery: NAME must be a string.'))
    n_out=copy_(nargout)
    if (n_out == 0):
        n_out=1
    if char('binomial') == (tolower____________________________________________________________(name)):
        error_(char('gallery: matrix %s not implemented.'),name)
    else:
        if char('cauchy') == (tolower____________________________________________________________(name)):
            varargout[1:n_out]=cauchy_(varargin[:])
        else:
            if char('chebspec') == (tolower____________________________________________________________(name)):
                varargout[1:n_out]=chebspec_(varargin[:])
            else:
                if char('chebvand') == (tolower____________________________________________________________(name)):
                    varargout[1:n_out]=chebvand_(varargin[:])
                else:
                    if char('chow') == (tolower____________________________________________________________(name)):
                        varargout[1:n_out]=chow_(varargin[:])
                    else:
                        if char('circul') == (tolower____________________________________________________________(name)):
                            varargout[1:n_out]=circul_(varargin[:])
                        else:
                            if char('clement') == (tolower____________________________________________________________(name)):
                                varargout[1:n_out]=clement_(varargin[:])
                            else:
                                if char('compar') == (tolower____________________________________________________________(name)):
                                    varargout[1:n_out]=compar_(varargin[:])
                                else:
                                    if char('condex') == (tolower____________________________________________________________(name)):
                                        varargout[1:n_out]=condex_(varargin[:])
                                    else:
                                        if char('cycol') == (tolower____________________________________________________________(name)):
                                            varargout[1:n_out]=cycol_(varargin[:])
                                        else:
                                            if char('dorr') == (tolower____________________________________________________________(name)):
                                                varargout[1:n_out]=dorr_(varargin[:])
                                            else:
                                                if char('dramadah') == (tolower____________________________________________________________(name)):
                                                    varargout[1:n_out]=dramadah_(varargin[:])
                                                else:
                                                    if char('fiedler') == (tolower____________________________________________________________(name)):
                                                        varargout[1:n_out]=fiedler_(varargin[:])
                                                    else:
                                                        if char('forsythe') == (tolower____________________________________________________________(name)):
                                                            varargout[1:n_out]=forsythe_(varargin[:])
                                                        else:
                                                            if char('frank') == (tolower____________________________________________________________(name)):
                                                                varargout[1:n_out]=frank_(varargin[:])
                                                            else:
                                                                if char('gearmat') == (tolower____________________________________________________________(name)):
                                                                    varargout[1:n_out]=gearmat_(varargin[:])
                                                                else:
                                                                    if char('gcdmat') == (tolower____________________________________________________________(name)):
                                                                        varargout[1:n_out]=gcdmat_(varargin[:])
                                                                    else:
                                                                        if char('grcar') == (tolower____________________________________________________________(name)):
                                                                            varargout[1:n_out]=grcar_(varargin[:])
                                                                        else:
                                                                            if char('hanowa') == (tolower____________________________________________________________(name)):
                                                                                varargout[1:n_out]=hanowa_(varargin[:])
                                                                            else:
                                                                                if char('house') == (tolower____________________________________________________________(name)):
                                                                                    varargout[1:n_out]=house_(varargin[:])
                                                                                else:
                                                                                    if char('integerdata') == (tolower____________________________________________________________(name)):
                                                                                        varargout[1:n_out]=integerdata_(varargin[:])
                                                                                    else:
                                                                                        if char('invhess') == (tolower____________________________________________________________(name)):
                                                                                            varargout[1:n_out]=invhess_(varargin[:])
                                                                                        else:
                                                                                            if char('invol') == (tolower____________________________________________________________(name)):
                                                                                                varargout[1:n_out]=invol_(varargin[:])
                                                                                            else:
                                                                                                if char('ipjfact') == (tolower____________________________________________________________(name)):
                                                                                                    varargout[1:n_out]=ipjfact_(varargin[:])
                                                                                                else:
                                                                                                    if char('jordbloc') == (tolower____________________________________________________________(name)):
                                                                                                        varargout[1:n_out]=jordbloc_(varargin[:])
                                                                                                    else:
                                                                                                        if char('kahan') == (tolower____________________________________________________________(name)):
                                                                                                            varargout[1:n_out]=kahan_(varargin[:])
                                                                                                        else:
                                                                                                            if char('kms') == (tolower____________________________________________________________(name)):
                                                                                                                varargout[1:n_out]=kms_(varargin[:])
                                                                                                            else:
                                                                                                                if char('krylov') == (tolower____________________________________________________________(name)):
                                                                                                                    varargout[1:n_out]=krylov_(varargin[:])
                                                                                                                else:
                                                                                                                    if char('lauchli') == (tolower____________________________________________________________(name)):
                                                                                                                        varargout[1:n_out]=lauchli_(varargin[:])
                                                                                                                    else:
                                                                                                                        if char('lehmer') == (tolower____________________________________________________________(name)):
                                                                                                                            varargout[1:n_out]=lehmer_(varargin[:])
                                                                                                                        else:
                                                                                                                            if char('leslie') == (tolower____________________________________________________________(name)):
                                                                                                                                error_(char('gallery: matrix %s not implemented.'),name)
                                                                                                                            else:
                                                                                                                                if char('lesp') == (tolower____________________________________________________________(name)):
                                                                                                                                    varargout[1:n_out]=lesp_(varargin[:])
                                                                                                                                else:
                                                                                                                                    if char('lotkin') == (tolower____________________________________________________________(name)):
                                                                                                                                        varargout[1:n_out]=lotkin_(varargin[:])
                                                                                                                                    else:
                                                                                                                                        if char('minij') == (tolower____________________________________________________________(name)):
                                                                                                                                            varargout[1:n_out]=minij_(varargin[:])
                                                                                                                                        else:
                                                                                                                                            if char('moler') == (tolower____________________________________________________________(name)):
                                                                                                                                                varargout[1:n_out]=moler_(varargin[:])
                                                                                                                                            else:
                                                                                                                                                if char('neumann') == (tolower____________________________________________________________(name)):
                                                                                                                                                    varargout[1:n_out]=neumann_(varargin[:])
                                                                                                                                                else:
                                                                                                                                                    if char('normaldata') == (tolower____________________________________________________________(name)):
                                                                                                                                                        varargout[1:n_out]=normaldata_(varargin[:])
                                                                                                                                                    else:
                                                                                                                                                        if char('orthog') == (tolower____________________________________________________________(name)):
                                                                                                                                                            varargout[1:n_out]=orthog_(varargin[:])
                                                                                                                                                        else:
                                                                                                                                                            if char('parter') == (tolower____________________________________________________________(name)):
                                                                                                                                                                varargout[1:n_out]=parter_(varargin[:])
                                                                                                                                                            else:
                                                                                                                                                                if char('pei') == (tolower____________________________________________________________(name)):
                                                                                                                                                                    varargout[1:n_out]=pei_(varargin[:])
                                                                                                                                                                else:
                                                                                                                                                                    if char('poisson') == (tolower____________________________________________________________(name)):
                                                                                                                                                                        varargout[1:n_out]=poisson_(varargin[:])
                                                                                                                                                                    else:
                                                                                                                                                                        if char('prolate') == (tolower____________________________________________________________(name)):
                                                                                                                                                                            varargout[1:n_out]=prolate_(varargin[:])
                                                                                                                                                                        else:
                                                                                                                                                                            if char('randcolu') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                error_(char('gallery: matrix %s not implemented.'),name)
                                                                                                                                                                            else:
                                                                                                                                                                                if char('randcorr') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                    error_(char('gallery: matrix %s not implemented.'),name)
                                                                                                                                                                                else:
                                                                                                                                                                                    if char('randhess') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                        varargout[1:n_out]=randhess_(varargin[:])
                                                                                                                                                                                    else:
                                                                                                                                                                                        if char('randjorth') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                            error_(char('gallery: matrix %s not implemented.'),name)
                                                                                                                                                                                        else:
                                                                                                                                                                                            if char('rando') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                varargout[1:n_out]=rando_(varargin[:])
                                                                                                                                                                                            else:
                                                                                                                                                                                                if char('randsvd') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                    varargout[1:n_out]=randsvd_(varargin[:])
                                                                                                                                                                                                else:
                                                                                                                                                                                                    if char('redheff') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                        varargout[1:n_out]=redheff_(varargin[:])
                                                                                                                                                                                                    else:
                                                                                                                                                                                                        if char('riemann') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                            varargout[1:n_out]=riemann_(varargin[:])
                                                                                                                                                                                                        else:
                                                                                                                                                                                                            if char('ris') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                                varargout[1:n_out]=ris_(varargin[:])
                                                                                                                                                                                                            else:
                                                                                                                                                                                                                if char('sampling') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                                    error_(char('gallery: matrix %s not implemented.'),name)
                                                                                                                                                                                                                else:
                                                                                                                                                                                                                    if char('smoke') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                                        varargout[1:n_out]=smoke_(varargin[:])
                                                                                                                                                                                                                    else:
                                                                                                                                                                                                                        if char('toeppd') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                                            varargout[1:n_out]=toeppd_(varargin[:])
                                                                                                                                                                                                                        else:
                                                                                                                                                                                                                            if char('toeppen') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                                                varargout[1:n_out]=toeppen_(varargin[:])
                                                                                                                                                                                                                            else:
                                                                                                                                                                                                                                if char('tridiag') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                                                    varargout[1:n_out]=tridiag_(varargin[:])
                                                                                                                                                                                                                                else:
                                                                                                                                                                                                                                    if char('triw') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                                                        varargout[1:n_out]=triw_(varargin[:])
                                                                                                                                                                                                                                    else:
                                                                                                                                                                                                                                        if char('uniformdata') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                                                            varargout[1:n_out]=uniformdata_(varargin[:])
                                                                                                                                                                                                                                        else:
                                                                                                                                                                                                                                            if char('wathen') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                                                                varargout[1:n_out]=wathen_(varargin[:])
                                                                                                                                                                                                                                            else:
                                                                                                                                                                                                                                                if char('wilk') == (tolower____________________________________________________________(name)):
                                                                                                                                                                                                                                                    varargout[1:n_out]=wilk_(varargin[:])
                                                                                                                                                                                                                                                else:
                                                                                                                                                                                                                                                    error_(char('gallery: unknown matrix with NAME %s'),name)
    return varargout
def cauchy_(x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 or 2 arguments are required for cauchy matrix.'))
    else:
        if (not isnumeric_(x)):
            error_(char('gallery: X must be numeric for cauchy matrix.'))
        else:
            if (nargin == 2 and not isnumeric_(y)):
                error_(char('gallery: Y must be numeric for cauchy matrix.'))
    n=numel_(x)
    if (isscalar_(x) and fix_(x) == x):
        n=copy_(x)
        x=arange_(1,n)
    else:
        if (n > 1 and isvector_(x)):
            pass
        else:
            error_(char('gallery: X be an integer or a vector for cauchy matrix.'))
    if (nargin == 1):
        y=copy_(x)
    x=x[:]
    y=y[:]
    if (numel_(x) != numel_(y)):
        error_(char('gallery: X and Y must be vectors of same length for cauchy matrix.'))
    C=x * ones_(1,n) + ones_(n,1) * y.T
    C=ones_(n) / C
    return C
def chebspec_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for chebspec matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for chebspec matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a scalar for chebspec matrix.'))
    if (0) == (k):
        pass
    else:
        if (1) == (k):
            n=n + 1
        else:
            error_(char("gallery: unknown K '%d' for chebspec matrix."),k)
    n=n - 1
    C=zeros_(n + 1)
    one=ones_(n + 1,1)
    x=cos_((arange_(0,n)).T * (pi / n))
    d=ones_(n + 1,1)
    d[1]=2
    d[n + 1]=2
    C=(d * (one / d).T) / (x * one.T - one * x.T + eye_(size_(C)))
    C[1,1]=(2 * n ** 2 + 1) / 6
    for i in arange_(2,n + 1).reshape(-1):
        if (rem_(i,2) == 0):
            C[:,i]=- C[:,i]
            C[i,:]=- C[i,:]
        if (i < n + 1):
            C[i,i]=- x[i] / (2 * (1 - x[i] ** 2))
        else:
            C[n + 1,n + 1]=- C[1,1]
    if (k == 1):
        C=C[2:n + 1,2:n + 1]
    return C
def chebvand_(m=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[m,p].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 or 2 arguments are required for chebvand matrix.'))
    if (nargin == 1):
        p=copy_(m)
    n=numel_(p)
    if (not isnumeric_(p)):
        error_(char('gallery: P must be numeric for chebvand matrix.'))
    else:
        if (isscalar_(p) and fix_(p) == p):
            n=copy_(p)
            p=linspace_(0,1,n)
        else:
            if (n > 1 and isvector_(p)):
                pass
    p=p[:].T
    if (nargin == 1):
        m=copy_(n)
    else:
        if (not isnumeric_(m) or not isscalar_(m)):
            error_(char('gallery: M must be a scalar for chebvand matrix.'))
    C=ones_(m,n)
    if (m != 1):
        C[2,:]=p
        for i in arange_(3,m).reshape(-1):
            C[i,:]=2.0 * p.dot(C[i - 1,:]) - C[i - 2,:]
    return C
def chow_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[n,alpha,delta].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        error_(char('gallery: 1 to 3 arguments are required for chow matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for chow matrix.'))
        else:
            if (not isnumeric_(alpha) or not isscalar_(alpha)):
                error_(char('gallery: ALPHA must be a scalar for chow matrix.'))
            else:
                if (not isnumeric_(delta) or not isscalar_(delta)):
                    error_(char('gallery: DELTA must be a scalar for chow matrix.'))
    A=toeplitz_(alpha ** (arange_(1,n)),[alpha,1,zeros_(1,n - 2)]) + delta * eye_(n)
    return A
def circul_(v=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[v].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for circul matrix.'))
    else:
        if (not isnumeric_(v)):
            error_(char('gallery: V must be numeric for circul matrix.'))
    n=numel_(v)
    if (isscalar_(v) and fix_(v) == v):
        n=copy_(v)
        v=arange_(1,n)
    else:
        if (n > 1 and isvector_(v)):
            pass
        else:
            error_(char('gallery: X must be a scalar or a vector for circul matrix.'))
    v=v[:].T
    C=toeplitz_([v[1],v[n:- 1:2]],v)
    return C
def clement_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 or 2 arguments are required for clement matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for clement matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a numeric scalar for clement matrix.'))
    n=n - 1
    x=arange_(n,1,- 1)
    z=arange_(1,n)
    if (k == 0):
        A=diag_(x,- 1) + diag_(z,1)
    else:
        if (k == 1):
            y=sqrt_(x.dot(z))
            A=diag_(y,- 1) + diag_(y,1)
        else:
            error_(char('gallery: K must have a value of 0 or 1 for clement matrix.'))
    return A
def compar_(A=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 or 2 arguments are required for compar matrix.'))
    else:
        if (not isnumeric_(A) or ndims_(A) != 2):
            error_(char('gallery: A must be a 2-D matrix for compar matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a numeric scalar for compar matrix.'))
    m,n=size_(A,nargout=2)
    p=min_(m,n)
    if (k == 0):
        C=- abs_(A)
        for j in arange_(1,p).reshape(-1):
            C[j,j]=abs_(A[j,j])
    else:
        if (k == 1):
            C=A.T
            for j in arange_(1,p).reshape(-1):
                C[k,k]=0
            mx=max_(abs_(C))
            C=- mx.T * ones_(1,n)
            for j in arange_(1,p).reshape(-1):
                C[j,j]=abs_(A[j,j])
            if (all_(A == tril_(A))):
                C=tril_(C)
            if (all_(A == triu_(A))):
                C=triu_(C)
        else:
            error_(char('gallery: K must have a value of 0 or 1 for compar matrix.'))
    return C
def condex_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[n,k,theta].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        error_(char('gallery: 1 to 3 arguments are required for condex matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for condex matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a numeric scalar for condex matrix.'))
            else:
                if (not isnumeric_(theta) or not isscalar_(theta)):
                    error_(char('gallery: THETA must be a numeric scalar for condex matrix.'))
    if (k == 1):
        A=matlabarray([1,- 1,- 2 * theta,0,0,1,theta,- theta,0,1,1 + theta,- (theta + 1),0,0,0,theta])
    else:
        if (k == 2):
            A=matlabarray([1,1 - 2 / theta ** 2,- 2,0,1 / theta,- 1 / theta,0,0,1])
        else:
            if (k == 3):
                A=gallery_(char('triw'),n,- 1).T
                A[n,n]=- 1
            else:
                if (k == 4):
                    x=ones_(n,3)
                    x[2:n,2]=zeros_(n - 1,1)
                    x[:,3]=(- 1) ** [arange_(0,n - 1)].T.dot((1 + [arange_(0,n - 1)].T / (n - 1)))
                    Q=orth_(x)
                    P=eye_(n) - Q * Q.T
                    A=eye_(n) + theta * P
                else:
                    error_(char("gallery: unknown estimator K '%d' for condex matrix."),k)
    m=columns_(A)
    if (m < n):
        for i in arange_(n,m + 1,- 1).reshape(-1):
            A[i,i]=1
    return A
def cycol_(n=None,k=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 or 2 arguments are required for cycol matrix.'))
    else:
        if (not isnumeric_(n) or all_(numel_(n) != [1,2]) or fix_(n) != n):
            error_(char('gallery: N must be a 1 or 2 element integer for cycol matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a scalar for cycol matrix.'))
    m=n[1]
    n=n[end()]
    if (nargin < 2):
        k=max_(round_(n / 4),1)
    A=randn_(m,k)
    for i in arange_(2,ceil_(n / k)).reshape(-1):
        A=matlabarray([A,A[:,1:k]])
    A=A[:,1:n]
    return A
def dorr_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,theta].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 or 2 arguments are required for dorr matrix.'))
    else:
        if (not isscalar_(n) or not isnumeric_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for dorr matrix.'))
        else:
            if (not isscalar_(theta) or not isnumeric_(theta)):
                error_(char('gallery: THETA must be a numeric scalar for dorr matrix.'))
    c=zeros_(n,1)
    e=copy_(c)
    d=copy_(c)
    h=1 / (n + 1)
    m=floor_((n + 1) / 2)
    term=theta / h ** 2
    i=(arange_(1,m)).T
    c[i]=- term * ones_(m,1)
    e[i]=c[i] - (0.5 - i * h) / h
    d[i]=- (c[i] + e[i])
    i=(arange_(m + 1,n)).T
    e[i]=- term * ones_(n - m,1)
    c[i]=e[i] + (0.5 - i * h) / h
    d[i]=- (c[i] + e[i])
    c=c[2:n]
    e=e[1:n - 1]
    if (nargout <= 1):
        c=tridiag_(c,d,e)
    return c,d,e
def dramadah_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for dramadah matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for dramadah matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a numeric scalar for dramadah matrix.'))
    if (1) == (k):
        c=ones_(n,1)
        for i in arange_(2,n,4).reshape(-1):
            m=min_(1,n - i)
            c[i:i + m]=zeros_(m + 1,1)
        r=zeros_(n,1)
        r[1:4]=[1,1,0,1]
        if (n < 4):
            r=r[1:n]
        A=toeplitz_(c,r)
    else:
        if (2) == (k):
            c=zeros_(n,1)
            c[1]=1
            r=ones_(n,1)
            for i in arange_(3,n,2).reshape(-1):
                r[i]=0
            A=toeplitz_(c,r)
        else:
            if (3) == (k):
                c=ones_(n,1)
                for i in arange_(2,n,2).reshape(-1):
                    c[i]=0
                A=toeplitz_(c,[1,1,zeros_(1,n - 2)])
            else:
                error_(char("gallery: unknown K '%d' for dramadah matrix."),k)
    return A
def fiedler_(c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[c].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for fiedler matrix.'))
    else:
        if (not isnumeric_(c)):
            error_(char('gallery: C must be numeric for fiedler matrix.'))
    n=numel_(c)
    if (isscalar_(c) and fix_(c) == c):
        n=copy_(c)
        c=arange_(1,n)
    else:
        if (n > 1 and isvector_(c)):
            pass
        else:
            error_(char('gallery: C must be an integer or a vector for fiedler matrix.'))
    c=c[:].T
    A=ones_(n,1) * c
    A=abs_(A - A.T)
    return A
def forsythe_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[n,alpha,_lambda].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        error_(char('gallery: 1 to 3 arguments are required for forsythe matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for forsythe matrix.'))
        else:
            if (not isnumeric_(alpha) or not isscalar_(alpha)):
                error_(char('gallery: ALPHA must be a numeric scalar for forsythe matrix.'))
            else:
                if (not isnumeric_(_lambda) or not isscalar_(_lambda)):
                    error_(char('gallery: LAMBDA must be a numeric scalar for forsythe matrix.'))
    A=jordbloc_(n,_lambda)
    A[n,1]=alpha
    return A
def frank_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for frank matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for frank matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a numeric scalar for frank matrix.'))
    p=arange_(n,1,- 1)
    F=triu_(p[ones_(n,1),:] - diag_(ones_(n - 1,1),- 1),- 1)
    if (0) == (k):
        pass
    else:
        if (1) == (k):
            F=F[p,p].T
        else:
            error_(char('gallery: K must have a value of 0 or 1 for frank matrix.'))
    return F
def gcdmat_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for gcdmat matrix.'))
    else:
        if (not isscalar_(n) or not isnumeric_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for gcdmat matrix.'))
    c=gcd_(repmat_((arange_(1,n)).T,[1,n]),repmat_(arange_(1,n),[n,1]))
    return c
def gearmat_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[n,i,j].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        error_(char('gallery: 1 to 3 arguments are required for gearmat matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for gearmat matrix.'))
        else:
            if (not isnumeric_(i) or not isscalar_(i) or i == 0 or abs_(i) <= n):
                error_(char('gallery: I must be a non-zero scalar, and abs (I) <= N for gearmat matrix.'))
            else:
                if (not isnumeric_(j) or not isscalar_(j) or i == 0 or abs_(j) <= n):
                    error_(char('gallery: J must be a non-zero scalar, and abs (J) <= N for gearmat matrix.'))
    A=diag_(ones_(n - 1,1),- 1) + diag_(ones_(n - 1,1),1)
    A[1,abs_(i)]=sign_(i)
    A[n,n + 1 - abs_(j)]=sign_(j)
    return A
def grcar_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for grcar matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for grcar matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a numeric scalar for grcar matrix.'))
    G=tril_(triu_(ones_(n)),k) - diag_(ones_(n - 1,1),- 1)
    return G
def hanowa_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,d].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for hanowa matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for hanowa matrix.'))
        else:
            if (rem_(n,2) != 0):
                error_(char('gallery: N must be even for hanowa matrix.'))
            else:
                if (not isnumeric_(_lambda) or not isscalar_(_lambda)):
                    error_(char('gallery: D must be a numeric scalar for hanowa matrix.'))
    m=n / 2
    A=matlabarray([d * eye_(m),- diag_(arange_(1,m)),diag_(arange_(1,m)),d * eye_(m)])
    return A
def house_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for house matrix.'))
    else:
        if (not isnumeric_(x) or not isvector_(x) or numel_(x) <= 1):
            error_(char('gallery: X must be a vector for house matrix.'))
    x=x[:]
    s=norm_(x) * (sign_(x[1]) + (x[1] == 0))
    v=copy_(x)
    if (s == 0):
        beta=1
    else:
        v[1]=v[1] + s
        beta=1 / (s.T * v[1])
    return v,beta
def integerdata_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 3):
        error_(char('gallery: At least 3 arguments required for integerdata matrix.'))
    if (isnumeric_(varargin[end()])):
        jidx=varargin[end()]
        svec=matlabarray([varargin[:]])
        varargin[end()]=[]
    else:
        if (ischar_(varargin[end()])):
            if (nargin < 4):
                error_([char('gallery: CLASS argument requires 4 inputs '),char('for integerdata matrix.')])
            jidx=varargin[end() - 1]
            svec=matlabarray([varargin[1:end() - 1]])
            varargin[end() - 1]=[]
        else:
            error_([char('gallery: J must be an integer in the range [0, 2^32-1] '),char('for integerdata matrix')])
    if (not (isnumeric_(jidx) and isscalar_(jidx) and jidx == fix_(jidx) and jidx >= 0 and jidx <= 4294967295)):
        error_([char('gallery: J must be an integer in the range [0, 2^32-1] '),char('for integerdata matrix')])
    randstate=rand_(char('state'))
    try:
        rand_(char('state'),svec)
        A=randi_(varargin[:])
    finally:
        rand_(char('state'),randstate)
    return A
def invhess_(x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for invhess matrix.'))
    else:
        if (not isnumeric_(x)):
            error_(char('gallery: X must be numeric for invhess matrix.'))
    if (isscalar_(x) and fix_(x) == x):
        n=copy_(x)
        x=arange_(1,n)
    else:
        if (not isscalar_(x) and isvector_(x)):
            n=numel_(n)
        else:
            error_(char('gallery: X must be an integer scalar, or a vector for invhess matrix.'))
    if (nargin < 2):
        y=- x[1:end() - 1]
    else:
        if (not isvector_(y) or numel_(y) != numel_(x) - 1):
            error_(char('gallery: Y must be a vector of length -1 than X for invhess matrix.'))
    x=x[:]
    y=y[:]
    A=ones_(n,1) * x.T
    for j in arange_(2,n).reshape(-1):
        A[1:j - 1,j]=y[1:j - 1]
    return A
def invol_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for invol matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for invol matrix.'))
    A=hilb_(n)
    d=- n
    A[:,1]=d * A[:,1]
    for i in arange_(1,n - 1).reshape(-1):
        d=- (n + i) * (n - i) * d / (i * i)
        A[i + 1,:]=d * A[i + 1,:]
    return A
def ipjfact_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for ipjfact matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for ipjfact matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a numeric scalar for ipjfact matrix.'))
    c=cumprod_(arange_(2,n + 1))
    d=cumprod_(arange_(n + 1,2 * n)) * c[n - 1]
    A=hankel_(c,d)
    if (0) == (k):
        pass
    else:
        if (1) == (k):
            A=ones_(n) / A
        else:
            error_(char('gallery: K must have a value of 0 or 1 for ipjfact matrix.'))
    if (nargout == 2):
        d=1
        if (k == 0):
            for i in arange_(1,n - 1).reshape(-1):
                d=d * prod_(arange_(1,i + 1)) * prod_(arange_(1,n - i))
            d=d * prod_(arange_(1,n + 1))
        else:
            if (k == 1):
                for i in arange_(0,n - 1).reshape(-1):
                    d=d * prod_(arange_(1,i)) / prod_(arange_(1,n + 1 + i))
                if (rem_(n * (n - 1) / 2,2)):
                    d=- d
            else:
                error_(char('gallery: K must have a value of 0 or 1 for ipjfact matrix.'))
        detA=copy_(d)
    return A,detA
def jordbloc_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,_lambda].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for jordbloc matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for jordbloc matrix.'))
        else:
            if (not isnumeric_(_lambda) or not isscalar_(_lambda)):
                error_(char('gallery: LAMBDA must be a numeric scalar for jordbloc matrix.'))
    J=_lambda * eye_(n) + diag_(ones_(n - 1,1),1)
    return J
def kahan_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[n,theta,pert].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        error_(char('gallery: 1 to 3 arguments are required for kahan matrix.'))
    else:
        if (not isnumeric_(n) or all_(numel_(n) != [1,2]) or fix_(n) != n):
            error_(char('gallery: N must be a 1 or 2 element integer for kahan matrix.'))
        else:
            if (not isnumeric_(theta) or not isscalar_(theta)):
                error_(char('gallery: THETA must be a numeric scalar for kahan matrix.'))
            else:
                if (not isnumeric_(pert) or not isscalar_(pert)):
                    error_(char('gallery: PERT must be a numeric scalar for kahan matrix.'))
    r=n[1]
    n=n[end()]
    s=sin_(theta)
    c=cos_(theta)
    U=eye_(n) - c * triu_(ones_(n),1)
    U=diag_(s ** [arange_(0,n - 1)]) * U + pert * eps * diag_([arange_(n,1,- 1)])
    if (r > n):
        U[r,n]=0
    else:
        U=U[1:r,:]
    return U
def kms_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,rho].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for lauchli matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for lauchli matrix.'))
        else:
            if (not isscalar_(mu)):
                error_(char('gallery: MU must be a scalar for lauchli matrix.'))
    A=(arange_(1,n)).T * ones_(1,n)
    A=abs_(A - A.T)
    A=rho ** A
    if (imag_(rho)):
        A=conj_(tril_(A,- 1)) + triu_(A)
    return A
def krylov_(A=None,x=None,j=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[A,x,j].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        error_(char('gallery: 1 to 3 arguments are required for krylov matrix.'))
    else:
        if (not isnumeric_(A) or not issquare_(A) or ndims_(A) != 2):
            error_(char('gallery: A must be a square 2-D matrix for krylov matrix.'))
    n=length_(A)
    if (isscalar_(A)):
        n=copy_(A)
        A=randn_(n)
    if (nargin < 2):
        x=ones_(n,1)
    else:
        if (not isvector_(x) or numel_(x) != n):
            error_(char('gallery: X must be a vector of length equal to A for krylov matrix.'))
    if (nargin < 3):
        j=copy_(n)
    else:
        if (not isnumeric_(j) or not isscalar_(j) or fix_(j) != j):
            error_(char('gallery: J must be an integer for krylov matrix.'))
    B=ones_(n,j)
    B[:,1]=x[:]
    for i in arange_(2,j).reshape(-1):
        B[:,i]=A * B[:,i - 1]
    return B
def lauchli_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,mu].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for lauchli matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for lauchli matrix.'))
        else:
            if (not isscalar_(mu)):
                error_(char('gallery: MU must be a scalar for lauchli matrix.'))
    A=matlabarray([ones_(1,n),mu * eye_(n)])
    return A
def lehmer_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for lehmer matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for lehmer matrix.'))
    A=ones_(n,1) * (arange_(1,n))
    A=A / A.T
    A=tril_(A) + tril_(A,- 1).T
    return A
def lesp_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for lesp matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for lesp matrix.'))
    x=arange_(2,n)
    T=full_(tridiag_(ones_(size_(x)) / x,- (2 * [x,n + 1] + 1),x))
    return T
def lotkin_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for lotkin matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for lotkin matrix.'))
    A=hilb_(n)
    A[1,:]=ones_(1,n)
    return A
def minij_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for minij matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for minij matrix.'))
    A=min_(ones_(n,1) * (arange_(1,n)),(arange_(1,n)).T * ones_(1,n))
    return A
def moler_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,alpha].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for moler matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for moler matrix.'))
        else:
            if (not isscalar_(alpha)):
                error_(char('gallery: ALPHA must be a scalar for moler matrix.'))
    A=triw_(n,alpha).T * triw_(n,alpha)
    return A
def neumann_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for neumann matrix.'))
    else:
        if (not isnumeric_(n) or all_(numel_(n) != [1,2]) or fix_(n) != n):
            error_(char('gallery: N must be a 1 or 2 element integer for neumann matrix.'))
    if (isscalar_(n)):
        m=sqrt_(n)
        if (m ** 2 != n):
            error_(char('gallery: N must be a perfect square for neumann matrix.'))
        n[1]=m
        n[2]=m
    T=tridiag_(n[1],- 1,2,- 1)
    T[1,2]=- 2
    T[n[1],n[1] - 1]=- 2
    A=kron_(T,eye_(n[2])) + kron_(eye_(n[2]),T)
    return A,T
def normaldata_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 2):
        error_(char('gallery: At least 2 arguments required for normaldata matrix.'))
    if (isnumeric_(varargin[end()])):
        jidx=varargin[end()]
        svec=matlabarray([varargin[:]])
        varargin[end()]=[]
    else:
        if (ischar_(varargin[end()])):
            if (nargin < 3):
                error_([char('gallery: CLASS argument requires 3 inputs '),char('for normaldata matrix.')])
            jidx=varargin[end() - 1]
            svec=matlabarray([varargin[1:end() - 1]])
            varargin[end() - 1]=[]
        else:
            error_([char('gallery: J must be an integer in the range [0, 2^32-1] '),char('for normaldata matrix')])
    if (not (isnumeric_(jidx) and isscalar_(jidx) and jidx == fix_(jidx) and jidx >= 0 and jidx <= 4294967295)):
        error_([char('gallery: J must be an integer in the range [0, 2^32-1] '),char('for normaldata matrix')])
    randstate=randn_(char('state'))
    try:
        randn_(char('state'),svec)
        A=randn_(varargin[:])
    finally:
        randn_(char('state'),randstate)
    return A
def orthog_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for orthog matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for orthog matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a numeric scalar for orthog matrix.'))
    if (1) == (k):
        m=(arange_(1,n)).T * (arange_(1,n)) * (pi / (n + 1))
        Q=sin_(m) * sqrt_(2 / (n + 1))
    else:
        if (2) == (k):
            m=(arange_(1,n)).T * (arange_(1,n)) * (2 * pi / (2 * n + 1))
            Q=sin_(m) * (2 / sqrt_(2 * n + 1))
        else:
            if (3) == (k):
                m=arange_(0,n - 1)
                Q=exp_(m.T * m * 2 * pi * sqrt_(- 1) / n) / sqrt_(n)
            else:
                if (4) == (k):
                    Q=tril_(ones_(n))
                    Q[1,2:n]=ones_(1,n - 1)
                    for i in arange_(2,n).reshape(-1):
                        Q[i,i]=- (i - 1)
                    Q=numpy.linalg.solve(diag_(sqrt_([n,arange_(1,n - 1)].dot([arange_(1,n)]))),Q)
                else:
                    if (5) == (k):
                        m=(arange_(0,n - 1)).T * (arange_(0,n - 1)) * (2 * pi / n)
                        Q=(cos_(m) + sin_(m)) / sqrt_(n)
                    else:
                        if (- 1) == (k):
                            m=(arange_(0,n - 1)).T * (arange_(0,n - 1)) * (pi / (n - 1))
                            Q=cos_(m)
                        else:
                            if (- 2) == (k):
                                m=(arange_(0,n - 1)).T * (arange_(0.5,n - 0.5)) * (pi / n)
                                Q=cos_(m)
                            else:
                                error_(char("gallery: unknown K '%d' for orthog matrix."),k)
    return Q
def parter_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for parter matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for parter matrix.'))
    A=cauchy_((arange_(1,n)) + 0.5,- (arange_(1,n)))
    return A
def pei_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,alpha].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for pei matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for pei matrix.'))
        else:
            if (not isnumeric_(w) or not isscalar_(w)):
                error_(char('gallery: ALPHA must be a scalar for pei matrix.'))
    P=alpha * eye_(n) + ones_(n)
    return P
def poisson_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for poisson matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for poisson matrix.'))
    S=tridiag_(n,- 1,2,- 1)
    I=speye_(n)
    A=kron_(I,S) + kron_(S,I)
    return A
def prolate_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,w].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for prolate matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for prolate matrix.'))
        else:
            if (not isnumeric_(w) or not isscalar_(w)):
                error_(char('gallery: W must be a scalar for prolate matrix.'))
    a=zeros_(n,1)
    a[1]=2 * w
    a[2:n]=sin_(2 * pi * w * (arange_(1,n - 1))) / (pi * (arange_(1,n - 1)))
    A=toeplitz_(a)
    return A
def randhess_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for randhess matrix.'))
    else:
        if (not isnumeric_(x) or not isreal_(x)):
            error_(char('gallery: N or X must be numeric real values for randhess matrix.'))
    if (isscalar_(x)):
        n=copy_(x)
        x=rand_(n - 1,1) * 2 * pi
        H=eye_(n)
        H[n,n]=sign_(randn)
    else:
        if (isvector_(x)):
            n=numel_(x)
            H=eye_(n)
            H[n,n]=sign_(x[n]) + (x[n] == 0)
        else:
            error_(char('gallery: N or X must be a scalar or a vector for randhess matrix.'))
    for i in arange_(n,2,- 1).reshape(-1):
        theta=x[i - 1]
        c=cos_(theta)
        s=sin_(theta)
        H[[i - 1,i],:]=[c * H[i - 1,:] + s * H[i,:],- s * H[i - 1,:] + c * H[i,:]]
    return H
def rando_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for rando matrix.'))
    else:
        if (not isnumeric_(n) or all_(numel_(n) != [1,2]) or fix_(n) != n):
            error_(char('gallery: N must be an integer for rando matrix.'))
        else:
            if (not isnumeric_(k) or not isscalar_(k)):
                error_(char('gallery: K must be a numeric scalar for smoke matrix.'))
    m=n[1]
    n=n[end()]
    if (1) == (k):
        A=floor_(rand_(m,n) + 0.5)
    else:
        if (2) == (k):
            A=2 * floor_(rand_(m,n) + 0.5) - 1
        else:
            if (3) == (k):
                A=round_(3 * rand_(m,n) - 1.5)
            else:
                error_(char("gallery: unknown K '%d' for smoke matrix."),k)
    return A
def randsvd_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[n,kappa,mode,kl,ku].count(None)+len(args)

    if (nargin < 1 or nargin > 5):
        error_(char('gallery: 1 to 5 arguments are required for randsvd matrix.'))
    else:
        if (not isnumeric_(n) or all_(numel_(n) != [1,2]) or fix_(n) != n):
            error_(char('gallery: N must be a 1 or 2 element integer vector for randsvd matrix.'))
        else:
            if (not isnumeric_(kappa) or not isscalar_(kappa)):
                error_(char('gallery: KAPPA must be a numeric scalar for randsvd matrix.'))
            else:
                if (abs_(kappa) < 1):
                    error_(char('gallery: KAPPA must larger than or equal to 1 for randsvd matrix.'))
                else:
                    if (not isnumeric_(mode) or not isscalar_(mode)):
                        error_(char('gallery: MODE must be a numeric scalar for randsvd matrix.'))
                    else:
                        if (not isnumeric_(kl) or not isscalar_(kl)):
                            error_(char('gallery: KL must be a numeric scalar for randsvd matrix.'))
                        else:
                            if (not isnumeric_(ku) or not isscalar_(ku)):
                                error_(char('gallery: KU must be a numeric scalar for randsvd matrix.'))
    posdef=0
    if (kappa < 0):
        posdef=1
        kappa=- kappa
    m=n[1]
    n=n[end()]
    p=min_([m,n])
    if (p == 1):
        A=randn_(m,n)
        A=A / norm_(A)
        return A
    if (1) == (abs_____(mode)):
        sigma=ones_(p,1) / kappa
        sigma[1]=1
    else:
        if (2) == (abs_____(mode)):
            sigma=ones_(p,1)
            sigma[p]=1 / kappa
        else:
            if (3) == (abs_____(mode)):
                factor=kappa ** (- 1 / (p - 1))
                sigma=factor ** [arange_(0,p - 1)]
            else:
                if (4) == (abs_____(mode)):
                    sigma=ones_(p,1) - (arange_(0,p - 1)).T / (p - 1) * (1 - 1 / kappa)
                else:
                    if (5) == (abs_____(mode)):
                        rand_(char('uniform'))
                        sigma=exp_(- rand_(p,1) * log_(kappa))
                    else:
                        error_(char("gallery: unknown MODE '%d' for randsvd matrix."),mode)
    if (mode < 0):
        sigma=sigma[p:- 1:1]
    sigma=diag_(sigma)
    if (posdef):
        Q=qmult_(p)
        A=Q.T * sigma * Q
        A=(A + A.T) / 2
        return A
    if (m != n):
        sigma[m,n]=0
    if (kl == 0 and ku == 0):
        A=copy_(sigma)
    else:
        A=qmult_(sigma.T)
        A=qmult_(A.T)
        if (kl < n - 1 or ku < n - 1):
            A=bandred_(A,kl,ku)
    return A
def redheff_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for redheff matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for redheff matrix.'))
    i=(arange_(1,n)).T * ones_(1,n)
    A=not rem_(i.T,i)
    A[:,1]=ones_(n,1)
    return A
def riemann_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for riemann matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for riemann matrix.'))
    n=n + 1
    i=(arange_(2,n)).T * ones_(1,n - 1)
    j=i.T
    A=i.dot((not rem_(j,i))) - ones_(n - 1)
    return A
def ris_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for ris matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for ris matrix.'))
    p=- 2 * (arange_(1,n)) + (n + 1.5)
    A=cauchy_(p)
    return A
def smoke_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,k].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        error_(char('gallery: 1 to 2 arguments are required for smoke matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be an integer for smoke matrix.'))
        else:
            if (not isnumeric_(n) or not isscalar_(n)):
                error_(char('gallery: K must be a numeric scalar for smoke matrix.'))
    w=exp_(2 * pi * i / n)
    A=diag_([w ** (arange_(1,n - 1)),1]) + diag_(ones_(n - 1,1),1)
    if (0) == (k):
        A[n,1]=1
    else:
        if (1) == (k):
            pass
        else:
            error_(char('gallery: K must have a value of 0 or 1 for smoke matrix.'))
    return A
def toeppd_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[n,m,w,theta].count(None)+len(args)

    if (nargin < 1 or nargin > 4):
        error_(char('gallery: 1 to 4 arguments are required for toeppd matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be a numeric integer for toeppd matrix.'))
        else:
            if (not isnumeric_(m) or not isscalar_(m) or fix_(m) != m):
                error_(char('gallery: M must be a numeric integer for toeppd matrix.'))
            else:
                if (numel_(w) != m or numel_(theta) != m):
                    error_(char('gallery: W and THETA must be vectors of length M for toeppd matrix.'))
    T=zeros_(n)
    E=2 * pi * ((arange_(1,n)).T * ones_(1,n) - ones_(n,1) * (arange_(1,n)))
    for i in arange_(1,m).reshape(-1):
        T=T + w[i] * cos_(theta[i] * E)
    return T
def toeppen_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[n,a,b,c,d,e].count(None)+len(args)

    if (nargin < 1 or nargin > 6):
        error_(char('gallery: 1 to 6 arguments are required for toeppen matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n) or fix_(n) != n):
            error_(char('gallery: N must be a numeric integer for toeppen matrix.'))
        else:
            if (any_(not cellfun_(char('isnumeric'),[a,b,c,d,e])) or any_(cellfun_(char('numel'),[a,b,c,d,e]) != 1)):
                error_(char('gallery: A, B, C, D and E must be numeric scalars for toeppen matrix.'))
    P=spdiags_([a * ones_(n,1),b * ones_(n,1),c * ones_(n,1),d * ones_(n,1),e * ones_(n,1)],arange_(- 2,2),n,n)
    return P
def tridiag_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[n,x,y,z].count(None)+len(args)

    if (nargin != 1 and nargin != 3 and nargin != 4):
        error_(char('gallery: 1, 3, or 4 arguments are required for tridiag matrix.'))
    else:
        if (nargin == 3):
            z=copy_(y)
            y=copy_(x)
            x=copy_(n)
    x=x[:]
    y=y[:]
    z=z[:]
    if (isscalar_(x) and isscalar_(y) and isscalar_(z)):
        x *= ones_(n - 1,1)
        z *= ones_(n - 1,1)
        y *= ones_(n,1)
    else:
        if (numel_(y) != numel_(x) + 1):
            error_(char('gallery: X must have one element less than Y for tridiag matrix.'))
        else:
            if (numel_(y) != numel_(z) + 1):
                error_(char('gallery: Z must have one element less than Y for tridiag matrix.'))
    n=numel_(y)
    T=spdiags_([[[x],[0]],y,[[0],[z]]],arange_(- 1,1),n,n)
    return T
def triw_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[n,alpha,k].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        error_(char('gallery: 1 to 3 arguments are required for triw matrix.'))
    else:
        if (not isnumeric_(n) or all_(numel_(n) != [1,2])):
            error_(char('gallery: N must be a 1 or 2 elements vector for triw matrix.'))
        else:
            if (not isscalar_(alpha)):
                error_(char('gallery: ALPHA must be a scalar for triw matrix.'))
            else:
                if (not isscalar_(k) or not isnumeric_(k) or fix_(k) != k):
                    error_(char('gallery: K must be a numeric integer for triw matrix.'))
    m=n[1]
    n=n[end()]
    t=tril_(eye_(m,n) + alpha * triu_(ones_(m,n),1),k)
    return t
def uniformdata_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 2):
        error_(char('gallery: At least 2 arguments required for uniformdata matrix.'))
    if (isnumeric_(varargin[end()])):
        jidx=varargin[end()]
        svec=matlabarray([varargin[:]])
        varargin[end()]=[]
    else:
        if (ischar_(varargin[end()])):
            if (nargin < 3):
                error_([char('gallery: CLASS argument requires 3 inputs '),char('for uniformdata matrix.')])
            jidx=varargin[end() - 1]
            svec=matlabarray([varargin[1:end() - 1]])
            varargin[end() - 1]=[]
        else:
            error_([char('gallery: J must be an integer in the range [0, 2^32-1] '),char('for uniformdata matrix')])
    if (not (isnumeric_(jidx) and isscalar_(jidx) and jidx == fix_(jidx) and jidx >= 0 and jidx <= 4294967295)):
        error_([char('gallery: J must be an integer in the range [0, 2^32-1] '),char('for uniformdata matrix')])
    randstate=rand_(char('state'))
    try:
        rand_(char('state'),svec)
        A=rand_(varargin[:])
    finally:
        rand_(char('state'),randstate)
    return A
def wathen_(nx=None,ny=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[nx,ny,k].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        error_(char('gallery: 2 or 3 arguments are required for wathen matrix.'))
    else:
        if (not isnumeric_(nx) or not isscalar_(nx) or nx < 1):
            error_(char('gallery: NX must be a positive scalar for wathen matrix.'))
        else:
            if (not isnumeric_(ny) or not isscalar_(ny) or ny < 1):
                error_(char('gallery: NY must be a positive scalar for wathen matrix.'))
            else:
                if (not isscalar_(k)):
                    error_(char('gallery: K must be a scalar for wathen matrix.'))
    e1=matlabarray([6,- 6,2,- 8,- 6,32,- 6,20,2,- 6,6,- 6,- 8,20,- 6,32])
    e2=matlabarray([3,- 8,2,- 6,- 8,16,- 8,20,2,- 8,3,- 8,- 6,20,- 8,16])
    e=[e1,e2,e2.T,e1] / 45
    n=3 * nx * ny + 2 * nx + 2 * ny + 1
    A=sparse_(n,n)
    rho=100 * rand_(nx,ny)
    for j in arange_(1,ny).reshape(-1):
        for i in arange_(1,nx).reshape(-1):
            nn[1]=3 * j * nx + 2 * i + 2 * j + 1
            nn[2]=nn[1] - 1
            nn[3]=nn[2] - 1
            nn[4]=(3 * j - 1) * nx + 2 * j + i - 1
            nn[5]=3 * (j - 1) * nx + 2 * i + 2 * j - 3
            nn[6]=nn[5] + 1
            nn[7]=nn[6] + 1
            nn[8]=nn[4] + 1
            em=e * rho[i,j]
            for krow in arange_(1,8).reshape(-1):
                for kcol in arange_(1,8).reshape(-1):
                    A[nn[krow],nn[kcol]]=A[nn[krow],nn[kcol]] + em[krow,kcol]
    if (k):
        A=numpy.linalg.solve(diag_(diag_(A)),A)
    return A
def wilk_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        error_(char('gallery: 1 argument is required for wilk matrix.'))
    else:
        if (not isnumeric_(n) or not isscalar_(n)):
            error_(char('gallery: N must be a numeric scalar for wilk matrix.'))
    if (n == 3):
        A=matlabarray([1e-10,0.9,- 0.4,0,0.9,- 0.4,0,0,1e-10])
        b=matlabarray([0,0,1])
    else:
        if (n == 4):
            A=matlabarray([9.143e-05,0,0,0,0.8762,7.156e-05,0,0,0.7943,0.8143,9.504e-05,0,0.8017,0.6123,0.7165,7.123e-05])
            b=matlabarray([0.6524,0.3127,0.4186,0.7853])
        else:
            if (n == 5):
                A=hilb_(6)
                A=A[1:5,2:6] * 1.8144
            else:
                if (n == 21):
                    E=diag_(ones_(n - 1,1),1)
                    m=(n - 1) / 2
                    A=diag_(abs_(arange_(- m,m))) + E + E.T
                else:
                    error_(char("gallery: unknown N '%d' for wilk matrix."),n)
    return A,b
def bandred_(A=None,kl=None,ku=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[A,kl,ku].count(None)+len(args)

    flip=copy_(false)
    if (ku == 0):
        flip=copy_(true)
        A=A.T
        ku,kl=deal_(kl,ku,nargout=2)
    m,n=size_(A,nargout=2)
    for j in arange_(1,min_(min_(m,n),max_(m - kl - 1,n - ku - 1))).reshape(-1):
        if (j + kl + 1 <= m):
            v,beta=house_(A[j + kl:m,j],nargout=2)
            temp=A[j + kl:m,j:n]
            A[j + kl:m,j:n]=temp - beta * v * (v.T * temp)
            A[j + kl + 1:m,j]=zeros_(m - j - kl,1)
        if (j + ku + 1 <= n):
            v,beta=house_(A[j,j + ku:n].T,nargout=2)
            temp=A[j:m,j + ku:n]
            A[j:m,j + ku:n]=temp - beta * (temp * v) * v.T
            A[j,j + ku + 1:n]=zeros_(1,n - j - ku)
    if (flip):
        A=A.T
    return A
def rosser_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin != 0):
        print_usage_()
    retval=matlabarray([[611,196,- 192,407,- 8,- 52,- 49,29],[196,899,113,- 192,- 71,- 43,- 8,- 44],[- 192,113,899,196,61,49,8,52],[407,- 192,196,611,8,44,59,- 23],[- 8,- 71,61,8,411,- 599,208,208],[- 52,- 43,49,44,- 599,411,208,208],[- 49,- 8,8,59,208,208,99,- 911],[29,- 44,52,- 23,208,208,- 911,99]])
    return retval
def hilb_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    else:
        if (not isscalar_(n)):
            error_(char('hilb: N must be a scalar integer'))
    retval=zeros_(n)
    tmp=arange_(1,n)
    for i in arange_(1,n).reshape(-1):
        retval[i,:]=1.0 / tmp
        tmp
    return retval
def hankel_(c=None,r=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[c,r].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin == 1):
        if (not isvector_(c)):
            error_(char('hankel: C must be a vector'))
        nr=length_(c)
        nc=copy_(nr)
        data=matlabarray([[c[:]],[zeros_(nr,1)]])
    else:
        if (not (isvector_(c) and isvector_(r))):
            error_(char('hankel: C and R must be vectors'))
        else:
            if (r[1] != c[end()]):
                warning_(char('hankel: column wins anti-diagonal conflict'))
        nr=length_(c)
        nc=length_(r)
        data=matlabarray([[c[:]],[r[2:end()](arange_())]])
    slices=cellslices_(data,arange_(1,nc),arange_(nr,nc + nr - 1,1))
    retval=horzcat_(slices[:])
    return retval
def toeplitz_(c=None,r=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[c,r].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin == 1):
        if (not isvector_(c)):
            error_(char('toeplitz: C must be a vector'))
        r=copy_(c)
        nr=length_(c)
        nc=copy_(nr)
    else:
        if (not (isvector_(c) and isvector_(r))):
            error_(char('toeplitz: C and R must be vectors'))
        else:
            if (r[1] != c[1]):
                warning_(char('toeplitz: column wins diagonal conflict'))
        nr=length_(c)
        nc=length_(r)
    if (nr == 0 or nc == 0):
        retval=zeros_(nr,nc,class_(c))
        return retval
    if (nargin == 1 and iscomplex_(c)):
        c=conj_(c)
        c[1]=conj_(c[1])
    if (issparse_(c) and issparse_(r)):
        c=c[:].T
        r=r[:].T
        cidx=find_(c)
        ridx=find_(r)
        ridx=ridx[ridx > 1]
        retval=spdiags_(repmat_(c[cidx],nr,1),1 - cidx,nr,nc) + spdiags_(repmat_(r[ridx],nr,1),ridx - 1,nr,nc)
    else:
        data=matlabarray([[r[end():- 1:2](arange_())],[c[:]]])
        slices=cellslices_(data,arange_(nc,1,- 1),arange_(nc + nr - 1,nr,- 1))
        retval=horzcat_(slices[:])
    return retval
def hadamard_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    k=0
    while (n > 1 and fix_(n / 2) == n / 2):

        k
        n /= 2

    if (n != 1):
        k -= 2
    if (k < 0):
        n=- 1
    if 1 == (n):
        h=1
    else:
        if 3 == (n):
            h=h12_()
        else:
            if 5 == (n):
                h=h20_()
            else:
                if 7 == (n):
                    h=h28_()
                else:
                    error_(char('hadamard: N must be 2^k*p, for p = 1, 12, 20 or 28'))
    h2=matlabarray([[1,1],[1,- 1]])
    while (true):

        if (fix_(k / 2) != k / 2):
            h=kron_(h2,h)
        k=fix_(k / 2)
        if (k == 0):
            break
        h2=kron_(h2,h2)

    return h
def h12_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    tu=matlabarray([- 1,+ 1,- 1,+ 1,+ 1,+ 1,- 1,- 1,- 1,+ 1,- 1])
    tl=matlabarray([- 1,- 1,+ 1,- 1,- 1,- 1,+ 1,+ 1,+ 1,- 1,+ 1])
    h=ones_(12)
    h[2:end(),2:end()]=toeplitz_(tu,tl)
    return h
def h20_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    tu=matlabarray([+ 1,- 1,- 1,+ 1,+ 1,+ 1,+ 1,- 1,+ 1,- 1,+ 1,- 1,- 1,- 1,- 1,+ 1,+ 1,- 1,- 1])
    tl=matlabarray([+ 1,- 1,- 1,+ 1,+ 1,- 1,- 1,- 1,- 1,+ 1,- 1,+ 1,- 1,+ 1,+ 1,+ 1,+ 1,- 1,- 1])
    h=ones_(20)
    h[2:end(),2:end()]=fliplr_(toeplitz_(tu,tl))
    return h
def h28_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    h=matlabarray([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,- 1,- 1,- 1,- 1,- 1,- 1,- 1,1,- 1,- 1,- 1,1,1,1,1,1,- 1,1,1,1,1,- 1,1,- 1,1,- 1,1,- 1,1,- 1,- 1,- 1,- 1,1,- 1,1,1,- 1,- 1,1,- 1,- 1,- 1,- 1,1,1,- 1,1,- 1,1,1,1,1,1,1,- 1,- 1,1,- 1,- 1,- 1,1,1,1,1,1,- 1,1,1,1,1,1,- 1,- 1,- 1,- 1,- 1,- 1,- 1,1,- 1,1,1,- 1,- 1,- 1,1,- 1,- 1,1,1,- 1,1,1,1,1,1,- 1,- 1,- 1,1,1,1,- 1,1,- 1,1,- 1,- 1,- 1,1,- 1,- 1,- 1,- 1,1,- 1,1,1,- 1,- 1,1,1,- 1,- 1,- 1,1,1,- 1,- 1,- 1,1,1,1,1,1,1,- 1,1,- 1,- 1,- 1,- 1,- 1,1,- 1,1,- 1,- 1,- 1,1,- 1,1,1,1,- 1,1,1,1,1,- 1,1,- 1,1,- 1,1,1,- 1,1,1,1,1,- 1,- 1,1,- 1,- 1,- 1,- 1,1,1,1,- 1,- 1,- 1,- 1,1,- 1,- 1,1,1,1,1,- 1,1,- 1,- 1,1,1,1,1,1,- 1,- 1,- 1,- 1,- 1,1,- 1,- 1,- 1,1,- 1,1,1,1,1,- 1,- 1,1,- 1,1,1,1,1,1,- 1,- 1,- 1,- 1,- 1,- 1,1,1,1,- 1,1,- 1,- 1,- 1,- 1,- 1,1,1,1,- 1,- 1,1,1,1,1,- 1,1,1,1,- 1,- 1,- 1,- 1,1,- 1,1,1,- 1,- 1,- 1,1,1,- 1,1,1,- 1,- 1,1,1,- 1,- 1,1,1,- 1,- 1,1,1,1,- 1,- 1,- 1,1,1,- 1,1,- 1,- 1,1,1,- 1,1,1,- 1,- 1,1,- 1,- 1,1,1,- 1,1,- 1,- 1,- 1,1,1,1,- 1,- 1,1,1,1,- 1,- 1,1,1,- 1,- 1,- 1,- 1,- 1,1,1,1,1,- 1,- 1,1,1,1,1,1,1,- 1,- 1,1,1,- 1,- 1,- 1,- 1,- 1,- 1,1,1,- 1,1,- 1,- 1,1,1,- 1,1,- 1,- 1,1,1,1,- 1,1,1,- 1,1,- 1,1,- 1,1,1,- 1,1,- 1,- 1,1,- 1,- 1,1,- 1,1,- 1,1,- 1,- 1,1,- 1,1,1,- 1,1,- 1,- 1,1,- 1,1,1,1,- 1,- 1,- 1,- 1,- 1,- 1,1,1,- 1,1,- 1,1,1,1,1,- 1,- 1,1,1,- 1,1,- 1,1,1,1,1,1,- 1,- 1,1,- 1,1,- 1,- 1,- 1,- 1,1,- 1,- 1,- 1,- 1,1,- 1,1,1,1,1,- 1,1,- 1,1,- 1,1,- 1,1,- 1,1,1,1,- 1,1,- 1,- 1,1,- 1,1,1,- 1,1,- 1,- 1,- 1,- 1,1,- 1,1,- 1,1,- 1,1,1,1,1,1,- 1,1,- 1,- 1,1,- 1,1,- 1,- 1,1,1,- 1,- 1,- 1,- 1,1,- 1,1,1,1,- 1,1,- 1,1,1,- 1,1,- 1,- 1,1,1,1,- 1,1,- 1,- 1,- 1,- 1,- 1,1,1,- 1,1,- 1,- 1,1,1,- 1,- 1,1,- 1,1,- 1,- 1,- 1,- 1,1,1,1,- 1,1,- 1,1,1,- 1,- 1,- 1,- 1,- 1,1,1,1,1,1,1,1,- 1,- 1,1,1,1,- 1,- 1,1,1,- 1,- 1,- 1,1,1,- 1,- 1,1,1,- 1,- 1,- 1,1,1,- 1,- 1,1,1,- 1,- 1,1,1,- 1,1,- 1,- 1,1,- 1,- 1,- 1,1,- 1,1,1,1,- 1,1,- 1,- 1,1,- 1,- 1,1,1,1,- 1,1,- 1,- 1,1,1,- 1,1,1,- 1,1,- 1,1,- 1,- 1,1,- 1,1,- 1,1,- 1,1,- 1,- 1,- 1,1,1,1,1,1,- 1,1,1,- 1,- 1,1,1,- 1,1,- 1,- 1,1,- 1,- 1,1,1,1,- 1,1,- 1,- 1,- 1,1,- 1,- 1,1,- 1,1,1,- 1,1,1,- 1,- 1,- 1,1,- 1,1,1,1,- 1,1,1,1,- 1,- 1,1,- 1,- 1,1,- 1,- 1,- 1,1,1,1,- 1,- 1,1,- 1,- 1,1,- 1,1,- 1,1,1,- 1,1,- 1,1,- 1,1,- 1,- 1,1,1,- 1,- 1,- 1,1,1,- 1,1,1,- 1,- 1,1,1,- 1,- 1,- 1,1,- 1,- 1,1,1,- 1,1,1,1,- 1,- 1,1,1,- 1,- 1,1,- 1])
    return h
def invhilb_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    else:
        if (not isscalar_(n)):
            error_(char('invhilb: N must be a scalar integer'))
    retval=zeros_(n)
    k=matlabarray([arange_(1,n)])
    p=k.dot(bincoeff_(k + n - 1,k - 1)).dot(bincoeff_(n,k))
    p[2:2:n]=- p[2:2:n]
    if (n < 203):
        for l in arange_(1,n).reshape(-1):
            retval[l,:]=(p[l] * p) / [arange_(l,l + n - 1)]
    else:
        for l in arange_(1,n).reshape(-1):
            retval[l,:]=p[l] * (p / [arange_(l,l + n - 1)])
    return retval
def javaArray_(classname=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[classname].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    retval=javaMethod_(char('createArray'),char('org.octave.ClassHelper'),classname,[varargin[:]])
    return retval
def javarmpath_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    for i in arange_(1,numel_(varargin)).reshape(-1):
        clspath=varargin[i]
        if (not ischar_(clspath)):
            error_(char('javarmpath: CLSPATH must be a string'))
        old_path=canonicalize_file_name_(tilde_expand_(clspath))
        if (exist_(old_path,char('dir'))):
            if (old_path[end()] != filesep_()):
                old_path=matlabarray([old_path,filesep_()])
        success=javaMethod_(char('removeClassPath'),char('org.octave.ClassHelper'),old_path)
        if (not success):
            warning_(char('javarmpath: %s: not found in Java classpath'),old_path)
    return
def javaclasspath_(which=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[which].count(None)+len(args)

    dynamic_path=javaMethod_(char('getClassPath'),char('org.octave.ClassHelper'))
    dynamic_path_list=ostrsplit_(dynamic_path,pathsep_())
    static_path=javaMethod_(char('getProperty'),char('java.lang.System'),char('java.class.path'))
    static_path_list=ostrsplit_(static_path,pathsep_())
    if (numel_(static_path_list) > 1):
        static_path_list[1]=[]
    else:
        static_path_list=[]
    if 0 == (nargin):
        if 0 == (nargout):
            disp_path_list_(char('STATIC'),static_path_list)
            disp_(char(''))
            disp_path_list_(char('DYNAMIC'),dynamic_path_list)
        else:
            if 1 == (nargout):
                varargout[1]=cellstr_(dynamic_path_list)
            else:
                if 2 == (nargout):
                    varargout[1]=cellstr_(dynamic_path_list)
                    varargout[2]=cellstr_(static_path_list)
    else:
        if 1 == (nargin):
            if 0 == (nargout):
                if (strcmp_(which,char('-static'))):
                    disp_path_list_(char('STATIC'),static_path_list)
                else:
                    if (strcmp_(which,char('-dynamic'))):
                        disp_path_list_(char('DYNAMIC'),dynamic_path_list)
                    else:
                        if (strcmp_(which,char('-all')) == 1):
                            disp_path_list_(char('STATIC'),static_path_list)
                            disp_(char(''))
                            disp_path_list_(char('DYNAMIC'),dynamic_path_list)
            else:
                if 1 == (nargout):
                    if (strcmp_(which,char('-static')) == 1):
                        varargout[1]=cellstr_(static_path_list)
                    else:
                        if (strcmp_(which,char('-dynamic')) == 1):
                            varargout[1]=cellstr_(dynamic_path_list)
                        else:
                            if (strcmp_(which,char('-all')) == 1):
                                varargout[1]=cellstr_([static_path_list,dynamic_path_list])
    return varargout
def disp_path_list_(which=None,path_list=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[which,path_list].count(None)+len(args)

    printf_(char('   %s JAVA PATH\n\n'),which)
    if (numel_(path_list) > 0):
        printf_(char('      %s\n'),path_list[:])
    else:
        printf_(char('      - empty -\n'))
    return
def javamem_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    rt=javaMethod_(char('getRuntime'),char('java.lang.Runtime'))
    rt.gc
    jvmem=cell_(3,1)
    jvmem[1]=rt.maxMemory()
    jvmem[2]=rt.totalMemory()
    jvmem[3]=rt.freeMemory()
    if (nargout == 0):
        printf_(char('\nJava virtual machine (JVM) memory info:\n'))
        printf_(char('Maximum available memory:        %5d MiB;\n'),jvmem[1] / 1024 / 1024)
        printf_(char('   (...running garbage collector...)\n'))
        printf_(char('OK, current status:\n'))
        printf_(char('Total memory in virtual machine: %5d MiB;\n'),jvmem[2] / 1024 / 1024)
        printf_(char('Free memory in virtual machine:  %5d MiB;\n'),jvmem[3] / 1024 / 1024)
        printf_(char('%d CPUs available.\n'),rt.availableProcessors())
    else:
        jmem=copy_(jvmem)
    return jmem
def javaaddpath_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    for i in arange_(1,numel_(varargin)).reshape(-1):
        clspath=varargin[i]
        if (not ischar_(clspath)):
            error_(char('javaaddpath: CLSPATH must be a string'))
        new_path=canonicalize_file_name_(tilde_expand_(clspath))
        if (exist_(new_path,char('dir'))):
            if (new_path[end()] != filesep_()):
                new_path=matlabarray([new_path,filesep_()])
        else:
            if (not exist_(new_path,char('file'))):
                error_(char('javaaddpath: CLSPATH does not exist: %s'),clspath)
        success=javaMethod_(char('addClassPath'),char('org.octave.ClassHelper'),new_path)
        if (not success):
            warning_(char("javaaddpath: failed to add '%s' to Java classpath"),new_path)
    return
def usejava_(feature=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[feature].count(None)+len(args)

    if (nargin != 1 or not ischar_(feature)):
        print_usage_()
    retval=copy_(false)
    if char('awt') == feature:
        try:
            dum=methods_(char('java.awt.Frame'))
            retval=copy_(true)
        finally:
            pass
    else:
        if char('desktop') == feature:
            pass
        else:
            if char('jvm') == feature:
                try:
                    dum=methods_(char('java.lang.Runtime'))
                    retval=copy_(true)
                finally:
                    pass
            else:
                if char('swing') == feature:
                    try:
                        dum=methods_(char('javax.swing.Popup'))
                        retval=copy_(true)
                    finally:
                        pass
                else:
                    error_(char("usejava: unrecognized feature '%s'"),feature)
    return retval
def griddata_(x=None,y=None,z=None,xi=None,yi=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[x,y,z,xi,yi,method].count(None)+len(args)

    if (nargin < 5 or nargin > 7):
        print_usage_()
    if (ischar_(method)):
        method=tolower_(method)
    if (isvector_(x) and isvector_(y) and all_([numel_(y),numel_(x)] == size_(z))):
        x,y=meshgrid_(x,y,nargout=2)
    if (isvector_(x) and isvector_(y) and isvector_(z)):
        if (not isequal_(length_(x),length_(y),length_(z))):
            error_(char('griddata: X, Y, and Z must be vectors of the same length'))
    else:
        if (not size_equal_(x,y,z)):
            error_(char('griddata: lengths of X, Y must match the columns and rows of Z'))
    if (rows_(xi) == 1 and columns_(yi) == 1):
        xi,yi=meshgrid_(xi,yi,nargout=2)
    else:
        if (isvector_(xi) and isvector_(yi)):
            xi=xi[:]
            yi=yi[:]
    if (not size_equal_(xi,yi)):
        error_(char('griddata: XI and YI must be vectors or matrices of same size'))
    x=x[:]
    y=y[:]
    z=z[:]
    tri=delaunay_(x,y)
    zi=NaN_(size_(xi))
    if (strcmp_(method,char('cubic'))):
        error_(char('griddata: cubic interpolation not yet implemented'))
    else:
        if (strcmp_(method,char('nearest'))):
            idx=dsearch_(x,y,tri,xi,yi)
            valid=not isnan_(idx)
            zi[valid]=z[idx[valid]]
        else:
            if (strcmp_(method,char('linear'))):
                tri_list=tsearch_(x,y,tri,xi[:],yi[:])
                valid=not isnan_(tri_list)
                tri_list=tri_list[valid]
                nr_t=rows_(tri_list)
                tri=tri[tri_list,:]
                x1=x[tri[:,1]]
                x2=x[tri[:,2]]
                x3=x[tri[:,3]]
                y1=y[tri[:,1]]
                y2=y[tri[:,2]]
                y3=y[tri[:,3]]
                z1=z[tri[:,1]]
                z2=z[tri[:,2]]
                z3=z[tri[:,3]]
                N=cross_([x2 - x1,y2 - y1,z2 - z1],[x3 - x1,y3 - y1,z3 - z1])
                N=numpy.linalg.solve(diag_(norm_(N,char('rows'))),N)
                D=- (N[:,1].dot(x1) + N[:,2].dot(y1) + N[:,3].dot(z1))
                zi[valid]=- (N[:,1].dot(xi[:](valid)) + N[:,2].dot(yi[:](valid)) + D) / N[:,3]
            else:
                error_(char('griddata: unknown interpolation METHOD'))
    if (nargout == 3):
        rx=copy_(xi)
        ry=copy_(yi)
        rz=copy_(zi)
    else:
        if (nargout == 1):
            rx=copy_(zi)
        else:
            if (nargout == 0):
                mesh_(xi,yi,zi)
    return rx,ry,rz
def delaunay3_(x=None,y=None,z=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,y,z,options].count(None)+len(args)

    if (nargin < 3 or nargin > 4):
        print_usage_()
    if (not (isvector_(x) and isvector_(y) and isvector_(z) and length_(x) == length_(y) and length_(x) == length_(z))):
        error_(char('delaunay: X, Y, and Z must be the same size'))
    else:
        if (nargin == 4 and not (ischar_(options) or iscellstr_(options))):
            error_(char('delaunay3: OPTIONS must be a string or cell array of strings'))
    if (nargin == 3):
        tetr=delaunayn_([x[:],y[:],z[:]])
    else:
        tetr=delaunayn_([x[:],y[:],z[:]],options)
    return tetr
def convhull_(x=None,y=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,options].count(None)+len(args)

    if (nargin != 2 and nargin != 3):
        print_usage_()
    x=x[:]
    y=y[:]
    if (length_(x) != length_(y)):
        error_(char('convhull: X and Y must have the same size'))
    else:
        if (nargin == 3 and not (ischar_(options) or iscellstr_(options))):
            error_(char('convhull: OPTIONS must be a string or cell array of strings'))
    if (nargin == 2):
        i=convhulln_([x,y])
    else:
        i=convhulln_([x,y],options)
    n=rows_(i)
    i=i.T(arange_())
    H=zeros_(n + 1,1)
    H[1]=i[1]
    next_i=i[2]
    i[2]=0
    for k in arange_(2,n).reshape(-1):
        next_idx=find_(i == next_i)
        if (rem_(next_idx,2) == 0):
            H[k]=i[next_idx]
            next_i=i[next_idx - 1]
            i[next_idx - 1]=0
        else:
            H[k]=i[next_idx]
            next_i=i[next_idx + 1]
            i[next_idx + 1]=0
    H[n + 1]=H[1]
    return H
def delaunayn_(pts=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[pts].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    T=__delaunayn___(pts,varargin[:])
    if (isa_(pts,char('single'))):
        myeps=eps_(char('single'))
    else:
        myeps=copy_(eps)
    idx=matlabarray([])
    nt,n=size_(T,nargout=2)
    for i in arange_(1,nt).reshape(-1):
        X=pts[T[i,1:end() - 1],:] - pts[T[i,2:end()],:]
        if (abs_(det_(X)) / sqrt_(sum_(X ** 2,2)) < 1000.0 * myeps):
            idx[end() + 1]=i
    T[idx,:]=[]
    return T
def voronoi_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    narg=1
    if (isscalar_(varargin[1]) and ishandle_(varargin[1])):
        hax=varargin[1]
        if (not isaxes_(harg)):
            error_(char('imagesc: HAX argument must be an axes object'))
        narg
    else:
        if (nargout < 2):
            hax=gca_()
    if (nargin < 1 + narg or nargin > 3 + narg):
        print_usage_()
    x=varargin[narg]
    y=varargin[narg]
    opts=[]
    if (narg <= nargin):
        if (iscell_(varargin[narg])):
            opts=varargin[narg]
        else:
            if (isnumeric_(varargin[narg])):
                narg
    linespec=[char('b')]
    if (narg <= nargin and ischar_(varargin[narg])):
        linespec=varargin[narg]
    if (length_(x) != length_(y)):
        error_(char('voronoi: X and Y must be vectors of the same length'))
    xmax=max_(x[:])
    xmin=min_(x[:])
    ymax=max_(y[:])
    ymin=min_(y[:])
    xdelta=xmax - xmin
    ydelta=ymax - ymin
    scale=2
    xbox=matlabarray([[xmin - scale * xdelta],[xmin - scale * xdelta],[xmax + scale * xdelta],[xmax + scale * xdelta]])
    ybox=matlabarray([[ymin - scale * ydelta],[ymax + scale * ydelta],[ymax + scale * ydelta],[ymin - scale * ydelta]])
    p,c,infi=__voronoi___(char('voronoi'),[[[x[:]],[xbox[:]]],[[y[:]],[ybox[:]]]],opts[:],nargout=3)
    c=c[not infi].T
    c[cellfun_(char('isempty'),c)]=[]
    edges=cell2mat_(cellfun_(lambda x: [[x],[[x[end()],x[1:end() - 1]]]],c,char('uniformoutput'),false))
    edges=sortrows_(sort_(edges).T).T
    edges=edges[:,[(edges[1,1:end() - 1] != edges[1,2:end()] or edges[2,1:end() - 1] != edges[2,2:end()]),true]]
    poutside=(arange_(1,rows_(p)))(p[:,1] < xmin - xdelta or p[:,1] > xmax + xdelta or p[:,2] < ymin - ydelta or p[:,2] > ymax + ydelta)
    edgeoutside=ismember_(edges[1,:],poutside) and ismember_(edges[2,:],poutside)
    edges[:,edgeoutside]=[]
    Vvx=reshape_(p[edges,1],size_(edges))
    Vvy=reshape_(p[edges,2],size_(edges))
    if (nargout < 2):
        h=plot_(hax,Vvx,Vvy,linespec[:],x,y,char('+'))
        lim=matlabarray([xmin,xmax,ymin,ymax])
        axis_(lim + 0.1 * [[- 1,1] * xdelta,[- 1,1] * ydelta])
        if (nargout == 1):
            vx=copy_(h)
    else:
        vx=copy_(Vvx)
        vy=copy_(Vvy)
    return vx,vy
def rectint_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    else:
        if (ndims_(a) != 2 or ndims_(b) != 2):
            error_(char('rectint: expecting arguments to be 2-d arrays'))
        else:
            if (columns_(a) != 4):
                error_(char('rectint: A must have 4 columns'))
            else:
                if (columns_(b) != 4):
                    error_(char('rectint: B must have 4 columns'))
                else:
                    if (any_([[a[:,3:4]],[b[:,3:4]]](arange_()) < 0)):
                        error_(char('rectint: all widths and heights must be > 0'))
    swapinputs=false_()
    if (rows_(a) > rows_(b)):
        tmp=copy_(a)
        a=copy_(b)
        b=copy_(tmp)
        swapinputs=true_()
    area=zeros_(rows_(a),rows_(b))
    r1=matlabarray([a[:,1:2],a[:,1:2] + a[:,3:4]])
    r2=matlabarray([b[:,1:2],b[:,1:2] + b[:,3:4]])
    for i in arange_(1,columns_(area)).reshape(-1):
        r1x1small=r1[:,1] < r2[i,1]
        r1x1large=r1[:,1] > r2[i,3]
        r1x1mid=(r1[:,1] >= r2[i,1]) and (r1[:,1] <= r2[i,3])
        r1x2small=r1[:,3] < r2[i,1]
        r1x2large=r1[:,3] > r2[i,3]
        r1x2mid=(r1[:,3] >= r2[i,1]) and (r1[:,3] <= r2[i,3])
        r1y1small=r1[:,2] < r2[i,2]
        r1y1large=r1[:,2] > r2[i,4]
        r1y1mid=(r1[:,2] >= r2[i,2]) and (r1[:,2] <= r2[i,4])
        r1y2small=r1[:,4] < r2[i,2]
        r1y2large=r1[:,4] > r2[i,4]
        r1y2mid=(r1[:,4] >= r2[i,2]) and (r1[:,4] <= r2[i,4])
        area[r1x1small and r1x2large,i]=r2[i,3] - r2[i,1]
        mask=r1x1small and r1x2mid
        area[mask,i]=r1[mask,3] - r2[i,1]
        mask=r1x1mid and r1x2large
        area[mask,i]=r2[i,3] - r1[mask,1]
        mask=r1x1mid and r1x2mid
        area[mask,i]=r1[mask,3] - r1[mask,1]
        area[r1y1small and r1y2large,i] .*= r2[i,4] - r2[i,2]
        mask=r1y1small and r1y2mid
        area[mask,i] .*= r1[mask,4] - r2[i,2]
        mask=r1y1mid and r1y2large
        area[mask,i] .*= r2[i,4] - r1[mask,2]
        mask=r1y1mid and r1y2mid
        area[mask,i] .*= r1[mask,4] - r1[mask,2]
    if (swapinputs):
        area=area.T
    return area
def griddata3_(x=None,y=None,z=None,v=None,xi=None,yi=None,zi=None,method=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 8-[x,y,z,v,xi,yi,zi,method].count(None)+len(args)

    if (nargin < 7):
        print_usage_()
    if (isvector_(x) and isvector_(y) and isvector_(z) and isvector_(v)):
        if (not isequal_(length_(x),length_(y),length_(z),length_(v))):
            error_(char('griddata: X, Y, Z, and V must be vectors of the same length'))
    else:
        if (not size_equal_(x,y,z,v)):
            error_(char('griddata: X, Y, Z, and V must have equal sizes'))
    if (isvector_(xi) and isvector_(yi) and isvector_(zi)):
        if (not isequal_(length_(xi),length_(yi),length_(zi))):
            xi,yi,zi=meshgrid_(xi,yi,zi,nargout=3)
        else:
            xi=xi[:]
            yi=yi[:]
            zi=zi[:]
    if (not size_equal_(xi,yi,zi)):
        error_(char('griddata3: XI, YI, and ZI must be vectors or matrices of the same size'))
    vi=griddatan_([x[:],y[:],z[:]],v[:],[xi[:],yi[:],zi[:]],varargin[:])
    vi=reshape_(vi,size_(xi))
    return vi
def dsearch_(x=None,y=None,tri=None,xi=None,yi=None,s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[x,y,tri,xi,yi,s].count(None)+len(args)

    if (nargin < 5 or nargin > 6):
        print_usage_()
    idx=__dsearchn___([x[:],y[:]],[xi[:],yi[:]])
    return idx
def inpolygon_(x=None,y=None,xv=None,yv=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,y,xv,yv].count(None)+len(args)

    if (nargin != 4):
        print_usage_()
    if (not (isreal_(x) and isreal_(y) and ismatrix_(y) and ismatrix_(y) and size_equal_(x,y))):
        error_(char('inpolygon: first two arguments must be real matrices of same size'))
    else:
        if (not (isreal_(xv) and isreal_(yv) and isvector_(xv) and isvector_(yv) and size_equal_(xv,yv))):
            error_(char('inpolygon: last two arguments must be real vectors of same size'))
    npol=length_(xv)
    do_boundary=(nargout >= 2)
    _in=zeros_(size_(x),char('logical'))
    if (do_boundary):
        on=zeros_(size_(x),char('logical'))
    j=copy_(npol)
    for i in arange_(1,npol).reshape(-1):
        delta_xv=xv[j] - xv[i]
        delta_yv=yv[j] - yv[i]
        distance=delta_xv.dot((y - yv[i])) - (x - xv[i]).dot(delta_yv)
        idx1=(((yv[i] <= y and y < yv[j]) or (yv[j] <= y and y < yv[i])) and 0 < distance.dot(delta_yv))
        _in[idx1]=not _in[idx1]
        if (do_boundary):
            idx2=(((yv[i] <= y and y <= yv[j]) or (yv[j] <= y and y <= yv[i])) and ((xv[i] <= x and x <= xv[j]) or (xv[j] <= x and x <= xv[i])) and (0 == distance or not delta_xv))
            on[idx2]=true
        j=copy_(i)
    return _in,on
def griddatan_(x=None,y=None,xi=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,y,xi,method].count(None)+len(args)

    if (nargin < 3):
        print_usage_()
    if (ischar_(method)):
        method=tolower_(method)
    m,n=size_(x,nargout=2)
    mi,ni=size_(xi,nargout=2)
    if (n != ni or rows_(y) != m or columns_(y) != 1):
        error_(char('griddatan: dimensional mismatch'))
    tri=delaunayn_(x,varargin[:])
    yi=NaN_(mi,1)
    if (strcmp_(method,char('nearest'))):
        idx=dsearchn_(x,tri,xi)
        valid=not isnan_(idx)
        yi[valid]=y[idx[valid]]
    else:
        if (strcmp_(method,char('linear'))):
            tri_list,bary_list=tsearchn_(x,tri,xi,nargout=2)
            valid=not isnan_(tri_list)
            tri_list=tri_list[not isnan_(tri_list)]
            bary_list=bary_list[not isnan_(tri_list),:]
            nr_t=rows_(tri_list)
            xt=reshape_(x[tri[tri_list,:],:],[nr_t,n + 1,n])
            yt=y[tri[tri_list,:]]
            yi[valid]=sum_(y[tri[tri_list,:]].dot(bary_list),2)
        else:
            error_(char('griddatan: unknown interpolation METHOD'))
    return yi
def voronoin_(pts=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[pts,options].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    np,dim=size_(pts,nargout=2)
    if (np <= dim):
        error_(char('voronoin: number of points must be greater than their dimension'))
    caller=char('voronoin')
    if (nargin == 1):
        C,F=__voronoi___(caller,pts,nargout=2)
    else:
        C,F=__voronoi___(caller,pts,options,nargout=2)
    return C,F
def tsearchn_(x=None,t=None,xi=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,t,xi].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    nt=rows_(t)
    m,n=size_(x,nargout=2)
    mi=rows_(xi)
    idx=NaN_(mi,1)
    p=NaN_(mi,n + 1)
    ni=[arange_(1,mi)].T
    for i in arange_(1,nt).reshape(-1):
        b=cart2bary_(x[t[i,:],:],xi[ni,:])
        intri=all_(b >= - 1e-12,2)
        idx[ni[intri]]=i
        p[ni[intri],:]=b[intri,:]
        ni[intri]=[]
    return idx,p
def cart2bary_(T=None,P=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[T,P].count(None)+len(args)

    M,N=size_(P,nargout=2)
    Beta=(P - ones_(M,1) * T[end(),:]) / (T[1:end() - 1,:] - ones_(N,1) * T[end(),:])
    Beta[:,end() + 1]=1 - sum_(Beta,2)
    return Beta
def dsearchn_(x=None,tri=None,xi=None,outval=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,tri,xi,outval].count(None)+len(args)

    if (nargin < 2 or nargin > 4):
        print_usage_()
    if (nargin == 2):
        idx,d=__dsearchn___(x,tri,nargout=2)
    else:
        idx,d=__dsearchn___(x,xi,nargout=2)
        if (nargin == 4):
            idx2=isnan_(tsearchn_(x,tri,xi))
            idx[idx2]=outval
            d[idx2]=outval
    return idx,d
def delaunay_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    options=matlabarray([])
    if 1 == (nargin):
        if (not ismatrix_(varargin[1]) or columns_(varargin[1]) != 2):
            error_(char('delaunay: X must be a matrix with 2 columns'))
        else:
            x=varargin[1](arange_(),1)
            y=varargin[1](arange_(),2)
    else:
        if 2 == (nargin):
            if (isnumeric_(varargin[2])):
                x=varargin[1]
                y=varargin[2]
            else:
                if (ischar_(varargin[2]) or iscellstr_(varargin[2])):
                    options=varargin[2]
                    if (not ismatrix_(varargin[1]) and columns_(varargin[1]) != 2):
                        error_(char('delaunay: X must be a matrix with 2 columns'))
                    else:
                        x=varargin[1](arange_(),1)
                        y=varargin[1](arange_(),2)
                else:
                    error_(char('delaunay: OPTIONS must be a string or cell array of strings'))
        else:
            if 3 == (nargin):
                x=varargin[1]
                y=varargin[2]
                options=varargin[3]
                if (not (ischar_(options) or iscellstr_(options))):
                    error_(char('delaunay: OPTIONS must be a string or cell array of strings'))
    if (not (isequal_(size_(x),size_(y)))):
        error_(char('delaunay: X and Y must be the same size'))
    T=delaunayn_([x[:],y[:]],options)
    if (nargout == 0):
        x=x[:].T
        y=y[:].T
        VX=matlabarray([[x[T[:,1]]],[x[T[:,2]]],[x[T[:,3]]],[x[T[:,1]]]])
        VY=matlabarray([[y[T[:,1]]],[y[T[:,2]]],[y[T[:,3]]],[y[T[:,1]]]])
        plot_(VX,VY,char('b'),x,y,char('r*'))
    else:
        tri=copy_(T)
    return tri
def ctime_(t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[t].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    retval=asctime_(localtime_(t))
    return retval
def is_leap_year_(year=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[year].count(None)+len(args)

    if (nargin > 1):
        print_usage_()
    if (nargin == 0):
        t=clock_()
        year=t[1]
    retval=(rem_(year,4) == 0 and rem_(year,100) != 0) or (rem_(year,400) == 0)
    return retval
def calendar_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if 0 == (nargin):
        v=clock_()
        y=v[1]
        m=v[2]
        d=v[3]
    else:
        if 1 == (nargin):
            v=datevec_(varargin[1])
            y=v[1]
            m=v[2]
            d=v[3]
        else:
            if 2 == (nargin):
                y=varargin[1]
                m=varargin[2]
                d=matlabarray([])
            else:
                print_usage_()
    c=zeros_(7,6)
    dayone=datenum_(y,m,1)
    ndays=eomday_(y,m)
    c[weekday_(dayone) - 1 + [arange_(1,ndays)]]=arange_(1,ndays)
    if (nargout > 0):
        varargout[1]=c.T
    else:
        _str=sprintf_(char('    %2d    %2d    %2d    %2d    %2d    %2d    %2d\n'),c)
        if (not isempty_(d)):
            pos=weekday_(dayone) + d - 1
            idx=6 * pos + fix_(pos / 7.1) - ifelse_(d < 10,1,2)
            _str[idx]=char('*')
        s.year=y - 1900
        s.mon=m - 1
        puts_(strftime_(char('                    %b %Y\n'),s))
        puts_(char('     S     M    Tu     W    Th     F     S\n'))
        puts_(_str)
    return varargout
def asctime_(tm_struct=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[tm_struct].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    retval=strftime_(char('%a %b %d %H:%M:%S %Y\n'),tm_struct)
    return retval
def eomday_(y=None,m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[y,m].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    eom=matlabarray([31,28,31,30,31,30,31,31,30,31,30,31])
    e=reshape_(eom[m],size_(m))
    e += (m == 2) and (mod_(y,4) == 0 and (mod_(y,100) != 0 or mod_(y,400) == 0))
    return e
def clock_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    tm=localtime_(time_())
    retval=zeros_(1,6)
    retval[1]=tm.year + 1900
    retval[2]=tm.mon + 1
    retval[3]=tm.mday
    retval[4]=tm.hour
    retval[5]=tm.min
    retval[6]=tm.sec + tm.usec / 1000000.0
    return retval
def date_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    retval=strftime_(char('%d-%b-%Y'),localtime_(time_()))
    return retval
def etime_(t2=None,t1=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[t2,t1].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    __,s2=datenum_(t2,nargout=2)
    __,s1=datenum_(t1,nargout=2)
    secs=s2 - s1
    return secs
def now_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin != 0):
        print_usage_()
    t=datenum_(clock_())
    return t
def weekday_(d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[d,_format].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (iscellstr_(d) or isnumeric_(d)):
        endsize=size_(d)
    else:
        if (ischar_(d)):
            endsize=matlabarray([rows_(d),1])
    if (ischar_(d) or iscellstr_(d)):
        d=datenum_(d)
    d=floor_(reshape_(mod_(d - 733048,7),endsize))
    d[not d]=7
    if (isargout_(2)):
        if (strcmpi_(_format,char('long'))):
            names=[char('Sunday'),char('Monday'),char('Tuesday'),char('Wednesday'),char('Thursday'),char('Friday'),char('Saturday')]
        else:
            names=[char('Sun'),char('Mon'),char('Tue'),char('Wed'),char('Thu'),char('Fri'),char('Sat')]
        s=strvcat_(names[d])
    return d,s
def swapbytes_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    clx=class_(x)
    if (strcmp_(clx,char('int8')) or strcmp_(clx,char('uint8')) or isempty_(x)):
        y=copy_(x)
    else:
        if (strcmp_(clx,char('int16')) or strcmp_(clx,char('uint16'))):
            nb=2
        else:
            if (strcmp_(clx,char('int32')) or strcmp_(clx,char('uint32'))):
                nb=4
            else:
                if (strcmp_(clx,char('int64')) or strcmp_(clx,char('uint64')) or strcmp_(clx,char('double'))):
                    nb=8
                else:
                    error_(char('swapbytes: invalid class of object'))
        y=reshape_(typecast_(reshape_(typecast_(x[:],char('uint8')),nb,numel_(x))([arange_(nb,1,- 1)],arange_())(arange_()),clx),size_(x))
    return y
def perl_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[scriptfile].count(None)+len(args)

    if (ischar_(scriptfile) and ((nargin == 1 and not isempty_(scriptfile)) or (nargin != 1 and iscellstr_(varargin)))):
        if (not strcmp_(scriptfile[1:2],char('-e'))):
            scriptfile=file_in_loadpath_(scriptfile)
        status,output=system_([char('perl '),scriptfile,sprintf_(char(' %s'),varargin[:])],nargout=2)
    else:
        error_(char('perl: invalid arguments'))
    return output,status
def dump_prefs_(file=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[_file].count(None)+len(args)

    if (nargin == 0):
        _file=copy_(stdout)
    sym_list=matlabarray([[char('EDITOR')],[char('EXEC_PATH')],[char('IMAGE_PATH')],[char('PAGER')],[char('PS1')],[char('PS2')],[char('PS4')],[char('beep_on_error')],[char('completion_append_char')],[char('crash_dumps_octave_core')],[char('echo_executing_commands')],[char('fixed_point_format')],[char('gnuplot_binary')],[char('gnuplot_command_end')],[char('gnuplot_command_plot')],[char('gnuplot_command_replot')],[char('gnuplot_command_splot')],[char('gnuplot_command_title')],[char('gnuplot_command_using')],[char('gnuplot_command_with')],[char('history_file')],[char('history_size')],[char('ignore_function_time_stamp')],[char('info_file')],[char('info_program')],[char('makeinfo_program')],[char('max_recursion_depth')],[char('output_max_field_width')],[char('output_precision')],[char('page_output_immediately')],[char('page_screen_output')],[char('print_answer_id_name')],[char('print_empty_dimensions')],[char('save_precision')],[char('saving_history')],[char('sighup_dumps_octave_core')],[char('sigterm_dumps_octave_core')],[char('silent_functions')],[char('split_long_rows')],[char('string_fill_char')],[char('struct_levels_to_print')],[char('suppress_verbose_help_message')]])
    for i in arange_(1,rows_(sym_list)).reshape(-1):
        sym=deblank_(sym_list[i,:])
        try:
            val=feval_(sym)
            if (isnumeric_(val)):
                val=sprintf_(char('%g'),val)
            fprintf_(_file,char('  %s = %s\n'),sym,val)
        finally:
            pass
    return
def copyfile_(f1=None,f2=None,force=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[f1,f2,force].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    max_cmd_line=1024
    status=copy_(true)
    msg=char('')
    msgid=char('')
    if (ispc_() and not isunix_() and isempty_(file_in_path_(getenv_(char('PATH')),char('cp.exe')))):
        cmd=char('cmd /C xcopy /E')
        cmd_force_flag=char('/Y')
    else:
        cmd=char('cp -r')
        cmd_force_flag=char('-f')
    if (not (ischar_(f1) or iscellstr_(f1))):
        error_(char('copyfile: F1 must be a character string or a cell array of character strings'))
    if (not ischar_(f2)):
        error_(char('copyfile: F2 must be a character string'))
    if (nargin == 3 and strcmp_(force,char('f'))):
        cmd=matlabarray([cmd,char(' '),cmd_force_flag])
    if (ischar_(f1)):
        f1=cellstr_(f1)
    isdir=(exist_(f2,char('dir')) != 0)
    if (length_(f1) > 1 and not isdir):
        error_(char('copyfile: when copying multiple files, F2 must be a directory'))
    f1=glob_(f1)
    if (isempty_(f1)):
        error_(char('copyfile: no files to move'))
    p1=sprintf_(char('"%s" '),f1[:])
    p2=tilde_expand_(f2)
    if (isdir and length_(p1) > max_cmd_line):
        l2=length_(p2) + length_(cmd) + 6
        while (not isempty_(f1)):

            p1=sprintf_(char('"%s" '),f1[1])
            f1[1]=[]
            while (not isempty_(f1) and (length_(p1) + length_(f1[1]) + l2 < max_cmd_line)):

                p1=sprintf_(char('%s"%s" '),p1,f1[1])
                f1[1]=[]

            if (ispc_() and not isunix_() and not isempty_(file_in_path_(getenv_(char('PATH')),char('cp.exe')))):
                p1=strrep_(p1,char('\\'),char('/'))
                p2=strrep_(p2,char('\\'),char('/'))
            err,msg=system_(sprintf_(char('%s %s"%s"'),cmd,p1,p2),nargout=2)
            if (err != 0):
                status=copy_(false)
                msgid=char('copyfile')
                break

    else:
        if (ispc_() and not isunix_() and not isempty_(file_in_path_(getenv_(char('PATH')),char('cp.exe')))):
            p1=strrep_(p1,char('\\'),char('/'))
            p2=strrep_(p2,char('\\'),char('/'))
        err,msg=system_(sprintf_(char('%s %s"%s"'),cmd,p1,p2),nargout=2)
        if (err != 0):
            status=copy_(false)
            msgid=char('copyfile')
    return status,msg,msgid
def substruct_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    nargs=copy_(nargin)
    if (nargs > 1 and mod_(nargs,2) == 0):
        typ=varargin[1:2:nargs]
        sub=varargin[2:2:nargs]
        braces=strcmp_(typ,char('()')) or strcmp_(typ,char('{}'))
        dots=strcmp_(typ,char('.'))
        if (all_(braces or dots)):
            cells=cellfun_(char('isclass'),sub,char('cell'))
            chars=cellfun_(char('isclass'),sub,char('char'))
            if (any_(braces and not cells)):
                error_(char('substruct: for TYPE == () or {}, SUBS must be a cell array'))
            else:
                if (any_(dots and not chars)):
                    error_(char('substruct: for TYPE == ., SUBS must be a character string'))
        else:
            error_(char('substruct: expecting TYPE to be one of "()", "{}", or "."'))
        retval=struct_(char('type'),typ,char('subs'),sub)
    else:
        print_usage_()
    return retval
def zip_(zipfile=None,files=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[zipfile,files,rootdir].count(None)+len(args)

    if (nargin != 2 and nargin != 3):
        print_usage_()
    rootdir=tilde_expand_(rootdir)
    if (ischar_(files)):
        files=cellstr_(files)
    if (not ischar_(zipfile) and not iscellstr_(files)):
        error_(char('zip: expecting all arguments to be character strings'))
    cmd=sprintf_(char('cd %s; zip -r %s/%s %s'),rootdir,pwd_(),zipfile,sprintf_(char(' %s'),files[:]))
    status,output=system_(cmd,nargout=2)
    if (status):
        error_(char('zip: zip failed with exit status = %d'),status)
    if (nargout > 0):
        cmd=sprintf_(char('unzip -Z -1 %s'),zipfile)
        status,entries=system_(cmd,nargout=2)
        if (status):
            error_(char('zip: zipinfo failed with exit status = %d'),status)
        if (entries[end()] == char('\n')):
            entries[end()]=[]
        entries=ostrsplit_(entries,char('\n'))
    return entries
def ver_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[package].count(None)+len(args)

    if (nargin > 1):
        print_usage_()
    ret=struct_(char('Name'),char('Octave'),char('Version'),version,char('Release'),[],char('Date'),[])
    lst=pkg_(char('list'))
    for i in arange_(1,length_(lst)).reshape(-1):
        ret[end() + 1]=struct_(char('Name'),lst[i].name,char('Version'),lst[i].version,char('Release'),[],char('Date'),lst[i].date)
    if (nargout == 0):
        octave_license=license_()
        unm,status=uname_(nargout=2)
        if (status < 0):
            os_string=char('unknown')
        else:
            os_string=sprintf_(char('%s %s %s %s'),unm.sysname,unm.release,unm.version,unm.machine)
        hbar[1:70]=char('-')
        ver_line1=char('GNU Octave Version ')
        ver_line2=char('GNU Octave License: ')
        ver_line3=char('Operating System: ')
        ver_desc=sprintf_(char('%s\n%s%s\n%s%s\n%s%s\n%s\n'),hbar,ver_line1,version,ver_line2,octave_license,ver_line3,os_string,hbar)
        puts_(ver_desc)
        pkg_(char('list'))
    else:
        if (not isempty_(package)):
            n=matlabarray([])
            for r in arange_(1,numel_(ret)).reshape(-1):
                if (strcmpi_(ret[r].Name,package)):
                    n=copy_(r)
                    break
            ret=ret[n]
        varargout[1]=ret
    return varargout
def tar_(tarfile=None,files=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[tarfile,files,root].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (ischar_(files)):
        files=cellstr_(files)
    if (not (ischar_(tarfile) and iscellstr_(files) and ischar_(root))):
        error_(char('tar: all arguments must be character strings'))
    cmd=sprintf_(char('tar cvf %s -C %s %s'),tarfile,root,sprintf_(char(' %s'),files[:]))
    status,output=system_(cmd,nargout=2)
    if (status):
        error_(char('tar: tar exited with status = %d'),status)
    if (nargout > 0):
        if (output[end()] == char('\n')):
            output[end()]=[]
        entries=ostrsplit_(output,char('\n'))
        entries=entries.T
    return entries
def fileattrib_(file=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[_file].count(None)+len(args)

    status=copy_(true)
    msg=char('')
    msgid=char('')
    if (nargin == 0):
        _file=char('.')
    if (ischar_(_file)):
        files=glob_(_file)
        if (isempty_(files)):
            files=[_file]
            nfiles=1
        else:
            nfiles=length_(files)
    else:
        error_(char('fileattrib: expecting first argument to be a character string'))
    if (nargin == 0 or nargin == 1):
        r_n=r_a=r_s=r_h=r_d=r_u_r=r_u_w=r_u_x=r_g_r=r_g_w=r_g_x=r_o_r=r_o_w=r_o_x=cell_(nfiles,1)
        curr_dir=pwd_()
        for i in arange_(1,nfiles).reshape(-1):
            info,err,msg=stat_(files[i],nargout=3)
            if (not err):
                r_n[i]=canonicalize_file_name_(files[i])
                r_a[i]=NaN
                r_s[i]=NaN
                r_h[i]=NaN
                r_d[i]=S_ISDIR_(info.mode)
                modestr=info.modestr
                r_u_r[i]=modestr[2] == char('r')
                r_u_w[i]=modestr[3] == char('w')
                r_u_x[i]=modestr[4] == char('x')
                r_g_r[i]=modestr[5] == char('r')
                r_g_w[i]=modestr[6] == char('w')
                r_g_x[i]=modestr[7] == char('x')
                r_o_r[i]=modestr[8] == char('r')
                r_o_w[i]=modestr[9] == char('w')
                r_o_x[i]=modestr[10] == char('x')
            else:
                status=copy_(false)
                msgid=char('fileattrib')
                break
        if (status):
            r=struct_(char('Name'),r_n,char('archive'),r_a,char('system'),r_s,char('hidden'),r_s,char('directory'),r_d,char('UserRead'),r_u_r,char('UserWrite'),r_u_w,char('UserExecute'),r_u_x,char('GroupRead'),r_g_r,char('GroupWrite'),r_g_w,char('GroupExecute'),r_g_x,char('OtherRead'),r_o_r,char('OtherWrite'),r_o_w,char('OtherExecute'),r_o_x)
            if (nargout == 0):
                status=copy_(r)
            else:
                msg=copy_(r)
    else:
        print_usage_()
    return status,msg,msgid
def fileparts_(filename=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[filename].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not ischar_(filename) or rows_(filename) > 1):
        error_(char('fileparts: FILENAME must be a single string'))
    ds=strchr_(filename,filesep_(char('all')),1,char('last'))
    if (isempty_(ds)):
        ds=0
    es=rindex_(filename,char('.'))
    if (es <= ds):
        es=length_(filename) + 1
    if (ds == 0):
        directory=char('')
    else:
        if (ds == 1):
            directory=filename[1]
        else:
            directory=filename[1:ds - 1]
    name=filename[ds + 1:es - 1]
    if (es > 0 and es <= length_(filename)):
        extension=filename[es:end()]
    else:
        extension=char('')
    version=char('')
    return directory,name,extension,version
def dir_(directory=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[directory].count(None)+len(args)

    if (nargin == 0):
        directory=char('.')
    else:
        if (nargin > 1):
            print_usage_()
    info=struct_(zeros_(0,1),[char('name'),char('date'),char('bytes'),char('isdir'),char('datenum'),char('statinfo')])
    if (ischar_(directory)):
        if (strcmp_(directory,char('*'))):
            directory=char('.')
        if (strcmp_(directory,char('.'))):
            flst=[char('.')]
            nf=1
        else:
            flst=glob_(directory)
            nf=length_(flst)
        if (nf == 1):
            fn=flst[1]
            st,err,msg=stat_(fn,nargout=3)
            if (err < 0):
                warning_(char("dir: 'stat (%s)' failed: %s"),fn,msg)
                nf=0
            else:
                if (S_ISDIR_(st.mode)):
                    flst=readdir_(flst[1])
                    nf=length_(flst)
                    for i in arange_(1,nf).reshape(-1):
                        flst[i]=fullfile_(fn,flst[i])
        if (length_(flst) > 0):
            for i in arange_(nf,1,- 1).reshape(-1):
                fn=flst[i]
                st,err,msg=lstat_(fn,nargout=3)
                if (err < 0):
                    warning_(char("dir: 'lstat (%s)' failed: %s"),fn,msg)
                else:
                    if (S_ISLNK_(st.mode)):
                        xst,err,msg=stat_(fn,nargout=3)
                        if (not err):
                            st=copy_(xst)
                    dummy,fn,ext=fileparts_(fn,nargout=3)
                    fn=matlabarray([fn,ext])
                    info[i,1].name=fn
                    lt=localtime_(st.mtime)
                    info[i,1].date=strftime_(char('%d-%b-%Y %T'),lt)
                    info[i,1].bytes=st.size
                    info[i,1].isdir=S_ISDIR_(st.mode)
                    info[i,1].datenum=datenum_(lt.year + 1900,lt.mon + 1,lt.mday,lt.hour,lt.min,lt.sec)
                    info[i,1].statinfo=st
    else:
        error_(char('dir: expecting directory or filename to be a char array'))
    if (nargout > 0):
        retval=copy_(info)
    else:
        if (length_(info) > 0):
            printf_(char('%s'),list_in_columns_([info.name]))
        else:
            warning_(char("dir: nonexistent directory '%s'"),directory)
    return retval
def unzip_(zipfile=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[zipfile,_dir].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (nargout > 0):
        varargout=cell_(1,nargout)
        varargout[:]=unpack_(zipfile,_dir,mfilename_())
    else:
        unpack_(zipfile,_dir,mfilename_())
    return varargout
def dos_(command=None,echo_arg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[command,echo_arg].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    else:
        if (not isunix_()):
            status,text=system_(command,nargout=2)
            if (nargin > 1 or nargout == 0):
                printf_(char('%s\n'),text)
    return status,text
def movefile_(f1=None,f2=None,force=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[f1,f2,force].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    max_cmd_line=1024
    status=copy_(true)
    msg=char('')
    msgid=char('')
    if (ispc_() and not isunix_() and isempty_(file_in_path_(getenv_(char('PATH')),char('mv.exe')))):
        cmd=char('cmd /C move')
        cmd_force_flag=char('/Y')
    else:
        cmd=char('mv')
        cmd_force_flag=char('-f')
    if (not (ischar_(f1) or iscellstr_(f1))):
        error_(char('movefile: F1 must be a character string or a cell array of character strings'))
    if (nargin == 1):
        f2=pwd_()
    else:
        if (not ischar_(f2)):
            error_(char('movefile: F2 must be a character string'))
    if (nargin == 3 and strcmp_(force,char('f'))):
        cmd=matlabarray([cmd,char(' '),cmd_force_flag])
    if (ischar_(f1)):
        f1=cellstr_(f1)
    isdir=(exist_(f2,char('dir')) != 0)
    if (length_(f1) > 1 and not isdir):
        error_(char('movefile: when moving multiple files, F2 must be a directory'))
    f1=glob_(f1)
    if (isempty_(f1)):
        error_(char('movefile: no files to move'))
    p1=sprintf_(char('"%s" '),f1[:])
    p2=tilde_expand_(f2)
    if (isdir and length_(p1) > max_cmd_line):
        l2=length_(p2) + length_(cmd) + 6
        while (not isempty_(f1)):

            p1=sprintf_(char('"%s" '),f1[1])
            f1[1]=[]
            while (not isempty_(f1) and (length_(p1) + length_(f1[1]) + l2 < max_cmd_line)):

                p1=sprintf_(char('%s"%s" '),p1,f1[1])
                f1[1]=[]

            if (ispc_() and not isunix_() and not isempty_(file_in_path_(getenv_(char('PATH')),char('cp.exe')))):
                p1=strrep_(p1,char('\\'),char('/'))
                p2=strrep_(p2,char('\\'),char('/'))
            err,msg=system_(sprintf_(char('%s %s "%s"'),cmd,p1,p2),nargout=2)
            if (err != 0):
                status=copy_(false)
                msgid=char('movefile')

    else:
        if (ispc_() and not isunix_() and not isempty_(file_in_path_(getenv_(char('PATH')),char('cp.exe')))):
            p1=strrep_(p1,char('\\'),char('/'))
            p2=strrep_(p2,char('\\'),char('/'))
        err,msg=system_(sprintf_(char('%s %s "%s"'),cmd,p1,p2),nargout=2)
        if (err != 0):
            status=copy_(false)
            msgid=char('movefile')
    return status,msg,msgid
def license_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    __octave_licenses__
    if (isempty_(__octave_licenses__)):
        __octave_licenses__=cell_()
        __octave_licenses__[1,1]=char('Octave')
        __octave_licenses__[1,2]=char('GNU General Public License')
        __octave_licenses__[1,3]=true
        if (exist_(char('OCTAVE_FORGE_VERSION'))):
            __octave_licenses__[2,1]=char('octave-forge')
            __octave_licenses__[2,2]=char('<various licenses>')
            __octave_licenses__[2,3]=true
    nout=copy_(nargout)
    nin=copy_(nargin)
    nr_licenses=rows_(__octave_licenses__)
    if (nout > 1 or nin > 3):
        print_usage_()
    if (nin == 0):
        found=find_(strcmp_(__octave_licenses__[:,1],char('Octave')),1)
        if (not isempty_(found)):
            result=__octave_licenses__[found,2]
        else:
            result=char('unknown')
        if (nout == 0):
            printf_(char('%s\n'),result)
        else:
            retval=copy_(result)
    else:
        if (nin == 1):
            if (nout == 0):
                if (not strcmp_(varargin[1],char('inuse'))):
                    usage_(char('license ("inuse")'))
                printf_(char('%s\n'),__octave_licenses__[:,1])
            else:
                if (not strcmp_(varargin[1],char('inuse'))):
                    usage_(char('retval = license ("inuse")'))
                pw=getpwuid_(getuid_())
                if (isstruct_(pw)):
                    username=pw.name
                else:
                    username=char('octave_user')
                retval=struct_(char('feature'),__octave_licenses__[:,1],char('user'),username)
        else:
            feature=varargin[2](arange_(1,(min_([(length_(varargin[2])),27]))))
            if (strcmp_(varargin[1],char('test'))):
                found=find_(strcmpi_(__octave_licenses__[:,1],feature),1)
                if (nin == 2):
                    retval=not isempty_(found) and __octave_licenses__[found,3]
                else:
                    if (not isempty_(found)):
                        if (strcmp_(varargin[3],char('enable'))):
                            __octave_licenses__[found,3]=true
                        else:
                            if (strcmp_(varargin[3],char('disable'))):
                                __octave_licenses__[found,3]=false
                            else:
                                error_(char("license: TOGGLE must be either 'enable' or 'disable'"))
                    else:
                        error_(char("license: FEATURE '%s' not found"),feature)
            else:
                if (strcmp_(varargin[1],char('checkout'))):
                    if (nin != 2):
                        usage_(char('retval = license ("checkout", feature)'))
                    found=find_(strcmpi_(__octave_licenses__[:,1],feature),1)
                    retval=not isempty_(found) and __octave_licenses__[found,3]
                else:
                    print_usage_()
    return retval
def version_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin != 0):
        warning_(char('version: ignoring extra arguments'))
    vs=copy_(OCTAVE_VERSION)
    return vs
def gzip_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin != 1 and nargin != 2) or (nargout > 1):
        print_usage_()
    if (nargout == 0):
        __xzip___(char('gzip'),char('gz'),char('gzip -r %s'),varargin[:])
    else:
        entries=__xzip___(char('gzip'),char('gz'),char('gzip -r %s'),varargin[:])
    return entries
def menu_(title=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[title].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    fflush_(stdout)
    page_screen_output_(0,char('local'))
    if (nargin == 2):
        if (iscell_(varargin[1])):
            varargin=varargin[1]
            nopt=length_(varargin)
            for i in arange_(1,nopt).reshape(-1):
                while (iscell_(varargin[i])):

                    varargin[i]=varargin[i][1]

        else:
            nopt=nargin - 1
    else:
        for i in arange_(1,nargin - 1).reshape(-1):
            if (iscell_(varargin[i])):
                while (iscell_(varargin[i])):

                    varargin[i]=varargin[i][1]

            else:
                if (not ischar_(varargin[i])):
                    varargin[i]=varargin[i](1)
        nopt=length_(varargin)
    if (not isempty_(title)):
        disp_(title)
        printf_(char('\n'))
    while (1):

        for i in arange_(1,nopt).reshape(-1):
            printf_(char('  [%2d] '),i)
            disp_(varargin[i])
        printf_(char('\n'))
        s=input_(char('pick a number, any number: '),char('s'))
        num=sscanf_(s,char('%d'))
        if (not isscalar_(num) or num < 1 or num > nopt):
            printf_(char('\nerror: input invalid or out of range\n\n'))
        else:
            break

    return num
def what_(d=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[d].count(None)+len(args)

    if (nargin == 0):
        d=pwd_()
    else:
        if (isempty_(strfind_(d,filesep_()))):
            p=strtrim_(ostrsplit_(path_(),pathsep_()))
            d=p[find_(cellfun_(lambda x: not isempty_(strfind_(x,d)),p))(end())]
        else:
            status,msg,msgid=fileattrib_(d,nargout=3)
            if (status != 1):
                error_(char('what: could not find the file or path %s'),d)
            else:
                d=msg.Name
    files=dir_(d)
    w.path=d
    w.m=cell_(0,1)
    w.mex=cell_(0,1)
    w.oct=cell_(0,1)
    w.mat=cell_(0,1)
    w.mdl=cell_(0,1)
    w.p=cell_(0,1)
    w.classes=cell_(0,1)
    for i in arange_(1,length_(files)).reshape(-1):
        n=files[i].name
        if (strcmp_(n,char('.')) or strcmp_(n,char('..'))):
            continue
        else:
            dummy,f,e=fileparts_(n,nargout=3)
            if (strcmp_(e,char('.m'))):
                w.m[end() + 1]=n
            else:
                if (strcmp_(e,char('.oct'))):
                    w.oct[end() + 1]=n
                else:
                    if (strcmp_(e,mexext_())):
                        w.mex[end() + 1]=n
                    else:
                        if (strcmp_(e,char('.mat'))):
                            w.mat[end() + 1]=n
                        else:
                            if (strcmp_(n[1],char('@'))):
                                w.classes[end() + 1]=n
    if (nargout == 0):
        __display_filenames___(char('M-files in directory'),w.path,w.m)
        __display_filenames___(char('\nMEX-files in directory'),w.path,w.mex)
        __display_filenames___(char('\nOCT-files in directory'),w.path,w.oct)
        __display_filenames___(char('\nMAT-files in directory'),w.path,w.mat)
        __display_filenames___(char('\nClasses in directory'),w.path,w.classes)
    else:
        ret=copy_(w)
    return ret
def __display_filenames___(msg=None,p=None,f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[msg,p,f].count(None)+len(args)

    if (length_(f) > 0):
        printf_(char('%s %s:\n\n'),msg,p)
        maxlen=max_(cellfun_(char('length'),f))
        ncols=max_(1,floor_(terminal_size_()(2) / (maxlen + 3)))
        fmt=char('')
        for i in arange_(1,ncols).reshape(-1):
            fmt=sprintf_(char('%s   %%-%ds'),fmt,maxlen)
        fmt=matlabarray([fmt,char('\n')])
        nrows=ceil_(length_(f) / ncols)
        for i in arange_(1,nrows).reshape(-1):
            args=f[i:nrows:end()]
            if (length_(args) < ncols):
                args[end() + 1:ncols]=[char('')]
            printf_(fmt,args[:])
    return
def run_(script=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[script].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    d,f,ext=fileparts_(script,nargout=3)
    if (not strcmp_(ext,char('.m'))):
        if (exist_([script,char('.m')],char('file'))):
            f=matlabarray([f,ext])
            ext=char('.m')
            script=matlabarray([script,char('.m')])
    if (not exist_(script,char('file'))):
        error_(char('run: file SCRIPT must exist and be a valid Octave scriptfile'))
    if (not isempty_(d)):
        if (exist_(d,char('dir'))):
            wd=pwd_()
            try:
                cd_(d)
                evalin_(char('caller'),sprintf_(char('source ("%s%s");'),f,ext),char('rethrow (lasterror ())'))
            finally:
                cd_(wd)
        else:
            error_(char("run: the path %s doesn't exist"),d)
    else:
        if (not isempty_(ext)):
            script=which_(script)
        else:
            script=which_([script,char('.')])
        evalin_(char('caller'),sprintf_(char('source ("%s");'),script),char('rethrow (lasterror ())'))
    return
def recycle_(state=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[state].count(None)+len(args)

    current_state=char('off')
    if (nargin > 1):
        print_usage_()
    if (nargin == 0 or nargout > 0):
        retval=copy_(current_state)
    if (nargin == 1):
        if (ischar_(state)):
            if (strcmpi_(state,char('on'))):
                error_(char('recycle: recycling files is not implemented'))
            else:
                if (strcmpi_(state,char('off'))):
                    current_state=char('off')
                else:
                    error_(char("recycle: invalid value of STATE = '%s'"),state)
        else:
            error_(char('recycle: STATE must be a character string'))
    return retval
def mkoctfile_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    bindir=octave_config_info_(char('bindir'))
    ext=octave_config_info_(char('EXEEXT'))
    shell_script=fullfile_(bindir,sprintf_(char('mkoctfile-%s%s'),OCTAVE_VERSION,ext))
    if (not exist_(shell_script,char('file'))):
        __gripe_missing_component___(char('mkoctfile'),char('mkoctfile'))
    cmd=matlabarray([char('"'),shell_script,char('"')])
    for i in arange_(1,nargin).reshape(-1):
        cmd=matlabarray([cmd,char(' "'),varargin[i],char('"')])
    sys,out=system_(cmd,nargout=2)
    if (nargout > 0):
        output,status=deal_(out,sys,nargout=2)
    else:
        printf_(char('%s'),out)
    if (sys != 0):
        warning_(char('mkoctfile exited with failure status'))
    return output,status
def gunzip_(gzfile=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[gzfile,_dir].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (nargout > 0):
        varargout=cell_(1,nargout)
        varargout[:]=unpack_(gzfile,_dir,mfilename_())
    else:
        unpack_(gzfile,_dir,mfilename_())
    return varargout
def display_info_file_(func=None,package=None,file=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[func,package,_file].count(None)+len(args)

    if (not ischar_(package)):
        error_(char('%s: PACKAGE must be a string'),func)
    if (strcmpi_(package,char('octave'))):
        octetcdir=octave_config_info_(char('octetcdir'))
        filepath=fullfile_(octetcdir,_file)
    else:
        installed=pkg_(char('list'))
        names=cellfun_(lambda x: x.name,installed,char('UniformOutput'),false)
        pos=strcmpi_(names,package)
        if (not any_(pos)):
            error_(char("%s: package '%s' is not installed."),func,package)
        filepath=fullfile_(installed[pos].dir,char('packinfo'),_file)
    if (not exist_(filepath,char('file'))):
        if (strcmpi_(package,char('octave'))):
            error_(char('%s: broken installation -- unable to locate %s file'),func,_file)
        else:
            error_(char('%s: unable to locate %s file for package %s'),func,_file,package)
    fid=fopen_(filepath,char('r'))
    while (ischar_(line=fgets_(fid))):

        puts_(line)

    fclose_(fid)
    return
def __xzip___(commandname=None,extension=None,commandtemplate=None,files=None,outdir=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[commandname,extension,commandtemplate,files,outdir].count(None)+len(args)

    if (nargin == 5 and not exist_(outdir,char('dir'))):
        error_(char('__xzip__: OUTDIR output directory does not exist'))
    if (ischar_(files)):
        files=cellstr_(files)
    if (not iscellstr_(files)):
        error_(char('__xzip__: FILES must be a character array or cellstr'))
    if (nargin == 4):
        outdir=tmpnam_()
        mkdir_(outdir)
    cwd=pwd_()
    try:
        files=glob_(files)
        files[cellfun_(lambda x: (length_(x) > length_(extension) and strcmp_(x[(end() - length_(extension) + 1):end()],extension)),files)]=[]
        copyfile_(files,outdir)
        d,f=myfileparts_(files,nargout=2)
        cd_(outdir)
        cmd=sprintf_(commandtemplate,sprintf_(char(' %s'),f[:]))
        status,output=system_(cmd,nargout=2)
        if (status):
            error_(char('__xzip__: %s command failed with exit status = %d'),commandname,status)
        if (nargin == 5):
            if (nargout > 0):
                entries=cellfun_(lambda x: fullfile_(outdir,sprintf_(char('%s.%s'),x,extension)),f,char('uniformoutput'),false)
        else:
            movefile_(cellfun_(lambda x: sprintf_(char('%s.%s'),x,extension),f,char('uniformoutput'),false),cwd)
            if (nargout > 0):
                entries=cellfun_(lambda x: sprintf_(char('%s.%s'),x,extension),files,char('uniformoutput'),false)
    finally:
        cd_(cwd)
        if (nargin == 4):
            confirm_recursive_rmdir_(false,char('local'))
            rmdir_(outdir,char('s'))
    return entries
def myfileparts_(files=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[files].count(None)+len(args)

    d,f,ext=cellfun_(char('fileparts'),files,char('uniformoutput'),false,nargout=3)
    f=cellfun_(lambda x,y: sprintf_(char('%s%s'),x,y),f,ext,char('uniformoutput'),false)
    idx=cellfun_(char('isdir'),files)
    d[idx]=char('')
    f[idx]=files[idx]
    return d,f
def tempdir_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    dirname=getenv_(char('TMPDIR'))
    if (isempty_(dirname)):
        dirname=copy_(P_tmpdir)
    if (not strcmp_(dirname[end()],filesep)):
        dirname=matlabarray([dirname,filesep])
    if (not isdir_(dirname)):
        warning_(char("tempdir: '%s' does not exist or is not a directory"),dirname)
    return dirname
def citation_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[package].count(None)+len(args)

    if (nargin > 1):
        print_usage_()
    else:
        display_info_file_(char('citation'),package,char('CITATION'))
    return
def isappdata_(h=None,name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[h,name].count(None)+len(args)

    if (not (all_(ishandle_(h)) and ischar_(name))):
        error_(char('isappdata: invalid input'))
    for nh in arange_(1,numel_(h)).reshape(-1):
        data=get_(h[nh])
        if (isfield_(data,char('__appdata__')) and isfield_(data.__appdata__,name)):
            res[nh]=true
        else:
            res[nh]=false
    return res
def fullfile_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin > 0):
        varargin[cellfun_(char('isempty'),varargin)]=[]
        nargs=numel_(varargin)
        if (nargs > 1):
            filename=varargin[1]
            if (strcmp_(filename[end()],filesep)):
                filename[end()]=char('')
            for i in arange_(2,nargs).reshape(-1):
                tmp=varargin[i]
                if (i < nargs and strcmp_(tmp[end()],filesep)):
                    tmp[end()]=char('')
                else:
                    if (i == nargs and strcmp_(tmp,filesep)):
                        tmp=char('')
                filename=matlabarray([filename,filesep,tmp])
        else:
            if (nargs == 1):
                filename=varargin[1]
            else:
                filename=char('')
    else:
        print_usage_()
    return filename
def info_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    printf_(char('\n  Additional information about GNU Octave is available at\n  http://www.octave.org\n\n  Links to the mailing list and other resources for getting help with\n  Octave are available at\n  http://www.octave.org/support.html\n\n  You may also find some information in the Octave Wiki at\n  http://wiki.octave.org\n\n  Additional functionality can be enabled by using packages from\n  the Octave Forge project, which may be found at\n  http://octave.sourceforge.net\n\n  Report bugs to the bug tracker at\n  http://bugs.octave.org\n  But first, please read the guidelines to writing a helpful report at\n  http://www.octave.org/bugs.html\n'))
    return
def bug_report_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    puts_(char('\n'))
    puts_(char('  Bug reports play an essential role in making Octave\n'))
    puts_(char('  reliable.  Please use the Octave bug tracker at\n'))
    puts_(char('\n'))
    puts_(char('    http://bugs.octave.org\n'))
    puts_(char('\n'))
    puts_(char('  to report problems.\n'))
    puts_(char('\n'))
    puts_(char('  Please also read the bug reporting guidelines at\n'))
    puts_(char('\n'))
    puts_(char('    http://www.octave.org/bugs.html\n'))
    puts_(char('\n'))
    puts_(char('  to learn how to submit useful bug reports that will\n'))
    puts_(char('  help the Octave community diagnose and fix the problem\n'))
    puts_(char('  quickly and efficiently.\n'))
    puts_(char('\n'))
    return
def ls_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    global __ls_command__
    if (isempty_(__ls_command__) or not ischar_(__ls_command__)):
        ls_command_()
    if (not iscellstr_(varargin)):
        error_(char('ls: all arguments must be character strings'))
    if (nargin > 0):
        args=tilde_expand_(varargin)
        if (ispc_() and not isunix_()):
            args=regexprep_(args,char('([^\\w.*? -])'),char('^$1'))
        else:
            args=regexprep_(args,char('([^\\w.*?-])'),char('\\\\$1'))
        args=sprintf_(char('%s '),args[:])
    else:
        args=char('')
    cmd=sprintf_(char('%s %s'),__ls_command__,args)
    if (page_screen_output_() or nargout > 0):
        status,output=system_(cmd,nargout=2)
        if (status != 0):
            error_(char('ls: command exited abnormally with status %d\n'),status)
        else:
            if (nargout == 0):
                puts_(output)
            else:
                if (isempty_(output)):
                    retval=char('')
                else:
                    retval=strvcat_(regexp_(output,char('\\S+'),char('match'))[:])
    else:
        system_(cmd)
    return retval
def delete_(arg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[arg].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (ischar_(arg)):
        files=glob_(arg)
        if (isempty_(files)):
            warning_(char('delete: no such file: %s'),arg)
        for i in arange_(1,length_(files)).reshape(-1):
            _file=files[i]
            err,msg=unlink_(_file,nargout=2)
            if (err):
                warning_(char('delete: %s: %s'),_file,msg)
    else:
        if (all_(ishandle_(arg[:]))):
            __go_delete___(arg)
        else:
            error_(char('delete: first argument must be a filename or graphics handle'))
    return
def news_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[package].count(None)+len(args)

    if (nargin > 1):
        print_usage_()
    else:
        display_info_file_(char('news'),package,char('NEWS'))
    return
def desktop_(arg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[arg].count(None)+len(args)

    if (nargin == 0):
        if (isguirunning_()):
            return retval
        else:
            print_usage_()
    else:
        if (nargin > 1):
            error_(char('desktop: only one argument, "-inuse", is allowed'))
    if char('-inuse') == (tolower_(arg)):
        retval=isguirunning_()
    else:
        print_usage_()
    return retval
def ispc_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0):
        retval=octave_config_info_(char('windows'))
    else:
        print_usage_()
    return retval
def tempname_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    filename=tmpnam_(varargin[:])
    return filename
def compare_versions_(v1=None,v2=None,operator=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[v1,v2,operator].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not (ischar_(v1) and ischar_(v2))):
        error_(char('compare_versions: both version numbers must be strings'))
    else:
        if (rows_(v1) != 1 or rows_(v2) != 1):
            error_(char('compare_versions: version numbers must be a single row'))
    if (not ischar_(operator)):
        error_(char('compare_versions: OPERATOR must be a character string'))
    else:
        if (numel_(operator) > 2):
            error_(char('compare_versions: OPERATOR must be 1 or 2 characters long'))
    numbers=char('0123456789.')
    v1firstchar=find_(not ismember_(v1,numbers),1)
    v2firstchar=find_(not ismember_(v2,numbers),1)
    if (not isempty_(v1firstchar)):
        v1c=v1[v1firstchar:length_(v1)]
        v1nochar=v1[1:v1firstchar - 1]
    else:
        v1c=char('')
        v1nochar=copy_(v1)
    if (not isempty_(v2firstchar)):
        v2c=v2[v2firstchar:length_(v2)]
        v2nochar=v2[1:v2firstchar - 1]
    else:
        v2c=char('')
        v2nochar=copy_(v2)
    v1n=str2num_(char_(ostrsplit_(v1nochar,char('.'))))
    v2n=str2num_(char_(ostrsplit_(v2nochar,char('.'))))
    if ((isempty_(v1n) and isempty_(v1c)) or (isempty_(v2n) and isempty_(v2c))):
        error_(char('compare_versions: given version strings are not valid: %s %s'),v1,v2)
    maxnumlen=max_([length_(v1n),length_(v2n)])
    if (length_(v1n) < maxnumlen):
        v1n[length_(v1n) + 1:maxnumlen]=0
    if (length_(v2n) < maxnumlen):
        v2n[length_(v2n) + 1:maxnumlen]=0
    maxcharlen=max_([length_(v1c),length_(v2c)])
    if (length_(v1c) < maxcharlen):
        v1c[length_(v1c) + 1:maxcharlen]=char('\x00')
    if (length_(v2c) < maxcharlen):
        v2c[length_(v2c) + 1:maxcharlen]=char('\x00')
    if (any_(ismember_(operator,char('=')))):
        equal_op=copy_(true)
    else:
        equal_op=copy_(false)
    if (any_(ismember_(operator,char('~!')))):
        not_op=copy_(true)
    else:
        not_op=copy_(false)
    if (any_(ismember_(operator,char('<')))):
        lt_op=copy_(true)
    else:
        lt_op=copy_(false)
    if (any_(ismember_(operator,char('>')))):
        gt_op=copy_(true)
    else:
        gt_op=copy_(false)
    if (gt_op and lt_op):
        error_(char('compare_versions: OPERATOR cannot contain both greater and less than symbols'))
    else:
        if ((gt_op or lt_op) and not_op):
            error_(char('compare_versions: OPERATOR cannot contain not and greater than or less than symbols'))
        else:
            if (strcmp_(operator,char('='))):
                error_(char('compare_versions: equality OPERATOR is "==", not "="'))
            else:
                if (not (equal_op or not_op or lt_op or gt_op)):
                    error_(char('compare_versions: No valid OPERATOR specified'))
    vcmp=v1n[:] - v2n[:]
    vcmp=matlabarray([[vcmp],[(v1c - v2c)(arange_())]])
    if (lt_op):
        vcmp=- vcmp
    firstdiff=find_(vcmp != 0,1)
    if (isempty_(firstdiff)):
        out=copy_(equal_op)
    else:
        if (lt_op or gt_op):
            out=(vcmp[firstdiff] > 0)
        else:
            out=copy_(false)
    if (not_op):
        out=not out
    return out
def rmappdata_(h=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[h].count(None)+len(args)

    if (not (all_(ishandle_(h)) and iscellstr_(varargin))):
        error_(char('rmappdata: invalid input'))
    for nh in arange_(1,numel_(h)).reshape(-1):
        if (isprop_(h[nh],char('__appdata__'))):
            appdata=get_(h[nh],char('__appdata__'))
            for v in arange_(1,numel_(varargin)).reshape(-1):
                if (isfield_(appdata,varargin[v])):
                    appdata=rmfield_(appdata,varargin[v])
                else:
                    error_(char("rmappdata: appdata '%s' is not present"))
            set_(h[nh],char('__appdata__'),appdata)
    return
def isunix_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0):
        retval=octave_config_info_(char('unix'))
    else:
        print_usage_()
    return retval
def getfield_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    subs=copy_(varargin)
    flds=cellfun_(char('isclass'),subs,char('char'))
    idxs=cellfun_(char('isclass'),subs,char('cell'))
    if (all_(flds or idxs)):
        typs=merge_(flds,[char('.')],[char('()')])
        obj=subsref_(s,struct_(char('type'),typs,char('subs'),subs))
    else:
        error_(char('getfield: invalid index'))
    return obj
def mexext_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    retval=char('mex')
    return retval
def ismac_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 0):
        retval=octave_config_info_(char('mac'))
    else:
        print_usage_()
    return retval
def warning_ids_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    help_(char('warning_ids'))
    return
def error_ids_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    help_(char('error_ids'))
    return
def debug_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    help_(char('debug'))
    return
def unix_(command=None,echo_arg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[command,echo_arg].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    else:
        if (isunix_()):
            status,text=system_(command,nargout=2)
            if (nargin > 1 or nargout == 0):
                printf_(char('%s\n'),text)
    return status,text
def isdeployed_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    retval=copy_(false)
    return retval
def colon_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin != 0):
        error_(char('colon: not defined for class "%s"'),class_(varargin[1]))
    return r
def bunzip2_(bzfile=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[bzfile,_dir].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (nargout > 0):
        varargout=cell_(1,nargout)
        varargout[:]=unpack_(bzfile,_dir,mfilename_())
    else:
        unpack_(bzfile,_dir,mfilename_())
    return varargout
def xor_(x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin == 2):
        if (isscalar_(x) or isscalar_(y) or size_equal_(x,y)):
            z=logical_(x) != logical_(y)
        else:
            try:
                z=bsxfun_(xor,x,y)
            finally:
                pass
    else:
        print_usage_()
    return z
def untar_(tarfile=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[tarfile,_dir].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (nargout > 0):
        varargout=cell_(1,nargout)
        varargout[:]=unpack_(tarfile,_dir,mfilename_())
    else:
        unpack_(tarfile,_dir,mfilename_())
    return varargout
def inputname_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin == 1):
        s=evalin_(char('caller'),sprintf_(char('__varval__ (".argn."){%d};'),n))
        if (not isvarname_(s)):
            s=char('')
    else:
        print_usage_()
    return s
def genvarname_(str=None,exclusions=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[_str,exclusions].count(None)+len(args)

    strinput=ischar_(_str)
    if (nargin < 2):
        exclusions=[]
    else:
        if (ischar_(exclusions)):
            if (rows_(exclusions) != 1):
                error_(char('genvarname: if more than one exclusion is given, it must be a cellstr'))
            exclusions=[exclusions]
        else:
            if (not iscellstr_(exclusions)):
                error_(char('genvarname: EXCLUSIONS must be a string or a cellstr'))
    if (ischar_(_str)):
        if (rows_(_str) != 1):
            error_(char('genvarname: if more than one STR is given, it must be a cellstr'))
        _str=[_str]
    else:
        if (not iscellstr_(_str)):
            error_(char('genvarname: STR must be a string or a cellstr'))
    validchars=matlabarray([arange_(char('A'),char('Z')),arange_(char('a'),char('z')),arange_(char('0'),char('9')),char('_')])
    varname=cell_(size_(_str))
    for i in arange_(1,numel_(_str)).reshape(-1):
        _str[i][not ismember_(_str[i],validchars)]=char('_')
        if (iskeyword_(_str[i])):
            _str[i]=[char('_'),_str[i]]
        underscores=(_str[i] == char('_'))
        if (any_(underscores)):
            firstnon=find_(not underscores,1)
            lastnon=find_(not underscores,1,char('last'))
            _str[i][[arange_(1,firstnon - 2),arange_(lastnon + 2,end())]]=[]
        if (isempty_(_str[i])):
            _str[i]=char('x')
        if (ismember_(_str[i](1),arange_(char('0'),char('9')))):
            _str[i]=[char('_'),_str[i]]
        excluded=any_(strcmp_(_str[i],exclusions))
        if (excluded and ismember_(_str[i](end()),arange_(char('0'),char('9')))):
            _str[i][end() + 1]=char('_')
        varname[i]=_str[i]
        idx=0
        while (excluded):

            idx
            varname[i]=sprintf_(char('%s%d'),_str[i],idx)
            excluded=any_(strcmp_(varname[i],exclusions))

        exclusions[end() + 1]=varname[i]
    if (strinput):
        varname=varname[1]
    return varname
def python_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[scriptfile].count(None)+len(args)

    if (ischar_(scriptfile) and ((nargin == 1 and not isempty_(scriptfile)) or (nargin != 1 and iscellstr_(varargin)))):
        if (not strcmp_(scriptfile[1:2],char('-c'))):
            scriptfile=file_in_loadpath_(scriptfile)
        status,output=system_([char('python '),scriptfile,sprintf_(char(' %s'),varargin[:])],nargout=2)
    else:
        error_(char('python: invalid arguments'))
    return output,status
def computer_(a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[a].count(None)+len(args)

    if (nargin == 1 and ischar_(a) and strcmpi_(a,char('arch'))):
        tmp=ostrsplit_(octave_config_info_(char('canonical_host_type')),char('-'))
        if (numel_(tmp) == 4):
            c=sprintf_(char('%s-%s-%s'),tmp[4],tmp[3],tmp[1])
        else:
            c=sprintf_(char('%s-%s'),tmp[3],tmp[1])
    else:
        if (nargin == 0):
            msg=octave_config_info_(char('canonical_host_type'))
            if (strcmp_(msg,char('unknown'))):
                msg=char("Hi Dave, I'm a HAL-9000")
            if (nargout == 0):
                printf_(char('%s\n'),msg)
            else:
                c=copy_(msg)
                if (strcmp_(octave_config_info_(char('USE_64_BIT_IDX_T')),char('true'))):
                    maxsize=2 ** 63 - 1
                else:
                    maxsize=2 ** 31 - 1
                if (octave_config_info_(char('words_big_endian'))):
                    endian=char('B')
                else:
                    if (octave_config_info_(char('words_little_endian'))):
                        endian=char('L')
                    else:
                        endian=char('?')
        else:
            print_usage_()
    return c,maxsize,endian
def setfield_(obj=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[obj].count(None)+len(args)

    if (nargin < 3):
        print_usage_()
    subs=varargin[1:end() - 1]
    rhs=varargin[end()]
    flds=cellfun_(char('isclass'),subs,char('char'))
    idxs=cellfun_(char('isclass'),subs,char('cell'))
    if (all_(flds or idxs)):
        typs=merge_(flds,[char('.')],[char('()')])
        obj=subsasgn_(obj,struct_(char('type'),typs,char('subs'),subs),rhs)
    else:
        error_(char('setfield: invalid index'))
    return obj
def list_primes_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin > 0):
        if (not isscalar_(n)):
            error_(char('list_primes: argument must be a scalar'))
    if (nargin == 0):
        n=25
    if (n == 1):
        retval=2
        return retval
    if (n == 2):
        retval=matlabarray([[2],[3]])
        return retval
    retval=zeros_(1,n)
    retval[1]=2
    retval[2]=3
    n=n - 2
    i=3
    p=5
    while (n > 0):

        is_prime=1
        is_unknown=1
        d=3
        while (is_unknown):

            a=fix_(p / d)
            if (a <= d):
                is_unknown=0
            if (a * d == p):
                is_prime=0
                is_unknown=0
            d=d + 2

        if (is_prime):
            retval[i]=p
            n
        p=p + 2

    return retval
def bzip2_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin == 1 or nargin == 2):
        if (nargout == 0):
            __xzip___(char('bzip2'),char('bz2'),char('bzip2 %s'),varargin[:])
        else:
            entries=__xzip___(char('bzip2'),char('bz2'),char('bzip2 %s'),varargin[:])
    else:
        print_usage_()
    return entries
def symvar_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    args=argnames_(inline_(s))
    return args
def ls_command_(cmd=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[cmd].count(None)+len(args)

    global __ls_command__
    if (isempty_(__ls_command__)):
        if (ispc_() and not isunix_() and isempty_(file_in_path_(getenv_(char('PATH')),char('ls')))):
            __ls_command__=char('dir /D')
        else:
            __ls_command__=char('ls -C')
    if (nargin == 0 or nargin == 1):
        old_cmd=copy_(__ls_command__)
        if (nargin == 1):
            if (ischar_(cmd)):
                __ls_command__=copy_(cmd)
            else:
                error_(char('ls_command: expecting argument to be a character string'))
    return old_cmd
def parseparams_(params=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[params].count(None)+len(args)

    strs=cellfun_(char('isclass'),params,char('char'))
    i=find_(strs,1)
    if (i):
        reg=params[1:i - 1]
        prop=params[i:end()]
    else:
        reg=copy_(params)
        prop=[]
    if (nargin == 1):
        varargout=[prop]
    else:
        names=varargin[1:2:end()]
        defaults=varargin[2:2:end()]
        if (not size_equal_(names,defaults)):
            error_(char('parseparams: needs odd number of arguments'))
        names,sidx=sort_(names,nargout=2)
        varargout=copy_(defaults)
        if (i):
            pnames=prop[1:2:end()]
            values=prop[2:2:end()]
            if (not size_equal_(pnames,values) or not all_(strs[i:2:end()])):
                error_as_caller_(char('options must be given as name-value pairs'))
            idx=lookup_(toupper_(names),toupper_(pnames),char('m'))
            if (not all_(idx)):
                error_as_caller_(char('unrecognized option: %s'),pnames[find_(idx == 0,1)])
            else:
                varargout[sidx[idx]]=values
    return reg,varargout
def error_as_caller_(msg=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[msg].count(None)+len(args)

    stack=dbstack_(1)
    fname=stack[min_(2,end())].name
    error_([fname,char(': '),msg],varargin[:])
    return
def namelengthmax_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    n=63
    return n
def mex_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    args=[char('--mex'),varargin[:]]
    mkoctfile_(args[:])
    return
def matlabroot_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    retval=copy_(OCTAVE_HOME)
    return retval
def pathdef_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    pathdir=octave_config_info_(char('localstartupfiledir'))
    site_octaverc=fullfile_(pathdir,char('octaverc'))
    user_octaverc=fullfile_(char('~'),char('.octaverc'))
    site_path=__extractpath___(site_octaverc)
    if (exist_(user_octaverc,char('file'))):
        user_path=__extractpath___(user_octaverc)
    else:
        user_path=char('')
    if (not isempty_(user_path)):
        val=copy_(user_path)
    else:
        if (not isempty_(site_path)):
            val=copy_(site_path)
        else:
            val=__pathorig___()
    return val
def __extractpath___(savefile=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[savefile].count(None)+len(args)

    beginstring=char('## Begin savepath auto-created section, do not edit')
    endstring=char('## End savepath auto-created section')
    if (nargin == 0):
        savefile=tilde_expand_(char('~/.octaverc'))
    startline=endline=0
    filelines=[]
    if (exist_(savefile) == 2):
        fid,msg=fopen_(savefile,char('rt'),nargout=2)
        if (fid < 0):
            error_(char('__extractpath__: could not open savefile, %s: %s'),savefile,msg)
        try:
            linenum=0
            while (ischar_(line=fgetl_(fid))):

                filelines[++ linenum]=line
                if (strcmp_(line,beginstring)):
                    startline=copy_(linenum)
                else:
                    if (strcmp_(line,endstring)):
                        endline=copy_(linenum)

        finally:
            closeread=fclose_(fid)
            if (closeread < 0):
                error_(char('__extractpath__: could not close savefile after reading, %s'),savefile)
    if (startline > endline or (startline > 0 and endline == 0)):
        error_(char('__extractpath__: unable to parse file, %s'),savefile)
    else:
        if (startline > 0):
            specifiedpath=strrep_(regexprep_(cstrcat_(filelines[startline:endline][:]),char(" *path *\\('(.*)'\\); *"),char('$1')),char("''"),char("'"))
        else:
            specifiedpath=char('')
    return specifiedpath
def savepath_(file=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[_file].count(None)+len(args)

    ret=1
    beginstring=char('## Begin savepath auto-created section, do not edit')
    endstring=char('## End savepath auto-created section')
    if (nargin == 0):
        _file=fullfile_(char('~'),char('.octaverc'))
    startline=endline=0
    filelines=[]
    if (exist_(_file) == 2):
        fid,msg=fopen_(_file,char('rt'),nargout=2)
        if (fid < 0):
            error_(char('savepath: could not open file, %s: %s'),_file,msg)
        try:
            linenum=0
            while (ischar_(line=fgetl_(fid))):

                filelines[++ linenum]=line
                if (strcmp_(line,beginstring)):
                    startline=copy_(linenum)
                else:
                    if (strcmp_(line,endstring)):
                        endline=copy_(linenum)

        finally:
            closeread=fclose_(fid)
            if (closeread < 0):
                error_(char('savepath: could not close file after reading, %s'),_file)
    if (startline > endline or (startline > 0 and endline == 0)):
        error_(char('savepath: unable to parse file, %s'),_file)
    if (isempty_(filelines) or (startline == 1 and endline == length_(filelines))):
        pre=post=[]
    else:
        if (endline == 0):
            pre=copy_(filelines)
            post=[]
        else:
            if (startline == 1):
                pre=[]
                post=filelines[endline + 1:end()]
            else:
                if (endline == length_(filelines)):
                    pre=filelines[1:startline - 1]
                    post=[]
                else:
                    pre=filelines[1:startline - 1]
                    post=filelines[endline + 1:end()]
    fid,msg=fopen_(_file,char('wt'),nargout=2)
    if (fid < 0):
        error_(char('savepath: unable to open file for writing, %s, %s'),_file,msg)
    try:
        for i in arange_(1,length_(pre)).reshape(-1):
            fprintf_(fid,char('%s\n'),pre[i])
        workingpath=parsepath_(path)
        command_line_path=parsepath_(command_line_path_())
        octave_path=parsepath_(getenv_(char('OCTAVE_PATH')))
        pathdef=pathdef_()
        if (isempty_(pathdef)):
            __,n=setdiff_(workingpath,octave_path,nargout=2)
            default_path=copy_(command_line_path)
        else:
            __,n=setdiff_(workingpath,union_(command_line_path,octave_path),nargout=2)
            default_path=parsepath_(pathdef)
        path_to_preserve=workingpath[sort_(n)]
        pkg_user,pkg_system=pkg_(char('list'),nargout=2)
        pkg_user_path=cell_(1,numel_(pkg_user))
        pkg_system_path=cell_(1,numel_(pkg_system))
        for n in arange_(1,numel_(pkg_user)).reshape(-1):
            pkg_user_path[n]=pkg_user[n].archprefix
        for n in arange_(1,numel_(pkg_system)).reshape(-1):
            pkg_system_path[n]=pkg_system[n].archprefix
        pkg_path=union_(pkg_user_path,pkg_system_path)
        if (not isempty_(pkg_path)):
            __,n=setdiff_(path_to_preserve,strcat_(pkg_path,char(':')),nargout=2)
            path_to_preserve=path_to_preserve[sort_(n)]
        if (not isempty_(default_path)):
            n1=find_(strcmp_(default_path[1],path_to_preserve))
            n2=find_(strcmp_(default_path[end()],path_to_preserve))
            n_middle=round_(0.5 * (n1 + n2))
            __,n=setdiff_(path_to_preserve,default_path,nargout=2)
            path_to_save=path_to_preserve[sort_(n)]
            path_to_save=path_to_save[not strcmp_(path_to_save,[char('.'),pathsep])]
            n=ones_(size_(path_to_save))
            for m in arange_(1,numel_(path_to_save)).reshape(-1):
                n[m]=find_(strcmp_(path_to_save[m],path_to_preserve))
            path_to_save_begin=path_to_save[n <= n_middle]
            path_to_save_end=path_to_save[n > n_middle]
        else:
            path_to_save_begin=copy_(path_to_preserve)
            path_to_save_end=[]
        path_to_save_begin=cell2mat_(path_to_save_begin)
        path_to_save_end=cell2mat_(path_to_save_end)
        fprintf_(fid,char('%s\n'),beginstring)
        if (not isempty_(path_to_save_begin)):
            n=find_(path_to_save_begin != pathsep,1,char('last'))
            fprintf_(fid,char("  addpath ('%s', '-begin');\n"),strrep_(path_to_save_begin[1:n],char("'"),char("''")))
        if (not isempty_(path_to_save_end)):
            n=find_(path_to_save_end != pathsep,1,char('last'))
            fprintf_(fid,char("  addpath ('%s', '-end');\n"),strrep_(path_to_save_end[1:n],char("'"),char("''")))
        fprintf_(fid,char('%s\n'),endstring)
        for i in arange_(1,length_(post)).reshape(-1):
            fprintf_(fid,char('%s\n'),post[i])
    finally:
        closeread=fclose_(fid)
        if (closeread < 0):
            error_(char('savepath: could not close savefile after writing, %s'),_file)
        else:
            if (nargin == 0):
                warning_(char('savepath: current path saved to %s'),_file)
    ret=0
    if (nargout > 0):
        retval=copy_(ret)
    return retval
def parsepath_(p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[p].count(None)+len(args)

    pat=sprintf_(char('([^%s]+[%s$])'),pathsep,pathsep)
    path_elements=regexpi_(strcat_(p,pathsep),pat,char('match'))
    return path_elements
def __finish___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (exist_(char('finish'),char('file'))):
        finish
    return
def unifinv_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,x,a,b=common_size_(x,a,b,nargout=4)
        if (retval > 0):
            error_(char('unifinv: X, A, and B must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(a) or iscomplex_(b)):
        error_(char('unifinv: X, A, and B must not be complex'))
    if (isa_(x,char('single')) or isa_(a,char('single')) or isa_(b,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    k=(x >= 0) and (x <= 1) and (a < b)
    if (isscalar_(a) and isscalar_(b)):
        inv[k]=a + x[k] * (b - a)
    else:
        inv[k]=a[k] + x[k].dot((b[k] - a[k]))
    return inv
def norminv_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,mu,sigma].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(mu) or not isscalar_(sigma)):
        retval,x,mu,sigma=common_size_(x,mu,sigma,nargout=4)
        if (retval > 0):
            error_(char('norminv: X, MU, and SIGMA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(mu) or iscomplex_(sigma)):
        error_(char('norminv: X, MU, and SIGMA must not be complex'))
    if (isa_(x,char('single')) or isa_(mu,char('single')) or isa_(sigma,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    if (isscalar_(mu) and isscalar_(sigma)):
        if (isfinite_(mu) and (sigma > 0) and (sigma < Inf)):
            inv=mu + sigma * stdnormal_inv_(x)
    else:
        k=isfinite_(mu) and (sigma > 0) and (sigma < Inf)
        inv[k]=mu[k] + sigma[k].dot(stdnormal_inv_(x[k]))
    return inv
def nbincdf_(x=None,n=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,n,p].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(n) or not isscalar_(p)):
        retval,x,n,p=common_size_(x,n,p,nargout=4)
        if (retval > 0):
            error_(char('nbincdf: X, N, and P must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n) or iscomplex_(p)):
        error_(char('nbincdf: X, N, and P must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single')) or isa_(p,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=(isnan_(x) or isnan_(n) or (n < 1) or (n == Inf) or (p < 0) or (p > 1) or isnan_(p))
    cdf[k]=NaN
    k=(x == Inf) and (n > 0) and (n < Inf) and (p >= 0) and (p <= 1)
    cdf[k]=1
    k=((x >= 0) and (x < Inf) and (x == fix_(x)) and (n > 0) and (n < Inf) and (p > 0) and (p <= 1))
    if (isscalar_(n) and isscalar_(p)):
        cdf[k]=1 - betainc_(1 - p,x[k] + 1,n)
    else:
        cdf[k]=1 - betainc_(1 - p[k],x[k] + 1,n[k])
    return cdf
def finv_(x=None,m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,m,n].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(m) or not isscalar_(n)):
        retval,x,m,n=common_size_(x,m,n,nargout=4)
        if (retval > 0):
            error_(char('finv: X, M, and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(m) or iscomplex_(n)):
        error_(char('finv: X, M, and N must not be complex'))
    if (isa_(x,char('single')) or isa_(m,char('single')) or isa_(n,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    k=(x == 1) and (m > 0) and (m < Inf) and (n > 0) and (n < Inf)
    inv[k]=Inf
    k=(x >= 0) and (x < 1) and (m > 0) and (m < Inf) and (n > 0) and (n < Inf)
    if (isscalar_(m) and isscalar_(n)):
        inv[k]=((1 / betainv_(1 - x[k],n / 2,m / 2) - 1) * n / m)
    else:
        inv[k]=((1 / betainv_(1 - x[k],n[k] / 2,m[k] / 2) - 1).dot(n[k]) / m[k])
    return inv
def expcdf_(x=None,lambda=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,_lambda].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(_lambda)):
        retval,x,_lambda=common_size_(x,_lambda,nargout=3)
        if (retval > 0):
            error_(char('expcdf: X and LAMBDA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(_lambda)):
        error_(char('expcdf: X and LAMBDA must not be complex'))
    if (isa_(x,char('single')) or isa_(_lambda,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=isnan_(x) or not (_lambda > 0)
    cdf[k]=NaN
    k=(x == Inf) and (_lambda > 0)
    cdf[k]=1
    k=(x > 0) and (x < Inf) and (_lambda > 0)
    if (isscalar_(_lambda)):
        cdf[k]=1 - exp_(- x[k] / _lambda)
    else:
        cdf[k]=1 - exp_(- x[k] / _lambda[k])
    return cdf
def stdnormal_inv_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (iscomplex_(x)):
        error_(char('stdnormal_inv: X must not be complex'))
    inv=- sqrt_(2) * erfcinv_(2 * x)
    return inv
def tcdf_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(n)):
        retval,x,n=common_size_(x,n,nargout=3)
        if (retval > 0):
            error_(char('tcdf: X and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n)):
        error_(char('tcdf: X and N must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=not isinf_(x) and (n > 0)
    xx=x ** 2
    x_big_abs=(xx > n)
    kk=k and x_big_abs
    if (isscalar_(n)):
        cdf[kk]=betainc_(n / (n + xx[kk]),n / 2,1 / 2) / 2
    else:
        cdf[kk]=betainc_(n[kk] / (n[kk] + xx[kk]),n[kk] / 2,1 / 2) / 2
    kk=k and not x_big_abs
    if (isscalar_(n)):
        cdf[kk]=0.5 * (1 - betainc_(xx[kk] / (n + xx[kk]),1 / 2,n / 2))
    else:
        cdf[kk]=0.5 * (1 - betainc_(xx[kk] / (n[kk] + xx[kk]),1 / 2,n[kk] / 2))
    k &= (x > 0)
    if (any_(k[:])):
        cdf[k]=1 - cdf[k]
    k=isnan_(x) or not (n > 0)
    cdf[k]=NaN
    k=(x == Inf) and (n > 0)
    cdf[k]=1
    return cdf
def binocdf_(x=None,n=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,n,p].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(n) or not isscalar_(p)):
        retval,x,n,p=common_size_(x,n,p,nargout=4)
        if (retval > 0):
            error_(char('binocdf: X, N, and P must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n) or iscomplex_(p)):
        error_(char('binocdf: X, N, and P must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single')) or isa_(p,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=isnan_(x) or not (n >= 0) or (n != fix_(n)) or not (p >= 0) or not (p <= 1)
    cdf[k]=NaN
    k=(x >= n) and (n >= 0) and (n == fix_(n) and (p >= 0) and (p <= 1))
    cdf[k]=1
    k=(x >= 0) and (x < n) and (n == fix_(n)) and (p >= 0) and (p <= 1)
    tmp=floor_(x[k])
    if (isscalar_(n) and isscalar_(p)):
        cdf[k]=betainc_(1 - p,n - tmp,tmp + 1)
    else:
        cdf[k]=betainc_(1- p[k],n[k] - tmp,tmp + 1)
    return cdf
def betarnd_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,a,b=common_size_(a,b,nargout=3)
        if (retval > 0):
            error_(char('betarnd: A and B must be of common size or scalars'))
    if (iscomplex_(a) or iscomplex_(b)):
        error_(char('betarnd: A and B must not be complex'))
    if (nargin == 2):
        sz=size_(a)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('betarnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('betarnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(a) and not isequal_(size_(a),sz)):
        error_(char('betarnd: A and B must be scalar or of size SZ'))
    if (isa_(a,char('single')) or isa_(b,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(a) and isscalar_(b)):
        if ((a > 0) and (a < Inf) and (b > 0) and (b < Inf)):
            r=randg_(a,sz,cls)
            rnd=r / (r + randg_(b,sz,cls))
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=NaN_(sz,cls)
        k=(a > 0) and (a < Inf) and (b > 0) and (b < Inf)
        r=randg_(a[k],cls)
        rnd[k]=r / (r + randg_(b[k],cls))
    return rnd
def discrete_pdf_(x=None,v=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,v,p].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isvector_(v)):
        error_(char('discrete_pdf: V must be a vector'))
    else:
        if (any_(isnan_(v))):
            error_(char('discrete_pdf: V must not have any NaN elements'))
        else:
            if (not isvector_(p) or (length_(p) != length_(v))):
                error_(char('discrete_pdf: P must be a vector with length (V) elements'))
            else:
                if (not (all_(p >= 0) and any_(p))):
                    error_(char('discrete_pdf: P must be a nonzero, non-negative vector'))
    p=matlabarray([[0],[p[:] / sum_(p)]])
    if (isa_(x,char('single')) or isa_(v,char('single')) or isa_(p,char('single'))):
        pdf=NaN_(size_(x),char('single'))
    else:
        pdf=NaN_(size_(x))
    k=not isnan_(x)
    vs,vi=sort_(v[:],nargout=2)
    pdf[k]=p[[[0],[vi]](lookup_(vs,x[k],char('m')) + 1) + 1]
    return pdf
def logistic_inv_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (iscomplex_(x)):
        error_(char('logistic_inv: X must not be complex'))
    if (isa_(x,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    k=(x == 0)
    inv[k]=- Inf
    k=(x == 1)
    inv[k]=Inf
    k=(x > 0) and (x < 1)
    inv[k]=- log_(1 / x[k] - 1)
    return inv
def wblcdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,scale,shape].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not isscalar_(shape) or not isscalar_(scale)):
        retval,x,shape,scale=common_size_(x,shape,scale,nargout=4)
        if (retval > 0):
            error_(char('wblcdf: X, SCALE, and SHAPE must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(scale) or iscomplex_(shape)):
        error_(char('wblcdf: X, SCALE, and SHAPE must not be complex'))
    if (isa_(x,char('single')) or isa_(scale,char('single')) or isa_(shape,char('single'))):
        cdf=NaN_(size_(x),char('single'))
    else:
        cdf=NaN_(size_(x))
    ok=(shape > 0) and (shape < Inf) and (scale > 0) and (scale < Inf)
    k=(x <= 0) and ok
    cdf[k]=0
    k=(x == Inf) and ok
    cdf[k]=1
    k=(x > 0) and (x < Inf) and ok
    if (isscalar_(shape) and isscalar_(scale)):
        cdf[k]=1 - exp_(- (x[k] / scale) ** shape)
    else:
        cdf[k]=1 - exp_(- (x[k] / scale[k]) ** shape[k])
    return cdf
def wblrnd_(scale=None,shape=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[scale,shape].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isscalar_(scale) or not isscalar_(shape)):
        retval,scale,shape=common_size_(scale,shape,nargout=3)
        if (retval > 0):
            error_(char('wblrnd: SCALE and SHAPE must be of common size or scalars'))
    if (iscomplex_(scale) or iscomplex_(shape)):
        error_(char('wblrnd: SCALE and SHAPE must not be complex'))
    if (nargin == 2):
        sz=size_(scale)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('wblrnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('wblrnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(scale) and not isequal_(size_(scale),sz)):
        error_(char('wblrnd: SCALE and SHAPE must be scalar or of size SZ'))
    if (isa_(scale,char('single')) or isa_(shape,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(scale) and isscalar_(shape)):
        if ((scale > 0) and (scale < Inf) and (shape > 0) and (shape < Inf)):
            rnd=scale * rande_(sz,cls) ** (1 / shape)
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=scale.dot(rande_(sz,cls) ** (1.0 / shape))
        k=(scale <= 0) or (scale == Inf) or (shape <= 0) or (shape == Inf)
        rnd[k]=NaN
    return rnd
def poissrnd_(lambda=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[_lambda].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (nargin == 1):
        sz=size_(_lambda)
    else:
        if (nargin == 2):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('poissrnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 2):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('poissrnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(_lambda) and not isequal_(size_(_lambda),sz)):
        error_(char('poissrnd: LAMBDA must be scalar or of size SZ'))
    if (iscomplex_(_lambda)):
        error_(char('poissrnd: LAMBDA must not be complex'))
    if (isa_(_lambda,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(_lambda)):
        if (_lambda >= 0 and _lambda < Inf):
            rnd=randp_(_lambda,sz,cls)
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=NaN_(sz,cls)
        k=(_lambda >= 0) and (_lambda < Inf)
        rnd[k]=randp_(_lambda[k],cls)
    return rnd
def laplace_rnd_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (nargin == 1):
        if (isscalar_(varargin[1]) and varargin[1] >= 0):
            sz=matlabarray([varargin[1],varargin[1]])
        else:
            if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                sz=varargin[1](arange_()).T
            else:
                error_(char('laplace_rnd: dimension vector must be row vector of non-negative integers'))
    else:
        if (nargin > 1):
            if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                error_(char('laplace_rnd: dimensions must be non-negative integers'))
            sz=matlabarray([varargin[:]])
    tmp=rand_(sz)
    rnd=(tmp < 1 / 2).dot(log_(2 * tmp)) - (tmp > 1 / 2).dot(log_(2 * (1 - tmp)))
    return rnd
def cauchy_inv_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,location,scale].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(location) or not isscalar_(scale)):
        retval,x,location,scale=common_size_(x,location,scale,nargout=4)
        if (retval > 0):
            error_(char('cauchy_inv: X, LOCATION, and SCALE must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(location) or iscomplex_(scale)):
        error_(char('cauchy_inv: X, LOCATION, and SCALE must not be complex'))
    if (isa_(x,char('single')) or isa_(location,char('single')) or isa_(scale,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    ok=not isinf_(location) and (scale > 0) and (scale < Inf)
    k=(x == 0) and ok
    inv[k]=- Inf
    k=(x == 1) and ok
    inv[k]=Inf
    k=(x > 0) and (x < 1) and ok
    if (isscalar_(location) and isscalar_(scale)):
        inv[k]=location - scale * cot_(pi * x[k])
    else:
        inv[k]=location[k] - scale[k].dot(cot_(pi * x[k]))
    return inv
def poisscdf_(x=None,lambda=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,_lambda].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(_lambda)):
        retval,x,_lambda=common_size_(x,_lambda,nargout=3)
        if (retval > 0):
            error_(char('poisscdf: X and LAMBDA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(_lambda)):
        error_(char('poisscdf: X and LAMBDA must not be complex'))
    if (isa_(x,char('single')) or isa_(_lambda,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=isnan_(x) or not (_lambda > 0)
    cdf[k]=NaN
    k=(x == Inf) and (_lambda > 0)
    cdf[k]=1
    k=(x >= 0) and (x < Inf) and (_lambda > 0)
    if (isscalar_(_lambda)):
        cdf[k]=1 - gammainc_(_lambda,floor_(x[k]) + 1)
    else:
        cdf[k]=1 - gammainc_(_lambda[k],floor_(x[k]) + 1)
    return cdf
def logistic_pdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (iscomplex_(x)):
        error_(char('logistic_pdf: X must not be complex'))
    cdf=logistic_cdf_(x)
    pdf=cdf.dot((1 - cdf))
    return pdf
def hygeinv_(x=None,t=None,m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,t,m,n].count(None)+len(args)

    if (nargin != 4):
        print_usage_()
    if (not isscalar_(t) or not isscalar_(m) or not isscalar_(n)):
        retval,x,t,m,n=common_size_(x,t,m,n,nargout=5)
        if (retval > 0):
            error_(char('hygeinv: X, T, M, and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(t) or iscomplex_(m) or iscomplex_(n)):
        error_(char('hygeinv: X, T, M, and N must not be complex'))
    if (isa_(x,char('single')) or isa_(t,char('single')) or isa_(m,char('single')) or isa_(n,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    ok=((t >= 0) and (m >= 0) and (n > 0) and (m <= t) and (n <= t) and (t == fix_(t)) and (m == fix_(m)) and (n == fix_(n)))
    if (isscalar_(t)):
        if (ok):
            inv=discrete_inv_(x,arange_(0,n),hygepdf_(arange_(0,n),t,m,n))
            inv[x == 0]=0
    else:
        for i in find_(ok[:].T).reshape(-1):
            v=arange_(0,n[i])
            if (x[i] == 0):
                inv[i]=0
            else:
                inv[i]=discrete_inv_(x[i],v,hygepdf_(v,t[i],m[i],n[i]))
    return inv
def binoinv_(x=None,n=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,n,p].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(n) or not isscalar_(p)):
        retval,x,n,p=common_size_(x,n,p,nargout=4)
        if (retval > 0):
            error_(char('binoinv: X, N, and P must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n) or iscomplex_(p)):
        error_(char('binoinv: X, N, and P must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single')) or isa_(p,char('single'))):
        inv=zeros_(size_(x),char('single'))
    else:
        inv=zeros_(size_(x))
    k=(not (x >= 0) or not (x <= 1) or not (n >= 0) or (n != fix_(n)) or not (p >= 0) or not (p <= 1))
    inv[k]=NaN
    k=find_((x >= 0) and (x <= 1) and (n >= 0) and (n == fix_(n) and (p >= 0) and (p <= 1)))
    if (any_(k)):
        if (isscalar_(n) and isscalar_(p)):
            cdf=binopdf_(0,n,p) * ones_(size_(k))
            while (any_(inv[k] < n)):

                m=find_(cdf < x[k])
                if (any_(m)):
                    inv[k[m]]=inv[k[m]] + 1
                    cdf[m]=cdf[m] + binopdf_(inv[k[m]],n,p)
                else:
                    break

        else:
            cdf=binopdf_(0,n[k],p[k])
            while (any_(inv[k] < n[k])):

                m=find_(cdf < x[k])
                if (any_(m)):
                    inv[k[m]]=inv[k[m]] + 1
                    cdf[m]=cdf[m] + binopdf_(inv[k[m]],n[k[m]],p[k[m]])
                else:
                    break

    return inv
def laplace_cdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (iscomplex_(x)):
        error_(char('laplace_cdf: X must not be complex'))
    cdf=(1 + sign_(x).dot((1 - exp_(- abs_(x))))) / 2
    return cdf
def expinv_(x=None,lambda=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,_lambda].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(_lambda)):
        retval,x,_lambda=common_size_(x,_lambda,nargout=3)
        if (retval > 0):
            error_(char('expinv: X and LAMBDA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(_lambda)):
        error_(char('expinv: X and LAMBDA must not be complex'))
    if (not isscalar_(x)):
        sz=size_(x)
    else:
        sz=size_(_lambda)
    if (iscomplex_(x) or iscomplex_(_lambda)):
        error_(char('expinv: X and LAMBDA must not be complex'))
    if (isa_(x,char('single')) or isa_(_lambda,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    k=(x == 1) and (_lambda > 0)
    inv[k]=Inf
    k=(x >= 0) and (x < 1) and (_lambda > 0)
    if (isscalar_(_lambda)):
        inv[k]=- _lambda * log_(1 - x[k])
    else:
        inv[k]=- _lambda[k].dot(log_(1 - x[k]))
    return inv
def stdnormal_rnd_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (nargin == 1):
        if (isscalar_(varargin[1]) and varargin[1] >= 0):
            sz=matlabarray([varargin[1],varargin[1]])
        else:
            if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                sz=varargin[1]
            else:
                error_(char('stdnormal_rnd: dimension vector must be row vector of non-negative integers'))
    else:
        if (nargin > 1):
            if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                error_(char('stdnormal_rnd: dimensions must be non-negative integers'))
            sz=matlabarray([varargin[:]])
    rnd=randn_(sz)
    return rnd
def cauchy_cdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,location,scale].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(location) or not isscalar_(scale)):
        retval,x,location,scale=common_size_(x,location,scale,nargout=4)
        if (retval > 0):
            error_(char('cauchy_cdf: X, LOCATION, and SCALE must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(location) or iscomplex_(scale)):
        error_(char('cauchy_cdf: X, LOCATION, and SCALE must not be complex'))
    if (isa_(x,char('single')) or isa_(location,char('single')) or isa_(scale,char('single'))):
        cdf=NaN_(size_(x),char('single'))
    else:
        cdf=NaN_(size_(x))
    k=not isinf_(location) and (scale > 0) and (scale < Inf)
    if (isscalar_(location) and isscalar_(scale)):
        cdf=0.5 + atan_((x - location) / scale) / pi
    else:
        cdf[k]=0.5 + atan_((x[k] - location[k]) / scale[k]) / pi
    return cdf
def wienrnd_(t=None,d=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[t,d,n].count(None)+len(args)

    if (nargin == 1):
        d=1
        n=1000
    else:
        if (nargin == 2):
            n=1000
        else:
            if (nargin > 3):
                print_usage_()
    if (not isscalar_(t) or not isscalar_(d) or not isscalar_(n)):
        error_(char('wienrnd: T, D and N must all be positive integers'))
    retval=randn_(n * t,d)
    retval=cumsum_(retval) / sqrt_(n)
    retval=matlabarray([((arange_(1,n * t)).T / n),retval])
    return retval
def unidcdf_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(n)):
        retval,x,n=common_size_(x,n,nargout=3)
        if (retval > 0):
            error_(char('unidcdf: X and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n)):
        error_(char('unidcdf: X and N must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    knan=isnan_(x) or not (n > 0 and n == fix_(n))
    if (any_(knan[:])):
        cdf[knan]=NaN
    k=(x >= n) and not knan
    cdf[k]=1
    k=(x >= 1) and (x < n) and not knan
    if (isscalar_(n)):
        cdf[k]=floor_(x[k]) / n
    else:
        cdf[k]=floor_(x[k]) / n[k]
    return cdf
def tinv_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(n)):
        retval,x,n=common_size_(x,n,nargout=3)
        if (retval > 0):
            error_(char('tinv: X and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n)):
        error_(char('tinv: X and N must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    k=(x == 0) and (n > 0)
    inv[k]=- Inf
    k=(x == 1) and (n > 0)
    inv[k]=Inf
    if (isscalar_(n)):
        k=(x > 0) and (x < 1)
        if ((n > 0) and (n < 10000)):
            inv[k]=(sign_(x[k] - 1 / 2).dot(sqrt_(n * (1 / betainv_(2 * min_(x[k],1 - x[k]),n / 2,1 / 2) - 1))))
        else:
            if (n >= 10000):
                inv[k]=stdnormal_inv_(x[k])
    else:
        k=(x > 0) and (x < 1) and (n > 0) and (n < 10000)
        inv[k]=(sign_(x[k] - 1 / 2).dot(sqrt_(n[k].dot((1 / betainv_(2 * min_(x[k],1 - x[k]),n[k] / 2,1 / 2) - 1)))))
        k=(x > 0) and (x < 1) and (n >= 10000)
        inv[k]=stdnormal_inv_(x[k])
    return inv
def unidinv_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(n)):
        retval,x,n=common_size_(x,n,nargout=3)
        if (retval > 0):
            error_(char('unidcdf: X and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n)):
        error_(char('unidinv: X and N must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    k=(x > 0) and (x <= 1) and (n > 0 and n == fix_(n))
    if (isscalar_(n)):
        inv[k]=floor_(x[k] * n)
    else:
        inv[k]=floor_(x[k].dot(n[k]))
    return inv
def lognpdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,mu,sigma].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(mu) or not isscalar_(sigma)):
        retval,x,mu,sigma=common_size_(x,mu,sigma,nargout=4)
        if (retval > 0):
            error_(char('lognpdf: X, MU, and SIGMA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(mu) or iscomplex_(sigma)):
        error_(char('lognpdf: X, MU, and SIGMA must not be complex'))
    if (isa_(x,char('single')) or isa_(mu,char('single')) or isa_(sigma,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=isnan_(x) or not (sigma > 0) or not (sigma < Inf)
    pdf[k]=NaN
    k=(x > 0) and (x < Inf) and (sigma > 0) and (sigma < Inf)
    if (isscalar_(mu) and isscalar_(sigma)):
        pdf[k]=normpdf_(log_(x[k]),mu,sigma) / x[k]
    else:
        pdf[k]=normpdf_(log_(x[k]),mu[k],sigma[k]) / x[k]
    return pdf
def unifpdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,x,a,b=common_size_(x,a,b,nargout=4)
        if (retval > 0):
            error_(char('unifpdf: X, A, and B must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(a) or iscomplex_(b)):
        error_(char('unifpdf: X, A, and B must not be complex'))
    if (isa_(x,char('single')) or isa_(a,char('single')) or isa_(b,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=isnan_(x) or not (a < b)
    pdf[k]=NaN
    k=(x >= a) and (x <= b) and (a < b)
    if (isscalar_(a) and isscalar_(b)):
        pdf[k]=1 / (b - a)
    else:
        pdf[k]=1 / (b[k] - a[k])
    return pdf
def betapdf_(x=None,a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,x,a,b=common_size_(x,a,b,nargout=4)
        if (retval > 0):
            error_(char('betapdf: X, A, and B must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(a) or iscomplex_(b)):
        error_(char('betapdf: X, A, and B must not be complex'))
    if (isa_(x,char('single')) or isa_(a,char('single')) or isa_(b,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=not (a > 0) or not (b > 0) or isnan_(x)
    pdf[k]=NaN
    k=(x > 0) and (x < 1) and (a > 0) and (b > 0) and ((a != 1) or (b != 1))
    if (isscalar_(a) and isscalar_(b)):
        pdf[k]=exp_((a - 1) * log_(x[k]) + (b - 1) * log_(1 - x[k]) + lgamma_(a + b) - lgamma_(a) - lgamma_(b))
    else:
        pdf[k]=exp_((a[k] - 1).dot(log_(x[k])) + (b[k] - 1).dot(log_(1 - x[k])) + lgamma_(a[k] + b[k]) - lgamma_(a[k]) - lgamma_(b[k]))
    k=(x == 0) and (a == 1) and (b > 0) and (b != 1)
    if (isscalar_(a) and isscalar_(b)):
        pdf[k]=exp_(lgamma_(a + b) - lgamma_(a) - lgamma_(b))
    else:
        pdf[k]=exp_(lgamma_(a[k] + b[k]) - lgamma_(a[k]) - lgamma_(b[k]))
    k=(x == 1) and (b == 1) and (a > 0) and (a != 1)
    if (isscalar_(a) and isscalar_(b)):
        pdf[k]=exp_(lgamma_(a + b) - lgamma_(a) - lgamma_(b))
    else:
        pdf[k]=exp_(lgamma_(a[k] + b[k]) - lgamma_(a[k]) - lgamma_(b[k]))
    k=(x >= 0) and (x <= 1) and (a == 1) and (b == 1)
    pdf[k]=1
    k=(x == 0) and (a < 1)
    pdf[k]=Inf
    k=(x == 1) and (b < 1)
    pdf[k]=Inf
    return pdf
def binornd_(n=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,p].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isscalar_(n) or not isscalar_(p)):
        retval,n,p=common_size_(n,p,nargout=3)
        if (retval > 0):
            error_(char('binornd: N and P must be of common size or scalars'))
    if (iscomplex_(n) or iscomplex_(p)):
        error_(char('binornd: N and P must not be complex'))
    if (nargin == 2):
        sz=size_(n)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('binornd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('binornd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(n) and not isequal_(size_(n),sz)):
        error_(char('binornd: N and P must be scalar or of size SZ'))
    if (isa_(n,char('single')) or isa_(p,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(n) and isscalar_(p)):
        if ((n > 0) and (n < Inf) and (n == fix_(n)) and (p >= 0) and (p <= 1)):
            nel=prod_(sz)
            tmp=rand_(n,nel)
            rnd=sum_(tmp < p,1)
            rnd=reshape_(rnd,sz)
            if (strcmp_(cls,char('single'))):
                rnd=single_(rnd)
        else:
            if ((n == 0) and (p >= 0) and (p <= 1)):
                rnd=zeros_(sz,cls)
            else:
                rnd=NaN_(sz,cls)
    else:
        rnd=zeros_(sz,cls)
        k=not (n >= 0) or not (n < Inf) or not (n == fix_(n)) or not (p >= 0) or not (p <= 1)
        rnd[k]=NaN
        k=(n > 0) and (n < Inf) and (n == fix_(n)) and (p >= 0) and (p <= 1)
        if (any_(k[:])):
            N=max_(n[k])
            L=sum_(k[:])
            tmp=rand_(N,L)
            ind=repmat_((arange_(1,N)).T,1,L)
            rnd[k]=sum_((tmp < repmat_(p[k](arange_()).T,N,1)) and (ind <= repmat_(n[k](arange_()).T,N,1)),1)
    return rnd
def stdnormal_pdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (iscomplex_(x)):
        error_(char('stdnormal_pdf: X must not be complex'))
    pdf=(2 * pi) ** (- 1 / 2) * exp_(- x ** 2 / 2)
    return pdf
def logninv_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,mu,sigma].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(mu) or not isscalar_(sigma)):
        retval,x,mu,sigma=common_size_(x,mu,sigma,nargout=4)
        if (retval > 0):
            error_(char('logninv: X, MU, and SIGMA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(mu) or iscomplex_(sigma)):
        error_(char('logninv: X, MU, and SIGMA must not be complex'))
    if (isa_(x,char('single')) or isa_(mu,char('single')) or isa_(sigma,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    k=not (x >= 0) or not (x <= 1) or not (sigma > 0) or not (sigma < Inf)
    inv[k]=NaN
    k=(x == 1) and (sigma > 0) and (sigma < Inf)
    inv[k]=Inf
    k=(x >= 0) and (x < 1) and (sigma > 0) and (sigma < Inf)
    if (isscalar_(mu) and isscalar_(sigma)):
        inv[k]=exp_(mu).dot(exp_(sigma.dot(stdnormal_inv_(x[k]))))
    else:
        inv[k]=exp_(mu[k]).dot(exp_(sigma[k].dot(stdnormal_inv_(x[k]))))
    return inv
def trnd_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (nargin == 1):
        sz=size_(n)
    else:
        if (nargin == 2):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('trnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 2):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('trnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(n) and not isequal_(size_(n),sz)):
        error_(char('trnd: N must be scalar or of size SZ'))
    if (iscomplex_(n)):
        error_(char('trnd: N must not be complex'))
    if (isa_(n,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(n)):
        if ((n > 0) and (n < Inf)):
            rnd=randn_(sz,cls) / sqrt_(2 * randg_(n / 2,sz,cls) / n)
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=NaN_(sz,cls)
        k=(n > 0) and (n < Inf)
        rnd[k]=randn_(sum_(k[:]),1,cls) / sqrt_(2 * randg_(n[k] / 2,cls) / n[k])(arange_())
    return rnd
def gampdf_(x=None,a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,x,a,b=common_size_(x,a,b,nargout=4)
        if (retval > 0):
            error_(char('gampdf: X, A, and B must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(a) or iscomplex_(b)):
        error_(char('gampdf: X, A, and B must not be complex'))
    if (isa_(x,char('single')) or isa_(a,char('single')) or isa_(b,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=not (a > 0) or not (b > 0) or isnan_(x)
    pdf[k]=NaN
    k=(x >= 0) and (a > 0) and (a <= 1) and (b > 0)
    if (isscalar_(a) and isscalar_(b)):
        pdf[k]=(x[k] ** (a - 1)).dot(exp_(- x[k] / b)) / gamma_(a) / (b ** a)
    else:
        pdf[k]=(x[k] ** (a[k] - 1)).dot(exp_(- x[k] / b[k])) / gamma_(a[k]) / (b[k] ** a[k])
    k=(x >= 0) and (a > 1) and (b > 0)
    if (isscalar_(a) and isscalar_(b)):
        pdf[k]=exp_(- a * log_(b) + (a - 1) * log_(x[k]) - x[k] / b - gammaln_(a))
    else:
        pdf[k]=exp_(- a[k].dot(log_(b[k])) + (a[k] - 1).dot(log_(x[k])) - x[k] / b[k] - gammaln_(a[k]))
    return pdf
def logncdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,mu,sigma].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(mu) or not isscalar_(sigma)):
        retval,x,mu,sigma=common_size_(x,mu,sigma,nargout=4)
        if (retval > 0):
            error_(char('logncdf: X, MU, and SIGMA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(mu) or iscomplex_(sigma)):
        error_(char('logncdf: X, MU, and SIGMA must not be complex'))
    if (isa_(x,char('single')) or isa_(mu,char('single')) or isa_(sigma,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=isnan_(x) or not (sigma > 0) or not (sigma < Inf)
    cdf[k]=NaN
    k=(x == Inf) and (sigma > 0) and (sigma < Inf)
    cdf[k]=1
    k=(x > 0) and (x < Inf) and (sigma > 0) and (sigma < Inf)
    if (isscalar_(mu) and isscalar_(sigma)):
        cdf[k]=stdnormal_cdf_((log_(x[k]) - mu) / sigma)
    else:
        cdf[k]=stdnormal_cdf_((log_(x[k]) - mu[k]) / sigma[k])
    return cdf
def poissinv_(x=None,lambda=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,_lambda].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(_lambda)):
        retval,x,_lambda=common_size_(x,_lambda,nargout=3)
        if (retval > 0):
            error_(char('poissinv: X and LAMBDA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(_lambda)):
        error_(char('poissinv: X and LAMBDA must not be complex'))
    if (isa_(x,char('single')) or isa_(_lambda,char('single'))):
        inv=zeros_(size_(x),char('single'))
    else:
        inv=zeros_(size_(x))
    k=(x < 0) or (x > 1) or isnan_(x) or not (_lambda > 0)
    inv[k]=NaN
    k=(x == 1) and (_lambda > 0)
    inv[k]=Inf
    k=find_((x > 0) and (x < 1) and (_lambda > 0))
    if (isscalar_(_lambda)):
        cdf=exp_(- _lambda) * ones_(size_(k))
    else:
        cdf=exp_(- _lambda[k])
    while (1):

        m=find_(cdf < x[k])
        if (any_(m)):
            inv[k[m]] += 1
            if (isscalar_(_lambda)):
                cdf[m]=cdf[m] + poisspdf_(inv[k[m]],_lambda)
            else:
                cdf[m]=cdf[m] + poisspdf_(inv[k[m]],_lambda[k[m]])
        else:
            break

    return inv
def chi2cdf_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(n)):
        retval,x,n=common_size_(x,n,nargout=3)
        if (retval > 0):
            error_(char('chi2cdf: X and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n)):
        error_(char('chi2cdf: X and N must not be complex'))
    cdf=gamcdf_(x,n / 2,2)
    return cdf
def normrnd_(mu=None,sigma=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[mu,sigma].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isscalar_(mu) or not isscalar_(sigma)):
        retval,mu,sigma=common_size_(mu,sigma,nargout=3)
        if (retval > 0):
            error_(char('normrnd: mu and sigma must be of common size or scalars'))
    if (iscomplex_(mu) or iscomplex_(sigma)):
        error_(char('normrnd: MU and SIGMA must not be complex'))
    if (nargin == 2):
        sz=size_(mu)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('normrnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('normrnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(mu) and not isequal_(size_(mu),sz)):
        error_(char('normrnd: mu and sigma must be scalar or of size SZ'))
    if (isa_(mu,char('single')) or isa_(sigma,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(mu) and isscalar_(sigma)):
        if (isfinite_(mu) and (sigma > 0) and (sigma < Inf)):
            rnd=mu + sigma * randn_(sz,cls)
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=mu + sigma.dot(randn_(sz,cls))
        k=not isfinite_(mu) or not (sigma > 0) or not (sigma < Inf)
        rnd[k]=NaN
    return rnd
def gamrnd_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,a,b=common_size_(a,b,nargout=3)
        if (retval > 0):
            error_(char('gamrnd: A and B must be of common size or scalars'))
    if (iscomplex_(a) or iscomplex_(b)):
        error_(char('gamrnd: A and B must not be complex'))
    if (nargin == 2):
        sz=size_(a)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('gamrnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('gamrnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(a) and not isequal_(size_(a),sz)):
        error_(char('gamrnd: A and B must be scalar or of size SZ'))
    if (isa_(a,char('single')) or isa_(b,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(a) and isscalar_(b)):
        if ((a > 0) and (a < Inf) and (b > 0) and (b < Inf)):
            rnd=b * randg_(a,sz,cls)
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=NaN_(sz,cls)
        k=(a > 0) and (a < Inf) and (b > 0) and (b < Inf)
        rnd[k]=b[k].dot(randg_(a[k],cls))
    return rnd
def normpdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,mu,sigma].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(mu) or not isscalar_(sigma)):
        retval,x,mu,sigma=common_size_(x,mu,sigma,nargout=4)
        if (retval > 0):
            error_(char('normpdf: X, MU, and SIGMA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(mu) or iscomplex_(sigma)):
        error_(char('normpdf: X, MU, and SIGMA must not be complex'))
    if (isa_(x,char('single')) or isa_(mu,char('single')) or isa_(sigma,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    if (isscalar_(mu) and isscalar_(sigma)):
        if (isfinite_(mu) and (sigma > 0) and (sigma < Inf)):
            pdf=stdnormal_pdf_((x - mu) / sigma) / sigma
        else:
            pdf=NaN_(size_(x),class_(pdf))
    else:
        k=isinf_(mu) or not (sigma > 0) or not (sigma < Inf)
        pdf[k]=NaN
        k=not isinf_(mu) and (sigma > 0) and (sigma < Inf)
        pdf[k]=stdnormal_pdf_((x[k] - mu[k]) / sigma[k]) / sigma[k]
    return pdf
def normcdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,mu,sigma].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(mu) or not isscalar_(sigma)):
        retval,x,mu,sigma=common_size_(x,mu,sigma,nargout=4)
        if (retval > 0):
            error_(char('normcdf: X, MU, and SIGMA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(mu) or iscomplex_(sigma)):
        error_(char('normcdf: X, MU, and SIGMA must not be complex'))
    if (isa_(x,char('single')) or isa_(mu,char('single')) or isa_(sigma,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    if (isscalar_(mu) and isscalar_(sigma)):
        if (isfinite_(mu) and (sigma > 0) and (sigma < Inf)):
            cdf=stdnormal_cdf_((x - mu) / sigma)
        else:
            cdf=NaN_(size_(x),class_(cdf))
    else:
        k=not isfinite_(mu) or not (sigma > 0) or not (sigma < Inf)
        cdf[k]=NaN
        k=not k
        cdf[k]=stdnormal_cdf_((x[k] - mu[k]) / sigma[k])
    return cdf
def fpdf_(x=None,m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,m,n].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(m) or not isscalar_(n)):
        retval,x,m,n=common_size_(x,m,n,nargout=4)
        if (retval > 0):
            error_(char('fpdf: X, M, and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(m) or iscomplex_(n)):
        error_(char('fpdf: X, M, and N must not be complex'))
    if (isa_(x,char('single')) or isa_(m,char('single')) or isa_(n,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=isnan_(x) or not (m > 0) or not (m < Inf) or not (n > 0) or not (n < Inf)
    pdf[k]=NaN
    k=(x > 0) and (x < Inf) and (m > 0) and (m < Inf) and (n > 0) and (n < Inf)
    if (isscalar_(m) and isscalar_(n)):
        tmp=m / n * x[k]
        pdf[k]=(exp_((m / 2 - 1) * log_(tmp) - ((m + n) / 2) * log_(1 + tmp)) * (m / n) / beta_(m / 2,n / 2))
    else:
        tmp=m[k].dot(x[k]) / n[k]
        pdf[k]=(exp_((m[k] / 2 - 1).dot(log_(tmp)) - ((m[k] + n[k]) / 2).dot(log_(1 + tmp))).dot((m[k] / n[k])) / beta_(m[k] / 2,n[k] / 2))
    return pdf
def betacdf_(x=None,a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,x,a,b=common_size_(x,a,b,nargout=4)
        if (retval > 0):
            error_(char('betacdf: X, A, and B must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(a) or iscomplex_(b)):
        error_(char('betacdf: X, A, and B must not be complex'))
    if (isa_(x,char('single')) or isa_(a,char('single')) or isa_(b,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=isnan_(x) or not (a > 0) or not (b > 0)
    cdf[k]=NaN
    k=(x >= 1) and (a > 0) and (b > 0)
    cdf[k]=1
    k=(x > 0) and (x < 1) and (a > 0) and (b > 0)
    if (isscalar_(a) and isscalar_(b)):
        cdf[k]=betainc_(x[k],a,b)
    else:
        cdf[k]=betainc_(x[k],a[k],b[k])
    return cdf
def lognrnd_(mu=None,sigma=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[mu,sigma].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isscalar_(mu) or not isscalar_(sigma)):
        retval,mu,sigma=common_size_(mu,sigma,nargout=3)
        if (retval > 0):
            error_(char('lognrnd: MU and SIGMA must be of common size or scalars'))
    if (iscomplex_(mu) or iscomplex_(sigma)):
        error_(char('lognrnd: MU and SIGMA must not be complex'))
    if (nargin == 2):
        sz=size_(mu)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('lognrnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('lognrnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(mu) and not isequal_(size_(mu),sz)):
        error_(char('lognrnd: MU and SIGMA must be scalar or of size SZ'))
    if (isa_(mu,char('single')) or isa_(sigma,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(mu) and isscalar_(sigma)):
        if ((sigma > 0) and (sigma < Inf)):
            rnd=exp_(mu + sigma * randn_(sz,cls))
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=exp_(mu + sigma.dot(randn_(sz,cls)))
        k=(sigma < 0) or (sigma == Inf)
        rnd[k]=NaN
    return rnd
def logistic_rnd_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (nargin == 1):
        if (isscalar_(varargin[1]) and varargin[1] >= 0):
            sz=matlabarray([varargin[1],varargin[1]])
        else:
            if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                sz=varargin[1]
            else:
                error_(char('logistic_rnd: dimension vector must be row vector of non-negative integers'))
    else:
        if (nargin > 1):
            if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                error_(char('logistic_rnd: dimensions must be non-negative integers'))
            sz=matlabarray([varargin[:]])
    rnd=- log_(1 / rand_(sz) - 1)
    return rnd
def empirical_cdf_(x=None,data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,data].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isvector_(data)):
        error_(char('empirical_cdf: DATA must be a vector'))
    cdf=discrete_cdf_(x,data,ones_(size_(data)))
    return cdf
def exprnd_(lambda=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[_lambda].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (nargin == 1):
        sz=size_(_lambda)
    else:
        if (nargin == 2):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('exprnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 2):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('exprnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(_lambda) and not isequal_(size_(_lambda),sz)):
        error_(char('exprnd: LAMBDA must be scalar or of size SZ'))
    if (iscomplex_(_lambda)):
        error_(char('exprnd: LAMBDA must not be complex'))
    if (isa_(_lambda,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(_lambda)):
        if ((_lambda > 0) and (_lambda < Inf)):
            rnd=rande_(sz,cls) * _lambda
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=NaN_(sz,cls)
        k=(_lambda > 0) and (_lambda < Inf)
        rnd[k]=rande_(sum_(k[:]),1,cls).dot(_lambda[k](arange_()))
    return rnd
def wblpdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,scale,shape].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not isscalar_(scale) or not isscalar_(shape)):
        retval,x,scale,shape=common_size_(x,scale,shape,nargout=4)
        if (retval > 0):
            error_(char('wblpdf: X, SCALE, and SHAPE must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(scale) or iscomplex_(shape)):
        error_(char('wblpdf: X, SCALE, and SHAPE must not be complex'))
    if (isa_(x,char('single')) or isa_(scale,char('single')) or isa_(shape,char('single'))):
        pdf=NaN_(size_(x),char('single'))
    else:
        pdf=NaN_(size_(x))
    ok=((scale > 0) and (scale < Inf) and (shape > 0) and (shape < Inf))
    k=(x < 0) and ok
    pdf[k]=0
    k=(x >= 0) and (x < Inf) and ok
    if (isscalar_(scale) and isscalar_(shape)):
        pdf[k]=(shape * (scale ** - shape).dot((x[k] ** (shape - 1))).dot(exp_(- (x[k] / scale) ** shape)))
    else:
        pdf[k]=(shape[k].dot((scale[k] ** - shape[k])).dot((x[k] ** (shape[k] - 1))).dot(exp_(- (x[k] / scale[k]) ** shape[k])))
    return pdf
def poisspdf_(x=None,lambda=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,_lambda].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(_lambda)):
        retval,x,_lambda=common_size_(x,_lambda,nargout=3)
        if (retval > 0):
            error_(char('poisspdf: X and LAMBDA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(_lambda)):
        error_(char('poisspdf: X and LAMBDA must not be complex'))
    if (isa_(x,char('single')) or isa_(_lambda,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=isnan_(x) or not (_lambda > 0)
    pdf[k]=NaN
    k=(x >= 0) and (x < Inf) and (x == fix_(x)) and (_lambda > 0)
    if (isscalar_(_lambda)):
        pdf[k]=exp_(x[k] * log_(_lambda) - _lambda - gammaln_(x[k] + 1))
    else:
        pdf[k]=exp_(x[k].dot(log_(_lambda[k])) - _lambda[k] - gammaln_(x[k] + 1))
    return pdf
def geopdf_(x=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,p].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(p)):
        retval,x,p=common_size_(x,p,nargout=3)
        if (retval > 0):
            error_(char('geopdf: X and P must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(p)):
        error_(char('geopdf: X and P must not be complex'))
    if (isa_(x,char('single')) or isa_(p,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=isnan_(x) or (x == Inf) or not (p >= 0) or not (p <= 1)
    pdf[k]=NaN
    k=(x >= 0) and (x < Inf) and (x == fix_(x)) and (p > 0) and (p <= 1)
    if (isscalar_(p)):
        pdf[k]=p * ((1 - p) ** x[k])
    else:
        pdf[k]=p[k].dot(((1 - p[k]) ** x[k]))
    return pdf
def hygecdf_(x=None,t=None,m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,t,m,n].count(None)+len(args)

    if (nargin != 4):
        print_usage_()
    if (not isscalar_(t) or not isscalar_(m) or not isscalar_(n)):
        retval,x,t,m,n=common_size_(x,t,m,n,nargout=5)
        if (retval > 0):
            error_(char('hygecdf: X, T, M, and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(t) or iscomplex_(m) or iscomplex_(n)):
        error_(char('hygecdf: X, T, M, and N must not be complex'))
    if (isa_(x,char('single')) or isa_(t,char('single')) or isa_(m,char('single')) or isa_(n,char('single'))):
        cdf=NaN_(size_(x),char('single'))
    else:
        cdf=NaN_(size_(x))
    ok=((t >= 0) and (m >= 0) and (n > 0) and (m <= t) and (n <= t) and (t == fix_(t)) and (m == fix_(m)) and (n == fix_(n)))
    if (isscalar_(t)):
        if (ok):
            cdf=discrete_cdf_(x,arange_(0,n),hygepdf_(arange_(0,n),t,m,n))
    else:
        for i in find_(ok[:].T).reshape(-1):
            v=arange_(0,n[i])
            cdf[i]=discrete_cdf_(x[i],v,hygepdf_(v,t[i],m[i],n[i]))
    return cdf
def chi2pdf_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(n)):
        retval,x,n=common_size_(x,n,nargout=3)
        if (retval > 0):
            error_(char('chi2pdf: X and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n)):
        error_(char('chi2pdf: X and N must not be complex'))
    pdf=gampdf_(x,n / 2,2)
    return pdf
def laplace_inv_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (iscomplex_(x)):
        error_(char('laplace_inv: X must not be complex'))
    if (isa_(x,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    k=(x >= 0) and (x <= 1)
    inv[k]=((x[k] < 1 / 2).dot(log_(2 * x[k])) - (x[k] > 1 / 2).dot(log_(2 * (1 - x[k]))))
    return inv
def nbinrnd_(n=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,p].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isscalar_(n) or not isscalar_(p)):
        retval,n,p=common_size_(n,p,nargout=3)
        if (retval > 0):
            error_(char('nbinrnd: N and P must be of common size or scalars'))
    if (iscomplex_(n) or iscomplex_(p)):
        error_(char('nbinrnd: N and P must not be complex'))
    if (nargin == 2):
        sz=size_(n)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('nbinrnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('nbinrnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(n) and not isequal_(size_(n),sz)):
        error_(char('nbinrnd: N and P must be scalar or of size SZ'))
    if (isa_(n,char('single')) or isa_(p,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(n) and isscalar_(p)):
        if ((n > 0) and (n < Inf) and (p > 0) and (p <= 1)):
            rnd=randp_((1 - p) / p.dot(randg_(n,sz,cls)),cls)
        else:
            if ((n > 0) and (n < Inf) and (p == 0)):
                rnd=zeros_(sz,cls)
            else:
                rnd=NaN_(sz,cls)
    else:
        rnd=NaN_(sz,cls)
        k=(n > 0) and (n < Inf) and (p == 0)
        rnd[k]=0
        k=(n > 0) and (n < Inf) and (p > 0) and (p <= 1)
        rnd[k]=randp_((1 - p[k]) / p[k].dot(randg_(n[k],cls)))
    return rnd
def empirical_inv_(x=None,data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,data].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isvector_(data)):
        error_(char('empirical_inv: DATA must be a vector'))
    inv=discrete_inv_(x,data,ones_(size_(data)))
    return inv
def tpdf_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(n)):
        retval,x,n=common_size_(x,n,nargout=3)
        if (retval > 0):
            error_(char('tpdf: X and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n)):
        error_(char('tpdf: X and N must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=isnan_(x) or not (n > 0) or not (n < Inf)
    pdf[k]=NaN
    k=isfinite_(x) and (n > 0) and (n < Inf)
    if (isscalar_(n)):
        pdf[k]=(exp_(- (n + 1) * log_(1 + x[k] ** 2 / n) / 2) / (sqrt_(n) * beta_(n / 2,1 / 2)))
    else:
        pdf[k]=(exp_(- (n[k] + 1).dot(log_(1 + x[k] ** 2 / n[k])) / 2) / (sqrt_(n[k]).dot(beta_(n[k] / 2,1 / 2))))
    return pdf
def geoinv_(x=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,p].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(p)):
        retval,x,p=common_size_(x,p,nargout=3)
        if (retval > 0):
            error_(char('geoinv: X and P must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(p)):
        error_(char('geoinv: X and P must not be complex'))
    if (isa_(x,char('single')) or isa_(p,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    k=(x == 1) and (p >= 0) and (p <= 1)
    inv[k]=Inf
    k=(x >= 0) and (x < 1) and (p > 0) and (p <= 1)
    if (isscalar_(p)):
        inv[k]=max_(ceil_(log_(1 - x[k]) / log_(1 - p)) - 1,0)
    else:
        inv[k]=max_(ceil_(log_(1 - x[k]) / log_(1 - p[k])) - 1,0)
    return inv
def gaminv_(x=None,a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,x,a,b=common_size_(x,a,b,nargout=4)
        if (retval > 0):
            error_(char('gaminv: X, A, and B must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(a) or iscomplex_(b)):
        error_(char('gaminv: X, A, and B must not be complex'))
    if (isa_(x,char('single')) or isa_(a,char('single')) or isa_(b,char('single'))):
        inv=zeros_(size_(x),char('single'))
    else:
        inv=zeros_(size_(x))
    k=((x < 0) or (x > 1) or isnan_(x) or not (a > 0) or not (a < Inf) or not (b > 0) or not (b < Inf))
    inv[k]=NaN
    k=(x == 1) and (a > 0) and (a < Inf) and (b > 0) and (b < Inf)
    inv[k]=Inf
    k=find_((x > 0) and (x < 1) and (a > 0) and (a < Inf) and (b > 0) and (b < Inf))
    if (any_(k)):
        if (not isscalar_(a) or not isscalar_(b)):
            a=a[k]
            b=b[k]
            y=a.dot(b)
        else:
            y=a * b * ones_(size_(k))
        x=x[k]
        if (isa_(x,char('single'))):
            myeps=eps_(char('single'))
        else:
            myeps=copy_(eps)
        l=find_(x < myeps)
        if (any_(l)):
            y[l]=sqrt_(myeps) * ones_(length_(l),1)
        y_old=copy_(y)
        for i in arange_(1,100).reshape(-1):
            h=(gamcdf_(y_old,a,b) - x) / gampdf_(y_old,a,b)
            y_new=y_old - h
            ind=find_(y_new <= myeps)
            if (any_(ind)):
                y_new[ind]=y_old[ind] / 10
                h=y_old - y_new
            if (max_(abs_(h)) < sqrt_(myeps)):
                break
            y_old=copy_(y_new)
        inv[k]=y_new
    return inv
def wblinv_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,scale,shape].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not isscalar_(scale) or not isscalar_(shape)):
        retval,x,scale,shape=common_size_(x,scale,shape,nargout=4)
        if (retval > 0):
            error_(char('wblinv: X, SCALE, and SHAPE must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(scale) or iscomplex_(shape)):
        error_(char('wblinv: X, SCALE, and SHAPE must not be complex'))
    if (isa_(x,char('single')) or isa_(scale,char('single')) or isa_(shape,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    ok=(scale > 0) and (scale < Inf) and (shape > 0) and (shape < Inf)
    k=(x == 0) and ok
    inv[k]=0
    k=(x == 1) and ok
    inv[k]=Inf
    k=(x > 0) and (x < 1) and ok
    if (isscalar_(scale) and isscalar_(shape)):
        inv[k]=scale * (- log_(1 - x[k])) ** (1 / shape)
    else:
        inv[k]=scale[k].dot((- log_(1 - x[k])) ** (1 / shape[k]))
    return inv
def cauchy_rnd_(location=None,scale=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[location,scale].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isscalar_(location) or not isscalar_(scale)):
        retval,location,scale=common_size_(location,scale,nargout=3)
        if (retval > 0):
            error_(char('cauchy_rnd: LOCATION and SCALE must be of common size or scalars'))
    if (iscomplex_(location) or iscomplex_(scale)):
        error_(char('cauchy_rnd: LOCATION and SCALE must not be complex'))
    if (nargin == 2):
        sz=size_(location)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('cauchy_rnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('cauchy_rnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(location) and not isequal_(size_(location),sz)):
        error_(char('cauchy_rnd: LOCATION and SCALE must be scalar or of size SZ'))
    if (isa_(location,char('single')) or isa_(scale,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(location) and isscalar_(scale)):
        if (not isinf_(location) and (scale > 0) and (scale < Inf)):
            rnd=location - cot_(pi * rand_(sz,cls)) * scale
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=NaN_(sz,cls)
        k=not isinf_(location) and (scale > 0) and (scale < Inf)
        rnd[k]=location[k](arange_()) - cot_(pi * rand_(sum_(k[:]),1,cls)).dot(scale[k](arange_()))
    return rnd
def unidrnd_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (nargin == 1):
        sz=size_(n)
    else:
        if (nargin == 2):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('unidrnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 2):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('unidrnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(n) and not isequal_(size_(n),sz)):
        error_(char('unidrnd: N must be scalar or of size SZ'))
    if (iscomplex_(n)):
        error_(char('unidrnd: N must not be complex'))
    if (isa_(n,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(n)):
        if (n > 0 and n == fix_(n)):
            rnd=ceil_(rand_(sz,cls) * n)
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=ceil_(rand_(sz,cls).dot(n))
        k=not (n > 0 and n == fix_(n))
        rnd[k]=NaN
    return rnd
def betainv_(x=None,a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,x,a,b=common_size_(x,a,b,nargout=4)
        if (retval > 0):
            error_(char('betainv: X, A, and B must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(a) or iscomplex_(b)):
        error_(char('betainv: X, A, and B must not be complex'))
    if (isa_(x,char('single')) or isa_(a,char('single')) or isa_(b,char('single'))):
        inv=zeros_(size_(x),char('single'))
    else:
        inv=zeros_(size_(x))
    k=(x < 0) or (x > 1) or not (a > 0) or not (b > 0) or isnan_(x)
    inv[k]=NaN
    k=(x == 1) and (a > 0) and (b > 0)
    inv[k]=1
    k=find_((x > 0) and (x < 1) and (a > 0) and (b > 0))
    if (any_(k)):
        if (not isscalar_(a) or not isscalar_(b)):
            a=a[k]
            b=b[k]
            y=a / (a + b)
        else:
            y=a / (a + b) * ones_(size_(k))
        x=x[k]
        if (isa_(y,char('single'))):
            myeps=eps_(char('single'))
        else:
            myeps=copy_(eps)
        l=find_(y < myeps)
        if (any_(l)):
            y[l]=sqrt_(myeps) * ones_(length_(l),1)
        l=find_(y > 1 - myeps)
        if (any_(l)):
            y[l]=1 - sqrt_(myeps) * ones_(length_(l),1)
        y_old=copy_(y)
        for i in arange_(1,10000).reshape(-1):
            h=(betacdf_(y_old,a,b) - x) / betapdf_(y_old,a,b)
            y_new=y_old - h
            ind=find_(y_new <= myeps)
            if (any_(ind)):
                y_new[ind]=y_old[ind] / 10
            ind=find_(y_new >= 1 - myeps)
            if (any_(ind)):
                y_new[ind]=1 - (1 - y_old[ind]) / 10
            h=y_old - y_new
            if (max_(abs_(h)) < sqrt_(myeps)):
                break
            y_old=copy_(y_new)
        inv[k]=y_new
    return inv
def nbinpdf_(x=None,n=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,n,p].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(n) or not isscalar_(p)):
        retval,x,n,p=common_size_(x,n,p,nargout=4)
        if (retval > 0):
            error_(char('nbinpdf: X, N, and P must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n) or iscomplex_(p)):
        error_(char('nbinpdf: X, N, and P must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single')) or isa_(p,char('single'))):
        pdf=NaN_(size_(x),char('single'))
    else:
        pdf=NaN_(size_(x))
    ok=(x < Inf) and (x == fix_(x)) and (n > 0) and (n < Inf) and (p >= 0) and (p <= 1)
    k=(x < 0) and ok
    pdf[k]=0
    k=(x >= 0) and ok
    if (isscalar_(n) and isscalar_(p)):
        pdf[k]=bincoeff_(- n,x[k]).dot((p ** n)).dot(((p - 1) ** x[k]))
    else:
        pdf[k]=bincoeff_(- n[k],x[k]).dot((p[k] ** n[k])).dot(((p[k] - 1) ** x[k]))
    return pdf
def unifrnd_(a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[a,b].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,a,b=common_size_(a,b,nargout=3)
        if (retval > 0):
            error_(char('unifrnd: A and B must be of common size or scalars'))
    if (iscomplex_(a) or iscomplex_(b)):
        error_(char('unifrnd: A and B must not be complex'))
    if (nargin == 2):
        sz=size_(a)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('unifrnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('unifrnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(a) and not isequal_(size_(a),sz)):
        error_(char('unifrnd: A and B must be scalar or of size SZ'))
    if (isa_(a,char('single')) or isa_(b,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(a) and isscalar_(b)):
        if ((- Inf < a) and (a < b) and (b < Inf)):
            rnd=a + (b - a) * rand_(sz,cls)
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=a + (b - a).dot(rand_(sz,cls))
        k=not (- Inf < a) or not (a < b) or not (b < Inf)
        rnd[k]=NaN
    return rnd
def frnd_(m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[m,n].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isscalar_(m) or not isscalar_(n)):
        retval,m,n=common_size_(m,n,nargout=3)
        if (retval > 0):
            error_(char('frnd: M and N must be of common size or scalars'))
    if (iscomplex_(m) or iscomplex_(n)):
        error_(char('frnd: M and N must not be complex'))
    if (nargin == 2):
        sz=size_(m)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('frnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('frnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(m) and not isequal_(size_(m),sz)):
        error_(char('frnd: M and N must be scalar or of size SZ'))
    if (isa_(m,char('single')) or isa_(n,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(m) and isscalar_(n)):
        if ((m > 0) and (m < Inf) and (n > 0) and (n < Inf)):
            rnd=n / m * randg_(m / 2,sz,cls) / randg_(n / 2,sz,cls)
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=NaN_(sz,cls)
        k=(m > 0) and (m < Inf) and (n > 0) and (n < Inf)
        rnd[k]=n[k] / m[k].dot(randg_(m[k] / 2,cls)) / randg_(n[k] / 2,cls)
    return rnd
def chi2inv_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(n)):
        retval,x,n=common_size_(x,n,nargout=3)
        if (retval > 0):
            error_(char('chi2inv: X and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n)):
        error_(char('chi2inv: X and N must not be complex'))
    inv=gaminv_(x,n / 2,2)
    return inv
def kolmogorov_smirnov_cdf_(x=None,tol=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,tol].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin == 1):
        if (isa_(x,char('single'))):
            tol=eps_(char('single'))
        else:
            tol=copy_(eps)
    else:
        if (not (isscalar_(tol) and (tol > 0))):
            error_(char('kolmogorov_smirnov_cdf: TOL must be a positive scalar'))
    if (numel_(x) == 0):
        error_(char('kolmogorov_smirnov_cdf: X must not be empty'))
    cdf=zeros_(size_(x))
    ind=find_(x > 0)
    if (length_(ind) > 0):
        if (columns_(ind) < rows_(ind)):
            y=x[ind.T]
        else:
            y=x[ind]
        K=ceil_(sqrt_(- log_(tol) / 2) / min_(y))
        k=(arange_(1,K)).T
        A=exp_(- 2 * k ** 2 * y ** 2)
        odd=find_(rem_(k,2) == 1)
        A[odd,:]=- A[odd,:]
        cdf[ind]=1 + 2 * sum_(A)
    return cdf
def logistic_cdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (iscomplex_(x)):
        error_(char('logistic_cdf: X must not be complex'))
    cdf=1 / (1 + exp_(- x))
    return cdf
def hygepdf_(x=None,t=None,m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,t,m,n].count(None)+len(args)

    if (nargin != 4):
        print_usage_()
    if (not isscalar_(t) or not isscalar_(m) or not isscalar_(n)):
        retval,x,t,m,n=common_size_(x,t,m,n,nargout=5)
        if (retval > 0):
            error_(char('hygepdf: X, T, M, and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(t) or iscomplex_(m) or iscomplex_(n)):
        error_(char('hygepdf: X, T, M, and N must not be complex'))
    if (isa_(x,char('single')) or isa_(t,char('single')) or isa_(m,char('single')) or isa_(n,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    nel=(isnan_(x) or (t < 0) or (m < 0) or (n <= 0) or (m > t) or (n > t) or (t != fix_(t)) or (m != fix_(m)) or (n != fix_(n)))
    zel=((x != fix_(x)) or (x < 0) or (x > m) or (n < x) or (n - x > t - m))
    pdf[nel]=NaN
    k=not nel and not zel
    if (any_(k[:])):
        if (isscalar_(t) and isscalar_(m) and isscalar_(n)):
            pdf[k]=(bincoeff_(m,x[k]).dot(bincoeff_(t - m,n - x[k])) / bincoeff_(t,n))
        else:
            pdf[k]=(bincoeff_(m[k],x[k]).dot(bincoeff_(t[k] - m[k],n[k] - x[k])) / bincoeff_(t[k],n[k]))
    return pdf
def exppdf_(x=None,lambda=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,_lambda].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(_lambda)):
        retval,x,_lambda=common_size_(x,_lambda,nargout=3)
        if (retval > 0):
            error_(char('exppdf: X and LAMBDA must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(_lambda)):
        error_(char('exppdf: X and LAMBDA must not be complex'))
    if (isa_(x,char('single')) or isa_(_lambda,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=isnan_(x) or not (_lambda > 0)
    pdf[k]=NaN
    k=(x >= 0) and (x < Inf) and (_lambda > 0)
    if (isscalar_(_lambda)):
        pdf[k]=exp_(- x[k] / _lambda) / _lambda
    else:
        pdf[k]=exp_(- x[k] / _lambda[k]) / _lambda[k]
    return pdf
def geocdf_(x=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,p].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(p)):
        retval,x,p=common_size_(x,p,nargout=3)
        if (retval > 0):
            error_(char('geocdf: X and P must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(p)):
        error_(char('geocdf: X and P must not be complex'))
    if (isa_(x,char('single')) or isa_(p,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=isnan_(x) or not (p >= 0) or not (p <= 1)
    cdf[k]=NaN
    k=(x == Inf) and (p >= 0) and (p <= 1)
    cdf[k]=1
    k=(x >= 0) and (x < Inf) and (x == fix_(x)) and (p > 0) and (p <= 1)
    if (isscalar_(p)):
        cdf[k]=1 - ((1 - p) ** (x[k] + 1))
    else:
        cdf[k]=1 - ((1 - p[k]) ** (x[k] + 1))
    return cdf
def unifcdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,x,a,b=common_size_(x,a,b,nargout=4)
        if (retval > 0):
            error_(char('unifcdf: X, A, and B must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(a) or iscomplex_(b)):
        error_(char('unifcdf: X, A, and B must not be complex'))
    if (isa_(x,char('single')) or isa_(a,char('single')) or isa_(b,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=isnan_(x) or not (a < b)
    cdf[k]=NaN
    k=(x >= b) and (a < b)
    cdf[k]=1
    k=(x > a) and (x < b)
    if (isscalar_(a) and isscalar_(b)):
        cdf[k]=(x[k] < b).dot((x[k] - a)) / (b - a)
    else:
        cdf[k]=(x[k] < b[k]).dot((x[k] - a[k])) / (b[k] - a[k])
    return cdf
def laplace_pdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (iscomplex_(x)):
        error_(char('laplace_pdf: X must not be complex'))
    pdf=exp_(- abs_(x)) / 2
    return pdf
def nbininv_(x=None,n=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,n,p].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(n) or not isscalar_(p)):
        retval,x,n,p=common_size_(x,n,p,nargout=4)
        if (retval > 0):
            error_(char('nbininv: X, N, and P must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n) or iscomplex_(p)):
        error_(char('nbininv: X, N, and P must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single')) or isa_(p,char('single'))):
        inv=zeros_(size_(x),char('single'))
    else:
        inv=zeros_(size_(x))
    k=(isnan_(x) or (x < 0) or (x > 1) or isnan_(n) or (n < 1) or (n == Inf) or isnan_(p) or (p < 0) or (p > 1))
    inv[k]=NaN
    k=(x == 1) and (n > 0) and (n < Inf) and (p >= 0) and (p <= 1)
    inv[k]=Inf
    k=find_((x >= 0) and (x < 1) and (n > 0) and (n < Inf) and (p > 0) and (p <= 1))
    m=zeros_(size_(k))
    x=x[k]
    if (isscalar_(n) and isscalar_(p)):
        s=p ** n * ones_(size_(k))
        while (1):

            l=find_(s < x)
            if (any_(l)):
                m[l]=m[l] + 1
                s[l]=s[l] + nbinpdf_(m[l],n,p)
            else:
                break

    else:
        n=n[k]
        p=p[k]
        s=p ** n
        while (1):

            l=find_(s < x)
            if (any_(l)):
                m[l]=m[l] + 1
                s[l]=s[l] + nbinpdf_(m[l],n[l],p[l])
            else:
                break

    inv[k]=m
    return inv
def empirical_rnd_(data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[data].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (not isvector_(data)):
        error_(char('empirical_rnd: DATA must be a vector'))
    rnd=discrete_rnd_(data,ones_(size_(data)),varargin[:])
    return rnd
def empirical_pdf_(x=None,data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,data].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isvector_(data)):
        error_(char('empirical_pdf: DATA must be a vector'))
    pdf=discrete_pdf_(x,data,ones_(size_(data)))
    return pdf
def binopdf_(x=None,n=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,n,p].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(n) or not isscalar_(p)):
        retval,x,n,p=common_size_(x,n,p,nargout=4)
        if (retval > 0):
            error_(char('binopdf: X, N, and P must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n) or iscomplex_(p)):
        error_(char('binopdf: X, N, and P must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single')) or isa_(p,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=(x == fix_(x)) and (n == fix_(n)) and (n >= 0) and (p >= 0) and (p <= 1)
    pdf[not k]=NaN
    k &= ((x >= 0) and (x <= n))
    if (isscalar_(n) and isscalar_(p)):
        pdf[k]=exp_(gammaln_(n + 1) - gammaln_(x[k] + 1) - gammaln_(n - x[k] + 1) + x[k] * log_(p) + (n - x[k]) * log_(1 - p))
    else:
        pdf[k]=exp_(gammaln_(n[k] + 1) - gammaln_(x[k] + 1) - gammaln_(n[k] - x[k] + 1) + x[k].dot(log_(p[k])) + (n[k] - x[k]).dot(log_(1 - p[k])))
    ksp=k and (p == 0) and (x == 0)
    pdf[ksp]=1
    ksp=k and (p == 1) and (x == n)
    pdf[ksp]=1
    return pdf
def discrete_inv_(x=None,v=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,v,p].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isvector_(v)):
        error_(char('discrete_inv: V must be a vector'))
    else:
        if (not isvector_(p) or (length_(p) != length_(v))):
            error_(char('discrete_inv: P must be a vector with length (V) elements'))
        else:
            if (any_(isnan_(p))):
                error_(char('discrete_rnd: P must not have any NaN elements'))
            else:
                if (not (all_(p >= 0) and any_(p))):
                    error_(char('discrete_inv: P must be a nonzero, non-negative vector'))
    if (isa_(x,char('single')) or isa_(v,char('single')) or isa_(p,char('single'))):
        inv=NaN_(size_(x),char('single'))
    else:
        inv=NaN_(size_(x))
    if (isa_(p,char('single'))):
        p=double_(p)
    v,idx=sort_(v,nargout=2)
    p=cumsum_(p[idx](arange_())) / sum_(p)
    k=(x == 0)
    inv[k]=v[1]
    k=(x == 1)
    inv[k]=v[end()]
    k=(x > 0) and (x < 1)
    inv[k]=v[length_(p) - lookup_(sort_(p,char('descend')),x[k]) + 1]
    return inv
def cauchy_pdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,location,scale].count(None)+len(args)

    if (nargin != 1 and nargin != 3):
        print_usage_()
    if (not isscalar_(location) or not isscalar_(scale)):
        retval,x,location,scale=common_size_(x,location,scale,nargout=4)
        if (retval > 0):
            error_(char('cauchy_pdf: X, LOCATION, and SCALE must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(location) or iscomplex_(scale)):
        error_(char('cauchy_pdf: X, LOCATION, and SCALE must not be complex'))
    if (isa_(x,char('single')) or isa_(location,char('single')) or isa_(scale,char('single'))):
        pdf=NaN_(size_(x),char('single'))
    else:
        pdf=NaN_(size_(x))
    k=not isinf_(location) and (scale > 0) and (scale < Inf)
    if (isscalar_(location) and isscalar_(scale)):
        pdf=((1 / (1 + ((x - location) / scale) ** 2)) / pi / scale)
    else:
        pdf[k]=((1 / (1 + ((x[k] - location[k]) / scale[k]) ** 2)) / pi / scale[k])
    return pdf
def hygernd_(t=None,m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[t,m,n].count(None)+len(args)

    if (nargin < 3):
        print_usage_()
    if (not isscalar_(t) or not isscalar_(m) or not isscalar_(n)):
        retval,t,m,n=common_size_(t,m,n,nargout=4)
        if (retval > 0):
            error_(char('hygernd: T, M, and N must be of common size or scalars'))
    if (iscomplex_(t) or iscomplex_(m) or iscomplex_(n)):
        error_(char('hygernd: T, M, and N must not be complex'))
    if (nargin == 3):
        sz=size_(t)
    else:
        if (nargin == 4):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('hygernd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 4):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('hygernd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(t) and not isequal_(size_(t),sz)):
        error_(char('hygernd: T, M, and N must be scalar or of size SZ'))
    if (isa_(t,char('single')) or isa_(m,char('single')) or isa_(n,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    ok=((t >= 0) and (m >= 0) and (n > 0) and (m <= t) and (n <= t) and (t == fix_(t)) and (m == fix_(m)) and (n == fix_(n)))
    if (isscalar_(t)):
        if (ok):
            v=arange_(0,n)
            p=hygepdf_(v,t,m,n)
            rnd=v[lookup_(cumsum_(p[1:end() - 1]) / sum_(p),rand_(sz)) + 1]
            rnd=reshape_(rnd,sz)
            if (strcmp_(cls,char('single'))):
                rnd=single_(rnd)
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=NaN_(sz,cls)
        rn=rand_(sz)
        for i in find_(ok[:].T).reshape(-1):
            v=arange_(0,n[i])
            p=hygepdf_(v,t[i],m[i],n[i])
            rnd[i]=v[lookup_(cumsum_(p[1:end() - 1]) / sum_(p),rn[i]) + 1]
    return rnd
def geornd_(p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[p].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (nargin == 1):
        sz=size_(p)
    else:
        if (nargin == 2):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('geornd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 2):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('geornd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(p) and not isequal_(size_(p),sz)):
        error_(char('geornd: P must be scalar or of size SZ'))
    if (iscomplex_(p)):
        error_(char('geornd: P must not be complex'))
    if (isa_(p,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(p)):
        if (p > 0 and p < 1):
            rnd=floor_(- rande_(sz,cls) / log_(1 - p))
        else:
            if (p == 0):
                rnd=Inf_(sz,cls)
            else:
                if (p == 1):
                    rnd=zeros_(sz,cls)
                else:
                    if (p < 0 or p > 1):
                        rnd=NaN_(sz,cls)
    else:
        rnd=floor_(- rande_(sz,cls) / log_(1 - p))
        k=not (p >= 0) or not (p <= 1)
        rnd[k]=NaN
        k=(p == 0)
        rnd[k]=Inf
    return rnd
def unidpdf_(x=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,n].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not isscalar_(n)):
        retval,x,n=common_size_(x,n,nargout=3)
        if (retval > 0):
            error_(char('unidpdf: X and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(n)):
        error_(char('unidpdf: X and N must not be complex'))
    if (isa_(x,char('single')) or isa_(n,char('single'))):
        pdf=zeros_(size_(x),char('single'))
    else:
        pdf=zeros_(size_(x))
    k=isnan_(x) or not (n > 0 and n == fix_(n))
    pdf[k]=NaN
    k=not k and (x >= 1) and (x <= n) and (x == fix_(x))
    if (isscalar_(n)):
        pdf[k]=1 / n
    else:
        pdf[k]=1 / n[k]
    return pdf
def stdnormal_cdf_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (iscomplex_(x)):
        error_(char('stdnormal_cdf: X must not be complex'))
    cdf=erfc_(x / (- sqrt_(2))) / 2
    return cdf
def gamcdf_(x=None,a=None,b=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,a,b].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(a) or not isscalar_(b)):
        retval,x,a,b=common_size_(x,a,b,nargout=4)
        if (retval > 0):
            error_(char('gamcdf: X, A, and B must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(a) or iscomplex_(b)):
        error_(char('gamcdf: X, A, and B must not be complex'))
    if (isa_(x,char('single')) or isa_(a,char('single')) or isa_(b,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=isnan_(x) or not (a > 0) or not (a < Inf) or not (b > 0) or not (b < Inf)
    cdf[k]=NaN
    k=(x > 0) and (a > 0) and (a < Inf) and (b > 0) and (b < Inf)
    if (isscalar_(a) and isscalar_(b)):
        cdf[k]=gammainc_(x[k] / b,a)
    else:
        cdf[k]=gammainc_(x[k] / b[k],a[k])
    return cdf
def discrete_rnd_(v=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[v,p].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isvector_(v)):
        error_(char('discrete_rnd: V must be a vector'))
    else:
        if (not isvector_(p) or (length_(p) != length_(v))):
            error_(char('discrete_rnd: P must be a vector with length (V) elements'))
        else:
            if (any_(isnan_(p))):
                error_(char('discrete_rnd: P must not have any NaN elements'))
            else:
                if (not (all_(p >= 0) and any_(p))):
                    error_(char('discrete_rnd: P must be a nonzero, non-negative vector'))
    if (nargin == 2):
        sz=size_(v)
    else:
        if (nargin == 3):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('discrete_rnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 3):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('discrete_rnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    rnd=v[lookup_(cumsum_(p[1:end() - 1]) / sum_(p),rand_(sz)) + 1]
    rnd=reshape_(rnd,sz)
    return rnd
def chi2rnd_(n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[n].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (nargin == 1):
        sz=size_(n)
    else:
        if (nargin == 2):
            if (isscalar_(varargin[1]) and varargin[1] >= 0):
                sz=matlabarray([varargin[1],varargin[1]])
            else:
                if (isrow_(varargin[1]) and all_(varargin[1] >= 0)):
                    sz=varargin[1]
                else:
                    error_(char('chi2rnd: dimension vector must be row vector of non-negative integers'))
        else:
            if (nargin > 2):
                if (any_(cellfun_(lambda x: (not isscalar_(x) or x < 0),varargin))):
                    error_(char('chi2rnd: dimensions must be non-negative integers'))
                sz=matlabarray([varargin[:]])
    if (not isscalar_(n) and not isequal_(size_(n),sz)):
        error_(char('chi2rnd: N must be scalar or of size SZ'))
    if (iscomplex_(n)):
        error_(char('chi2rnd: N must not be complex'))
    if (isa_(n,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    if (isscalar_(n)):
        if ((n > 0) and (n < Inf)):
            rnd=2 * randg_(n / 2,sz,cls)
        else:
            rnd=NaN_(sz,cls)
    else:
        rnd=NaN_(sz,cls)
        k=(n > 0) or (n < Inf)
        rnd[k]=2 * randg_(n[k] / 2,cls)
    return rnd
def discrete_cdf_(x=None,v=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,v,p].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isvector_(v)):
        error_(char('discrete_cdf: V must be a vector'))
    else:
        if (any_(isnan_(v))):
            error_(char('discrete_cdf: V must not have any NaN elements'))
        else:
            if (not isvector_(p) or (length_(p) != length_(v))):
                error_(char('discrete_cdf: P must be a vector with length (V) elements'))
            else:
                if (not (all_(p >= 0) and any_(p))):
                    error_(char('discrete_cdf: P must be a nonzero, non-negative vector'))
    p=p[:] / sum_(p)
    if (isa_(x,char('single')) or isa_(v,char('single')) or isa_(p,char('single'))):
        cdf=NaN_(size_(x),char('single'))
    else:
        cdf=NaN_(size_(x))
    k=not isnan_(x)
    vs,vi=sort_(v,nargout=2)
    cdf[k]=[[0],[cumsum_(p[vi])]](lookup_(vs,x[k]) + 1)
    return cdf
def fcdf_(x=None,m=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,m,n].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not isscalar_(m) or not isscalar_(n)):
        retval,x,m,n=common_size_(x,m,n,nargout=4)
        if (retval > 0):
            error_(char('fcdf: X, M, and N must be of common size or scalars'))
    if (iscomplex_(x) or iscomplex_(m) or iscomplex_(n)):
        error_(char('fcdf: X, M, and N must not be complex'))
    if (isa_(x,char('single')) or isa_(m,char('single')) or isa_(n,char('single'))):
        cdf=zeros_(size_(x),char('single'))
    else:
        cdf=zeros_(size_(x))
    k=isnan_(x) or not (m > 0) or not (m < Inf) or not (n > 0) or not (n < Inf)
    cdf[k]=NaN
    k=(x == Inf) and (m > 0) and (m < Inf) and (n > 0) and (n < Inf)
    cdf[k]=1
    k=(x > 0) and (x < Inf) and (m > 0) and (m < Inf) and (n > 0) and (n < Inf)
    if (isscalar_(m) and isscalar_(n)):
        cdf[k]=1 - betainc_(1 / (1 + m * x[k] / n),n / 2,m / 2)
    else:
        cdf[k]=1 - betainc_(1 / (1 + m[k].dot(x[k]) / n[k]),n[k] / 2,m[k] / 2)
    return cdf
def logistic_regression_derivatives_(x=None,z=None,z1=None,g=None,g1=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[x,z,z1,g,g1,p].count(None)+len(args)

    v=g.dot((1 - g)) / p
    v1=g1.dot((1 - g1)) / p
    dlogp=matlabarray([(diag_(v) * z - diag_(v1) * z1),(diag_(v - v1) * x)])
    dl=sum_(dlogp).T
    w=v.dot((1 - 2 * g))
    w1=v1.dot((1 - 2 * g1))
    d2l=[z,x].T * diag_(w) * [z,x] - [z1,x].T * diag_(w1) * [z1,x] - dlogp.T * dlogp
    return dl,d2l
def logistic_regression_likelihood_(y=None,x=None,beta=None,z=None,z1=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[y,x,beta,z,z1].count(None)+len(args)

    e=exp_([z,x] * beta)
    e1=exp_([z1,x] * beta)
    g=e / (1 + e)
    g1=e1 / (1 + e1)
    g=max_(y == max_(y),g)
    g1=min_(y > min_(y),g1)
    p=g - g1
    dev=- 2 * sum_(log_(p))
    return g,g1,p,dev
def logistic_regression_(y=None,x=None,print=None,theta=None,beta=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[y,x,_print,theta,beta].count(None)+len(args)

    y=round_(vec_(y))
    my,ny=size_(y,nargout=2)
    if (nargin < 2):
        x=zeros_(my,0)
    mx,nx=size_(x,nargout=2)
    if (mx != my):
        error_(char('logistic_regression: X and Y must have the same number of observations'))
    x=- x
    tol=1e-06
    incr=10
    decr=2
    ymin=min_(y)
    ymax=max_(y)
    yrange=ymax - ymin
    z=(y * ones_(1,yrange)) == ((y * 0 + 1) * (arange_(ymin,(ymax - 1))))
    z1=(y * ones_(1,yrange)) == ((y * 0 + 1) * (arange_((ymin + 1),ymax)))
    z=z[:,any_(z)]
    z1=z1[:,any_(z1)]
    mz,nz=size_(z,nargout=2)
    if (nargin < 3):
        _print=0
    if (nargin < 4):
        beta=zeros_(nx,1)
    if (nargin < 5):
        g=cumsum_(sum_(z)).T / my
        theta=log_(g / (1 - g))
    tb=matlabarray([[theta],[beta]])
    g,g1,p,dev=logistic_regression_likelihood_(y,x,tb,z,z1,nargout=4)
    dl,d2l=logistic_regression_derivatives_(x,z,z1,g,g1,p,nargout=2)
    epsilon=std_(vec_(d2l)) / 1000
    _iter=0
    while (abs_(dl.T * (numpy.linalg.solve(d2l,dl)) / length_(dl)) > tol):

        _iter=_iter + 1
        tbold=copy_(tb)
        devold=copy_(dev)
        tb=tbold - numpy.linalg.solve(d2l,dl)
        g,g1,p,dev=logistic_regression_likelihood_(y,x,tb,z,z1,nargout=4)
        if ((dev - devold) / (dl.T * (tb - tbold)) < 0):
            epsilon=epsilon / decr
        else:
            while ((dev - devold) / (dl.T * (tb - tbold)) > 0):

                epsilon=epsilon * incr
                if (epsilon > 1e+15):
                    error_(char('logistic_regression: epsilon too large'))
                tb=tbold - numpy.linalg.solve((d2l - epsilon * eye_(size_(d2l))),dl)
                g,g1,p,dev=logistic_regression_likelihood_(y,x,tb,z,z1,nargout=4)
                disp_(char('epsilon'))
                disp_(epsilon)

        dl,d2l=logistic_regression_derivatives_(x,z,z1,g,g1,p,nargout=2)
        if (_print == 2):
            disp_(char('Iteration'))
            disp_(_iter)
            disp_(char('Deviance'))
            disp_(dev)
            disp_(char('First derivative'))
            disp_(dl.T)
            disp_(char('Eigenvalues of second derivative'))
            disp_(eig_(d2l).T)

    theta=tb[1:nz,1]
    beta=tb[(nz + 1):(nz + nx),1]
    if (_print >= 1):
        printf_(char('\n'))
        printf_(char('Logistic Regression Results:\n'))
        printf_(char('\n'))
        printf_(char('Number of Iterations: %d\n'),_iter)
        printf_(char('Deviance:             %f\n'),dev)
        printf_(char('Parameter Estimates:\n'))
        printf_(char('     Theta         S.E.\n'))
        se=sqrt_(diag_(inv_(- d2l)))
        for i in arange_(1,nz).reshape(-1):
            printf_(char('   %8.4f     %8.4f\n'),tb[i],se[i])
        if (nx > 0):
            printf_(char('      Beta         S.E.\n'))
            for i in arange_((nz + 1),(nz + nx)).reshape(-1):
                printf_(char('   %8.4f     %8.4f\n'),tb[i],se[i])
    if (nargout == 6):
        if (nx > 0):
            e=((x * beta) * ones_(1,nz)) + ((y * 0 + 1) * theta.T)
        else:
            e=(y * 0 + 1) * theta.T
        gamma=diff_([(y * 0),(exp_(e) / (1 + exp_(e))),(y * 0 + 1)].T).T
    return theta,beta,dev,dl,d2l,p
def manova_(x=None,g=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,g].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (isvector_(x)):
        error_(char('manova: X must not be a vector'))
    n,p=size_(x,nargout=2)
    if (not isvector_(g) or (length_(g) != n)):
        error_(char('manova: G must be a vector of length rows (X)'))
    s=sort_(g)
    i=find_(s[2:n] > s[1:(n - 1)])
    k=length_(i) + 1
    if (k == 1):
        error_(char('manova: there should be at least 2 groups'))
    else:
        group_label=s[[1,(reshape_(i,1,k - 1) + 1)]]
    x=x - ones_(n,1) * mean_(x)
    SST=x.T * x
    s=zeros_(1,p)
    SSB=zeros_(p,p)
    for i in arange_(1,k).reshape(-1):
        v=x[find_(g == group_label[i]),:]
        s=sum_(v)
        SSB=SSB + s.T * s / rows_(v)
    n_b=k - 1
    SSW=SST - SSB
    n_w=n - k
    l=real_(eig_(SSB / SSW))
    if (isa_(l,char('single'))):
        l[l < eps_(char('single'))]=0
    else:
        l[l < eps]=0
    Lambda=prod_(1 / (1 + l))
    delta=n_w + n_b - (p + n_b + 1) / 2
    df_num=p * n_b
    W_pval_1=1 - chi2cdf_(- delta * log_(Lambda),df_num)
    if (p < 3):
        eta=copy_(p)
    else:
        eta=sqrt_((p ** 2 * n_b ** 2 - 4) / (p ** 2 + n_b ** 2 - 5))
    df_den=delta * eta - df_num / 2 + 1
    WT=exp_(- log_(Lambda) / eta) - 1
    W_pval_2=1 - fcdf_(WT * df_den / df_num,df_num,df_den)
    if (0):
        HL=sum_(l)
        theta=min_(p,n_b)
        u=(abs_(p - n_b) - 1) / 2
        v=(n_w - p - 1) / 2
        df_num=theta * (2 * u + theta + 1)
        df_den=2 * (theta * v + 1)
        HL_pval=1 - fcdf_(HL * df_den / df_num,df_num,df_den)
        PB=sum_(l / (1 + l))
        df_den=theta * (2 * v + theta + 1)
        PB_pval=1 - fcdf_(PB * df_den / df_num,df_num,df_den)
        printf_(char('\n'))
        printf_(char('One-way MANOVA Table:\n'))
        printf_(char('\n'))
        printf_(char('Test             Test Statistic      Approximate p\n'))
        printf_(char('**************************************************\n'))
        printf_(char('Wilks            %10.4f           %10.9f \n'),Lambda,W_pval_1)
        printf_(char('                                      %10.9f \n'),W_pval_2)
        printf_(char('Hotelling-Lawley %10.4f           %10.9f \n'),HL,HL_pval)
        printf_(char('Pillai-Bartlett  %10.4f           %10.9f \n'),PB,PB_pval)
        printf_(char('\n'))
    printf_(char('\n'))
    printf_(char('MANOVA Results:\n'))
    printf_(char('\n'))
    printf_(char('# of groups:    %d\n'),k)
    printf_(char('# of samples:   %d\n'),n)
    printf_(char('# of variables: %d\n'),p)
    printf_(char('\n'))
    printf_(char("Wilks' Lambda:  %5.4f\n"),Lambda)
    printf_(char('Approximate p:  %10.9f (chisquare approximation)\n'),W_pval_1)
    printf_(char('                 %10.9f (F approximation)\n'),W_pval_2)
    printf_(char('\n'))
    return
def prop_test_2_(x1=None,n1=None,x2=None,n2=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[x1,n1,x2,n2,alt].count(None)+len(args)

    if ((nargin < 4) or (nargin > 5)):
        print_usage_()
    p1=x1 / n1
    p2=x2 / n2
    pc=(x1 + x2) / (n1 + n2)
    z=(p1 - p2) / sqrt_(pc * (1 - pc) * (1 / n1 + 1 / n2))
    cdf=stdnormal_cdf_(z)
    if (nargin == 4):
        alt=char('!=')
    if (not ischar_(alt)):
        error_(char('prop_test_2: ALT must be a string'))
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        pval=2 * min_(cdf,1 - cdf)
    else:
        if (strcmp_(alt,char('>'))):
            pval=1 - cdf
        else:
            if (strcmp_(alt,char('<'))):
                pval=copy_(cdf)
            else:
                error_(char('prop_test_2: option %s not recognized'),alt)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,z
def wilcoxon_test_(x=None,y=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,alt].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not (isvector_(x) and isvector_(y) and (length_(x) == length_(y)))):
        error_(char('wilcoxon_test: X and Y must be vectors of the same length'))
    n=length_(x)
    x=reshape_(x,1,n)
    y=reshape_(y,1,n)
    d=x - y
    d=d[find_(d != 0)]
    n=length_(d)
    if (n > 25):
        r=ranks_(abs_(d))
        z=sum_(r[find_(d > 0)])
        z=((z - n * (n + 1) / 4) / sqrt_(n * (n + 1) * (2 * n + 1) / 24))
    else:
        error_(char('wilcoxon_test: implementation requires more than 25 different pairs'))
    cdf=stdnormal_cdf_(z)
    if (nargin == 2):
        alt=char('!=')
    if (not ischar_(alt)):
        error_(char('wilcoxon_test: ALT must be a string'))
    else:
        if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
            pval=2 * min_(cdf,1 - cdf)
        else:
            if (strcmp_(alt,char('>'))):
                pval=1 - cdf
            else:
                if (strcmp_(alt,char('<'))):
                    pval=copy_(cdf)
                else:
                    error_(char('wilcoxon_test: option %s not recognized'),alt)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,z
def cor_test_(x=None,y=None,alt=None,method=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,y,alt,method].count(None)+len(args)

    if ((nargin < 2) or (nargin > 4)):
        print_usage_()
    if (not isvector_(x) or not isvector_(y) or length_(x) != length_(y)):
        error_(char('cor_test: X and Y must be vectors of the same length'))
    if (nargin < 3):
        alt=char('!=')
    else:
        if (not ischar_(alt)):
            error_(char('cor_test: ALT must be a string'))
    if (nargin < 4):
        method=char('pearson')
    else:
        if (not ischar_(method)):
            error_(char('cor_test: METHOD must be a string'))
    n=length_(x)
    m=method[1]
    if (m == char('p')):
        r=corr_(x,y)
        df=n - 2
        t.method=char("Pearson's product moment correlation")
        t.params=df
        t.stat=sqrt_(df).dot(r) / sqrt_(1 - r ** 2)
        t.dist=char('t')
        cdf=tcdf_(t.stat,df)
    else:
        if (m == char('k')):
            tau=kendall_(x,y)
            t.method=char("Kendall's rank correlation tau")
            t.params=[]
            t.stat=tau / sqrt_((2 * (2 * n + 5)) / (9 * n * (n - 1)))
            t.dist=char('stdnormal')
            cdf=stdnormal_cdf_(t.stat)
        else:
            if (m == char('s')):
                rho=spearman_(x,y)
                t.method=char("Spearman's rank correlation rho")
                t.params=[]
                t.stat=sqrt_(n - 1) * (rho - 6 / (n ** 3 - n))
                t.dist=char('stdnormal')
                cdf=stdnormal_cdf_(t.stat)
            else:
                error_(char("cor_test: METHOD '%s' not recognized"),method)
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        t.pval=2 * min_(cdf,1 - cdf)
    else:
        if (strcmp_(alt,char('>'))):
            t.pval=1 - cdf
        else:
            if (strcmp_(alt,char('<'))):
                t.pval=cdf
            else:
                error_(char("cor_test: alternative '%s' not recognized"),alt)
    t.alternative=alt
    if (nargout == 0):
        printf_(char('pval: %g\n'),t.pval)
    return t
def chisquare_test_homogeneity_(x=None,y=None,c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,c].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not (isvector_(x) and isvector_(y) and isvector_(c))):
        error_(char('chisquare_test_homogeneity: X, Y and C must be vectors'))
    df=length_(c)
    if (any_((c[2:df] - c[1:(df - 1)]) <= 0)):
        error_(char('chisquare_test_homogeneity: C must be increasing'))
    c=matlabarray([(reshape_(c,1,df)),Inf])
    l_x=length_(x)
    x=reshape_(x,l_x,1)
    n_x=sum_(x * ones_(1,df + 1) < ones_(l_x,1) * c)
    l_y=length_(y)
    y=reshape_(y,l_y,1)
    n_y=sum_(y * ones_(1,df + 1) < ones_(l_y,1) * c)
    chisq=l_x * l_y * sum_((n_x / l_x - n_y / l_y) ** 2 / (n_x + n_y))
    pval=1 - chi2cdf_(chisq,df)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,chisq,df
def z_test_2_(x=None,y=None,v_x=None,v_y=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[x,y,v_x,v_y,alt].count(None)+len(args)

    if ((nargin < 4) or (nargin > 5)):
        print_usage_()
    if (not (isvector_(x) and isvector_(y))):
        error_(char('z_test_2: both X and Y must be vectors'))
    else:
        if (not (isscalar_(v_x) and (v_x > 0) and isscalar_(v_y) and (v_y > 0))):
            error_(char('z_test_2: both V_X and V_Y must be positive scalars'))
    n_x=length_(x)
    n_y=length_(y)
    mu_x=sum_(x) / n_x
    mu_y=sum_(y) / n_y
    z=(mu_x - mu_y) / sqrt_(v_x / n_x + v_y / n_y)
    cdf=stdnormal_cdf_(z)
    if (nargin == 4):
        alt=char('!=')
    if (not ischar_(alt)):
        error_(char('z_test_2: ALT must be a string'))
    else:
        if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
            pval=2 * min_(cdf,1 - cdf)
        else:
            if (strcmp_(alt,char('>'))):
                pval=1 - cdf
            else:
                if (strcmp_(alt,char('<'))):
                    pval=copy_(cdf)
                else:
                    error_(char('z_test_2: option %s not recognized'),alt)
    if (nargout == 0):
        s=matlabarray([char('Two-sample Z-test of mean(x) == mean(y) against '),char('mean(x) %s mean(y),\n'),char('with known var(x) == %g and var(y) == %g:\n'),char('  pval = %g\n')])
        printf_(s,alt,v_x,v_y,pval)
    return pval,z
def mcnemar_test_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (min_(size_(x)) > 1) and issquare_(x)):
        error_(char('mcnemar_test: X must be a square matrix of size > 1'))
    else:
        if (not (all_(all_(x >= 0)) and all_(all_(x == fix_(x))))):
            error_(char('mcnemar_test: all entries of X must be non-negative integers'))
    r=rows_(x)
    df=r * (r - 1) / 2
    if (r == 2):
        num=max_(abs_(x - x.T) - 1,0) ** 2
    else:
        num=abs_(x - x.T) ** 2
    chisq=sum_(sum_(triu_(num / (x + x.T),1)))
    pval=1 - chi2cdf_(chisq,df)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,chisq,df
def z_test_(x=None,m=None,v=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,m,v,alt].count(None)+len(args)

    if ((nargin < 3) or (nargin > 4)):
        print_usage_()
    if (not isvector_(x)):
        error_(char('z_test: X must be a vector'))
    if (not isscalar_(m)):
        error_(char('z_test: M must be a scalar'))
    if (not (isscalar_(v) and (v > 0))):
        error_(char('z_test: V must be a positive scalar'))
    n=length_(x)
    z=sqrt_(n / v) * (sum_(x) / n - m)
    cdf=stdnormal_cdf_(z)
    if (nargin == 3):
        alt=char('!=')
    if (not ischar_(alt)):
        error_(char('z_test: ALT must be a string'))
    else:
        if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
            pval=2 * min_(cdf,1 - cdf)
        else:
            if (strcmp_(alt,char('>'))):
                pval=1 - cdf
            else:
                if (strcmp_(alt,char('<'))):
                    pval=copy_(cdf)
                else:
                    error_(char('z_test: option %s not recognized'),alt)
    if (nargout == 0):
        s=matlabarray([char('Z-test of mean(x) == %g against mean(x) %s %g,\n'),char('with known var(x) == %g:\n'),char('  pval = %g\n')])
        printf_(s,m,alt,m,v,pval)
    return pval,z
def welch_test_(x=None,y=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,alt].count(None)+len(args)

    if ((nargin < 2) or (nargin > 3)):
        print_usage_()
    if (not (isvector_(x) and isvector_(y))):
        error_(char('welch_test: both X and Y must be vectors'))
    n_x=length_(x)
    n_y=length_(y)
    mu_x=sum_(x) / n_x
    mu_y=sum_(y) / n_y
    v_x=sumsq_(x - mu_x) / (n_x * (n_x - 1))
    v_y=sumsq_(y - mu_y) / (n_y * (n_y - 1))
    c=v_x / (v_x + v_y)
    df=1 / (c ** 2 / (n_x - 1) + (1 - c) ** 2 / (n_y - 1))
    t=(mu_x - mu_y) / sqrt_(v_x + v_y)
    cdf=tcdf_(t,df)
    if (nargin == 2):
        alt=char('!=')
    if (not ischar_(alt)):
        error_(char('welch_test: ALT must be a string'))
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        pval=2 * min_(cdf,1 - cdf)
    else:
        if (strcmp_(alt,char('>'))):
            pval=1 - cdf
        else:
            if (strcmp_(alt,char('<'))):
                pval=copy_(cdf)
            else:
                error_(char('welch_test: option %s not recognized'),alt)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,t,df
def t_test_2_(x=None,y=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,alt].count(None)+len(args)

    if ((nargin < 2) or (nargin > 3)):
        print_usage_()
    if (not (isvector_(x) and isvector_(y))):
        error_(char('t_test_2: both X and Y must be vectors'))
    n_x=length_(x)
    n_y=length_(y)
    df=n_x + n_y - 2
    mu_x=sum_(x) / n_x
    mu_y=sum_(y) / n_y
    v=sumsq_(x - mu_x) + sumsq_(y - mu_y)
    t=(mu_x - mu_y) * sqrt_((n_x * n_y * df) / (v * (n_x + n_y)))
    cdf=tcdf_(t,df)
    if (nargin == 2):
        alt=char('!=')
    if (not ischar_(alt)):
        error_(char('t_test_2: ALT must be a string'))
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        pval=2 * min_(cdf,1 - cdf)
    else:
        if (strcmp_(alt,char('>'))):
            pval=1 - cdf
        else:
            if (strcmp_(alt,char('<'))):
                pval=copy_(cdf)
            else:
                error_(char('t_test_2: option %s not recognized'),alt)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,t,df
def anova_(y=None,g=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[y,g].count(None)+len(args)

    if ((nargin < 1) or (nargin > 2)):
        print_usage_()
    else:
        if (nargin == 1):
            if (isvector_(y)):
                error_(char("anova: for 'anova (Y)', Y must not be a vector"))
            group_count,k=size_(y,nargout=2)
            n=group_count * k
            group_mean=mean_(y)
        else:
            if (not isvector_(y)):
                error_(char("anova: for 'anova (Y, G)', Y must be a vector"))
            n=length_(y)
            if (not isvector_(g) or (length_(g) != n)):
                error_(char('anova: G must be a vector of the same length as Y'))
            s=sort_(g)
            i=find_(s[2:n] > s[1:(n - 1)])
            k=length_(i) + 1
            if (k == 1):
                error_(char('anova: there should be at least 2 groups'))
            else:
                group_label=s[[1,(reshape_(i,1,k - 1) + 1)]]
            for i in arange_(1,k).reshape(-1):
                v=y[find_(g == group_label[i])]
                group_count[i]=length_(v)
                group_mean[i]=mean_(v)
    total_mean=mean_(y[:])
    SSB=sum_(group_count.dot((group_mean - total_mean) ** 2))
    SST=sumsq_(reshape_(y,n,1) - total_mean)
    SSW=SST - SSB
    df_b=k - 1
    df_w=n - k
    v_b=SSB / df_b
    v_w=SSW / df_w
    f=v_b / v_w
    pval=1 - fcdf_(f,df_b,df_w)
    if (nargout == 0):
        printf_(char('\n'))
        printf_(char('One-way ANOVA Table:\n'))
        printf_(char('\n'))
        printf_(char('Source of Variation   Sum of Squares    df  Empirical Var\n'))
        printf_(char('*********************************************************\n'))
        printf_(char('Between Groups       %15.4f  %4d  %13.4f\n'),SSB,df_b,v_b)
        printf_(char('Within Groups        %15.4f  %4d  %13.4f\n'),SSW,df_w,v_w)
        printf_(char('---------------------------------------------------------\n'))
        printf_(char('Total                %15.4f  %4d\n'),SST,n - 1)
        printf_(char('\n'))
        printf_(char('Test Statistic f     %15.4f\n'),f)
        printf_(char('p-value              %15.4f\n'),pval)
        printf_(char('\n'))
    return pval,f,df_b,df_w
def var_test_(x=None,y=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,alt].count(None)+len(args)

    if ((nargin < 2) or (nargin > 3)):
        print_usage_()
    if (not (isvector_(x) and isvector_(y))):
        error_(char('var_test: both X and Y must be vectors'))
    df_num=length_(x) - 1
    df_den=length_(y) - 1
    f=var_(x) / var_(y)
    cdf=fcdf_(f,df_num,df_den)
    if (nargin == 2):
        alt=char('!=')
    if (not ischar_(alt)):
        error_(char('var_test: ALT must be a string'))
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        pval=2 * min_(cdf,1 - cdf)
    else:
        if (strcmp_(alt,char('>'))):
            pval=1 - cdf
        else:
            if (strcmp_(alt,char('<'))):
                pval=copy_(cdf)
            else:
                error_(char('var_test: option %s not recognized'),alt)
    if (nargout == 0):
        printf_(char('pval: %g\n'),pval)
    return pval,f,df_num,df_den
def kolmogorov_smirnov_test_2_(x=None,y=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,alt].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not (isvector_(x) and isvector_(y))):
        error_(char('kolmogorov_smirnov_test_2: both X and Y must be vectors'))
    if (nargin == 2):
        alt=char('!=')
    else:
        if (not ischar_(alt)):
            error_(char('kolmogorov_smirnov_test_2: ALT must be a string'))
    n_x=length_(x)
    n_y=length_(y)
    n=n_x * n_y / (n_x + n_y)
    x=reshape_(x,n_x,1)
    y=reshape_(y,n_y,1)
    s,i=sort_([[x],[y]],nargout=2)
    count[find_(i <= n_x)]=1 / n_x
    count[find_(i > n_x)]=- 1 / n_y
    z=cumsum_(count)
    ds=diff_(s)
    if (any_(ds == 0)):
        warning_(char('cannot compute correct p-values with ties'))
        elems=matlabarray([[find_(ds)],[n_x + n_y]])
        z=z[elems]
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        d=max_(abs_(z))
        ks=sqrt_(n) * d
        pval=1 - kolmogorov_smirnov_cdf_(ks)
    else:
        if (strcmp_(alt,char('>'))):
            d=max_(z)
            ks=sqrt_(n) * d
            pval=exp_(- 2 * ks ** 2)
        else:
            if (strcmp_(alt,char('<'))):
                d=min_(z)
                ks=- sqrt_(n) * d
                pval=exp_(- 2 * ks ** 2)
            else:
                error_(char('kolmogorov_smirnov_test_2: option %s not recognized'),alt)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,ks,d
def u_test_(x=None,y=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,alt].count(None)+len(args)

    if ((nargin < 2) or (nargin > 3)):
        print_usage_()
    if (not (isvector_(x) and isvector_(y))):
        error_(char('u_test: both X and Y must be vectors'))
    n_x=length_(x)
    n_y=length_(y)
    r=ranks_([(reshape_(x,1,n_x)),(reshape_(y,1,n_y))])
    z=(sum_(r[1:n_x]) - n_x * (n_x + n_y + 1) / 2) / sqrt_(n_x * n_y * (n_x + n_y + 1) / 12)
    cdf=stdnormal_cdf_(z)
    if (nargin == 2):
        alt=char('!=')
    if (not ischar_(alt)):
        error_(char('u_test: ALT must be a string'))
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        pval=2 * min_(cdf,1 - cdf)
    else:
        if (strcmp_(alt,char('>'))):
            pval=copy_(cdf)
        else:
            if (strcmp_(alt,char('<'))):
                pval=1 - cdf
            else:
                error_(char('u_test: option %s not recognized'),alt)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,z
def hotelling_test_(x=None,m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,m].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (isvector_(x)):
        if (not isscalar_(m)):
            error_(char('hotelling_test: if X is a vector, M must be a scalar'))
        n=length_(x)
        p=1
    else:
        if (ismatrix_(x)):
            n,p=size_(x,nargout=2)
            if (n <= p):
                error_(char('hotelling_test: X must have more rows than columns'))
            if (isvector_(m) and length_(m) == p):
                m=reshape_(m,1,p)
            else:
                error_(char('hotelling_test: if X is a matrix, M must be a vector of length columns (X)'))
        else:
            error_(char('hotelling_test: X must be a matrix or vector'))
    d=mean_(x) - m
    Tsq=n * d * (numpy.linalg.solve(cov_(x),d.T))
    pval=1 - fcdf_((n - p) * Tsq / (p * (n - 1)),p,n - p)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,Tsq
def kolmogorov_smirnov_test_(x=None,dist=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dist].count(None)+len(args)

    if (nargin < 2):
        print_usage_()
    if (not isvector_(x)):
        error_(char('kolmogorov_smirnov_test: X must be a vector'))
    n=length_(x)
    s=sort_(x)
    try:
        f=str2func_(sprintf_(char('%scdf'),dist))
    finally:
        pass
    alt=char('!=')
    args[1]=s
    nvargs=numel_(varargin)
    if (nvargs > 0):
        if (ischar_(varargin[end()])):
            alt=varargin[end()]
            args[2:nvargs]=varargin[1:end() - 1]
        else:
            args[2:nvargs + 1]=varargin
    z=reshape_(feval_(f,args[:]),1,n)
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        ks=sqrt_(n) * max_(max_([[abs_(z - (arange_(0,(n - 1))) / n)],[abs_(z - (arange_(1,n)) / n)]]))
        pval=1 - kolmogorov_smirnov_cdf_(ks)
    else:
        if (strcmp_(alt,char('>'))):
            ks=sqrt_(n) * max_(max_([[z - (arange_(0,(n - 1))) / n],[z - (arange_(1,n)) / n]]))
            pval=exp_(- 2 * ks ** 2)
        else:
            if (strcmp_(alt,char('<'))):
                ks=- sqrt_(n) * min_(min_([[z - (arange_(0,(n - 1))) / n],[z - (arange_(1,n)) / n]]))
                pval=exp_(- 2 * ks ** 2)
            else:
                error_(char('kolmogorov_smirnov_test: alternative %s not recognized'),alt)
    if (nargout == 0):
        printf_(char('pval: %g\n'),pval)
    return pval,ks
def t_test_(x=None,m=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,m,alt].count(None)+len(args)

    if ((nargin < 2) or (nargin > 3)):
        print_usage_()
    if (not isvector_(x)):
        error_(char('t_test: X must be a vector'))
    if (not isscalar_(m)):
        error_(char('t_test: M must be a scalar'))
    n=length_(x)
    df=n - 1
    t=sqrt_(n) * (sum_(x) / n - m) / std_(x)
    cdf=tcdf_(t,df)
    if (nargin == 2):
        alt=char('!=')
    if (not ischar_(alt)):
        error_(char('t_test: ALT must be a string'))
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        pval=2 * min_(cdf,1 - cdf)
    else:
        if (strcmp_(alt,char('>'))):
            pval=1 - cdf
        else:
            if (strcmp_(alt,char('<'))):
                pval=copy_(cdf)
            else:
                error_(char('t_test: option %s not recognized'),alt)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,t,df
def f_test_regression_(y=None,x=None,rr=None,r=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[y,x,rr,r].count(None)+len(args)

    if (nargin < 3 or nargin > 4):
        print_usage_()
    T,k=size_(x,nargout=2)
    if (not (isvector_(y) and (length_(y) == T))):
        error_(char('f_test_regression: Y must be a vector of length rows (X)'))
    y=reshape_(y,T,1)
    q,c_R=size_(rr,nargout=2)
    if (c_R != k):
        error_(char('f_test_regression: RR must have as many columns as X'))
    if (nargin == 4):
        s_r=size_(r)
        if ((min_(s_r) != 1) or (max_(s_r) != q)):
            error_(char('f_test_regression: R must be a vector of length rows (RR)'))
        r=reshape_(r,q,1)
    else:
        r=zeros_(q,1)
    df_num=copy_(q)
    df_den=T - k
    b,v=ols_(y,x,nargout=2)
    diff=rr * b - r
    f=diff.T * inv_(rr * inv_(x.T * x) * rr.T) * diff / (q * v)
    pval=1 - fcdf_(f,df_num,df_den)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,f,df_num,df_den
def kruskal_wallis_test_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    m=copy_(nargin)
    if (m < 2):
        print_usage_()
    n=matlabarray([])
    p=matlabarray([])
    for i in arange_(1,m).reshape(-1):
        x=varargin[i]
        if (not isvector_(x)):
            error_(char('kruskal_wallis_test: all arguments must be vectors'))
        l=length_(x)
        n=matlabarray([n,l])
        p=matlabarray([p,(reshape_(x,1,l))])
    r=ranks_(p)
    k=0
    j=0
    for i in arange_(1,m).reshape(-1):
        k=k + (sum_(r[(j + 1):(j + n[i])])) ** 2 / n[i]
        j=j + n[i]
    n=length_(p)
    k=12 * k / (n * (n + 1)) - 3 * (n + 1)
    sum_ties=sum_(polyval_([1,0,- 1,0],runlength_(sort_(p))))
    k=k / (1 - sum_ties / (n ** 3 - n))
    df=m - 1
    pval=1 - chi2cdf_(k,df)
    if (nargout == 0):
        printf_(char('pval: %g\n'),pval)
    return pval,k,df
def hotelling_test_2_(x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (isvector_(x)):
        n_x=length_(x)
        if (not isvector_(y)):
            error_(char('hotelling_test_2: if X is a vector, Y must also be a vector'))
        else:
            n_y=length_(y)
            p=1
    else:
        if (ismatrix_(x)):
            n_x,p=size_(x,nargout=2)
            n_y,q=size_(y,nargout=2)
            if (p != q):
                error_(char('hotelling_test_2: X and Y must have the same number of columns'))
        else:
            error_(char('hotelling_test_2: X and Y must be matrices (or vectors)'))
    d=mean_(x) - mean_(y)
    S=((n_x - 1) * cov_(x) + (n_y - 1) * cov_(y)) / (n_x + n_y - 2)
    Tsq=(n_x * n_y / (n_x + n_y)) * d * (numpy.linalg.solve(S,d.T))
    pval=1 - fcdf_((n_x + n_y - p - 1) * Tsq / (p * (n_x + n_y - 2)),p,n_x + n_y - p - 1)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,Tsq
def bartlett_test_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    k=copy_(nargin)
    if (k < 2):
        print_usage_()
    f=zeros_(k,1)
    v=zeros_(k,1)
    for i in arange_(1,k).reshape(-1):
        x=varargin[i]
        if (not isvector_(x)):
            error_(char('bartlett_test: all arguments must be vectors'))
        f[i]=length_(x) - 1
        v[i]=var_(x)
    f_tot=sum_(f)
    v_tot=sum_(f.dot(v)) / f_tot
    c=1 + (sum_(1 / f) - 1 / f_tot) / (3 * (k - 1))
    chisq=(f_tot * log_(v_tot) - sum_(f.dot(log_(v)))) / c
    df=copy_(k)
    pval=1 - chi2cdf_(chisq,df)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,chisq,df
def t_test_regression_(y=None,x=None,rr=None,r=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[y,x,rr,r,alt].count(None)+len(args)

    if (nargin == 3):
        r=0
        alt=char('!=')
    else:
        if (nargin == 4):
            if (ischar_(r)):
                alt=copy_(r)
                r=0
            else:
                alt=char('!=')
        else:
            if (not (nargin == 5)):
                print_usage_()
    if (not isscalar_(r)):
        error_(char('t_test_regression: R must be a scalar'))
    else:
        if (not ischar_(alt)):
            error_(char('t_test_regression: ALT must be a string'))
    T,k=size_(x,nargout=2)
    if (not (isvector_(y) and (length_(y) == T))):
        error_(char('t_test_regression: Y must be a vector of length rows (X)'))
    s=size_(rr)
    if (not ((max_(s) == k) and (min_(s) == 1))):
        error_(char('t_test_regression: RR must be a vector of length columns (X)'))
    rr=reshape_(rr,1,k)
    y=reshape_(y,T,1)
    b,v=ols_(y,x,nargout=2)
    df=T - k
    t=(rr * b - r) / sqrt_(v * rr * inv_(x.T * x) * rr.T)
    cdf=tcdf_(t,df)
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        pval=2 * min_(cdf,1 - cdf)
    else:
        if (strcmp_(alt,char('>'))):
            pval=1 - cdf
        else:
            if (strcmp_(alt,char('<'))):
                pval=copy_(cdf)
            else:
                error_(char("t_test_regression: the value '%s' for alt is not possible"),alt)
    if (nargout == 0):
        printf_(char('pval: %g\n'),pval)
    return pval,t,df
def chisquare_test_independence_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    r,s=size_(x,nargout=2)
    df=(r - 1) * (s - 1)
    n=sum_(sum_(x))
    y=sum_(x.T).T * sum_(x) / n
    x=(x - y) ** 2 / y
    chisq=sum_(sum_(x))
    pval=1 - chi2cdf_(chisq,df)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,chisq,df
def sign_test_(x=None,y=None,alt=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,alt].count(None)+len(args)

    if ((nargin < 2) or (nargin > 3)):
        print_usage_()
    if (not (isvector_(x) and isvector_(y) and (length_(x) == length_(y)))):
        error_(char('sign_test: X and Y must be vectors of the same length'))
    n=length_(x)
    x=reshape_(x,1,n)
    y=reshape_(y,1,n)
    n=sum_(x != y)
    b=sum_(x > y)
    cdf=binocdf_(b,n,1 / 2)
    if (nargin == 2):
        alt=char('!=')
    if (not ischar_(alt)):
        error_(char('sign_test: ALT must be a string'))
    if (strcmp_(alt,char('!=')) or strcmp_(alt,char('<>'))):
        pval=2 * min_(cdf,1 - cdf)
    else:
        if (strcmp_(alt,char('>'))):
            pval=1 - cdf
        else:
            if (strcmp_(alt,char('<'))):
                pval=copy_(cdf)
            else:
                error_(char('sign_test: option %s not recognized'),alt)
    if (nargout == 0):
        printf_(char('  pval: %g\n'),pval)
    return pval,b,n
def run_test_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    A=matlabarray([[4529.4,9044.9,13568,18091,22615,27892],[9044.4,18097,27139,36187,45234,55789],[13568,27139,40721,54281,67852,83685],[18091,36187,54281,72414,90470,111580],[22615,45234,67852,90470,113262,139476],[27892,55789,83685,111580,139476,172860]])
    b=matlabarray([[1 / 6],[5 / 24],[11 / 120],[19 / 720],[29 / 5040],[1 / 840]])
    n=rows_(x)
    r=run_count_(x,6) - n * b * ones_(1,columns_(x))
    chisq=diag_(r.T * A * r).T / n
    pval=chi2cdf_(chisq,6)
    if (nargout == 0):
        printf_(char('pval: %g\n'),pval)
    return pval,chisq
def zscore_(x=None,opt=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,opt,dim].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('zscore: X must be a numeric vector or matrix'))
    if (nargin < 2):
        opt=0
    else:
        if (opt != 0 and opt != 1 or not isscalar_(opt)):
            error_(char('zscore: OPT must be empty, 0, or 1'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 3):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('zscore: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    if (n == 0):
        z=copy_(x)
    else:
        if (isinteger_(x)):
            x=double_(x)
        mu=mean_(x,dim)
        sigma=std_(x,opt,dim)
        s=copy_(sigma)
        s[s == 0]=1
        z=bsxfun_(rdivide,bsxfun_(minus,x,mu),s)
    return z,mu,sigma
def corr_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (isscalar_(x)):
        if (isa_(x,char('single'))):
            retval=single_(1)
        else:
            retval=1
        return retval
    if (nargin == 2):
        c=cov_(x,y)
        s=std_(x).T * std_(y)
        retval=c / s
    else:
        c=cov_(x)
        s=sqrt_(diag_(c))
        retval=c / (s * s.T)
    return retval
def prctile_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,p,dim].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('prctile: X must be a numeric vector or matrix'))
    if (isempty_(p)):
        p=matlabarray([0,25,50,75,100])
    if (not (isnumeric_(p) and isvector_(p))):
        error_(char('prctile: P must be a numeric vector'))
    nd=ndims_(x)
    if (nargin < 3):
        if (nd == 2):
            dim=1
        else:
            dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('prctile: DIM must be an integer and a valid dimension'))
    p /= 100
    q=quantile_(x,p,dim)
    return q
def meansq_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('mean: X must be a numeric vector or matrix'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 2):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('mean: DIM must be an integer and a valid dimension'))
    y=sumsq_(x,dim) / sz[dim]
    return y
def ranks_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('ranks: X must be a numeric vector or matrix'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin != 2):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('ranks: DIM must be an integer and a valid dimension'))
    if (sz[dim] == 1):
        y=ones_(sz)
    else:
        if (dim != 1):
            perm=matlabarray([arange_(1,nd)])
            perm[1]=dim
            perm[dim]=1
            x=permute_(x,perm)
        sz=size_(x)
        infvec=- Inf_([1,sz[2:end()]])
        xs,xi=sort_(x,nargout=2)
        eq_el=find_(diff_([[xs],[infvec]]) == 0)
        if (isempty_(eq_el)):
            eq_el,y=sort_(xi,nargout=2)
        else:
            runs=setdiff_(eq_el,eq_el + 1)
            _len=diff_(find_(diff_([[Inf],[eq_el],[- Inf]]) != 1)) + 1
            eq_el,y=sort_(xi,nargout=2)
            for i in arange_(1,length_(runs)).reshape(-1):
                y[xi[runs[i] + [arange_(0,(_len[i] - 1))]] + floor_(runs[i] / sz[1]) * sz[1]]=eq_el[runs[i]] + (_len[i] - 1) / 2
        if (dim != 1):
            y=permute_(y,perm)
    return y
def statistics_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('statistics: X must be a numeric vector or matrix'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin != 2):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('statistics: DIM must be an integer and a valid dimension'))
    if (sz[dim] < 2):
        error_(char('statistics: dimension of X is too small (<2)'))
    emp_inv=quantile_(x,[[0.25],[0.5],[0.75]],dim,7)
    stats=cat_(dim,min_(x,[],dim),emp_inv,max_(x,[],dim),mean_(x,dim),std_(x,[],dim),skewness_(x,[],dim),kurtosis_(x,[],dim))
    return stats
def kendall_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x)) or not (isnumeric_(y) or islogical_(y))):
        error_(char('kendall: X and Y must be numeric matrices or vectors'))
    if (ndims_(x) != 2 or ndims_(y) != 2):
        error_(char('kendall: X and Y must be 2-D matrices or vectors'))
    if (isrow_(x)):
        x=x.T
    n,c=size_(x,nargout=2)
    if (nargin == 2):
        if (isrow_(y)):
            y=y.T
        if (rows_(y) != n):
            error_(char('kendall: X and Y must have the same number of observations'))
        else:
            x=matlabarray([x,y])
    if (isa_(x,char('single')) or isa_(y,char('single'))):
        cls=char('single')
    else:
        cls=char('double')
    r=ranks_(x)
    m=sign_(kron_(r,ones_(n,1,cls)) - kron_(ones_(n,1,cls),r))
    tau=corr_(m)
    if (nargin == 2):
        tau=tau[1:c,(c + 1):columns_(x)]
    return tau
def table_(x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin == 1):
        if (not isnumeric_(x) or not isvector_(x)):
            error_(char('table: X must be a numeric vector'))
        v=unique_(x)
        for i in arange_(1,length_(v)).reshape(-1):
            t[i]=sum_(x == v[i] or isnan_(v[i]) * isnan_(x))
    else:
        if (nargin == 2):
            if (not (isvector_(x) and isnumeric_(x) and isvector_(y) and isnumeric_(y) and (length_(x) == length_(y)))):
                error_(char('table: X and Y must be numeric vectors of the same length'))
            v=unique_(x)
            w=unique_(y)
            for i in arange_(1,length_(v)).reshape(-1):
                for j in arange_(1,length_(w)).reshape(-1):
                    t[i,j]=sum_((x == v[i] or isnan_(v[i]) * isnan_(x)) and (y == w[j] or isnan_(w[j]) * isnan_(y)))
    return t,v,w
def probit_(p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[p].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=stdnormal_inv_(p)
    return y
def median_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('median: X must be a numeric vector or matrix'))
    if (isempty_(x)):
        error_(char('median: X cannot be an empty matrix'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 2):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('median: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    k=floor_((n + 1) / 2)
    if (mod_(n,2) == 1):
        retval=nth_element_(x,k,dim)
    else:
        retval=mean_(nth_element_(x,arange_(k,k + 1),dim),dim)
    retval[any_(isnan_(x),dim)]=NaN
    return retval
def iqr_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('iqr: X must be a numeric vector or matrix'))
    nd=ndims_(x)
    sz=size_(x)
    nel=numel_(x)
    if (nargin != 2):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('iqr: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    sz[dim]=1
    if (isa_(x,char('single'))):
        y=zeros_(sz,char('single'))
    else:
        y=zeros_(sz)
    stride=prod_(sz[1:dim - 1])
    for i in arange_(1,nel / n).reshape(-1):
        offset=copy_(i)
        offset2=0
        while (offset > stride):

            offset -= stride
            offset2

        offset += offset2 * stride * n
        rng=[arange_(0,n - 1)] * stride + offset
        y[i]=diff_(empirical_inv_([1 / 4,3 / 4],x[rng]))
    return y
def qqplot_(x=None,dist=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dist].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (not (isnumeric_(x) and isvector_(x))):
        error_(char('qqplot: X must be a numeric vector'))
    if (nargin == 1):
        f=stdnormal_inv
    else:
        if (isnumeric_(dist)):
            f=lambda y: empirical_inv_(y,dist)
        else:
            if (ischar_(dist) and (exist_(invname=matlabarray([dist,char('inv')])) or exist_(invname=matlabarray([dist,char('%s_inv')])))):
                f=str2func_(invname)
            else:
                error_(char('qqplot: no inverse CDF found for distribution DIST'))
    s=sort_(x)
    n=length_(x)
    t=((arange_(1,n)).T - 0.5) / n
    if (nargin <= 2):
        q=f[t]
        q_label=func2str_(f)
    else:
        q=f[t,varargin[:]]
        if (nargin == 3):
            q_label=sprintf_(char('%s with parameter %g'),func2str_(f),varargin[1])
        else:
            q_label=sprintf_(char('%s with parameters %g'),func2str_(f),varargin[1])
            param_str=sprintf_(char(', %g'),varargin[2:end()])
            q_label=matlabarray([q_label,param_str])
    if (nargout == 0):
        plot_(q,s)
        q_label=strrep_(q_label,char('_inv'),char('\\_inv'))
        if (q_label[1] == char('@')):
            q_label=q_label[6:end()]
        xlabel_(q_label)
        ylabel_(char('sample points'))
    else:
        qout=copy_(q)
        sout=copy_(s)
    return qout,sout
def cloglog_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=- log_(- log_(x))
    return y
def kurtosis_(x=None,flag=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,flag,dim].count(None)+len(args)

    if (nargin < 1) or (nargin > 3):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('kurtosis: X must be a numeric vector or matrix'))
    if (nargin < 2 or isempty_(flag)):
        flag=1
    else:
        if ((not isscalar_(flag)) or (flag != 0 and flag != 1)):
            error_(char('kurtosis: FLAG must be 0 or 1'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 3):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('kurtosis: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    sz[dim]=1
    x=center_(x,dim)
    v=var_(x,1,dim)
    y=sum_(x ** 4,dim)
    idx=(v != 0)
    y[idx]=y[idx] / (n * v[idx] ** 2)
    y[not idx]=NaN
    if (flag == 0):
        if (n > 3):
            C=(n - 1) / ((n - 2) * (n - 3))
            y=3 + C * ((n + 1) * y - 3 * (n - 1))
        else:
            y[:]=NaN
    return y
def ppplot_(x=None,dist=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dist].count(None)+len(args)

    if (nargin < 1):
        print_usage_()
    if (not isvector_(x)):
        error_(char('ppplot: X must be a vector'))
    s=sort_(x)
    n=length_(x)
    p=((arange_(1,n)).T - 0.5) / n
    if (nargin == 1):
        F=stdnormal_cdf
    else:
        F=str2func_(sprintf_(char('%scdf'),dist))
    if (nargin <= 2):
        y=feval_(F,s)
    else:
        y=feval_(F,s,varargin[:])
    if (nargout == 0):
        plot_(p,y)
        axis_([0,1,0,1])
    return p,y
def moment_(x=None,p=None,opt1=None,opt2=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,p,opt1,opt2].count(None)+len(args)

    if (nargin < 2 or nargin > 4):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x)) or isempty_(x)):
        error_(char('moment: X must be a non-empty numeric matrix or vector'))
    if (not (isnumeric_(p) and isscalar_(p))):
        error_(char('moment: P must be a numeric scalar'))
    need_dim=copy_(false)
    if (nargin == 2):
        _type=char('')
        need_dim=copy_(true)
    else:
        if (nargin == 3):
            if (ischar_(opt1)):
                _type=copy_(opt1)
                need_dim=copy_(true)
            else:
                dim=copy_(opt1)
                _type=char('')
        else:
            if (nargin == 4):
                if (ischar_(opt1)):
                    _type=copy_(opt1)
                    dim=copy_(opt2)
                else:
                    if (ischar_(opt2)):
                        _type=copy_(opt2)
                        dim=copy_(opt1)
                    else:
                        error_(char('moment: expecting TYPE to be a string'))
    nd=ndims_(x)
    sz=size_(x)
    if (need_dim):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('moment: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    if (not any_(_type == char('r'))):
        x=center_(x,dim)
    if (any_(_type == char('a'))):
        x=abs_(x)
    m=sum_(x ** p,dim) / n
    return m
def ols_(y=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[y,x].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not (isnumeric_(x) and isnumeric_(y))):
        error_(char('ols: X and Y must be numeric matrices or vectors'))
    if (ndims_(x) != 2 or ndims_(y) != 2):
        error_(char('ols: X and Y must be 2-D matrices or vectors'))
    nr,nc=size_(x,nargout=2)
    ry,cy=size_(y,nargout=2)
    if (nr != ry):
        error_(char('ols: number of rows of X and Y must be equal'))
    if (isinteger_(x)):
        x=double_(x)
    if (isinteger_(y)):
        y=double_(y)
    z=x.T * x
    u,p=chol_(z,nargout=2)
    if (p):
        beta=pinv_(x) * y
    else:
        beta=numpy.linalg.solve(u,(numpy.linalg.solve(u.T,(x.T * y))))
    if (isargout_(2) or isargout_(3)):
        r=y - x * beta
    if (isargout_(2)):
        if (p == 0):
            rnk=columns_(z)
        else:
            rnk=rank_(z)
        sigma=r.T * r / (nr - rnk)
    return beta,sigma,r
def runlength_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x)) or not isvector_(x)):
        error_(char('runlength: X must be a numeric vector'))
    if (iscolumn_(x)):
        x=x.T
    idx=matlabarray([find_(x[1:end() - 1] != x[2:end()]),length_(x)])
    count=diff_([0,idx])
    if (nargout == 2):
        value=x[idx]
    return count,value
def cov_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,opt].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x)) or not (isnumeric_(y) or islogical_(y))):
        error_(char('cov: X and Y must be numeric matrices or vectors'))
    if (ndims_(x) != 2 or ndims_(y) != 2):
        error_(char('cov: X and Y must be 2-D matrices or vectors'))
    if (nargin == 2 and isscalar_(y)):
        opt=copy_(y)
    if (opt != 0 and opt != 1):
        error_(char('cov: normalization OPT must be 0 or 1'))
    if (isscalar_(x)):
        if (isa_(x,char('single'))):
            c=single_(0)
        else:
            c=0
        return c
    if (isrow_(x)):
        x=x.T
    n=rows_(x)
    if (nargin == 1 or isscalar_(y)):
        x=center_(x,1)
        c=conj_(x.T * x / (n - 1 + opt))
    else:
        if (isrow_(y)):
            y=y.T
        if (rows_(y) != n):
            error_(char('cov: X and Y must have the same number of observations'))
        x=center_(x,1)
        y=center_(y,1)
        c=conj_(x.T * y / (n - 1 + opt))
    return c
def mode_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('mode: X must be a numeric vector or matrix'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 2):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('mode: DIM must be an integer and a valid dimension'))
    sz2=copy_(sz)
    sz2[dim]=1
    sz3=ones_(1,nd)
    sz3[dim]=sz[dim]
    if (issparse_(x)):
        t2=sparse_(sz[1],sz[2])
    else:
        t2=zeros_(sz)
    if (dim != 1):
        perm=matlabarray([dim,arange_(1,dim - 1),arange_(dim + 1,nd)])
        t2=permute_(t2,perm)
    xs=sort_(x,dim)
    t=cat_(dim,true_(sz2),diff_(xs,1,dim) != 0)
    if (dim != 1):
        t2[permute_(t != 0,perm)]=diff_([[find_(permute_(t,perm))(arange_())],[prod_(sz) + 1]])
        f=max_(ipermute_(t2,perm),[],dim)
        xs=permute_(xs,perm)
    else:
        t2[t]=diff_([[find_(t)(arange_())],[prod_(sz) + 1]])
        f=max_(t2,[],dim)
    c=cell_(sz2)
    if (issparse_(x)):
        m=sparse_(sz2[1],sz2[2])
    else:
        m=zeros_(sz2,class_(x))
    for i in arange_(1,prod_(sz2)).reshape(-1):
        c[i]=xs[t2[:,i] == f[i],i]
        m[i]=c[i](1)
    return m,f,c
def logit_(p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[p].count(None)+len(args)

    if (nargin != 1):
        print_usage_()
    y=logistic_inv_(p)
    return y
def spearman_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x)) or not (isnumeric_(y) or islogical_(y))):
        error_(char('spearman: X and Y must be numeric matrices or vectors'))
    if (ndims_(x) != 2 or ndims_(y) != 2):
        error_(char('spearman: X and Y must be 2-D matrices or vectors'))
    if (isrow_(x)):
        x=x.T
    if (nargin == 1):
        rho=corr_(ranks_(x))
    else:
        if (isrow_(y)):
            y=y.T
        if (rows_(x) != rows_(y)):
            error_(char('spearman: X and Y must have the same number of observations'))
        rho=corr_(ranks_(x),ranks_(y))
    if (isa_(x,char('single')) or isa_(y,char('single'))):
        rho=single_(rho)
    return rho
def range_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin == 1):
        y=max_(x) - min_(x)
    else:
        y=max_(x,[],dim) - min_(x,[],dim)
    return y
def center_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('center: X must be a numeric vector or matrix'))
    if (isinteger_(x)):
        x=double_(x)
    nd=ndims_(x)
    sz=size_(x)
    if (nargin != 2):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('center: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    if (n == 0):
        retval=copy_(x)
    else:
        retval=bsxfun_(minus,x,mean_(x,dim))
    return retval
def gls_(y=None,x=None,o=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[y,x,o].count(None)+len(args)

    if (nargin != 3):
        print_usage_()
    if (not (isnumeric_(x) and isnumeric_(y) and isnumeric_(o))):
        error_(char('gls: X, Y, and O must be numeric matrices or vectors'))
    if (ndims_(x) != 2 or ndims_(y) != 2 or ndims_(o) != 2):
        error_(char('gls: X, Y and O must be 2-D matrices or vectors'))
    rx,cx=size_(x,nargout=2)
    ry,cy=size_(y,nargout=2)
    ro,co=size_(o,nargout=2)
    if (rx != ry):
        error_(char('gls: number of rows of X and Y must be equal'))
    if (not issquare_(o) or ro != ry * cy):
        error_(char('gls: matrix O must be square matrix with rows = rows (Y) * cols (Y)'))
    if (isinteger_(x)):
        x=double_(x)
    if (isinteger_(y)):
        y=double_(y)
    if (isinteger_(o)):
        o=double_(o)
    o=o ** (- 1 / 2)
    z=kron_(eye_(cy),x)
    z=o * z
    y1=o * reshape_(y,ry * cy,1)
    u=z.T * z
    r=rank_(u)
    if (r == cx * cy):
        b=inv_(u) * z.T * y1
    else:
        b=pinv_(z) * y1
    beta=reshape_(b,cx,cy)
    if (isargout_(2) or isargout_(3)):
        r=y - x * beta
        if (isargout_(2)):
            v=(reshape_(r,ry * cy,1)).T * (o ** 2) * reshape_(r,ry * cy,1) / (rx * cy - r)
    return beta,v,r
def histc_(x=None,edges=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,edges,dim].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (not isreal_(x)):
        error_(char('histc: X argument must be real-valued, not complex'))
    num_edges=numel_(edges)
    if (num_edges == 0):
        error_(char('histc: EDGES must not be empty'))
    if (not isreal_(edges)):
        error_(char('histc: EDGES must be real-valued, not complex'))
    else:
        edges=edges[:]
        if (not issorted_(edges) or edges[1] > edges[end()]):
            warning_(char('histc: edge values not sorted on input'))
            edges=sort_(edges)
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 3):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('histc: DIM must be an integer and a valid dimension'))
    nsz=copy_(sz)
    nsz[dim]=num_edges
    if (num_edges <= 3):
        n=zeros_(nsz)
        if (nargout > 1):
            idx=zeros_(sz)
        idx1=cell_(1,dim - 1)
        for k in arange_(1,length_(idx1)).reshape(-1):
            idx1[k]=arange_(1,sz[k])
        idx2=cell_(length_(sz) - dim)
        for k in arange_(1,length_(idx2)).reshape(-1):
            idx2[k]=arange_(1,sz[k + dim])
        for k in arange_(1,num_edges - 1).reshape(-1):
            b=(edges[k] <= x and x < edges[k + 1])
            n[idx1[:],k,idx2[:]]=sum_(b,dim)
            if (nargout > 1):
                idx[b]=k
        b=(x == edges[end()])
        n[idx1[:],num_edges,idx2[:]]=sum_(b,dim)
        if (nargout > 1):
            idx[b]=num_edges
    else:
        idx=lookup_(edges,x)
        idx[not (x <= edges[end()])]=0
        iidx=copy_(idx)
        if (not isvector_(x)):
            nl=prod_(sz[1:dim - 1])
            nn=sz[dim]
            nu=prod_(sz[dim + 1:end()])
            if (nl != 1):
                iidx=(iidx - 1) * nl
                iidx += reshape_(kron_(ones_(1,nn * nu),arange_(1,nl)),sz)
            if (nu != 1):
                ne=length_(edges)
                iidx += reshape_(kron_(nl * ne * (arange_(0,nu - 1)),ones_(1,nl * nn)),sz)
        iidx=iidx[idx != 0]
        n=accumarray_(iidx[:],1,nsz)
    return n,idx
def var_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,opt,dim].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('var: X must be a numeric vector or matrix'))
    if (isempty_(opt)):
        opt=0
    if (opt != 0 and opt != 1):
        error_(char('var: normalization OPT must be 0 or 1'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 3):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('var: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    if (n == 1):
        if (isa_(x,char('single'))):
            retval=zeros_(sz,char('single'))
        else:
            retval=zeros_(sz)
    else:
        if (numel_(x) > 0):
            retval=sumsq_(center_(x,dim),dim) / (n - 1 + opt)
        else:
            error_(char('var: X must not be empty'))
    return retval
def run_count_(x=None,n=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,n,dim].count(None)+len(args)

    if (nargin != 2 and nargin != 3):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('run_count: X must be a numeric vector or matrix'))
    if (not (isscalar_(n) and n == fix_(n) and n > 0)):
        error_(char('run_count: N must be a positive integer'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin != 3):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('run_count: DIM must be an integer and a valid dimension'))
    if (dim != 1):
        perm=matlabarray([arange_(1,nd)])
        perm[1]=dim
        perm[dim]=1
        x=permute_(x,perm)
    sz=size_(x)
    idx=cell_()
    for i in arange_(1,nd).reshape(-1):
        idx[i]=arange_(1,sz[i])
    c=sz[1]
    tmp=zeros_([c + 1,sz[2:end()]])
    infvec=Inf_([1,sz[2:end()]])
    ind=find_(diff_([[infvec],[x],[- infvec]]) < 0)
    tmp[ind[2:end()] - 1]=diff_(ind)
    tmp=tmp[idx[:]]
    sz[1]=n
    retval=zeros_(sz)
    for k in arange_(1,(n - 1)).reshape(-1):
        idx[1]=k
        retval[idx[:]]=sum_(tmp == k)
    idx[1]=n
    retval[idx[:]]=sum_(tmp >= n)
    if (dim != 1):
        retval=ipermute_(retval,perm)
    return retval
def quantile_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[x,p,dim,method].count(None)+len(args)

    if (nargin < 1 or nargin > 4):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('quantile: X must be a numeric vector or matrix'))
    if (isempty_(p)):
        p=matlabarray([0.0,0.25,0.5,0.75,1.0])
    if (not (isnumeric_(p) and isvector_(p))):
        error_(char('quantile: P must be a numeric vector'))
    if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= ndims_(x))):
        error_(char('quantile: DIM must be an integer and a valid dimension'))
    perm=arange_(1,ndims_(x))
    perm[1]=dim
    perm[dim]=1
    x=permute_(x,perm)
    sx=size_(x)
    x=reshape_(x,[sx[1],prod_(sx[2:end()])])
    q=__quantile___(x,p,method)
    q=reshape_(q,[numel_(p),sx[2:end()]])
    q=ipermute_(q,perm)
    return q
def __quantile___(x=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,p,method].count(None)+len(args)

    if (nargin < 2 or nargin > 3):
        print_usage_()
    if (isinteger_(x) or islogical_(x)):
        x=double_(x)
    p=p[:]
    x=sort_(x)
    m=sum_(not isnan_(x))
    xr,xc=size_(x,nargout=2)
    inv=Inf_(class_(x)) * (- (p < 0) + (p > 1))
    inv=repmat_(inv,1,xc)
    if (any_(k=find_((p >= 0) and (p <= 1)))):
        n=length_(k)
        p=p[k]
        if (xr == 1):
            inv[k,:]=repmat_(x,n,1)
            return inv
        pcd=kron_(ones_(n,1),xr * (arange_(0,xc - 1)))
        mm=kron_(ones_(n,1),m)
        if [1,2,3] == (method):
            if 1 == (method):
                p=max_(ceil_(kron_(p,m)),1)
                inv[k,:]=x[p + pcd]
            else:
                if 2 == (method):
                    p=kron_(p,m)
                    p_lr=max_(ceil_(p),1)
                    p_rl=min_(floor_(p + 1),mm)
                    inv[k,:]=(x[p_lr + pcd] + x[p_rl + pcd]) / 2
                else:
                    if 3 == (method):
                        t=max_(kron_(p,m),1)
                        t=roundb_(t)
                        inv[k,:]=x[t + pcd]
        else:
            if 4 == (method):
                p=kron_(p,m)
            else:
                if 5 == (method):
                    p=kron_(p,m) + 0.5
                else:
                    if 6 == (method):
                        p=kron_(p,m + 1)
                    else:
                        if 7 == (method):
                            p=kron_(p,m - 1) + 1
                        else:
                            if 8 == (method):
                                p=kron_(p,m + 1 / 3) + 1 / 3
                            else:
                                if 9 == (method):
                                    p=kron_(p,m + 0.25) + 0.375
                                else:
                                    error_(char("quantile: Unknown METHOD, '%d'"),method)
            imm1=(mm == 1)
            x[2,imm1]=x[1,imm1]
            pi=max_(min_(floor_(p),mm - 1),1)
            pr=max_(min_(p - pi,1),0)
            pi += pcd
            inv[k,:]=(1 - pr).dot(x[pi]) + pr.dot(x[pi + 1])
    return inv
def mean_(x=None,opt1=None,opt2=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,opt1,opt2].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('mean: X must be a numeric vector or matrix'))
    need_dim=copy_(false)
    if (nargin == 1):
        opt=char('a')
        need_dim=copy_(true)
    else:
        if (nargin == 2):
            if (ischar_(opt1)):
                opt=copy_(opt1)
                need_dim=copy_(true)
            else:
                dim=copy_(opt1)
                opt=char('a')
        else:
            if (nargin == 3):
                if (ischar_(opt1)):
                    opt=copy_(opt1)
                    dim=copy_(opt2)
                else:
                    if (ischar_(opt2)):
                        opt=copy_(opt2)
                        dim=copy_(opt1)
                    else:
                        error_(char('mean: OPT must be a string'))
            else:
                print_usage_()
    nd=ndims_(x)
    sz=size_(x)
    if (need_dim):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('mean: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    if (strcmp_(opt,char('a'))):
        y=sum_(x,dim) / n
    else:
        if (strcmp_(opt,char('g'))):
            if (all_(x[:] >= 0)):
                y=exp_(sum_(log_(x),dim) / n)
            else:
                error_(char('mean: X must not contain any negative values'))
        else:
            if (strcmp_(opt,char('h'))):
                y=n / sum_(1 / x,dim)
            else:
                error_(char("mean: option '%s' not recognized"),opt)
    return y
def std_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,opt,dim].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x))):
        error_(char('std: X must be a numeric vector or matrix'))
    if (isempty_(opt)):
        opt=0
    if (opt != 0 and opt != 1):
        error_(char('std: normalization OPT must be 0 or 1'))
    nd=ndims_(x)
    sz=size_(x)
    if (nargin < 3):
        dim=find_(sz > 1,1) or 1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('std: DIM must be an integer and a valid dimension'))
    n=sz[dim]
    if (n == 1 or isempty_(x)):
        if (isa_(x,char('single'))):
            retval=zeros_(sz,char('single'))
        else:
            retval=zeros_(sz)
    else:
        retval=sqrt_(sumsq_(center_(x,dim),dim) / (n - 1 + opt))
    return retval
def mahalanobis_(x=None,y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    if (nargin != 2):
        print_usage_()
    if (not (isnumeric_(x) or islogical_(x)) or not (isnumeric_(y) or islogical_(y))):
        error_(char('mahalanobis: X and Y must be numeric matrices or vectors'))
    if (ndims_(x) != 2 or ndims_(y) != 2):
        error_(char('mahalanobis: X and Y must be 2-D matrices or vectors'))
    xr,xc=size_(x,nargout=2)
    yr,yc=size_(y,nargout=2)
    if (xc != yc):
        error_(char('mahalanobis: X and Y must have the same number of columns'))
    if (isinteger_(x)):
        x=double_(x)
    xm=mean_(x)
    ym=mean_(y)
    x=bsxfun_(minus,x,xm)
    y=bsxfun_(minus,y,ym)
    w=(x.T * x + y.T * y) / (xr + yr - 2)
    winv=inv_(w)
    retval=(xm - ym) * winv * (xm - ym).T
    return retval
def cut_(x=None,breaks=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,breaks].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('cut is obsolete and will be removed from a future version of Octave; please use histc instead'))
    if (nargin != 2):
        print_usage_()
    if (not isvector_(x)):
        error_(char('cut: X must be a vector'))
    if (isscalar_(breaks)):
        breaks=linspace_(min_(x),max_(x),breaks + 1)
        breaks[1]=breaks[1] - 1
    else:
        if (isvector_(breaks)):
            breaks=sort_(breaks)
        else:
            error_(char('cut: BREAKS must be a scalar or vector'))
    group=NaN_(size_(x))
    m=length_(breaks)
    if (any_(k=find_((x >= min_(breaks)) and (x < max_(breaks))))):
        n=length_(k)
        group[k]=sum_((ones_(m,1) * reshape_(x[k],1,n)) >= (reshape_(breaks,m,1) * ones_(1,n)))
    return group
def polyderiv_(p=None,a=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[p,a].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('polyderiv is obsolete and will be removed from a future version of Octave; please use polyder instead'))
    if (nargin == 1 or nargin == 2):
        if (not isvector_(p)):
            error_(char('polyderiv: argument must be a vector'))
        if (nargin == 2):
            if (not isvector_(a)):
                error_(char('polyderiv: argument must be a vector'))
            if (nargout == 1):
                q=polyderiv_(conv_(p,a))
            else:
                d=conv_(a,a)
                if (numel_(p) == 1):
                    q=- p * polyderiv_(a)
                else:
                    if (numel_(a) == 1):
                        q=a * polyderiv_(p)
                    else:
                        q=conv_(polyderiv_(p),a) - conv_(p,polyderiv_(a))
                        q=polyreduce_(q)
                x=polygcd_(q,d)
                if (length_(x) != 1):
                    q=deconv_(q,x)
                    d=deconv_(d,x)
                q=q / d[1]
                d=d / d[1]
        else:
            lp=numel_(p)
            if (lp == 1):
                q=0
                return q,d
            else:
                if (lp == 0):
                    q=matlabarray([])
                    return q,d
            p=p[:].T
            q=p[1:(lp - 1)].dot([arange_((lp - 1),1,- 1)])
    else:
        print_usage_()
    return q,d
def java_debug_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('java_debug is obsolete and will be removed from a future version of Octave; use debug_java instead'))
    if (nargin > 2):
        print_usage_()
    old_val=debug_java_(varargin[:])
    return old_val
def gen_doc_cache_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('gen_doc_cache is obsolete and will be removed from a future version of Octave, please use doc_cache_create instead'))
    doc_cache_create_(varargin[:])
    return
def interp1q_(x=None,y=None,xi=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[x,y,xi].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('interp1q is obsolete and will be removed from a future version of Octave; use interp1 instead'))
    x=x[:]
    nx=rows_(x)
    szy=size_(y)
    y=y[:,:]
    ny,nc=size_(y,nargout=2)
    szx=size_(xi)
    xi=xi[:]
    dy=diff_(y)
    dx=diff_(x)
    idx=lookup_(x,xi,char('lr'))
    s=(xi - x[idx]) / dx[idx]
    yi=bsxfun_(times,s,dy[idx,:]) + y[idx,:]
    _range=xi < x[1] or not (xi <= x[nx])
    yi[_range,:]=NA
    if (length_(szx) == 2 and any_(szx == 1)):
        yi=reshape_(yi,[max_(szx),szy[2:end()]])
    else:
        yi=reshape_(yi,[szx,szy[2:end()]])
    return yi
def java_unsigned_conversion_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('java_unsigned_conversion is obsolete and will be removed from a future version of Octave; use java_unsigned_autoconversion instead'))
    if (nargin > 2):
        print_usage_()
    old_val=java_unsigned_autoconversion_(varargin[:])
    return old_val
def __error_text___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('__error_text__ is obsolete and will be removed from a future version of Octave, please use lasterr instead'))
    msg,msgid=lasterr_(varargin[:],nargout=2)
    return msg,msgid
def default_save_options_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('default_save_options is obsolete and will be removed from a future version of Octave, please use save_default_options instead'))
    retval=save_default_options_(varargin[:])
    return retval
def java_invoke_(obj=None,methodname=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[obj,methodname].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('java_invoke is obsolete and will be removed from a future version of Octave, please use javaMethod instead'))
    if (nargin < 2):
        print_usage_()
    retval=javaMethod_(methodname,obj,varargin[:])
    return retval
def cor_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('cor is obsolete and will be removed from a future version of Octave; please use corr instead'))
    if (nargin < 1 or nargin > 2):
        print_usage_()
    retval=corrcoef_(x,y)
    return retval
def re_read_readline_init_file_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('re_read_readline_init_file is obsolete and will be removed from a future version of Octave, please use readline_re_read_init_file instead'))
    readline_re_read_init_file_(varargin[:])
    return
def studentize_(x=None,dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,dim].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('studentize is obsolete and will be removed from a future version of Octave; please use zscore instead'))
    if (nargin != 1 and nargin != 2):
        print_usage_()
    if (not isnumeric_(x)):
        error_(char('studentize: X must be a numeric vector or matrix'))
    if (isinteger_(x)):
        x=double_(x)
    nd=ndims_(x)
    sz=size_(x)
    if (nargin != 2):
        dim=find_(sz > 1,1)
        if (isempty_(dim)):
            dim=1
    else:
        if (not (isscalar_(dim) and dim == fix_(dim)) or not (1 <= dim and dim <= nd)):
            error_(char('studentize: DIM must be an integer and a valid dimension'))
    c=sz[dim]
    if (c == 0):
        t=copy_(x)
    else:
        idx=ones_(1,nd)
        idx[dim]=c
        t=x - repmat_(mean_(x,dim),idx)
        t=t / repmat_(max_(cat_(dim,std_(t,[],dim),not any_(t,dim)),[],dim),idx)
    return t
def java_convert_matrix_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('java_convert_matrix is obsolete and will be removed from a future version of Octave; use java_matrix_autoconversion instead'))
    if (nargin > 2):
        print_usage_()
    old_val=java_matrix_autoconversion_(varargin[:])
    return old_val
def isstr_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('isstr is obsolete and will be removed from a future version of Octave, please use ischar instead'))
    retval=ischar_(varargin[:])
    return retval
def shell_cmd_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('shell_cmd is obsolete and will be removed from a future version of Octave; please use system instead'))
    status,output=system_(varargin[:],nargout=2)
    return status,output
def isequalwithequalnans_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('isequalwithequalnans is obsolete and will be removed from a future version of Octave, please use isequaln instead'))
    retval=isequaln_(varargin[:])
    return retval
def corrcoef_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[x,y].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('corrcoef is not equivalent to Matlab and will be removed from a future version of Octave; for similar functionality see corr'))
    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (isscalar_(x)):
        if (isa_(x,char('single'))):
            retval=single_(1)
        else:
            retval=1
        return retval
    if (nargin == 2):
        c=cov_(x,y)
        s=std_(x).T * std_(y)
        retval=c / s
    else:
        c=cov_(x)
        s=sqrt_(diag_(c))
        retval=c / (s * s.T)
    return retval
def read_readline_init_file_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('read_readline_init_file is obsolete and will be removed from a future version of Octave, please use readline_read_init_file instead'))
    readline_read_init_file_(varargin[:])
    return
def sylvester_matrix_(k=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[k].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('sylvester_matrix is obsolete and will be removed from a future version of Octave; please use hadamard(2^k) instead'))
    if (nargin != 1):
        print_usage_()
    if (isscalar_(k)):
        if (k < 1):
            retval=1
        else:
            tmp=sylvester_matrix_(k - 1)
            retval=matlabarray([[tmp,tmp],[tmp,- tmp]])
    else:
        error_(char('sylvester_matrix: expecting scalar argument'))
    return retval
def error_text_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('error_text is obsolete and will be removed from a future version of Octave, please use lasterr instead'))
    msg,msgid=lasterr_(varargin[:],nargout=2)
    return msg,msgid
def saving_history_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('saving_history is obsolete and will be removed from a future version of Octave, please use history_save instead'))
    retval=save_default_options_(varargin[:])
    return retval
def javamethods_(classname=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[classname].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('javamethods is obsolete and will be removed from a future version of Octave, please use methods instead'))
    if (nargin != 1):
        print_usage_()
    cls_methods=javaMethod_(char('getMethods'),char('org.octave.ClassHelper'),classname)
    method_list=ostrsplit_(cls_methods,char(';'))
    if (nargout == 0):
        if (not isempty_(method_list)):
            disp_(method_list)
    else:
        mtd_names=cellstr_(method_list)
    return mtd_names
def java_new_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('java_new is obsolete and will be removed from a future version of Octave; please use javaObject instead'))
    if (nargin < 1):
        print_usage_()
    retval=javaObject_(varargin[:])
    return retval
def javafields_(javaobj=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[javaobj].count(None)+len(args)

    warned=copy_(false)
    if (not warned):
        warned=copy_(true)
        warning_(char('Octave:deprecated-function'),char('javafields is obsolete and will be removed from a future version of Octave, please use fieldnames instead'))
    if (nargin != 1):
        print_usage_()
    c_methods=javaMethod_(char('getFields'),char('org.octave.ClassHelper'),javaobj)
    method_list=ostrsplit_(c_methods,char(';'))
    if (nargout == 0):
        if (not isempty_(method_list)):
            disp_(method_list)
    else:
        fld_names=cellstr_(method_list)
    return fld_names
def fail_(code=None,pattern=None,warning_pattern=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[code,pattern,warning_pattern].count(None)+len(args)

    if (nargin < 1 or nargin > 3):
        print_usage_()
    test_warning=(nargin > 1 and strcmp_(pattern,char('warning')))
    if (nargin == 3):
        pattern=copy_(warning_pattern)
    else:
        if (nargin == 1 or (nargin == 2 and test_warning)):
            pattern=char('')
    if (isempty_(pattern)):
        pattern=char('.')
    if (nargout):
        ret=1
    if (test_warning):
        lastwarn_()
        state=warning_(char('query'),char('quiet'))
        warning_(char('on'),char('quiet'))
        try:
            evalin_(char('caller'),sprintf_(char('%s;'),code))
            err=lastwarn_()
            warning_(state.state,char('quiet'))
            if (isempty_(err)):
                msg=sprintf_(char('expected warning <%s> but got none'),pattern)
            else:
                err[[arange_(1,9),end()]]=[]
                if (not isempty_(regexp_(err,pattern,char('once')))):
                    return ret
                msg=sprintf_(char('expected warning <%s>\nbut got <%s>'),pattern,err)
        finally:
            pass
    else:
        try:
            evalin_(char('caller'),sprintf_(char('%s;'),code))
            msg=sprintf_(char('expected error <%s> but got none'),pattern)
        finally:
            pass
    error_(msg)
    return ret
def demo_(name=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[name,n].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin < 2):
        n=0
    else:
        if (ischar_(n)):
            n=str2double_(n)
    code,idx=test_(name,char('grabdemo'),nargout=2)
    if (idx == - 1):
        warning_(char('no function %s found'),name)
        return
    else:
        if (isempty_(idx)):
            warning_(char('no demo available for %s'),name)
            return
        else:
            if (n >= length_(idx)):
                warning_(char('only %d demos available for %s'),length_(idx) - 1,name)
                return
    if (n > 0):
        doidx=copy_(n)
    else:
        doidx=arange_(1,(length_(idx) - 1))
    for i in arange_(1,length_(doidx)).reshape(-1):
        if (i > 1):
            input_(char('Press <enter> to continue: '),char('s'))
        try:
            block=code[idx[doidx[i]]:idx[doidx[i] + 1] - 1]
            eval_([char('function __demo__()\n'),block,char('\nendfunction')])
            printf_(char('%s example %d:%s\n\n'),name,doidx[i],block)
            __demo__
        finally:
            pass
        clear_(char('__demo__'))
    return
def example_(name=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[name,n].count(None)+len(args)

    if (nargin < 1 or nargin > 2):
        print_usage_()
    if (nargin < 2):
        n=0
    else:
        if (ischar_(n)):
            n=str2double_(n)
    code,idx=test_(name,char('grabdemo'),nargout=2)
    if (nargout > 0):
        if (n > 0):
            if (n <= length_(idx)):
                code_r=code[idx[n]:idx[n + 1] - 1]
                idx_r=matlabarray([1,length_(code_r) + 1])
            else:
                code_r=char('')
                idx_r=matlabarray([])
        else:
            code_r=copy_(code)
            idx_r=copy_(idx)
    else:
        if (n > 0):
            doidx=copy_(n)
        else:
            doidx=arange_(1,length_(idx) - 1)
        if (isempty_(idx)):
            warning_(char('no example available for %s'),name)
            return code_r,idx_r
        else:
            if (n >= length_(idx)):
                warning_(char('only %d examples available for %s'),length_(idx) - 1,name)
                return code_r,idx_r
        for i in arange_(1,length_(doidx)).reshape(-1):
            block=code[idx[doidx[i]]:idx[doidx[i] + 1] - 1]
            printf_(char('%s example %d:%s\n\n'),name,doidx[i],block)
    return code_r,idx_r
def rundemos_(directory=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[directory].count(None)+len(args)

    if (nargin == 0):
        dirs=ostrsplit_(path_(),pathsep_())
        do_class_dirs=copy_(true)
    else:
        if (nargin == 1):
            if (is_absolute_filename_(directory)):
                dirs=[directory]
            else:
                if (is_rooted_relative_filename_(directory)):
                    dirs=[canonicalize_file_name_(directory)]
                else:
                    if (directory[end()] == filesep_()):
                        directory=directory[1:end() - 1]
                    fullname=find_dir_in_path_(directory)
                    if (not isempty_(fullname)):
                        dirs=[fullname]
                    else:
                        error_(char('rundemos: DIRECTORY argument must be a valid pathname'))
            do_class_dirs=copy_(false)
        else:
            print_usage_()
    for i in arange_(1,numel_(dirs)).reshape(-1):
        d=dirs[i]
        run_all_demos_(d,do_class_dirs)
    return
def run_all_demos_(directory=None,do_class_dirs=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[directory,do_class_dirs].count(None)+len(args)

    flist=readdir_(directory)
    dirs=[]
    for i in arange_(1,numel_(flist)).reshape(-1):
        f=flist[i]
        if ((length_(f) > 2 and strcmpi_(f[(end() - 1):end()],char('.m'))) or (length_(f) > 3 and strcmpi_(f[(end() - 2):end()],char('.cc')))):
            f=fullfile_(directory,f)
            if (has_demos_(f)):
                try:
                    demo_(f)
                finally:
                    pass
                if (i != numel_(flist)):
                    input_(char('Press <enter> to continue: '),char('s'))
        else:
            if (f[1] == char('@')):
                f=fullfile_(directory,f)
                if (isdir_(f)):
                    dirs[end() + 1]=f
    if (do_class_dirs):
        for i in arange_(1,numel_(dirs)).reshape(-1):
            d=dirs[i]
            run_all_demos_(d,false)
    return
def has_demos_(f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[f].count(None)+len(args)

    fid=fopen_(f)
    if (f < 0):
        error_(char('rundemos: fopen failed: %s'),f)
    else:
        _str=fread_(fid,char('*char')).T
        fclose_(fid)
        retval=not isempty_(regexp_(_str,char('^%!demo'),char('lineanchors'),char('once')))
    return retval
def __prog_output_assert___(str=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[_str].count(None)+len(args)

    global _assert_printf
    if (isempty_(_assert_printf)):
        ret=isempty_(_str)
    else:
        if (_assert_printf[end()] == char('\n')):
            ret=strcmp_(_assert_printf[1:(end() - 1)],_str)
        else:
            ret=strcmp_(_assert_printf,_str)
    _assert_printf=char('')
    return ret
def speed_(__f1=None,__init=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[__f1,__init,__max_n,__f2,__tol].count(None)+len(args)

    if (nargin < 1 or nargin > 6):
        print_usage_()
    if (nargin < 2 or isempty_(__init)):
        __init=char('x = randn (n, 1)')
    if (isempty_(__max_n)):
        __max_n=100
    __numtests=15
    if (isscalar_(__max_n)):
        __min_n=1
        assert_(__max_n > __min_n)
        __test_n=logspace_(0,log10_(__max_n),__numtests)
    else:
        if (length_(__max_n) == 2):
            __min_n,__max_n=deal_(__max_n[1],__max_n[2],nargout=2)
            assert_(__min_n >= 1)
            assert_(__max_n > __min_n)
            __test_n=logspace_(log10_(__min_n),log10_(__max_n),__numtests)
        else:
            assert_(all_(__max_n > 0))
            __test_n=copy_(__max_n)
    __test_n=unique_(round_(__test_n))
    assert_(__test_n >= 1)
    __torig=__tnew=zeros_(size_(__test_n))
    do_display=(nargout == 0)
    if (do_display):
        disp_([char('testing '),__f1,char('\ninit: '),__init])
    __init[end() + 1]=char(';')
    __f1[end() + 1]=char(';')
    if (not isempty_(__f2)):
        __f2[end() + 1]=char(';')
    n=1
    k=0
    eval_(__init)
    eval_(__f1)
    if (not isempty_(__f2)):
        eval_(__f2)
    for k in arange_(1,length_(__test_n)).reshape(-1):
        n=__test_n[k]
        eval_(__init)
        if (do_display):
            printf_(char('n%i = %i  '),k,n)
            fflush_(stdout)
        eval_([char('__t = time();'),__f1,char('__v1=ans; __t = time()-__t;')])
        if (__t < 0.25):
            eval_([char('__t2 = time();'),__f1,char('__t2 = time()-__t2;')])
            eval_([char('__t3 = time();'),__f1,char('__t3 = time()-__t3;')])
            __t=min_([__t,__t2,__t3])
        __tnew[k]=__t
        if (not isempty_(__f2)):
            eval_([char('__t = time();'),__f2,char('__v2=ans; __t = time()-__t;')])
            if (__t < 0.25):
                eval_([char('__t2 = time();'),__f2,char('__t2 = time()-__t2;')])
                eval_([char('__t3 = time();'),__f2,char('__t3 = time()-__t3;')])
                __t=min_([__t,__t2,__t3])
            __torig[k]=__t
            if (not isinf_(__tol)):
                assert_(__v1,__v2,__tol)
    if (isempty_(__f2)):
        zidx=(__tnew < 100 * eps)
        __test_n[zidx]=[]
        __tnew[zidx]=[]
    else:
        zidx=(__tnew < 100 * eps or __torig < 100 * eps)
        __test_n[zidx]=[]
        __tnew[zidx]=[]
        __torig[zidx]=[]
    if (isempty_(__test_n)):
        error_([char('speed: All running times were zero.\n'),char('error: speed: Choose larger MAX_N or do more work per function evaluation')])
    tailidx=arange_(ceil_(length_(__test_n) / 2),length_(__test_n))
    p=polyfit_(log_(__test_n[tailidx]),log_(__tnew[tailidx]),1)
    if (nargout > 0):
        __order.p=p[1]
        __order.a=exp_(p[2])
    if (do_display):
        figure
        __init[end()]=char('')
        __f1[end()]=char('')
        if (not isempty_(__f2)):
            __f2[end()]=char('')
    if (do_display and isempty_(__f2)):
        loglog_(__test_n,__tnew * 1000,char('*-g;execution time;'))
        xlabel_(char('test length'))
        ylabel_(char('best execution time (ms)'))
        title_([__f1,[char('init: '),__init]])
    else:
        if (do_display):
            subplot_(1,2,1)
            semilogx_(__test_n,__torig / __tnew,[char('-*r;'),strrep_(__f1,char(';'),char('.')),char(' / '),strrep_(__f2,char(';'),char('.')),char(';')],__test_n,__tnew / __torig,[char('-*g;'),strrep_(__f2,char(';'),char('.')),char(' / '),strrep_(__f1,char(';'),char('.')),char(';')])
            title_(char('Speedup Ratio'))
            xlabel_(char('test length'))
            ylabel_(char('speedup ratio'))
            subplot_(1,2,2)
            loglog_(__test_n,__tnew * 1000,[char('*-g;'),strrep_(__f1,char(';'),char('.')),char(';')],__test_n,__torig * 1000,[char('*-r;'),strrep_(__f2,char(';'),char('.')),char(';')])
            title_([char('Execution Times'),[char('init: '),__init]])
            xlabel_(char('test length'))
            ylabel_(char('best execution time (ms)'))
            ratio=mean_(__torig / __tnew)
            printf_(char("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n"),ratio,__f2,__f1)
    if (do_display):
        figure
        order=round_(10 * p[1]) / 10
        if (order >= 0.1):
            order=sprintf_(char('O(n^%g)'),order)
        else:
            order=char('O(1)')
        v=polyval_(p,log_(__test_n[tailidx]))
        loglog_(__test_n[tailidx],exp_(v) * 1000,sprintf_(char('b;%s;'),order))
        title_([char('Time Complexity'),__f1])
        xlabel_(char('test length'))
        dt=exp_(p[2])
        dt=floor_(dt / 10 ** floor_(log10_(dt))) * 10 ** floor_(log10_(dt))
        if (log10_(dt) >= - 0.5):
            time=sprintf_(char('%g s'),dt)
        else:
            if (log10_(dt) >= - 3.5):
                time=sprintf_(char('%g ms'),dt * 1000.0)
            else:
                if (log10_(dt) >= - 6.5):
                    time=sprintf_(char('%g us'),dt * 1000000.0)
                else:
                    time=sprintf_(char('%g ns'),dt * 1000000000.0)
        printf_(char('\nFor %s:\n'),__f1)
        printf_(char('  asymptotic power: %s\n'),order)
        printf_(char('  approximate time per operation: %s\n'),time)
    return __order,__test_n,__tnew,__torig
def __printf_assert___(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    global _assert_printf
    _assert_printf=cat_(2,_assert_printf,sprintf_(varargin[:]))
    return
def runtests_(directory=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[directory].count(None)+len(args)

    if (nargin == 0):
        dirs=ostrsplit_(path_(),pathsep_())
        do_class_dirs=copy_(true)
    else:
        if (nargin == 1):
            if (is_absolute_filename_(directory)):
                dirs=[directory]
            else:
                if (is_rooted_relative_filename_(directory)):
                    dirs=[canonicalize_file_name_(directory)]
                else:
                    if (directory[end()] == filesep_()):
                        directory=directory[1:end() - 1]
                    fullname=find_dir_in_path_(directory)
                    if (not isempty_(fullname)):
                        dirs=[fullname]
                    else:
                        error_(char('runtests: DIRECTORY argument must be a valid pathname'))
            do_class_dirs=copy_(false)
        else:
            print_usage_()
    for i in arange_(1,numel_(dirs)).reshape(-1):
        d=dirs[i]
        run_all_tests_(d,do_class_dirs)
    return
def run_all_tests_(directory=None,do_class_dirs=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[directory,do_class_dirs].count(None)+len(args)

    flist=readdir_(directory)
    dirs=[]
    no_tests=[]
    printf_(char('Processing files in %s:\n\n'),directory)
    fflush_(stdout)
    for i in arange_(1,numel_(flist)).reshape(-1):
        f=flist[i]
        if ((length_(f) > 2 and strcmpi_(f[(end() - 1):end()],char('.m'))) or (length_(f) > 3 and strcmpi_(f[(end() - 2):end()],char('.cc')))):
            ff=fullfile_(directory,f)
            if (has_tests_(ff)):
                print_test_file_name_(f)
                p,n,xf,sk=test_(ff,char('quiet'),nargout=4)
                print_pass_fail_(n,p)
                fflush_(stdout)
            else:
                if (has_functions_(ff)):
                    no_tests[end() + 1]=f
        else:
            if (f[1] == char('@')):
                f=fullfile_(directory,f)
                if (isdir_(f)):
                    dirs[end() + 1]=f
    if (not isempty_(no_tests)):
        printf_(char('\nThe following files in %s have no tests:\n\n'),directory)
        printf_(char('%s'),list_in_columns_(no_tests))
    if (do_class_dirs):
        for i in arange_(1,numel_(dirs)).reshape(-1):
            d=dirs[i]
            run_all_tests_(d,false)
    return
def has_functions_(f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[f].count(None)+len(args)

    n=length_(f)
    if (n > 3 and strcmpi_(f[(end() - 2):end()],char('.cc'))):
        fid=fopen_(f)
        if (fid >= 0):
            _str=fread_(fid,char('*char')).T
            fclose_(fid)
            retval=not isempty_(regexp_(_str,char('^(?:DEFUN|DEFUN_DLD|DEFUNX)\\>'),char('lineanchors'),char('once')))
        else:
            error_(char('fopen failed: %s'),f)
    else:
        if (n > 2 and strcmpi_(f[(end() - 1):end()],char('.m'))):
            retval=copy_(true)
        else:
            retval=copy_(false)
    return retval
def has_tests_(f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[f].count(None)+len(args)

    fid=fopen_(f)
    if (fid >= 0):
        _str=fread_(fid,char('*char')).T
        fclose_(fid)
        retval=not isempty_(regexp_(_str,char('^%!(?:test|xtest|assert|error|warning)'),char('lineanchors'),char('once')))
    else:
        error_(char('runtests: fopen failed: %s'),f)
    return retval
def print_pass_fail_(n=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,p].count(None)+len(args)

    if (n > 0):
        printf_(char(' PASS %4d/%-4d'),p,n)
        nfail=n - p
        if (nfail > 0):
            printf_(char(' FAIL %d'),nfail)
    puts_(char('\n'))
    return
def print_test_file_name_(nm=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[nm].count(None)+len(args)

    filler=repmat_(char('.'),1,55 - length_(nm))
    printf_(char('  %s %s'),nm,filler)
    return
