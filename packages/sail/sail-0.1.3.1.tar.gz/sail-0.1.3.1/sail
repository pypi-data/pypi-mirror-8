#!/usr/bin/env python
# -*- coding: utf-8 -*-
# PYTHON_ARGCOMPLETE_OK
'''
sail services add [<namespace>/]<repository>[:tag] [namespace/]<service-name>
            --model         Container model
            --number        Number of container to run
            [--network {public|private|<namespace name>}]
            [--restart {no|always[:<max>]|on-failure[:<max>]}]
       override docker options:
            --user
            --entrypoint
            --command
            --workdir
            --environment KEY=val
        other options:
            --link name:alias

sail services ps
sail services inspect [namespace/]service-name
sail services rm [namespace/]service-name
sail services redeploy [namespace/]service-name
            --model         Container model
            [--network {public|private|<namespace name>}]
            [--restart {no|always[:<max>]|on-failure[:<max>]}]
       override docker options:
            --user
            --entrypoint
            --command
            --workdir
            --environment KEY=val
sail services scale --number <X> [namespace/]service-name
sail services start [namespace/]service-name
sail services stop [namespace/]service-name
sail services attach [namespace/]service-name
sail containers ps
sail containers inspect [namespace/]container-name
sail containers attach [namespace/]container-name

configuration: (by priority)
    from command line
    from environment
    from .dockercfg

common options:
    -h --api-host           Docker index endpoint   [env: SAIL_HOST]
    -u --api-user           Docker index user       [env: SAIL_USER]
    -p --api-password       Docker index password   [env: SAIL_PASSWORD]
'''

import os
import sys
import json
import argparse, argcomplete
from base64 import b64decode
from datetime import datetime
import shlex

from tabulate import tabulate
import requests
import dateutil.parser
import requests.exceptions
import pyaml

ENDPOINT='sailabove.io'
DOCKERCFG='~/.dockercfg'

## Helpers

def ping(url):
    try:
        res = requests.get(url)
    except Exception:
        return False
    else:
        return res.status_code < 400

def expand_registry_url(hostname):
    if hostname.startswith('http:') or hostname.startswith('https:'):
        if '/' not in hostname[9:]:
            hostname = hostname + '/v1'
        return hostname
    if ping('https://' + hostname + '/v1/_ping'):
        return 'https://' + hostname + '/v1'
    return 'http://' + hostname + '/v1'

def parse_repository(repo, default_ns=None):
    column_index = repo.rfind(':')
    if column_index >= 0:
        tag = repo[column_index + 1:]
        repo = repo[:column_index]
    else:
        tag = None
    slash_index = repo.find('/')
    if slash_index >= 0:
        namespace = repo[:slash_index]
        repo = repo[slash_index + 1:]
    else:
        namespace = default_ns
    return namespace, repo, tag

def docker_parse_config(endpoint):
    '''
    Try hard to load user's credentials from dockerfile. Failing is an option
    '''
    path = os.path.expanduser(DOCKERCFG)
    conf = {
        'USERNAME': None,
        'PASSWORD': None,
    }

    try:
        with open(path) as f:
            parsed = json.load(f)
        if endpoint in parsed:
            auth = b64decode(parsed[endpoint]['auth']).split(':')
            conf['USERNAME'] = auth[0]
            conf['PASSWORD'] = auth[1]
    except IOError:
        print >> sys.stderr, "[WARNING] Failed to read %s" % DOCKERCFG
    except ValueError:
        print >> sys.stderr, "[WARNING] Failed to parse %s" % DOCKERCFG

    return conf

def _print(data):
    if isinstance(data, requests.Response):
        data = data.json()
    print pyaml.dump(data)

def _tabulate(data, headers):
    print(tabulate(data, headers, stralign='left', tablefmt='plain'))

def exit_exc(message, e, args):
    resource_desc = args.func.func_name.split('_')[1:]
    action = resource_desc[1]
    resource = resource_desc[0]
    object_name = getattr(args, resource, '')

    print >> sys.stderr, "Failed to %s %s %s: %s" % (action, resource, object_name, message)

    if args.debug:
        raise e

    sys.exit(1)

## API methods

def api_request(args, method, path, data=None, headers={}, display=True, stream=False):
    url = expand_registry_url(args.api_host) + path
    auth = (args.api_user, args.api_password)

    if method in ['PUT', 'POST'] and data is not None:
        headers['Content-type'] = 'application/json'
        data = json.dumps(data)

    if args.debug:
        print 'Request: %s %s' % (method, url)
        print 'Body: %s' %data

    resp = requests.request(method, url, data=data, headers=headers, auth=auth, stream=stream)
    resp.raise_for_status()

    if stream:
        return resp
    if display or args.debug:
        _print(resp)
    return resp.json()

def api_app_list(argsu, display=True):
    return api_request(args, 'GET', '/applications', display=display)

def api_service_add(args):
    ns, repository, tag = parse_repository(args.repository, args.api_user)
    ns_service, service, _ = parse_repository(args.service, ns)

    if args.entrypoint is not None:
        args.entrypoint = shlex.split(args.entrypoint)
    if args.command is not None:
        args.command = shlex.split(args.command)

    links = {}
    for link in args.link:
        link = link.split(':', 1)
        if len(link) == 1:
            links[link[0]] = link[1]
        else:
            links[link[0]] = link[0]

    networks = {}
    if not args.network:
        args.network = ['public', 'private']
    for network in args.network:
        if network == 'private':
            network = ns
        networks[network] = {}

    params = {
        'namespace': ns,
        'repository': repository,
        'repository_tag': tag,
        'container_model': args.model,
        'container_number': int(args.number),
        'container_user': args.user,
        'container_entrypoint': args.entrypoint,
        'container_command': args.command,
        'container_workdir': args.workdir,
        'container_environment': args.env,
        'container_network': networks,
        'links': links,
        'restart_policy': args.restart,
    }

    path = '/applications/%s/services/%s?stream' % (ns_service, service)
    resp = api_request(args, 'POST', path, params, stream=True)

    for msg in resp.iter_lines(chunk_size=1):
        msg = json.loads(msg)
        if 'message' in msg:
            print msg.get('message', None)
        elif 'error' in msg:
            return exit_exc(msg.get('error_details'), Exception(msg), args)

    # Spawn stream and start the service
    print "\nStarting service..."
    stream = api_service_attach(args, return_generator=True)
    api_service_start(args)

    print "\nAttaching to container(s) console..."
    try:
        for line in stream.iter_lines(chunk_size=1):
            print line
    except (KeyboardInterrupt, IOError):
        pass

def api_service_delete(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/' % (ns, service)
    return api_request(args, 'DELETE', path)

def api_service_redeploy(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/redeploy?stream' % (ns, service)

    if args.entrypoint is not None:
        args.entrypoint = shlex.split(args.entrypoint)
    if args.command is not None:
        args.command = shlex.split(args.command)

    params = {}
    if args.model:
        params['container_model'] = args.model
    if args.user:
        params['container_user'] = args.user
    if args.entrypoint:
        params['container_entrypoint'] = args.entrypoint
    if args.command:
        params['container_command'] = args.command
    if args.workdir:
        params['container_workdir'] = args.workdir
    if args.env:
        params['container_environment'] = args.env

    if args.network:
        networks = {}
        for network in args.network:
            if network == 'private':
                network = ns
            networks[network] = {}
        params['container_network'] = networks

    stream = api_service_attach(args, return_generator=True)
    resp = api_request(args, 'POST', path, params, stream=True)
    for msg in resp.iter_lines(chunk_size=1):
        msg = json.loads(msg)
        if 'message' in msg:
            print msg.get('message', None)
        elif 'error' in msg:
            return exit_exc(msg.get('error_details'), Exception(msg), args)
        else:
            print "\nRedeployed service:"
            _print(msg)

    print "\nAttaching to container(s) console..."
    try:
        for line in stream.iter_lines(chunk_size=1):
            print line
    except (KeyboardInterrupt, IOError):
        pass

def api_service_start(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/start' % (ns, service)
    return api_request(args, 'POST', path, {})

def api_service_stop(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/stop' % (ns, service)
    return api_request(args, 'POST', path, {})

def api_service_scale(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/scale' % (ns, service)
    params = {
        'container_number': int(args.number)
    }
    return api_request(args, 'POST', path, params)

def api_service_ps(args):
    if args.namespace:
        applications = [args.namespace]
    else:
        applications = api_app_list(args, display=False)

    displayed = []
    for application in applications:
        path = '/applications/%s/services' % (application)
        services = api_request(args, 'GET', path, display=False)
        headers = ['NAME', 'REPOSITORY', 'IMAGE ID', 'STATE', 'CREATED', 'DEPLOYED']
        for service in services:
            path = '/applications/%s/services/%s' % (application, service)
            service = api_request(args, 'GET', path, display=False)
            displayed.append([
                '%s/%s' % (application, service['name']),
                '%s@%s' % (service['repository'], service['repository_tag']),
                service['image'][:12],
                service['state'].capitalize(),
                dateutil.parser.parse(service['creation_date']).replace(tzinfo=None),
                dateutil.parser.parse(service['deployment_date']).replace(tzinfo=None)
            ])

    if len(displayed) == 0:
        displayed.append(['', '', '', '', '', ''])
    _tabulate(displayed, headers)

def api_service_inspect(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/' % (ns, service)
    return api_request(args, 'GET', path)

def api_service_attach(args, return_generator=False):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/attach' % (ns, service)
    r = api_request(args, 'GET', path, stream=True)
    if return_generator:
        return r
    try:
        for line in r.iter_lines(chunk_size=1):
            print line
    except (KeyboardInterrupt, IOError):
        pass

def api_container_ps(args):
    if args.namespace:
        applications = [args.namespace]
    else:
        applications = api_app_list(args, display=False)
    displayed = []
    for application in applications:
        path = '/applications/%s/containers' % (application)
        containers = api_request(args, 'GET', path, display=False)
        headers = ['NAME', 'REPOSITORY', 'IMAGE ID', 'STATE', 'DEPLOYED']
        for container in containers:
            path = '/applications/%s/containers/%s' % (application, container)
            container = api_request(args, 'GET', path, display=False)
            displayed.append([
                '%s/%s' % (application, container['name']),
                '%s@%s' % (container['repository'], container['repository_tag']),
                container['image'][:12],
                #' '.join(container['command'])[:20],
                container['state'].capitalize(),
                dateutil.parser.parse(container['deployment_date']).replace(tzinfo=None)
            ])

    if len(displayed) == 0:
        displayed.append(['', '', '', '', '', ''])
    _tabulate(displayed, headers)

def api_container_inspect(args):
    ns, container, _ = parse_repository(args.container, args.api_user)
    path = '/applications/%s/containers/%s/' % (ns, container)
    return api_request(args, 'GET', path)

def api_container_attach(args):
    ns, container, _ = parse_repository(args.container, args.api_user)
    path = '/applications/%s/containers/%s/attach' % (ns, container)
    r = api_request(args, 'GET', path, stream=True)
    try:
        for line in r.iter_lines(chunk_size=1):
            print line
    except (KeyboardInterrupt, IOError):
        pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='OVH Docker as a Service CLI')

    parser.add_argument('-H', '--api-host',
                        help='Docker index host [env: SAIL_HOST] or [%s]' % ENDPOINT,
                        default=None)
    parser.add_argument('-u', '--api-user',
                        help='Docker index user [env: SAIL_USER] or [file: .dockercfg]',
                        default=None)
    parser.add_argument('-p', '--api-password',
                        help='Docker index password [env: SAIL_PASSWORD] or [file: .dockercfg]',
                        default=None)
    parser.add_argument('--debug', help='Debug the API requests', action='store_true')

    subparsers = parser.add_subparsers()

    # app-list
    app_parser = subparsers.add_parser('apps', help='Applications')
    app_sub = app_parser.add_subparsers()

    app_list = app_sub.add_parser('list', help='List granted apps')
    app_list.set_defaults(func=api_app_list)

    # service-add
    service_parser = subparsers.add_parser('services', help='Services')
    service_sub = service_parser.add_subparsers()
    service_add = service_sub.add_parser('add',
                                         help='Add a new docker service')

    service_add.add_argument('repository', help='[namespace/]repository:tag')
    service_add.add_argument('service', help='the new service name')

    service_add.add_argument('--model', help='the containers model',
                             default='x1')
    service_add.add_argument('--number', help='number of containers to launch',
                             default=1)

    service_add.add_argument('--user', help='override docker user')
    service_add.add_argument('--entrypoint', help='override docker entrypoint')
    service_add.add_argument('--command', help='override docker run command')
    service_add.add_argument('--workdir', help='override docker workdir')
    service_add.add_argument('--restart', help='Docker like restart policy (no, always[:max], on-failure[:max])',
                             default='no')
    service_add.add_argument('--env', help='override docker environment',
                             action='append', default=[])
    service_add.add_argument('--link', help='link to another service',
                             action='append', default=[])
    service_add.add_argument('--network', help='Specify service network {public|private|<namespace name>}. "public" assigns a public IP, "private" selects this namespace\'s private network (default: [public, private])',
                             action='append', default=[])
    service_add.set_defaults(func=api_service_add)

    # service-delete
    service_delete = service_sub.add_parser('rm', help='Delete a docker service')
    service_delete.add_argument('service', help='[namespace/]service name')
    service_delete.set_defaults(func=api_service_delete)

    # service-attach
    service_attach = service_sub.add_parser('attach', help='Attach to the console of the service containers')
    service_attach.add_argument('service', help='[namespace/]service name')
    service_attach.set_defaults(func=api_service_attach)

    # service-list
    service_ps = service_sub.add_parser('ps', help='List docker services')
    service_ps.add_argument('-n', '--namespace', help='the namespace name')
    service_ps.set_defaults(func=api_service_ps)

    service_inspect = service_sub.add_parser('inspect', help='Inspect a docker service')
    service_inspect.add_argument('service', help='[namespace/]service name')
    service_inspect.set_defaults(func=api_service_inspect)

    # service-redeploy
    service_redeploy = service_sub.add_parser('redeploy', help='Redeploy a docker service')
    service_redeploy.add_argument('service', help='[namespace/]service name')
    service_redeploy.add_argument('--model', help='the containers model')
    service_redeploy.add_argument('--user', help='override docker user')
    service_redeploy.add_argument('--entrypoint', help='override docker entrypoint')
    service_redeploy.add_argument('--command', help='override docker run command')
    service_redeploy.add_argument('--workdir', help='override docker workdir')
    service_redeploy.add_argument('--restart', help='Docker like restart policy (no, always[:max], on-failure[:max])')
    service_redeploy.add_argument('--env', help='override docker environment',
                             action='append', default=[])
    service_redeploy.add_argument('--network', help='Specify service network {public|private|<namespace name>}. "public" assigns a public IP, "private" selects this namespace\'s private network (default: [public, private])',
                             action='append', default=[])
    service_redeploy.set_defaults(func=api_service_redeploy)

    # service-stop
    service_stop = service_sub.add_parser('stop', help='Stop a docker service')
    service_stop.add_argument('service', help='[namespace/]service name')
    service_stop.set_defaults(func=api_service_stop)

    # service-start
    service_start = service_sub.add_parser('start', help='Start a docker service')
    service_start.add_argument('service', help='[namespace/]service name')
    service_start.set_defaults(func=api_service_start)

    # service-scale
    service_scale = service_sub.add_parser('scale', help='Scale a docker service')
    service_scale.add_argument('service', help='[namespace/]service name')
    service_scale.add_argument('--number', help='scale to `number` of containers')
    service_scale.set_defaults(func=api_service_scale)

    # container-list
    container_parser = subparsers.add_parser('containers', help='Containers')
    container_sub = container_parser.add_subparsers()

    # container-list
    container_ps = container_sub.add_parser('ps', help='List docker containers')
    container_ps.add_argument('-n', '--namespace', help='the namespace name')
    container_ps.set_defaults(func=api_container_ps)

    # container-inspect
    container_inspect = container_sub.add_parser('inspect', help='Inspect a docker container')
    container_inspect.add_argument('container', help='[namespace/]container name')
    container_inspect.set_defaults(func=api_container_inspect)

    # container-attach
    container_attach = container_sub.add_parser('attach', help='Attach to a container console')
    container_attach.add_argument('container', help='[namespace/]container name')
    container_attach.set_defaults(func=api_container_attach)

    # load conf: user
    argcomplete.autocomplete(parser)
    args = parser.parse_args()

    # compute configuration
    if not args.api_host:
        if 'SAIL_HOST' in os.environ:
            args.api_host = os.environ['SAIL_HOST']
        else:
            args.api_host = ENDPOINT

    # load conf: file
    dockercfg = docker_parse_config(args.api_host)

    if not args.api_user:
        if 'SAIL_USER' in os.environ:
            args.api_user = os.environ['SAIL_USER']
        else:
            args.api_user = dockercfg['USERNAME']

    if not args.api_password:
        if 'SAIL_PASSWORD' in os.environ:
            args.api_password = os.environ['SAIL_PASSWORD']
        else:
            args.api_password = dockercfg['PASSWORD']

    if not args.api_user or not args.api_password:
        print >> sys.stderr, "Missing --api-user or --api-password"
        sys.exit(1)

    # start real work
    try:
        args.func(args)
    except KeyboardInterrupt:
        print "Interrupted..."
    except requests.exceptions.HTTPError as e:

        status = e.response.status_code

        if status == 401:
            exit_exc("Authentication failed for user '%s'" % args.api_user, e, args)
        elif status == 403:
            exit_exc("Access denied for user '%s'" % args.api_user, e, args)
        elif status == 404:
            exit_exc("Object not found", e, args)
        elif status < 499:
            exit_exc(e.response.json(), e, args)
        elif status in [501, 502, 503, 504]:
            exit_exc("Service maintenance", e, args)
        else:
            exit_exc("Internal error", e, args)

    except requests.exceptions.ConnectionError as e:
        exit_exc("Error: connection failed.", e, args)
    except requests.exceptions.Timeout as e:
        exit_exc("Error: timeout while waiting for server's response", e, args)
    except requests.exceptions.RequestException as e:
        exit_exc("Error: unknown request error", e, args)
    except Exception as e:
        exit_exc("", e, args)
