#!/usr/bin/env python
# -*- coding: utf-8 -*-
# PYTHON_ARGCOMPLETE_OK
'''
sail service add [<namespace>/]<repository>[:tag] [namespace/]<service-name>
            --model         Container model
            --number        Number of container to run
            [--network {public|private|<namespace name>}]
            [--restart {no|always[:<max>]|on-failure[:<max>]}]
       override docker options:
            --user
            --entrypoint
            --command
            --workdir
            --environment KEY=val
        other options:
            --link name:alias

sail service ps
sail service inspect [namespace/]service-name
sail service rm [namespace/]service-name
sail service redeploy [namespace/]service-name
            --model         Container model
            [--network {public|private|<namespace name>}]
            [--restart {no|always[:<max>]|on-failure[:<max>]}]
       override docker options:
            --user
            --entrypoint
            --command
            --workdir
            --environment KEY=val
sail service scale --number <X> [namespace/]service-name
sail service start [namespace/]service-name
sail service stop [namespace/]service-name
sail containers ps
sail containers inspect [namespace/]container-name
sail containers attach [namespace/]container-name

configuration: (by priority)
    from command line
    from environment
    from .dockercfg

common options:
    -h --api-host           Docker index endpoint   [env: SAIL_HOST]
    -u --api-user           Docker index user       [env: SAIL_USER]
    -p --api-password       Docker index password   [env: SAIL_PASSWORD]
'''

import os
import sys
import json
import argparse, argcomplete
from base64 import b64decode
from datetime import datetime
import shlex

from tabulate import tabulate
import requests
import dateutil.parser
import requests.exceptions

ENDPOINT='sailabove.io'
DOCKERCFG='~/.dockercfg'

## Helpers

def ping(url):
    try:
        res = requests.get(url)
    except Exception:
        return False
    else:
        return res.status_code < 400

def expand_registry_url(hostname):
    if hostname.startswith('http:') or hostname.startswith('https:'):
        if '/' not in hostname[9:]:
            hostname = hostname + '/v1'
        return hostname
    if ping('https://' + hostname + '/v1/_ping'):
        return 'https://' + hostname + '/v1'
    return 'http://' + hostname + '/v1'

def parse_repository(repo, default_ns=None):
    column_index = repo.rfind(':')
    if column_index >= 0:
        tag = repo[column_index + 1:]
        repo = repo[:column_index]
    else:
        tag = None
    slash_index = repo.find('/')
    if slash_index >= 0:
        namespace = repo[:slash_index]
        repo = repo[slash_index + 1:]
    else:
        namespace = default_ns
    return namespace, repo, tag

def docker_parse_config(endpoint):
    '''
    Try hard to load user's credentials from dockerfile. Failing is an option
    '''
    path = os.path.expanduser(DOCKERCFG)
    conf = {
        'USERNAME': None,
        'PASSWORD': None,
    }

    try:
        with open(path) as f:
            parsed = json.load(f)
        if endpoint in parsed:
            auth = b64decode(parsed[endpoint]['auth']).split(':')
            conf['USERNAME'] = auth[0]
            conf['PASSWORD'] = auth[1]
    except IOError:
        print >> sys.stderr, "[WARNING] Failed to read %s" % DOCKERCFG
    except ValueError:
        print >> sys.stderr, "[WARNING] Failed to parse %s" % DOCKERCFG

    return conf

def _json_print(data):
    if isinstance(data, requests.Response):
        data = data.json()
    print json.dumps(data, indent=4, sort_keys=True)

def _tabulate(data, headers):
    print(tabulate(data, headers, stralign='left', tablefmt='plain'))

def exit_exc(message, e, args):
    resource_desc = args.func.func_name.split('_')[1:]
    action = resource_desc[1]
    resource = resource_desc[0]
    object_name = getattr(args, resource, '')

    print >> sys.stderr, "Failed to %s %s %s: %s" % (action, resource, object_name, message)

    if args.debug:
        raise e

    sys.exit(1)

## API methods

def api_request(args, method, path, data=None, headers={}, display=True, stream=False):
    url = expand_registry_url(args.api_host) + path
    auth = (args.api_user, args.api_password)

    if method in ['PUT', 'POST'] and data is not None:
        headers['Content-type'] = 'application/json'
        data = json.dumps(data)

    if args.debug:
        print 'Request: %s %s' % (method, url)
        print 'Body: %s' %data

    resp = requests.request(method, url, data=data, headers=headers, auth=auth, stream=stream)
    resp.raise_for_status()

    if stream:
        return resp
    if display or args.debug:
        _json_print(resp)
    return resp.json()

def api_app_list(argsu, display=True):
    return api_request(args, 'GET', '/applications', display=display)

def api_service_add(args):
    ns, repository, tag = parse_repository(args.repository, args.api_user)
    ns_service, service, _ = parse_repository(args.service, ns)

    if args.entrypoint is not None:
        args.entrypoint = shlex.split(args.entrypoint)
    if args.command is not None:
        args.command = shlex.split(args.command)

    links = {}
    for link in args.link:
        link = link.split(':', 1)
        if len(link) == 1:
            links[link[0]] = link[1]
        else:
            links[link[0]] = link[0]

    networks = {}
    if not args.network:
        args.network = ['public', 'private']
    for network in args.network:
        if network == 'private':
            network = ns
        networks[network] = {}

    params = {
        'namespace': ns,
        'repository': repository,
        'repository_tag': tag,
        'container_model': args.model,
        'container_number': int(args.number),
        'container_user': args.user,
        'container_entrypoint': args.entrypoint,
        'container_command': args.command,
        'container_workdir': args.workdir,
        'container_environment': args.env,
        'container_network': networks,
        'links': links,
        'restart_policy': args.restart,
    }

    path = '/applications/%s/services/%s/' % (ns_service, service)
    return api_request(args, 'POST', path, params)

def api_service_delete(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/' % (ns, service)
    return api_request(args, 'DELETE', path)

def api_service_redeploy(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/redeploy' % (ns, service)

    params = {}
    if args.model:
        params['container_model'] = args.model
    if args.user:
        params['container_user'] = args.user
    if args.entrypoint:
        params['container_entrypoint'] = args.entrypoint
    if args.command:
        params['container_command'] = args.command
    if args.workdir:
        params['container_workdir'] = args.workdir
    if args.env:
        params['container_environment'] = args.env

    if args.network:
        networks = {}
        for network in args.network:
            if network == 'private':
                network = ns
            networks[network] = {}
        params['container_network'] = networks

    return api_request(args, 'POST', path, params)

def api_service_start(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/start' % (ns, service)
    return api_request(args, 'POST', path, {})

def api_service_stop(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/stop' % (ns, service)
    return api_request(args, 'POST', path, {})

def api_service_scale(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/scale' % (ns, service)
    params = {
        'container_number': int(args.number)
    }
    return api_request(args, 'POST', path, params)

def api_service_ps(args):
    if args.namespace:
        applications = [args.namespace]
    else:
        applications = api_app_list(args, display=False)

    displayed = []
    for application in applications:
        path = '/applications/%s/services' % (application)
        services = api_request(args, 'GET', path, display=False)
        headers = ['NAME', 'REPOSITORY', 'IMAGE ID', 'STATE', 'CREATED', 'DEPLOYED']
        for service in services:
            path = '/applications/%s/services/%s' % (application, service)
            service = api_request(args, 'GET', path, display=False)
            displayed.append([
                '%s/%s' % (application, service['name']),
                '%s@%s' % (service['repository'], service['repository_tag']),
                service['image'][:12],
                service['state'].capitalize(),
                dateutil.parser.parse(service['creation_date']).replace(tzinfo=None),
                dateutil.parser.parse(service['deployment_date']).replace(tzinfo=None)
            ])

    if len(displayed) == 0:
        displayed.append(['', '', '', '', '', ''])
    _tabulate(displayed, headers)

def api_service_inspect(args):
    ns, service, _ = parse_repository(args.service, args.api_user)
    path = '/applications/%s/services/%s/' % (ns, service)
    return api_request(args, 'GET', path)

def api_container_ps(args):
    if args.namespace:
        applications = [args.namespace]
    else:
        applications = api_app_list(args, display=False)
    displayed = []
    for application in applications:
        path = '/applications/%s/containers' % (application)
        containers = api_request(args, 'GET', path, display=False)
        headers = ['NAME', 'REPOSITORY', 'IMAGE ID', 'STATE', 'DEPLOYED']
        for container in containers:
            path = '/applications/%s/containers/%s' % (application, container)
            container = api_request(args, 'GET', path, display=False)
            displayed.append([
                '%s/%s' % (application, container['name']),
                '%s@%s' % (container['repository'], container['repository_tag']),
                container['image'][:12],
                #' '.join(container['command'])[:20],
                container['state'].capitalize(),
                dateutil.parser.parse(container['deployment_date']).replace(tzinfo=None)
            ])

    if len(displayed) == 0:
        displayed.append(['', '', '', '', '', ''])
    _tabulate(displayed, headers)

def api_container_inspect(args):
    ns, container, _ = parse_repository(args.container, args.api_user)
    path = '/applications/%s/containers/%s/' % (ns, container)
    return api_request(args, 'GET', path)

def api_container_attach(args):
    ns, container, _ = parse_repository(args.container, args.api_user)
    path = '/applications/%s/containers/%s/attach' % (ns, container)
    r = api_request(args, 'GET', path, stream=True)
    try:
        for line in r.iter_lines():
            print line
    except KeyboardInterrupt:
        pass
    except IOError:
        pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='OVH Docker as a Service CLI')

    parser.add_argument('-H', '--api-host',
                        help='Docker index host [env: SAIL_HOST] or [%s]' % ENDPOINT,
                        default=None)
    parser.add_argument('-u', '--api-user',
                        help='Docker index user [env: SAIL_USER] or [file: .dockercfg]',
                        default=None)
    parser.add_argument('-p', '--api-password',
                        help='Docker index password [env: SAIL_PASSWORD] or [file: .dockercfg]',
                        default=None)
    parser.add_argument('--debug', help='Debug the API requests', action='store_true')

    subparsers = parser.add_subparsers()

    # app-list
    app_parser = subparsers.add_parser('apps', help='Applications')
    app_sub = app_parser.add_subparsers()

    app_list = app_sub.add_parser('list', help='List granted apps')
    app_list.set_defaults(func=api_app_list)

    # service-add
    service_parser = subparsers.add_parser('services', help='Services')
    service_sub = service_parser.add_subparsers()
    service_add = service_sub.add_parser('add',
                                         help='Add a new docker service')

    service_add.add_argument('repository', help='[namespace/]repository:tag')
    service_add.add_argument('service', help='the new service name')

    service_add.add_argument('--model', help='the containers model',
                             default='x1')
    service_add.add_argument('--number', help='number of containers to launch',
                             default=1)

    service_add.add_argument('--user', help='override docker user')
    service_add.add_argument('--entrypoint', help='override docker entrypoint')
    service_add.add_argument('--command', help='override docker run command')
    service_add.add_argument('--workdir', help='override docker workdir')
    service_add.add_argument('--restart', help='Docker like restart policy (no, always[:max], on-failure[:max])',
                             default='no')
    service_add.add_argument('--env', help='override docker environment',
                             action='append', default=[])
    service_add.add_argument('--link', help='link to another service',
                             action='append', default=[])
    service_add.add_argument('--network', help='Specify service network {public|private|<namespace name>}. "public" assigns a public IP, "private" selects this namespace\'s private network (default: [public, private])',
                             action='append', default=[])
    service_add.set_defaults(func=api_service_add)

    # service-delete
    service_delete = service_sub.add_parser('rm', help='Delete a docker service')
    service_delete.add_argument('service', help='[namespace/]service name')
    service_delete.set_defaults(func=api_service_delete)

    # service-list
    service_ps = service_sub.add_parser('ps', help='List docker services')
    service_ps.add_argument('-n', '--namespace', help='the namespace name')
    service_ps.set_defaults(func=api_service_ps)

    service_inspect = service_sub.add_parser('inspect', help='Inspect a docker service')
    service_inspect.add_argument('service', help='[namespace/]service name')
    service_inspect.set_defaults(func=api_service_inspect)

    # service-redeploy
    service_redeploy = service_sub.add_parser('redeploy', help='Redeploy a docker service')
    service_redeploy.add_argument('service', help='[namespace/]service name')
    service_redeploy.add_argument('--model', help='the containers model')
    service_redeploy.add_argument('--user', help='override docker user')
    service_redeploy.add_argument('--entrypoint', help='override docker entrypoint')
    service_redeploy.add_argument('--command', help='override docker run command')
    service_redeploy.add_argument('--workdir', help='override docker workdir')
    service_redeploy.add_argument('--restart', help='Docker like restart policy (no, always[:max], on-failure[:max])')
    service_redeploy.add_argument('--env', help='override docker environment',
                             action='append', default=[])
    service_redeploy.add_argument('--network', help='Specify service network {public|private|<namespace name>}. "public" assigns a public IP, "private" selects this namespace\'s private network (default: [public, private])',
                             action='append', default=[])
    service_redeploy.set_defaults(func=api_service_redeploy)

    # service-stop
    service_stop = service_sub.add_parser('stop', help='Stop a docker service')
    service_stop.add_argument('service', help='[namespace/]service name')
    service_stop.set_defaults(func=api_service_stop)

    # service-start
    service_start = service_sub.add_parser('start', help='Start a docker service')
    service_start.add_argument('service', help='[namespace/]service name')
    service_start.set_defaults(func=api_service_start)

    # service-scale
    service_scale = service_sub.add_parser('scale', help='Scale a docker service')
    service_scale.add_argument('service', help='[namespace/]service name')
    service_scale.add_argument('--number', help='scale to `number` of containers')
    service_scale.set_defaults(func=api_service_scale)

    # container-list
    container_parser = subparsers.add_parser('containers', help='Containers')
    container_sub = container_parser.add_subparsers()

    # container-list
    container_ps = container_sub.add_parser('ps', help='List docker containers')
    container_ps.add_argument('-n', '--namespace', help='the namespace name')
    container_ps.set_defaults(func=api_container_ps)

    # container-inspect
    container_inspect = container_sub.add_parser('inspect', help='Inspect a docker container')
    container_inspect.add_argument('container', help='[namespace/]container name')
    container_inspect.set_defaults(func=api_container_inspect)

    # container-attach
    container_attach = container_sub.add_parser('attach', help='Attach to a container console')
    container_attach.add_argument('container', help='[namespace/]container name')
    container_attach.set_defaults(func=api_container_attach)

    # load conf: user
    argcomplete.autocomplete(parser)
    args = parser.parse_args()

    # compute configuration
    if not args.api_host:
        if 'SAIL_HOST' in os.environ:
            args.api_host = os.environ['SAIL_HOST']
        else:
            args.api_host = ENDPOINT

    # load conf: file
    dockercfg = docker_parse_config(args.api_host)

    if not args.api_user:
        if 'SAIL_USER' in os.environ:
            args.api_user = os.environ['SAIL_USER']
        else:
            args.api_user = dockercfg['USERNAME']

    if not args.api_password:
        if 'SAIL_PASSWORD' in os.environ:
            args.api_password = os.environ['SAIL_PASSWORD']
        else:
            args.api_password = dockercfg['PASSWORD']

    if not args.api_user or not args.api_password:
        print >> sys.stderr, "Missing --api-user or --api-password"
        sys.exit(1)

    # start real work
    try:
        args.func(args)
    except KeyboardInterrupt:
        print "Interrupted..."
    except requests.exceptions.HTTPError as e:

        status = e.response.status_code

        if status == 401:
            exit_exc("Authentication failed for user '%s'" % args.api_user, e, args)
        elif status == 403:
            exit_exc("Access denied for user '%s'" % args.api_user, e, args)
        elif status == 404:
            exit_exc("Object not found", e, args)
        elif status < 499:
            exit_exc(e.response.json(), e, args)
        elif status in [501, 502, 503, 504]:
            exit_exc("Service maintenance", e, args)
        else:
            exit_exc("Internal error", e, args)

    except requests.exceptions.ConnectionError as e:
        exit_exc("Error: connection failed.", e, args)
    except requests.exceptions.Timeout as e:
        exit_exc("Error: timeout while waiting for server's response", e, args)
    except requests.exceptions.RequestException as e:
        exit_exc("Error: unknown request error", e, args)
    except Exception as e:
        exit_exc("", e, args)

