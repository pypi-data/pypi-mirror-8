

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Scenario definition &mdash; mosaik 2.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'./',
        VERSION:'2.0',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="mosaik 2.0 documentation" href="index.html"/>
        <link rel="next" title="The simulator manager" href="simmanager.html"/>
        <link rel="prev" title="The high-level API" href="mosaik-api/high-level.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="icon icon-home"> mosaik</a>
        <form class="wy-form" action="search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="installation.html#linux">Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#os-x">OS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#windows">Windows</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="overview.html#what-s-mosaik-supposed-to-do">What&#8217;s mosaik supposed to do?</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html#mosaik-s-main-components">Mosaik&#8217;s main components</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ecosystem.html">The mosaik ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/index.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/examplesim.html">Integrating a simulation model into the mosaik ecosystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/demo1.html">Creating and running simple simulation scenarios</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/examplectrl.html">Adding a control mechanism to a scenario</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/demo2.html">Integrating a control mechanism</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mosaik-api/index.html">The mosaik API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="mosaik-api/overview.html">How mosaik communicates with a simulator</a></li>
<li class="toctree-l2"><a class="reference internal" href="mosaik-api/low-level.html">The low-level API</a></li>
<li class="toctree-l2"><a class="reference internal" href="mosaik-api/high-level.html">The high-level API</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Scenario definition</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-setup">The setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#starting-simulators">Starting simulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instantiating-simulation-models">Instantiating simulation models</a></li>
<li class="toctree-l2"><a class="reference internal" href="#connecting-entities">Connecting entities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-the-simulation">Running the simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-achieve-bi-directional-data-flows">How to achieve bi-directional data-flows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-filter-entity-sets">How to filter entity sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-create-user-defined-connection-rules">How to create user-defined connection rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-retrieve-static-data-from-entities">How to retrieve static data from entities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-access-topology-and-data-flow-information">How to access topology and data-flow information</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-destroy-a-world">How to destroy a world</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-to-real-time-simulations">How to to real-time simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-call-extra-methods-of-a-simulator">How to call extra methods of a simulator</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="simmanager.html">The simulator manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="scheduler.html">Scheduling and simulation execution</a><ul>
<li class="toctree-l2"><a class="reference internal" href="scheduler.html#anatomy-of-a-step">Anatomy of a step</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheduler.html#synchronization-and-data-flows">Synchronization and data-flows</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheduler.html#cyclic-data-flows">Cyclic data-flows</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheduler.html#stepping-and-simulation-duration">Stepping and simulation duration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="faq.html#general-questions">General questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#coupling-models-with-mosaik">Coupling models with mosaik</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#the-mosaik-demo">The mosaik demo</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dev/index.html">Developer&#8217;s Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="dev/setup.html">Development setup and tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="dev/release_process.html">Release Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="dev/requirements.html">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="dev/design-decisions.html">Discussion of design decisions</a></li>
<li class="toctree-l2"><a class="reference internal" href="dev/logo-ci.html">Logo and corporate identity</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_reference/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.html"><tt class="docutils literal"><span class="pre">mosaik</span></tt> &#8212; The ende-user API</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.exceptions.html"><tt class="docutils literal"><span class="pre">mosaik.exceptions</span></tt> &#8212; mosaik specific error types</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.scenario.html"><tt class="docutils literal"><span class="pre">mosaik.scenario</span></tt> &#8212; Classes related to the scenario creation</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.scheduler.html"><tt class="docutils literal"><span class="pre">mosaik.scheduler</span></tt> &#8212; Coordinate and execute simulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.simmanager.html"><tt class="docutils literal"><span class="pre">mosaik.simmanager</span></tt> &#8212; Management of external processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.util.html"><tt class="docutils literal"><span class="pre">mosaik.util</span></tt> &#8212; Utility classes and functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="about/index.html">About mosaik</a><ul>
<li class="toctree-l2"><a class="reference internal" href="about/acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="about/history.html">The history of mosaik</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">mosaik</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="index.html">Docs</a> &raquo;</li>
  <li><a href="">Scenario definition</a></li>
  
</ul>
<hr/>

          
  <div class="section" id="scenario-definition">
<h1>Scenario definition<a class="headerlink" href="#scenario-definition" title="Permalink to this headline">¶</a></h1>
<p>Modeling or composing a scenario in mosaik comprises three steps:</p>
<ol class="arabic simple">
<li>Starting simulators,</li>
<li>Instantiating models within the simulators, and</li>
<li>Connecting the model instances of different simulators to establish data
flows between them.</li>
</ol>
<p>This page will show you how to create simple scenarios in these three steps.
It will also provide some recipes that allow you to create more complex
scenarios.</p>
<div class="section" id="the-setup">
<h2>The setup<a class="headerlink" href="#the-setup" title="Permalink to this headline">¶</a></h2>
<p>The central class for creating scenarios is <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World" title="mosaik.scenario.World"><tt class="xref py py-class docutils literal"><span class="pre">mosaik.scenario.World</span></tt></a> (for
your convenience, you can also import <tt class="docutils literal"><span class="pre">World</span></tt> directly from <tt class="docutils literal"><span class="pre">mosaik</span></tt>). This
class stores all data and state that belongs to your scenario and its
simulation. It also provides various methods that allow you to start simulators
and establish data-flows between them.</p>
<p>During this tutorial, we&#8217;ll create a very simple scenario using the examle
simulation that is provided with the <a class="reference external" href="https://bitbucket.org/mosaik/mosaik-api-python/src">Python implementation of the simulator
API</a>.</p>
<p>We start by importing the <a class="reference internal" href="api_reference/mosaik.html#module-mosaik" title="mosaik"><tt class="xref py py-mod docutils literal"><span class="pre">mosaik</span></tt></a> package and creating
a <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World" title="mosaik.scenario.World"><tt class="xref py py-class docutils literal"><span class="pre">World</span></tt></a> instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mosaik</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim_config</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s">&#39;ExampleSim&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;python&#39;</span><span class="p">:</span> <span class="s">&#39;example_sim.mosaik:ExampleSim&#39;</span><span class="p">},</span>
<span class="gp">... </span><span class="p">}</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">world</span> <span class="o">=</span> <span class="n">mosaik</span><span class="o">.</span><span class="n">World</span><span class="p">(</span><span class="n">sim_config</span><span class="p">)</span>
</pre></div>
</div>
<p>Because we start simulator instances via our <em>world</em>, it needs to know what
simulators are available and how to start them. This is called the <em>sim config</em>
and is a dict that contains every simulator we want to use together with some
information on how to start it.</p>
<p>In this case, we only have the <em>ExampleSim</em>. It will be started by importing
the module <tt class="docutils literal"><span class="pre">example_sim.mosaik</span></tt> and instantiating the class <tt class="docutils literal"><span class="pre">ExampleSim</span></tt>.
This is only possible with simulators written in Python 3. You can also let
mosaik start simulator as external processes or let it connect to already
running processes. The <a class="reference internal" href="simmanager.html"><em>simulator manager docs</em></a> explain how
this all works and give you some hints when to use which method of starting
a simulator.</p>
<p>In addition to the <em>sim config</em> you can optionally pass another dictionary to
<a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World" title="mosaik.scenario.World"><tt class="xref py py-class docutils literal"><span class="pre">World</span></tt></a> in order to overwrite some general parameters for mosaik (e.g.,
the host and port number for its network socket or timeouts).  Usually, the
defaults work just well.</p>
</div>
<div class="section" id="starting-simulators">
<h2>Starting simulators<a class="headerlink" href="#starting-simulators" title="Permalink to this headline">¶</a></h2>
<p>Now that the basic set-up is done, we can start our simulators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">exsim_0</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;ExampleSim&#39;</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Starting &quot;ExampleSim&quot; as &quot;ExampleSim-0&quot; ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exsim_1</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;ExampleSim&#39;</span><span class="p">)</span>
<span class="go">Starting &quot;ExampleSim&quot; as &quot;ExampleSim-1&quot; ...</span>
</pre></div>
</div>
<p>To start a simulator, we call <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.start" title="mosaik.scenario.World.start"><tt class="xref py py-meth docutils literal"><span class="pre">World.start()</span></tt></a> and pass the name of the
simulator. Mosaik looks up that name in its <em>sim config</em>, starts the simulator
for us and returns a <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.ModelFactory" title="mosaik.scenario.ModelFactory"><tt class="xref py py-class docutils literal"><span class="pre">ModelFactory</span></tt></a>. This factory allows us to
instantiate simulation models within that simulator.</p>
<p>In addition to the simulator name, you can pass further parameters for the
simulators. These parameters are passed to the simulator via the <a class="reference internal" href="mosaik-api/low-level.html#api-init"><em>init()
API call</em></a>.</p>
</div>
<div class="section" id="instantiating-simulation-models">
<h2>Instantiating simulation models<a class="headerlink" href="#instantiating-simulation-models" title="Permalink to this headline">¶</a></h2>
<p>Simulators specify a set of public models in their meta data (see <a class="reference internal" href="mosaik-api/low-level.html#api-init"><em>init()
API call</em></a>). These models can be accessed via the
<a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.ModelFactory" title="mosaik.scenario.ModelFactory"><tt class="xref py py-class docutils literal"><span class="pre">ModelFactory</span></tt></a> that <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.start" title="mosaik.scenario.World.start"><tt class="xref py py-meth docutils literal"><span class="pre">World.start()</span></tt></a> returns as if they were normal
Python classes. So to create one instance of <em>ExampleSim&#8217;s</em> model <em>A</em> we just
write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">exsim_0</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">init_val</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This will create one instance of the <em>A</em> simulation model and pass the model
parameter <tt class="docutils literal"><span class="pre">init_val=0</span></tt> to it (see <a class="reference internal" href="mosaik-api/low-level.html#api-create"><em>create() API call</em></a>).
Lets see what it is that gets returned to us:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Entity(&#39;ExampleSim-0&#39;, &#39;0.0&#39;, &#39;ExampleSim&#39;, A)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sid</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">eid</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">full_id</span>
<span class="go">(&#39;ExampleSim-0&#39;, &#39;0.0&#39;, &#39;ExampleSim-0.0.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sim_name</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span>
<span class="go">(&#39;ExampleSim&#39;, &#39;A&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">children</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>A model instances is represented in your scenario as an <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.Entity" title="mosaik.scenario.Entity"><tt class="xref py py-class docutils literal"><span class="pre">Entity</span></tt></a>. The
entity belongs to the simulator <em>ExampleSim-0</em>, has the ID <em>0.0</em> and its type
is <em>A</em>. The entity ID is unique within a simulator. To make it globally unique,
we prepend it with the simulator ID. This is called the entity&#8217;s <em>full ID</em> (see
<a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.Entity.full_id" title="mosaik.scenario.Entity.full_id"><tt class="xref py py-attr docutils literal"><span class="pre">Entity.full_id</span></tt></a>). You can also get a list of its child entities (which
is empty in this case).</p>
<p>In order to instantiate multiple instances of a model, you can either use
a simple list comprehension (or <tt class="docutils literal"><span class="pre">for</span></tt> loop) or call the static method
<cite>create()</cite> of the model:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">exsim_0</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">init_val</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b_set</span> <span class="o">=</span> <span class="n">exsim_1</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">init_val</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The list comprehension is more verbose but allows you to pass individual
parameter values to each instance. Using <tt class="docutils literal"><span class="pre">create()</span></tt> is more concise but all
three instance will have the same value for <em>init_val</em>. In both cases you&#8217;ll
get a list of entities (aka <a class="reference internal" href="glossary.html#term-entity-set"><em class="xref std std-term">entity sets</em></a>).</p>
</div>
<div class="section" id="connecting-entities">
<h2>Connecting entities<a class="headerlink" href="#connecting-entities" title="Permalink to this headline">¶</a></h2>
<p>If we would now run our simulation, both, <em>exsim_0</em> and <em>exsim_1</em> would run
in parallel and never exchange any data. To change that, we need to connect
the models providing input data to entities requiring this data. In our case,
we will connect the <em>val_out</em> attribute of the <em>A</em> instances with the <em>val_in</em>
attribute of the <em>B</em> instances:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a_set</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  <span class="c"># Put our first A instance to the others</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a_set</span><span class="p">,</span> <span class="n">b_set</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;val_out&#39;</span><span class="p">,</span> <span class="s">&#39;val_in&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The method <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.connect" title="mosaik.scenario.World.connect"><tt class="xref py py-meth docutils literal"><span class="pre">World.connect()</span></tt></a> takes the source entity, the destination
entity and an arbitrary amount of <em>(source attribute, dest. attribute)</em> tuples.
If the name of the source attributes equals that of the destination attribute,
you can alternatively just pass a single string (e.g., <tt class="docutils literal"><span class="pre">connect(a,</span> <span class="pre">b,</span>
<span class="pre">'attr')</span></tt>).</p>
<p>You can only connect entities that belong to different simulators with each
other (that&#8217;s why we created two instances of the <em>ExampleSim</em>).</p>
<p>You are also not allowed to created circular dependencies (e.g., connect <em>a</em> to
<em>b</em> and then connect <em>b</em> to <em>a</em>). To allow a bidirectional exchange of data,
which is required for things like control strategies, there is another
mechanism that is explained in one of the next sections
(<a class="reference internal" href="#integrate-control-strategies"><em>How to achieve bi-directional data-flows</em></a>).</p>
</div>
<div class="section" id="running-the-simulation">
<span id="id2"></span><h2>Running the simulation<a class="headerlink" href="#running-the-simulation" title="Permalink to this headline">¶</a></h2>
<p>When all simulators are started, models are instantiated and connected, we can
finally run our simulation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">Starting simulation.</span>
<span class="go">Simulation finished successfully.</span>
</pre></div>
</div>
<p>This will execute the simulation from time 0 until we reach the time <em>until</em>
(in simulated seconds). The <a class="reference internal" href="scheduler.html"><em>scheduler section</em></a> explains in
detail what happens when you call <tt class="docutils literal"><span class="pre">run()</span></tt>.</p>
<p>To wrap it all up, this is how our small example scenario finally looks like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Setup</span>
<span class="kn">import</span> <span class="nn">mosaik</span>

<span class="n">sim_config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;ExampleSim&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;python&#39;</span><span class="p">:</span> <span class="s">&#39;example_sim.mosaik:ExampleSim&#39;</span><span class="p">},</span>
<span class="p">}</span>

<span class="n">world</span> <span class="o">=</span> <span class="n">mosaik</span><span class="o">.</span><span class="n">World</span><span class="p">(</span><span class="n">sim_config</span><span class="p">)</span>

<span class="c"># Start simulators</span>
<span class="n">exsim_0</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;ExampleSim&#39;</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">exsim_1</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;ExampleSim&#39;</span><span class="p">)</span>

<span class="c"># Instantiate models</span>
<span class="n">a_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">exsim_0</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">init_val</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">b_set</span> <span class="o">=</span> <span class="n">exsim_1</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">init_val</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Connect entities</span>
<span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a_set</span><span class="p">,</span> <span class="n">b_set</span><span class="p">):</span>
    <span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;val_out&#39;</span><span class="p">,</span> <span class="s">&#39;val_in&#39;</span><span class="p">))</span>

<span class="c"># Run simulation</span>
<span class="n">world</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="how-to-achieve-bi-directional-data-flows">
<span id="integrate-control-strategies"></span><h2>How to achieve bi-directional data-flows<a class="headerlink" href="#how-to-achieve-bi-directional-data-flows" title="Permalink to this headline">¶</a></h2>
<p>Bi-directional data-flows are important when you want to integrate, for
example, control strategies. However, this trivial approach is not allowed
in mosaik:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Send battery&#39;s active power value to the controller</span>
<span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">battery</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">)</span>
<span class="c"># Controller sends back a schedule to the battery</span>
<span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">battery</span><span class="p">,</span> <span class="s">&#39;schedule&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The problem with this is that mosaik cannot know whether to compute <em>battery.P</em>
or <em>controller.schedule</em> first.</p>
<p>To solve this problem, you only connect the battery&#8217;s <em>P</em> to the controller and
let the control strategy set the new schedule via the asynchronous request
<a class="reference internal" href="mosaik-api/low-level.html#rpc-set-data"><em>set_data</em></a>. To indicate this in your scenario, you set the
<em>async_request</em> flag of <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.connect" title="mosaik.scenario.World.connect"><tt class="xref py py-meth docutils literal"><span class="pre">World.connect()</span></tt></a> to <tt class="docutils literal"><span class="pre">True</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">battery</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="n">async_requests</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>This way, mosaik will push the value for <em>P</em> from the battery to the
controller. It will then wait until the controller&#8217;s <a class="reference internal" href="mosaik-api/low-level.html#api-step"><em>step</em></a> is
done before the next step for the battery will be computed.</p>
<p>The <em>step</em> implementation of the controller could roughly look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Conroller</span><span class="p">(</span><span class="n">Simulator</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
       <span class="n">schedule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_schedule</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
       <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">mosaik</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">schedule</span><span class="p">)</span>
       <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span>
</pre></div>
</div>
</div>
<div class="section" id="how-to-filter-entity-sets">
<h2>How to filter entity sets<a class="headerlink" href="#how-to-filter-entity-sets" title="Permalink to this headline">¶</a></h2>
<p>When you create large-scale scenarios, you often work with large sets of
entities rather then single ones. This section provides some examples how you
can extract a sub-set of entities from a larger entity set based on arbitrary
criteria.</p>
<p>Lets assume that we have created a power grid with <a class="reference external" href="https://pypi.python.org/pypi/mosaik-pypower">mosaik-pypower</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grid</span> <span class="o">=</span> <span class="n">pypower</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">gridfile</span><span class="o">=</span><span class="s">&#39;data/grid.json&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">children</span>
</pre></div>
</div>
<p>Since mosaik-pypower&#8217;s <em>Grid</em> entity only serves as a container for the buses
and branches of our power grid, we directly bound its <em>children</em> to the name
<tt class="docutils literal"><span class="pre">grid</span></tt>. So <em>grid</em> is now a list containing a <em>RefBus</em> entity and multiple
<em>Transformer</em>, <em>PQBus</em> and <em>Branch</em> entities.</p>
<p>So how do we get a list of all transformers? This way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">transformers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&#39;Transformer&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>How do we get the single <em>RefBus</em>? This way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">refbus</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&#39;RefBus&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Our <em>PQBus</em> entities are named like <em>Busbar_&lt;i&gt;</em> and <em>ConnectionPoint_&lt;i&gt;</em> to
indicate to which buses we can connect consumers and producers and to which we
shouldn&#8217;t connect anything. How do we get a list of all <em>ConnectionPoint</em>
buses? We might be tempted to do it this way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">conpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">eid</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;ConnectionPoint_&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>The problem in this particular case is, that <em>mosaik-pypower</em> prepends a &#8220;grid
ID&#8221; to each entity ID, because it can handle multiple grid instances at once.
So our entity IDs are actually looking like this:
<em>&lt;grid_idx&gt;-ConnectionPoint_&lt;i&gt;</em>.  Using regular expressions, we can get our
list:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">re</span>

<span class="n">regex_conpoint</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\d+-ConnectionPoint_\d+&#39;</span><span class="p">)</span>

<span class="n">conpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">regex_conpoint</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">eid</span><span class="p">)]</span>
</pre></div>
</div>
<p>If we want to connect certain consumers or producers to defined nodes in our
grid (e.g., your boss says: &#8220;This PV module needs to be connected to
<em>ConnectionPoint_23</em>!&#8221;), creating a dict instead of a list is a good idea:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">remove_grididx</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">eid</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># Little helper function</span>
<span class="n">cps_by_name</span> <span class="o">=</span> <span class="p">{</span><span class="n">remove_grididx</span><span class="p">(</span><span class="n">e</span><span class="p">):</span> <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">regex_conpoint</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e</span><span class="p">)}</span>
</pre></div>
</div>
<p>This will create a mapping where the string <tt class="docutils literal"><span class="pre">'ConnectionPoint_23'</span></tt> maps to
the corresponding <tt class="docutils literal"><span class="pre">Entity</span></tt> instance.</p>
<p>This was just a small selection of how you can filter entity sets using
list/dict comprehensions. Alternatively, you can also use the <a class="reference external" href="http://docs.python.org/3/library/functions.html#filter" title="(in Python v3.4)"><tt class="xref py py-func docutils literal"><span class="pre">filter()</span></tt></a>
function or a normal <tt class="docutils literal"><span class="pre">for</span></tt> loop. You should also take at look at the
<a class="reference external" href="http://docs.python.org/3/library/itertools.html#module-itertools" title="(in Python v3.4)"><tt class="xref py py-mod docutils literal"><span class="pre">itertools</span></tt></a> and <a class="reference external" href="http://docs.python.org/3/library/functools.html#module-functools" title="(in Python v3.4)"><tt class="xref py py-mod docutils literal"><span class="pre">functools</span></tt></a> modules. You&#8217;ll find even more
functionality in specialized packages like <a class="reference external" href="http://toolz.readthedocs.org/en/latest/index.html">PyToolz</a>.</p>
</div>
<div class="section" id="how-to-create-user-defined-connection-rules">
<h2>How to create user-defined connection rules<a class="headerlink" href="#how-to-create-user-defined-connection-rules" title="Permalink to this headline">¶</a></h2>
<p>The method <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.connect" title="mosaik.scenario.World.connect"><tt class="xref py py-meth docutils literal"><span class="pre">World.connect()</span></tt></a> allows you to only connect one pair of
entities with each other. When you work with larger entity sets, you might not
want to connect every entity manually, but use functions that take to sets of
entities and connect them with each other based on some criteria.</p>
<p>The most common case is that you want to randomly connect the entities of one
set to another, for example, when you distribute a number of PV modules over a
power grid.</p>
<p>For this use case, mosaik provides <a class="reference internal" href="api_reference/mosaik.util.html#mosaik.util.connect_randomly" title="mosaik.util.connect_randomly"><tt class="xref py py-func docutils literal"><span class="pre">mosaik.util.connect_randomly()</span></tt></a>. It
takes two sets and connects them either evenly or purely randomly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">world</span> <span class="o">=</span> <span class="n">mosaik</span><span class="o">.</span><span class="n">World</span><span class="p">(</span><span class="n">sim_config</span><span class="p">)</span>

<span class="n">grid</span> <span class="o">=</span> <span class="n">pypower</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">gridfile</span><span class="o">=</span><span class="n">GRID_FILE</span><span class="p">)</span><span class="o">.</span><span class="n">children</span>
<span class="n">pq_buses</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&#39;PQBus&#39;</span><span class="p">]</span>
<span class="n">pvs</span> <span class="o">=</span> <span class="n">pvsim</span><span class="o">.</span><span class="n">PV</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>

<span class="c"># Assuming that len(pvs) &lt; len(pq_buses), this will</span>
<span class="c"># connect 0 or 1 PV module to each bus:</span>
<span class="n">mosaik</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">connect_randomly</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">pvs</span><span class="p">,</span> <span class="n">pq_buses</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">)</span>

<span class="c"># This will distribute the PV modules purely randomly, but every</span>
<span class="c"># bus will have at most 3 modules connected to it.</span>
<span class="n">mosaik</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">connect_randomly</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">pvs</span><span class="p">,</span> <span class="n">pq_buses</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span>
                              <span class="n">evenly</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">max_connects</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Another relatively common use case is connecting a set of entities to one other
entities, e.g., when you want to connect a number of controllable energy
producers to a central scheduler:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="k">def</span> <span class="nf">connect_many_to_one</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">src_set</span><span class="p">,</span> <span class="n">dest_entity</span><span class="p">,</span> <span class="o">*</span><span class="n">attrs</span><span class="p">,</span>
                        <span class="n">async_requests</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">src_entity</span> <span class="ow">in</span> <span class="n">src_set</span><span class="p">:</span>
        <span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">src_entity</span><span class="p">,</span> <span class="n">dest_entity</span><span class="p">,</span> <span class="o">*</span><span class="n">attrs</span><span class="p">,</span>
                      <span class="n">async_requests</span><span class="o">=</span><span class="n">async_requests</span><span class="p">)</span>


<span class="n">pvs</span> <span class="o">=</span> <span class="n">pvsim</span><span class="o">.</span><span class="n">PV</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="n">chps</span> <span class="o">=</span> <span class="n">chpsim</span><span class="o">.</span><span class="n">CHP</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">controller</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">Scheduler</span><span class="p">()</span>

<span class="c"># Connect all producers to the controller, remember to set the</span>
<span class="c"># &quot;async_requests&quot; flag.</span>
<span class="n">connect_many_to_one</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">chain</span><span class="p">(</span><span class="n">pvs</span><span class="p">,</span> <span class="n">chps</span><span class="p">),</span> <span class="n">controller</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span>
                    <span class="n">async_requests</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Connection rules are oftentimes highly specific for a project.
<a class="reference internal" href="api_reference/mosaik.util.html#mosaik.util.connect_randomly" title="mosaik.util.connect_randomly"><tt class="xref py py-func docutils literal"><span class="pre">connect_randomly()</span></tt></a> is currently the only function that is
useful and complicated enough to ship it with mosaik. But as you can see in the
<tt class="docutils literal"><span class="pre">connect_many_to_one</span></tt> example, writing your own connection method is not that
hard.</p>
</div>
<div class="section" id="how-to-retrieve-static-data-from-entities">
<h2>How to retrieve static data from entities<a class="headerlink" href="#how-to-retrieve-static-data-from-entities" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, the entities don&#8217;t contain all the information that you need in
order to decide which entity connect to which, but your simulation model could
provide that data. An example for this might be the maximum amount of active
power that a producer is able to produce.</p>
<p>Mosaik allows you to query a simulator for that data during composition time
via <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.get_data" title="mosaik.scenario.World.get_data"><tt class="xref py py-meth docutils literal"><span class="pre">World.get_data()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">exsim</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;ExampleSim&#39;</span><span class="p">)</span>
<span class="go">Starting &quot;ExampleSim&quot; as &quot;ExampleSim-2&quot; ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entities</span> <span class="o">=</span> <span class="n">exsim</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">init_val</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">entities</span><span class="p">,</span> <span class="s">&#39;val_out&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="n">entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="go">{&#39;val_out&#39;: 42}</span>
</pre></div>
</div>
<p>The entities that you pass to this function don&#8217;t need to belong to the same
simulator (instance) as long as they all can provide the required attributes.</p>
</div>
<div class="section" id="how-to-access-topology-and-data-flow-information">
<h2>How to access topology and data-flow information<a class="headerlink" href="#how-to-access-topology-and-data-flow-information" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World" title="mosaik.scenario.World"><tt class="xref py py-class docutils literal"><span class="pre">World</span></tt></a> contains to <a class="reference external" href="http://networkx.github.io/documentation/latest/overview.html">networkx Graphs</a> which hold
information about the data-flows between simulators and the simulation topology
that you created in your scenario. You can use these graphs, for example, to
export the simulation topology that mosaik created into a custom data or file
format.</p>
<p><a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.df_graph" title="mosaik.scenario.World.df_graph"><tt class="xref py py-attr docutils literal"><span class="pre">World.df_graph</span></tt></a> is the directed <em>dataflow graph</em> for your scenarios. It
contains a note for every simulator that you started. The simulator ID is used
to label the nodes. If you established a data-flow between two simulators (by
connecting at least two of their entities), a directed edge between two nodes
is inserted.  The edges contain the <em>async_requests</em> flag (see
<a class="reference internal" href="#integrate-control-strategies"><em>How to achieve bi-directional data-flows</em></a>) and a list of the data-flows.</p>
<p>The data-flow graph may, for example, look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">world</span><span class="o">.</span><span class="n">df_graph</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s">&#39;PvSim-0&#39;</span><span class="p">:</span> <span class="p">{},</span>
    <span class="s">&#39;PyPower-0&#39;</span><span class="p">:</span> <span class="p">{},</span>
<span class="p">}</span>
<span class="n">world</span><span class="o">.</span><span class="n">df_graph</span><span class="o">.</span><span class="n">edge</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s">&#39;PvSim-0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;PypPower-0&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;async_requests&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="s">&#39;dataflows&#39;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">(</span><span class="s">&#39;PV_0&#39;</span><span class="p">,</span> <span class="s">&#39;bus_0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;P_out&#39;</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;Q_out&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s">&#39;PV_1&#39;</span><span class="p">,</span> <span class="s">&#39;bus_1&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;P_out&#39;</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;Q_out&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">)),</span>
         <span class="p">],</span>
    <span class="p">}},</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.entity_graph" title="mosaik.scenario.World.entity_graph"><tt class="xref py py-attr docutils literal"><span class="pre">World.entity_graph</span></tt></a> is the undirected <em>entity graph</em>. It contains a node
for every entity. The full entity ID (<tt class="docutils literal"><span class="pre">'sim_id.entity_id'</span></tt>) is used as node
label.  Every node also stores the simulator name and entity type. An edge
between two entities is inserted</p>
<ul class="simple">
<li>if they are somehow related within a simulator (e.g., a PyPower branch is
related to the two PyPower buses to which it is adjacent) (see
<a class="reference internal" href="mosaik-api/low-level.html#api-create"><em>create</em></a>); or</li>
<li>if they are connected via <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.connect" title="mosaik.scenario.World.connect"><tt class="xref py py-meth docutils literal"><span class="pre">World.connect()</span></tt></a>.</li>
</ul>
<p>The entity graph may, for example, look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">world</span><span class="o">.</span><span class="n">entity_graph</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s">&#39;PvSim_0.PV_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;sim&#39;</span><span class="p">:</span> <span class="s">&#39;PvSim&#39;</span><span class="p">,</span> <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;PV&#39;</span><span class="p">},</span>
    <span class="s">&#39;PvSim_0.PV_1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;sim&#39;</span><span class="p">:</span> <span class="s">&#39;PvSim&#39;</span><span class="p">,</span> <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;PV&#39;</span><span class="p">},</span>
    <span class="s">&#39;PyPower_0.branch_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;sim&#39;</span><span class="p">:</span> <span class="s">&#39;PyPower&#39;</span><span class="p">,</span> <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;Branch&#39;</span><span class="p">},</span>
    <span class="s">&#39;PyPower_0.bus_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;sim&#39;</span><span class="p">:</span> <span class="s">&#39;PyPower&#39;</span><span class="p">,</span> <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;PQBus&#39;</span><span class="p">},</span>
    <span class="s">&#39;PyPower_0.bus_1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;sim&#39;</span><span class="p">:</span> <span class="s">&#39;PyPower&#39;</span><span class="p">,</span> <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;PQBus&#39;</span><span class="p">},</span>
<span class="p">}</span>
<span class="n">world</span><span class="o">.</span><span class="n">entity_graph</span><span class="o">.</span><span class="n">edge</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s">&#39;PvSim_0.PV_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;PyPower_0.bus_0&#39;</span><span class="p">:</span> <span class="p">{}},</span>
    <span class="s">&#39;PvSim_0.PV_1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;PyPower_0.bus_1&#39;</span><span class="p">:</span> <span class="p">{}},</span>
    <span class="s">&#39;PyPower_0.branch_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;PyPower_0.bus_0&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s">&#39;PyPower_0.bus_1&#39;</span><span class="p">:</span> <span class="p">{}},</span>
    <span class="s">&#39;PyPower_0.bus_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;PvSim_0.PV_0&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s">&#39;PyPower_0.branch_0&#39;</span><span class="p">:</span> <span class="p">{}},</span>
    <span class="s">&#39;PyPower_0.bus_1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;PvSim_0.PV_1&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s">&#39;PyPower_0.branch_0&#39;</span><span class="p">:</span> <span class="p">{}},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="mosaik-api/low-level.html#rpc-get-related-entities"><em>get_related_entities</em></a> API call also uses and returns (parts of)
the entity graph. So you can access it in your scenario definition as well as
from with a simulator, control strategy or monitoring tool.</p>
<p>Please consult the <a class="reference external" href="http://networkx.github.io/documentation/latest/">networkx documentation</a> for more details about
working with graphs and directed graphs.</p>
</div>
<div class="section" id="how-to-destroy-a-world">
<h2>How to destroy a world<a class="headerlink" href="#how-to-destroy-a-world" title="Permalink to this headline">¶</a></h2>
<p>When you are done working with a world, you should shut it down properly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
</pre></div>
</div>
<p>This will, for instance, close mosaik&#8217;s socket and allows new <tt class="docutils literal"><span class="pre">World</span></tt>
instances to reuse the same port again.</p>
<p><a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.run" title="mosaik.scenario.World.run"><tt class="xref py py-meth docutils literal"><span class="pre">World.run()</span></tt></a> automatically calls <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.shutdown" title="mosaik.scenario.World.shutdown"><tt class="xref py py-meth docutils literal"><span class="pre">World.shutdown()</span></tt></a> for you.</p>
</div>
<div class="section" id="how-to-to-real-time-simulations">
<h2>How to to real-time simulations<a class="headerlink" href="#how-to-to-real-time-simulations" title="Permalink to this headline">¶</a></h2>
<p>It is very easy to do real-time (or &#8220;wall-clock time&#8221;) simulations in mosaik.
You just pass an <em>rt_factor</em> to <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.run" title="mosaik.scenario.World.run"><tt class="xref py py-meth docutils literal"><span class="pre">World.run()</span></tt></a> to enable it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">world</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">rt_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>A real-time factor of 1 means, that 1 simulation time unit (usually
a simulation second) takes 1 second of real time. Thus, if you set the
real-time factor to 0.5, the simulation will run twice as fast as the real
time. If you set it to 1/60, one simulated minute will take one real-time
second.</p>
<p>It may happen that the simulators are too slow for the real-time factor chosen.
That means, they take longer than, e.g., one second to compute a step when
a real-time factor of one second is set. If this happens, mosaik will by
default just print a warning message to stdout. However, you can also let your
simulation crash in this case by setting the parameter <em>rt_strict</em> to <tt class="docutils literal"><span class="pre">True</span></tt>.
Mosaik will then raise a <a class="reference external" href="http://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.4)"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> if your simulation is too slow:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">world</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">rt_factor</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">60</span><span class="p">,</span> <span class="n">rt_strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="how-to-call-extra-methods-of-a-simulator">
<h2>How to call extra methods of a simulator<a class="headerlink" href="#how-to-call-extra-methods-of-a-simulator" title="Permalink to this headline">¶</a></h2>
<p>A simulator may optionally define additional API methods (see <a class="reference internal" href="mosaik-api/low-level.html#api-init"><em>init</em></a>)
that you can call from your scenario. These methods can implement operations,
like setting some static data to a simulator, which don&#8217;t really fit into
<tt class="docutils literal"><span class="pre">init()</span></tt> or <tt class="docutils literal"><span class="pre">create()</span></tt>.</p>
<p>These methods are exposed via the model factory that you get when you start
a simulator. In the following example, we&#8217;ll call the <tt class="docutils literal"><span class="pre">example_method()</span></tt>
that the example simulator shipped with the mosaik Python API:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span> <span class="o">=</span> <span class="n">mosaik</span><span class="o">.</span><span class="n">World</span><span class="p">({</span><span class="s">&#39;ExampleSim&#39;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s">&#39;python&#39;</span><span class="p">:</span> <span class="s">&#39;example_sim.mosaik:ExampleSim&#39;</span><span class="p">}})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">es</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;ExampleSim&#39;</span><span class="p">)</span>
<span class="go">Starting &quot;ExampleSim&quot; as &quot;ExampleSim-0&quot; ...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Now brace yourself ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">es</span><span class="o">.</span><span class="n">example_method</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>
<span class="go">23</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">world</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


          <footer>
  
    <div class="rst-footer-buttons">
      
        <a href="simmanager.html" class="btn btn-neutral float-right" title="The simulator manager"/>Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="mosaik-api/high-level.html" class="btn btn-neutral" title="The high-level API"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <p>
      &copy; Copyright 2013, Stefan Scherfke.
  </p>

  <a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>