

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Scheduling and simulation execution &mdash; mosaik 2.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'./',
        VERSION:'2.0',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="mosaik 2.0 documentation" href="index.html"/>
        <link rel="next" title="FAQ" href="faq.html"/>
        <link rel="prev" title="The simulator manager" href="simmanager.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="icon icon-home"> mosaik</a>
        <form class="wy-form" action="search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="installation.html#linux">Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#os-x">OS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#windows">Windows</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="overview.html#what-s-mosaik-supposed-to-do">What&#8217;s mosaik supposed to do?</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html#mosaik-s-main-components">Mosaik&#8217;s main components</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ecosystem.html">The mosaik ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/index.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/examplesim.html">Integrating a simulation model into the mosaik ecosystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/demo1.html">Creating and running simple simulation scenarios</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/examplectrl.html">Adding a control mechanism to a scenario</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/demo2.html">Integrating a control mechanism</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mosaik-api/index.html">The mosaik API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="mosaik-api/overview.html">How mosaik communicates with a simulator</a></li>
<li class="toctree-l2"><a class="reference internal" href="mosaik-api/low-level.html">The low-level API</a></li>
<li class="toctree-l2"><a class="reference internal" href="mosaik-api/high-level.html">The high-level API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="scenario-definition.html">Scenario definition</a><ul>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#the-setup">The setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#starting-simulators">Starting simulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#instantiating-simulation-models">Instantiating simulation models</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#connecting-entities">Connecting entities</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#running-the-simulation">Running the simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#how-to-achieve-bi-directional-data-flows">How to achieve bi-directional data-flows</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#how-to-filter-entity-sets">How to filter entity sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#how-to-create-user-defined-connection-rules">How to create user-defined connection rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#how-to-retrieve-static-data-from-entities">How to retrieve static data from entities</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#how-to-access-topology-and-data-flow-information">How to access topology and data-flow information</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#how-to-destroy-a-world">How to destroy a world</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#how-to-to-real-time-simulations">How to to real-time simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="scenario-definition.html#how-to-call-extra-methods-of-a-simulator">How to call extra methods of a simulator</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="simmanager.html">The simulator manager</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Scheduling and simulation execution</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#anatomy-of-a-step">Anatomy of a step</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronization-and-data-flows">Synchronization and data-flows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cyclic-data-flows">Cyclic data-flows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stepping-and-simulation-duration">Stepping and simulation duration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="faq.html#general-questions">General questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#coupling-models-with-mosaik">Coupling models with mosaik</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#the-mosaik-demo">The mosaik demo</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dev/index.html">Developer&#8217;s Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="dev/setup.html">Development setup and tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="dev/release_process.html">Release Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="dev/requirements.html">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="dev/design-decisions.html">Discussion of design decisions</a></li>
<li class="toctree-l2"><a class="reference internal" href="dev/logo-ci.html">Logo and corporate identity</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api_reference/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.html"><tt class="docutils literal"><span class="pre">mosaik</span></tt> &#8212; The ende-user API</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.exceptions.html"><tt class="docutils literal"><span class="pre">mosaik.exceptions</span></tt> &#8212; mosaik specific error types</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.scenario.html"><tt class="docutils literal"><span class="pre">mosaik.scenario</span></tt> &#8212; Classes related to the scenario creation</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.scheduler.html"><tt class="docutils literal"><span class="pre">mosaik.scheduler</span></tt> &#8212; Coordinate and execute simulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.simmanager.html"><tt class="docutils literal"><span class="pre">mosaik.simmanager</span></tt> &#8212; Management of external processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="api_reference/mosaik.util.html"><tt class="docutils literal"><span class="pre">mosaik.util</span></tt> &#8212; Utility classes and functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="about/index.html">About mosaik</a><ul>
<li class="toctree-l2"><a class="reference internal" href="about/acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="about/history.html">The history of mosaik</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">mosaik</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="index.html">Docs</a> &raquo;</li>
  <li><a href="">Scheduling and simulation execution</a></li>
  
</ul>
<hr/>

          
  <div class="section" id="scheduling-and-simulation-execution">
<h1>Scheduling and simulation execution<a class="headerlink" href="#scheduling-and-simulation-execution" title="Permalink to this headline">¶</a></h1>
<p>When you <a class="reference internal" href="scenario-definition.html"><em>defined your scenario</em></a> and <a class="reference internal" href="scenario-definition.html#running-the-simulation"><em>start the
simulation</em></a>, mosaik&#8217;s scheduler becomes active. It
manages the execution of all involved simulators, keeps them in sync and
handles the <a class="reference internal" href="glossary.html#term-data-flow"><em class="xref std std-term">data-flows</em></a> between them.</p>
<p>Mosaik runs the simulation by <a class="reference internal" href="glossary.html#term-step"><em class="xref std std-term">stepping</em></a> simulators through time.
The time has internally no unit attached, but by convention, seconds are used.
If all simulators involved in your scenario agree on another unit (e.g.,
minutes or milliseconds), this can be used as well.</p>
<div class="section" id="anatomy-of-a-step">
<h2>Anatomy of a step<a class="headerlink" href="#anatomy-of-a-step" title="Permalink to this headline">¶</a></h2>
<p>When the simulation starts, all simulators are at time 0. Mosaik tracks the
current simulation time for every simulator individually. When it asks
a simulator to perform its next step, it passes its current simulation time
<em>t</em><sub>now</sub> to it. After its step, the simulator returns the time at which it
wants to perform its next step (<em>t</em><sub>next</sub>). Thus, a simulator&#8217;s step size
doesn&#8217;t need to be constant but can vary during the simulation.</p>
<p>The data that a simulator computes during a step is valid for the right-open
interval [<em>t</em><sub>now</sub>, <em>t</em><sub>next</sub>) as shown in the following figure.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/scheduler-step.svg"><img alt="Anatomy of a step" src="_images/scheduler-step.svg" width="600" /></a>
<p class="caption">Schematic execution of a simulator <em>A</em>. <em>t</em><sub>now</sub>, <em>t</em><sub>next</sub> and
the validity interval for its first step 0 are shown. The figure also shows
that the step size of a simulator may vary during the simulation.</p>
</div>
</div>
<div class="section" id="synchronization-and-data-flows">
<h2>Synchronization and data-flows<a class="headerlink" href="#synchronization-and-data-flows" title="Permalink to this headline">¶</a></h2>
<p>If there are data-flows between two simulators (because you connected some of
their entities), a simulator can only perform a step if all input data has been
computed.</p>
<p>Let&#8217;s assume we created a data-flow from a simulator <em>A</em> to a simulator <em>B</em> and
<em>B</em> wants to perform a step from <em>t</em><sub>now(B)</sub>. Mosaik determines which
simulators provide input data for <em>B</em>. This is only <em>A</em> in this example. In
order to provide data for <em>B</em>, <em>A</em> needs to step far enough to produce data for
<em>t</em><sub>now(B)</sub>, that means <em>t</em><sub>next(A)</sub> &gt; <em>t</em><sub>now(B)</sub> as the
following figure illustrates.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/scheduler-step-dependencies.svg"><img alt="t_next(A) must be greater then t_now(B) in order for B to step." src="_images/scheduler-step-dependencies.svg" width="600" /></a>
<p class="caption"><strong>(a)</strong> <em>B</em> cannot yet step because <em>A</em> has not progressed far enough yet
(<em>t</em><sub>next(A)</sub> &lt;= <em>t</em><sub>now(B)</sub>).</p>
<div class="legend">
<strong>(b)</strong> <em>B</em> can perform its next step, because <em>A</em> now has progressed far
enough (<em>t</em><sub>next(A)</sub> &gt; <em>t</em><sub>now(B)</sub>).</div>
</div>
<p>If this condition is met for all simulators providing input for <em>B</em>, mosaik
collects all input data for <em>B</em> that is valid at <em>t</em><sub>now(B)</sub> (you could
say it takes <em>one</em> snapshot of the global simulation state). It passes
this data to <em>B</em>. Based upon this (and <em>only</em> this) data, <em>B</em> performs its step
[<em>t</em><sub>now(B)</sub>, <em>t</em><sub>next(B)</sub>).</p>
<p>This is relatively easy to understand if <em>A</em> and <em>B</em> have the same step size,
as the following figures shows:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/scheduler-dataflow-1-1.svg"><img alt="Dataflow from A to B where both simulators have the same step size." src="_images/scheduler-dataflow-1-1.svg" width="600" /></a>
<p class="caption">In this example, <em>A</em> and <em>B</em> have the same step size. Mosaik steps them
in an alternating order starting with <em>A</em>, because it provides the input
data for <em>B</em>.</p>
</div>
<p>If <em>B</em> had a larger step size then <em>A</em>, <em>A</em> would produce new data while <em>B</em>
steps. <em>B</em> would still only use the data that was valid at <em>t</em><sub>now(B)</sub>,
because it only &#8220;measures&#8221; its inputs once at the beginning of its step:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/scheduler-dataflow-1-2.svg"><img alt="Dataflow from A to B where B has a larger step size." src="_images/scheduler-dataflow-1-2.svg" width="600" /></a>
<p class="caption">In this example, <em>B</em> has a larger step size. It doesn&#8217;t consume all data
that <em>A</em> produces, because it only gets data once at the beginning of its
step.</p>
</div>
<p>On the other hand, if <em>A</em> had a larger step size then <em>B</em>, we would reuse the
same data from <em>A</em> multiple times as long as it is valid:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/scheduler-dataflow-2-1.svg"><img alt="Dataflow from A to B where A has a larger step size." src="_images/scheduler-dataflow-2-1.svg" width="600" /></a>
<p class="caption">In this example, <em>A</em> has a larger step size. <em>B</em> reuses the same data
multiple times because it is still valid.</p>
</div>
<p>The last two examples may look like special cases, but they actually arise from
the approach explained above.</p>
<div class="section" id="how-data-flows-through-mosaik">
<h3>How data flows through mosaik<a class="headerlink" href="#how-data-flows-through-mosaik" title="Permalink to this headline">¶</a></h3>
<p>After a simulator is done with its step, mosaik determines, based on the
data-flows that you created in your scenario, which data other simulators need
from it. It makes a <em>get_data()</em> API call to the simulator and stores the data
that this call returns in an internal buffer. It also memorizes for which
period of time this data is valid.</p>
<p>Before a simulator steps, mosaik determines in a similar fashion what input
data the simulator needs. Mosaik checks its internal data buffer if input data
from all simulators is available. If not, it waits until all simulators stepped
far enough to provide that data. All input data is then passed to the <em>inputs</em>
parameter of the <em>step()</em> API call.</p>
<p>It is important to understand that simulators don&#8217;t talk to each other directly
but that all data flows through mosaik were it can be cached and managed.</p>
</div>
</div>
<div class="section" id="cyclic-data-flows">
<h2>Cyclic data-flows<a class="headerlink" href="#cyclic-data-flows" title="Permalink to this headline">¶</a></h2>
<p>Cyclic data-flows are necessary to model situations in which a control
mechanism <em>(C)</em> controls another entity <em>(E)</em> based on its state, e.g. by
sending commands or a schedule.</p>
<p>It is not possible to perform both data-flows (the state from <em>E</em> to <em>C</em> and
the commands/schedule from <em>C</em> to <em>E</em>) at the same time because they depend on
each other (yes, this is similar to the chicken or egg dilemma).</p>
<p>The cycle can be resolved by first stepping <em>E</em> (e.g., from <em>t</em> = 0 to <em>t</em>
= 1). <em>E</em>’s state for that interval can then be used as input for <em>C</em>&nbsp;’s
step for the same interval. The commands/schedule that <em>C</em> generates for <em>E</em>
will then be used in <em>E</em>’s next step.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/scheduler-cyclic-dataflow.svg"><img alt="Cyclic data-flow between a controller and a controlled entity." src="_images/scheduler-cyclic-dataflow.svg" width="600" /></a>
<p class="caption">In this example, a controlled entity <em>E</em> provides state data to the
controller <em>C</em>. The commands or schedule from <em>C</em> is used by <em>E</em> in its next
step.</p>
</div>
<p>This resolution of the cycle makes sense if you think how this would work in
real life. The controller would measure the data from the controlled unit at
a certain point <em>t</em>. It would then do some calculation which take a certain
amount of time Δ<em>t</em> which would be send to the controlled unit at <em>t</em> + Δ<em>t</em>.</p>
<p>However, mosaik is not able to automatically resolve that cycle. That&#8217;s why you
are not allowed to <tt class="docutils literal"><span class="pre">connect(E,</span> <span class="pre">C)</span></tt> and <tt class="docutils literal"><span class="pre">connect(C,</span> <span class="pre">E)</span></tt> in a scenario.
Instead you have to <tt class="docutils literal"><span class="pre">connect(E,</span> <span class="pre">C,</span> <span class="pre">async_requests=True)</span></tt> and use the
<a class="reference internal" href="mosaik-api/overview.html#async-requests-overview"><em>asynchronous callback</em></a> <tt class="docutils literal"><span class="pre">set_data()</span></tt> in <em>C</em>’s <em>step()</em> implementation in order to send the commands or schedule from <em>C</em>
to <em>E</em>.</p>
<p>You can take a look at our <a class="reference internal" href="dev/design-decisions.html#circular-data-flows"><em>discussion of design decissions</em></a> to learn why cyclic data-flows are handled this way.</p>
</div>
<div class="section" id="stepping-and-simulation-duration">
<h2>Stepping and simulation duration<a class="headerlink" href="#stepping-and-simulation-duration" title="Permalink to this headline">¶</a></h2>
<p>By now you should have a general idea of how mosaik handles data-flows between
simulators. You should also have the idea that simulators only perform a step
when all required input data is available. But what if they don&#8217;t need any? In
this section you&#8217;ll learn about the algorithm that mosaik uses to determine
whether a simulator can be stepped or not.</p>
<p>The general idea behind idea is laziness. A simulator will only step if it
really needs to. This is usually, because someone else needs its data. This
becomes problematic if your simulator is the only one in the simulation (e.g.,
for testing purposes) or at the end of a data-flow chain.</p>
<p>This is how it works:</p>
<ol class="arabic">
<li><p class="first">Should there be a next step at all? <sup>*</sup></p>
<p><em>Yes:</em> Go to step 2.</p>
<p><em>No:</em> Stop the simulator.</p>
<p><sup>*</sup> <em>We&#8217;ll explain how to answer this question below.</em></p>
</li>
<li><p class="first">Are there simulators that need data from us?</p>
<p><em>Yes:</em> Go to step 3.</p>
<p><em>No:</em> Go to step 4.</p>
</li>
<li><p class="first">Does a depending simulator require new data from us?</p>
<p><em>Yes:</em> Go to step 4.</p>
<p><em>No:</em> Wait until someone does. Then go to step 4.</p>
</li>
<li><p class="first">Is all required input data from other simulators available?</p>
<p><em>Yes:</em> Go to step 5.</p>
<p><em>No:</em> Wait until all data is available. Then go step 5.</p>
</li>
<li><p class="first">Collect all required input data.</p>
</li>
<li><p class="first">Send collected input data to simulator, perform the simulation step and get
the time for the next step.</p>
</li>
<li><p class="first">Get all data from the simulator that other simulators need.</p>
</li>
<li><p class="first">Notify simulators that already wait for that data.</p>
</li>
</ol>
<p>So how do we determine whether a simulator must perform another step of it is
done?</p>
<p>When we start the simulation, we pass a time unto which our simulation should
run (<tt class="docutils literal"><span class="pre">world.run(until=END)</span></tt>). Usually a simulator is done if the time of its
next step is larger then the value of <em>until</em>. This is, however, not true for
<em>all</em> simulators in a simulation. If no one needs the data of a simulator step,
why perform this step?</p>
<p>So the actual algorithm is as follows:</p>
<p>If a simulator has no outgoing data-flows (no other simulator needs its data)
it simulates until the condition <em>t</em><sub>next</sub> &gt; <em>t</em><sub>until</sub> is met.</p>
<p>Else, if a simulator needs to provide data for other simulators, it keeps
running until all of these simulators have stopped.</p>
<p>The algorithm explained above allows mosaik to perform as little simulation
steps as possible and only perform theses steps when necessary.</p>
</div>
</div>


          <footer>
  
    <div class="rst-footer-buttons">
      
        <a href="faq.html" class="btn btn-neutral float-right" title="FAQ"/>Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="simmanager.html" class="btn btn-neutral" title="The simulator manager"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <p>
      &copy; Copyright 2013, Stefan Scherfke.
  </p>

  <a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>