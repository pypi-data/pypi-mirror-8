-----------------------------------------------------------------------
--  Fulcrum
--
--  This is the Fulcrum header file which specifies all stored
--  procedures, types, sequences and views used by the TNGEMS/Fulcrum
--  database.
--
--  Rendered {{ generated }} with options:
--
--      schema_domain           : {{ schema_domain }}
--      schema_application      : {{ schema_application }}
--      schema_infrastructure   : {{ schema_infrastructure }}
--      schema_common           : {{ schema_common }}
--      schema_public           : {{ schema_public }}
--      schema_history          : {{ schema_history }}
--      with_data               : {{ with_data }}
--      with_drop               : {{ with_drop }}
--      with_history_drop       : {{ with_history_drop }}
--      with_remote_data        : {{ with_remote_data }}
--      with_example_data       : {{ with_example_data }}
--      drop_cascade            : {{ drop_cascade }}
--
--
--  SYNOPSIS
--
--  This file specifies the TNG Enterprise Management System master
--  database through a series of Stuctured Query Language (SQL)
--  statements.
--
--  OVERVIEW
--
--  The TNGEMS database declares multiple schemata, logically grouping
--  tables, views and stored procedures.
--
--  -   The ``{{ schema_common }}`` schema contains data the is shared
--      by all system components, such as object type declarations and
--      ISO code lists.
--
--  -   The ``{{ schema_application }}`` schema holds global data
--      relation to the functioning of applications, such as user
--      accounts and their authorizations.
--
--  -   The ``{{ schema_domain }}`` schema contains all data relating
--      to the enterprise business process(es).
--
--  -   The ``{{ schema_infrastructure }}`` schema contains all data
--      relating to the system infrastructure, such as e-mail accounts,
--      file descriptors and network node metadata.
--
--  -   The ``{{ schema_history }}`` schema contains the historical states
--      of the logical entities.
--
--  Please note that cross-references between these schemata may exists,
--  with the exception of ``{{ schema_common }}`` and ``{{ schema_infrastructure }}``,
--  which may only be referenced.
--
--  DESIGN CONSIDERATIONS
--
--  -   All entities that are used in decision-making should store
--      their historical state and a reference to the user and client
--      whose actions produced that state.
--
-----------------------------------------------------------------------
{% if with_drop %}
DROP SCHEMA IF EXISTS {{ schema_domain }} CASCADE;
DROP SCHEMA IF EXISTS {{ schema_common }} CASCADE;
--DROP SCHEMA IF EXISTS {{ schema_virtual }} CASCADE;
DROP SCHEMA IF EXISTS {{ schema_history }} CASCADE;
DROP SCHEMA IF EXISTS {{ schema_infrastructure }} CASCADE;
DROP SCHEMA IF EXISTS data_system CASCADE;
{% endif %}

{% set _INCL_FULCRUM = True %}


-- Master schema containing application data
CREATE SCHEMA IF NOT EXISTS {{ schema_application }};

-- Master schema containing the physical data
CREATE SCHEMA IF NOT EXISTS {{ schema_domain }};

-- Holds the domain tables specifying values.
CREATE SCHEMA IF NOT EXISTS {{ schema_common }};

-- Contains the virtual relations
--CREATE SCHEMA IF NOT EXISTS {{ schema_virtual }};

-- Contains history
CREATE SCHEMA IF NOT EXISTS {{ schema_history }};

-- Provisioner data.
CREATE SCHEMA IF NOT EXISTS {{ schema_infrastructure }};


-- Data related to the runtime operation of the TNG Enterprise
-- Management System.
CREATE SCHEMA IF NOT EXISTS data_system;


--  This is the main sequences for all domain objects that are identified
--  by a surrogate primary key.
DO
$$
BEGIN
    PERFORM 1
    FROM pg_class R1
    JOIN pg_namespace R2 ON
        R1.relnamespace = R2.oid
    WHERE
        R1.relname = 'tngems_object_id' AND
        R2.nspname = 'public' AND
        R1.relkind = 'S';
    IF NOT FOUND THEN
        CREATE SEQUENCE {{ schema_public }}.tngems_object_id;
    END IF;
END
$$ LANGUAGE PLPGSQL;

--  These are the extensions used by the TNGEMS/Fulcrum database. In future
--  releases a mechanism must be defined to include these extensions only
--  if they are actually needed.
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS lo;
CREATE EXTENSION IF NOT EXISTS plpython3u;
CREATE EXTENSION IF NOT EXISTS pgcrypto;


-- Set the PYTHONPATH for all subsequent commands using PL/Python so that
-- it can import libtng.
DO
$$
    import sys
    sys.path.append("{{ libtng_module_dir }}")

    # Import libtng and just let it raise a fatal exception if we couldn't
    # import it (the transaction will rollback).
    import libtng

    plpy.notice("libtng succesfully imported")
$$
LANGUAGE PLPYTHON3U;

-- Procedures related to the authentication of system clients and
-- users.

-----------------------------------------------------------------------
--  Returns the ID of the client that is currently connected.
--
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.get_session_client()
RETURNS int AS
$$
DECLARE
    pk int;
BEGIN
    SELECT client_id INTO pk
    FROM tngems_session_client_id;
    RETURN pk;
EXCEPTION
    WHEN undefined_table THEN RETURN NULL;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


CREATE OR REPLACE FUNCTION public.set_session_client(int)
RETURNS VOID AS
$$
BEGIN
    DROP TABLE IF EXISTS tngems_session_client_id;
    IF $1 IS NOT NULL THEN
        CREATE TEMPORARY TABLE tngems_session_client_id (
            client_id int PRIMARY KEY
        );
        INSERT INTO tngems_session_client_id VALUES ($1);
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


CREATE OR REPLACE FUNCTION public.set_session_client(varchar)
RETURNS VOID AS
$$
BEGIN
    DROP TABLE IF EXISTS tngems_session_client_id;
    IF $1 IS NOT NULL THEN
        CREATE TEMPORARY TABLE tngems_session_client_id (
            client_id int PRIMARY KEY
        );
        INSERT INTO tngems_session_client_id
        SELECT R1.client_id
        FROM {{ schema_application }}.clients R1
        WHERE R1.identifier = $1;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-----------------------------------------------------------------------
--  Returns the ID of the user that is currently connected.
--
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.get_session_user()
RETURNS int AS
$$
DECLARE
    pk int;
BEGIN
    SELECT user_id INTO pk
    FROM tngems_session_user_id;
    RETURN pk;
EXCEPTION
    WHEN undefined_table THEN RETURN NULL;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


CREATE OR REPLACE FUNCTION public.set_session_user(int)
RETURNS VOID AS
$$
BEGIN
    DROP TABLE IF EXISTS tngems_session_user_id;
    IF $1 IS NOT NULL THEN
        CREATE TEMPORARY TABLE tngems_session_user_id (
            user_id int PRIMARY KEY
        );
        INSERT INTO tngems_session_user_id VALUES ($1);
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


CREATE OR REPLACE FUNCTION public.set_session_user(varchar)
RETURNS VOID AS
$$
BEGIN
    DROP TABLE IF EXISTS tngems_session_user_id;
    IF $1 IS NOT NULL THEN
        CREATE TEMPORARY TABLE tngems_session_user_id (
            user_id int PRIMARY KEY
        );
        INSERT INTO tngems_session_user_id
        SELECT R1.user_id
        FROM {{ schema_application }}.users_username R1
        WHERE R1.username = $1;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-----------------------------------------------------------------------
--  Set the user/client authorization for the current transaction.
--
--  Args:
--      int: the user id.
--      int: the client_id.
--
--  Returns:
--      void
--
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.set_session_authorization(int, int)
RETURNS VOID AS
$$
BEGIN
    PERFORM public.set_session_user($1);
    PERFORM public.set_session_client($2);
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;


-----------------------------------------------------------------------
--  Set the user/client authorization for the current transaction.
--
--  Args:
--      varchar: the user id.
--      varchar: the client_id.
--
--  Returns:
--      void
--
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.set_session_authorization(varchar, varchar)
RETURNS VOID AS
$$
BEGIN
    PERFORM public.set_session_user($1);
    PERFORM public.set_session_client($2);
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;


-----------------------------------------------------------------------
--  Set the user/client authorization for the current transaction.
--
--  Args:
--      varchar: the user/client formatted as 'user:client'
--
--  Returns:
--      void
--
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.set_session_authorization(varchar)
RETURNS VOID AS
$$
DECLARE
    x varchar[];
BEGIN
    x := string_to_array($1, ':');
    PERFORM public.set_session_user(x[1]);
    PERFORM public.set_session_client(x[2]);
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;



-----------------------------------------------------------------------
--  Set automatic history for current session.
--
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.get_auto_history()
RETURNS boolean AS
$$
DECLARE
    pk boolean;
BEGIN
    SELECT is_enabled INTO pk
    FROM tngems_auto_history_enabled;
    RETURN pk;
EXCEPTION
    WHEN undefined_table THEN RETURN FALSE;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;


CREATE OR REPLACE FUNCTION public.set_auto_history(boolean)
RETURNS VOID AS
$$
BEGIN
    DROP TABLE IF EXISTS tngems_auto_history_enabled;
    CREATE TEMPORARY TABLE tngems_auto_history_enabled (
        is_enabled boolean PRIMARY KEY
    );
    INSERT INTO tngems_auto_history_enabled VALUES ($1);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;




-- Constraint enforcing functions; these procedures are use to enforce
-- contraints, usually at the table level. We have chosen not to implement
-- these as DOMAIN types, because it would be impossible to initialize them
-- with NULL attributes.

-----------------------------------------------------------------------
--  Returns a boolean indicating if the specified value is legal for
--  use as an object transaction time.
--
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_valid_transaction_time(tstzrange)
RETURNS boolean AS
$$
    SELECT isfinite(lower($1)) AND lower($1) IS NOT NULL
        AND upper($1) IS NOT NULL;
$$ LANGUAGE SQL SECURITY DEFINER IMMUTABLE RETURNS NULL ON NULL INPUT;


-----------------------------------------------------------------------
--  Validate an IPv4 address.
--
--  Args:
--      varchar: an IPv4 address.
--
--  Returns:
--      boolean
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_valid_ipv4(varchar)
RETURNS boolean AS
$$
    SELECT NOT EXISTS(
        SELECT x::int
        FROM unnest(string_to_array($1, '.')) x
        WHERE
            NOT int4range(0, 255, '[]') @> x::int
    );
$$ LANGUAGE SQL SECURITY DEFINER IMMUTABLE;


-----------------------------------------------------------------------
--  Assert that a hostname is a valid hostname.
--
--  Args:
--      varchar: the hostname.
--
--  Returns:
--      boolean
--
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_valid_hostname(varchar)
RETURNS boolean AS
$$
    SELECT $1 ~ '^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$';
$$ LANGUAGE SQL SECURITY DEFINER IMMUTABLE RETURNS NULL ON NULL INPUT;


-----------------------------------------------------------------------
--  Return a boolean indicating if the specified IP-address
--  identifies a single host.
--
--  Args:
--      inet: the IPv4 or IPv6 address.
--
--  Returns:
--      boolean
--
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_single_host(inet)
RETURNS boolean AS
$$
    SELECT (
        CASE
            WHEN family($1) = 6 THEN masklen($1) = 128
            WHEN family($1) = 4 THEN masklen($1) = 32
            ELSE FALSE
        END
    );
$$ LANGUAGE SQL SECURITY DEFINER IMMUTABLE RETURNS NULL ON NULL INPUT;


-----------------------------------------------------------------------
--  Assert that a given IP address is a private network.
--
--  Args:
--      inet: the IP address.
--
--  Returns:
--      boolean
--
-----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_private_network(inet)
RETURNS boolean AS
$$
    SELECT
        ('10.0.0.0/8'::inet >>= $1) OR
        ('172.16.0.0/12'::inet >>= $1) OR
        ('192.168.0.0/16'::inet >>= $1);
$$ LANGUAGE SQL SECURITY DEFINER IMMUTABLE RETURNS NULL ON NULL INPUT;


------------------------------------------------------------------------
--  Return a boolean indicating if a certain domain exists.
--
--  Args:
--      varchar: the schema name of the domain.
--      varchar: the name of the domain.
--
--  Returns:
--      boolean
--
------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.domain_exists(varchar, varchar)
RETURNS boolean AS
$$
    SELECT EXISTS(
        SELECT 1
        FROM pg_catalog.pg_type
        JOIN pg_catalog.pg_namespace ON
            pg_namespace.oid = pg_type.typnamespace
        WHERE
            typtype = 'd' AND
            lower(nspname) = lower($1) AND
            lower(typname) = lower($2)
    );
$$ LANGUAGE SQL;


-----------------------------------------------------------------------
--  Domain  types
--
-----------------------------------------------------------------------
DO $$
BEGIN

IF NOT public.domain_exists('public', 'transaction_time') THEN
    CREATE DOMAIN public.transaction_time AS tstzrange
        DEFAULT tstzrange(CURRENT_TIMESTAMP, 'infinity', '[)')
        CONSTRAINT transaction_time_bounds_chk CHECK (
            lower(VALUE) IS NOT NULL AND
            isfinite(lower(VALUE)) AND
            upper(VALUE) IS NOT NULL
        );
END IF;


IF NOT public.domain_exists('public', 'mutation_timestamp') THEN
    CREATE DOMAIN public.mutation_timestamp AS timestamp with time zone
        DEFAULT CURRENT_TIMESTAMP;
END IF;


IF NOT public.domain_exists('public', 'session_user') THEN
    CREATE DOMAIN public.session_user AS int
        DEFAULT public.get_session_user();
END IF;


IF NOT public.domain_exists('public', 'session_client') THEN
    CREATE DOMAIN public.session_client AS int
        DEFAULT public.get_session_client();
END IF;


IF NOT public.domain_exists('public', 'identifier') THEN
    CREATE DOMAIN public.identifier AS varchar
        CONSTRAINT identifier_valid_pattern
        CHECK (VALUE != '');
END IF;


IF NOT public.domain_exists('public', 'string') THEN
    CREATE DOMAIN public.string AS varchar
        CONSTRAINT string_valid_pattern
        CHECK (VALUE != '');
END IF;
ALTER DOMAIN public.string DROP NOT NULL;


IF NOT public.domain_exists('public', 'username') THEN
    CREATE DOMAIN public.username AS varchar
        CONSTRAINT username_valid_pattern
        CHECK (VALUE != '');
END IF;


IF NOT public.domain_exists('public', 'rsapublic') THEN
    CREATE DOMAIN public.rsapublic AS varchar
        CONSTRAINT rsa_public_valid_pattern
        CHECK (VALUE ~ 'ssh-rsa AAAA[0-9A-Za-z+/]+[=]{0,3}');
END IF;

IF NOT public.domain_exists('public', 'ipv4') THEN
    CREATE DOMAIN public.ipv4 AS varchar
        CONSTRAINT ipv4_valid
        CHECK (public.is_valid_ipv4(VALUE));
END IF;


IF NOT public.domain_exists('public', 'hostname') THEN
    CREATE DOMAIN public.hostname AS varchar
        CONSTRAINT hostname_valid
        CHECK (public.is_valid_hostname(VALUE));
END IF;


IF NOT public.domain_exists('public', 'ipaddress') THEN
    CREATE DOMAIN public.ipaddress AS inet
        CONSTRAINT ipaddress_valid
        CHECK (public.is_single_host(VALUE));
END IF;


IF NOT public.domain_exists('public', 'filepath') THEN
    CREATE DOMAIN public.filepath AS varchar
        CONSTRAINT filepath_valid
        CHECK (VALUE ~ '^((/[\d\w\_\-\.]+)+|/)$'); -- TODO: probably does not work with Unicode
END IF;


IF NOT public.domain_exists('public', 'mimetype') THEN
    CREATE DOMAIN public.mimetype AS varchar
        CONSTRAINT mimetype_pattern
        CHECK (VALUE ~ '^(application|audio|example|image|message|model|multipart|text|video)/.*$');
END IF;


IF NOT public.domain_exists('public', 'surah') THEN
    CREATE DOMAIN public.surah AS smallint
        CONSTRAINT surah_number_valid
        CHECK (int4range(1, 114, '[]') @> VALUE::int);
END IF;



IF NOT public.domain_exists('public', 'slug') THEN
    CREATE DOMAIN public.slug AS varchar
        CONSTRAINT slug_valid
        CHECK (VALUE ~ '^[a-z0-9]+(?:-[a-z0-9]+)*$');
END IF;


IF NOT public.domain_exists('public', 'phonenumber') THEN
    CREATE DOMAIN public.phonenumber AS varchar
        CONSTRAINT phonenumber_valid
        CHECK (VALUE ~ '^\+[0-9]{8,}$');
END IF;



-----------------------------------------------------------------------
--  Specifies a gender type domain. Though the subject is complicated due
--  to identity/biological complexities, the domain tries to be as
--  comprehensive as possible. The gender domain is to be used for a
--  persons phenotype in common applications; e.g. medical applications
--  should define their own domain for specifying a persons genotype.
--
--  Values are:
--      M: Male
--      F: Female
--      N: Neither
--      B: Both
--      D: Decline to state
--      C: It's complicated
--      X: Unknown.
--
--  See also http://www.sarahdopp.com/blog/2010/designing-a-better-drop-down-menu-for-gender/
--
-----------------------------------------------------------------------
IF NOT public.domain_exists('public', 'gender') THEN
    CREATE DOMAIN public.gender AS varchar(1)
        CHECK (VALUE IN ('M','F','N','B','D','C','X'));
END IF;


END;
$$ LANGUAGE plpgsql;