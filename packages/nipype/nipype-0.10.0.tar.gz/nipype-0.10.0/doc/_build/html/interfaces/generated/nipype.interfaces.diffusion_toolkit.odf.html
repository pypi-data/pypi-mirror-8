<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python - Pipelines and Interfaces &mdash; nipy pipeline and interfaces package</title>
    
    <link rel="stylesheet" href="../../_static/nipype.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.10.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="nipy pipeline and interfaces package" href="../../index.html" />
 
<meta name="keywords" content="nipype, neuroimaging, pipeline, workflow, parallel, python, neuroscience">
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-339450-7', 'nipy.org/nipype');
  ga('send', 'pageview');
</script>

  </head>
  <body>
<div class="header-wrapper">
    <div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
            <a href="../../index.html">
            <img src="../../_static/nipype-banner-bg.png" alt="NIPY logo"  border="0" />
        <div style="margin-top: 1em;
                border-top: 1px solid #AAA;
                border-bottom: 1px solid #AAA;
                border-radius: 5px;
                padding: 3px 1em;">
            <link rel="stylesheet" href="http://www.google.com/cse/style/look/default.css" type="text/css" />
<style type="text/css">
    a.navbar {
    color: ;
    letter-spacing: .05em;
    font-weight: bold;
        }
</style>

<a class="navbar" href="../../index.html">Home</a> ·
<a class="navbar" href="../../quickstart.html">Quickstart</a> ·
<a class="navbar" href="../../documentation.html">Documentation</a> ·
<a class="navbar" href="../../about.html">Citation</a> ·
<a class="navbar" href="http://nipy.org">NiPy</a>

        </div>
    </div>
</div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<style type="text/css">
    input.gsc-input {
        border-color: #BCCDF0;
    }
    input.gsc-search-button {
        border-color: #666666;
        background-color: #CECECE;
        padding: 0;
    }
    div.sphinxsidebar .tile {
        border: 1px solid #D1DDE2;
        border-radius: 10px;
        background-color: #E1E8EC;
        padding-left: 0.5em;
        margin: 1em 0;
    }
    div.sphinxsidebar input[type="text"] {
        width: 100%;
    }
    div.sphinxsidebar input[type="submit"] {
        width: 100%;
    }
</style>

<div class="sidebarblock">
    <div id="cse-search-form">Loading</div>

    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript">
        google.load('search', '1', {language : 'en'});
        google.setOnLoadCallback(function() {
            var customSearchControl = new google.search.CustomSearchControl(
                    '010960497803984932957:u8pmqf7fdoq');

            customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
            var options = new google.search.DrawOptions();
            options.enableSearchboxOnly("../../searchresults.html");
            customSearchControl.draw('cse-search-form', options);
        }, true);
    </script>
</div>

  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">interfaces.diffusion_toolkit.odf</a><ul>
<li><a class="reference internal" href="#hardimat">HARDIMat</a></li>
<li><a class="reference internal" href="#odfrecon">ODFRecon</a></li>
<li><a class="reference internal" href="#odftracker">ODFTracker</a></li>
</ul>
</li>
</ul>

<style type="text/css">
    div.sphinxsidebar .tile {
        border: 1px solid #D1DDE2;
        border-radius: 10px;
        background-color: #E1E8EC;
        padding-left: 0.5em;
        margin: 1em 0;
    }
</style>
<div class="sidebarblock">
    <h3>Versions</h3>

    <div class="tile">
        <table style="width: 100%;">
            <tr style="font-weight: bold;">
                <td align="left">Release</td><td align="right">Devel</td>
            </tr>
            <tr>
                <td align="left">0.10.0</td><td align="right">1.0-dev</td>
            </tr>
            <tr>
                <td align="left"><a href="../../users/install.html">Download</a></td>
                <td align="right"><a href="https://github.com/nipy/nipype">Github</a></td>
            </tr>
        </table>
    </div>

    <div id="buttons">
        <div id="ohloh-use" style="margin-right: 25px; margin-top: -2px; float: left;">
            <script type="text/javascript"
                    src="http://www.ohloh.net/p/480871/widgets/project_users_logo.js">
            </script>
        </div><!-- use -->
        <g:plusone size="medium" annotation="none"></g:plusone>
        <div class="clear"></div>
    </div><!-- buttons container -->
</div>


<script type="text/javascript">
    (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
</script>

<h3>Links</h3>

<ul>
    <li>Docs: <a href="http://nipy.org/nipype">Stable</a> · <a href="http://www.mit.edu/~satra/nipype-nightly/">Nightly</a></li>
    <li>Code: <a href="http://github.com/nipy/nipype">Github</a> · <a href="http://github.com/nipy/nipype/issues">Bugs-Requests</a></li>
    <li>Forum: <a href="http://neurostars.org/t/nipype">User</a> · <a href="http://projects.scipy.org/mailman/listinfo/nipy-devel">Developer</a></li>
    <li><a href="http://nipy.org/software/license/index.html"><img src="https://pypip.in/license/nipype/badge.png" alt="License"></a> · <a href="http://nipy.org/about/funding.html">Funding</a></li>
    <li><a href="https://travis-ci.org/nipy/nipype"><img src="https://travis-ci.org/nipy/nipype.png?branch=master" alt="travis"></a> · <a href='https://coveralls.io/r/nipy/nipype'><img src='https://coveralls.io/repos/nipy/nipype/badge.png' alt='Coverage Status' /></a></li>
    <li><a href="https://pypi.python.org/pypi/nipype/"><img src="https://pypip.in/download/nipype/badge.png" alt="Downloads"></a> · <a href='https://pypi.python.org/pypi/nipype/'><img src='https://pypip.in/py_versions/nipype/badge.png' alt='Python Versions' /></a></li>
</ul>


        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="interfaces-diffusion-toolkit-odf">
<h1>interfaces.diffusion_toolkit.odf<a class="headerlink" href="#interfaces-diffusion-toolkit-odf" title="Permalink to this headline">¶</a></h1>
<span class="target" id="nipype-interfaces-diffusion-toolkit-odf-hardimat"></span><div class="section" id="hardimat">
<span id="index-0"></span><h2>HARDIMat<a class="headerlink" href="#hardimat" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://github.com/nipy/nipype/tree/e63e055194d62d2bdc4665688261c03a42fd0025/nipype/interfaces/diffusion_toolkit/odf.py#L54">Link to code</a></p>
<p>Wraps command <strong>hardi_mat</strong></p>
<p>Use hardi_mat to calculate a reconstruction matrix from a gradient table</p>
<p>Inputs:</p>
<div class="highlight-python"><div class="highlight"><pre>[Mandatory]
bvals: (an existing file name)
        b values file
bvecs: (an existing file name)
        b vectors file
        flag: %s, position: 1
terminal_output: (&#39;stream&#39; or &#39;allatonce&#39; or &#39;file&#39; or &#39;none&#39;)
        Control terminal output: `stream` - displays to terminal
        immediately, `allatonce` - waits till command is finished to display
        output, `file` - writes output to file, `none` - output is ignored

[Optional]
args: (a string)
        Additional parameters to the command
        flag: %s
environ: (a dictionary with keys which are a value of type &#39;str&#39; and
         with values which are a value of type &#39;str&#39;, nipype default value:
         {})
        Environment variables
ignore_exception: (a boolean, nipype default value: False)
        Print an error message instead of throwing an exception in case the
        interface fails to run
image_info: (an existing file name)
        specify image information file. the image info file is generated
         from original dicom image by diff_unpack program and contains image
         orientation and other information needed for reconstruction and
         tracking. by default will look into the image folder for .info file
        flag: -info %s
image_orientation_vectors: (a list of from 6 to 6 items which are a
         float)
        specify image orientation vectors. if just one argument given,
         will treat it as filename and read the orientation vectors from
         the file. if 6 arguments are given, will treat them as 6 float
         numbers and construct the 1st and 2nd vector and calculate the 3rd
         one automatically.
         this information will be used to determine image orientation,
         as well as to adjust gradient vectors with oblique angle when
        flag: -iop %f
oblique_correction: (a boolean)
        when oblique angle(s) applied, some SIEMENS dti protocols do not
         adjust gradient accordingly, thus it requires adjustment for
        correct
         diffusion tensor calculation
        flag: -oc
odf_file: (an existing file name)
        filename that contains the reconstruction points on a HEMI-sphere.
         use the pre-set 181 points by default
        flag: -odf %s
order: (an integer)
        maximum order of spherical harmonics. must be even number. default
         is 4
        flag: -order %s
out_file: (a file name, nipype default value: recon_mat.dat)
        output matrix file
        flag: %s, position: 2
reference_file: (an existing file name)
        provide a dicom or nifti image as the reference for the program to
         figure out the image orientation information. if no such info was
         found in the given image header, the next 5 options -info, etc.,
         will be used if provided. if image orientation info can be found
         in the given reference, all other 5 image orientation options will
         be IGNORED
        flag: -ref %s
</pre></div>
</div>
<p>Outputs:</p>
<div class="highlight-python"><div class="highlight"><pre>out_file: (an existing file name)
        output matrix file
</pre></div>
</div>
<span class="target" id="nipype-interfaces-diffusion-toolkit-odf-odfrecon"></span></div>
<div class="section" id="odfrecon">
<span id="index-1"></span><h2>ODFRecon<a class="headerlink" href="#odfrecon" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://github.com/nipy/nipype/tree/e63e055194d62d2bdc4665688261c03a42fd0025/nipype/interfaces/diffusion_toolkit/odf.py#L126">Link to code</a></p>
<p>Wraps command <strong>odf_recon</strong></p>
<p>Use odf_recon to generate tensors and other maps</p>
<p>Inputs:</p>
<div class="highlight-python"><div class="highlight"><pre>[Mandatory]
DWI: (an existing file name)
        Input raw data
        flag: %s, position: 1
matrix: (an existing file name)
        use given file as reconstruction matrix.
        flag: -mat %s
n_b0: (an integer)
        number of b0 scans. by default the program gets this information
         from the number of directions and number of volumes in
         the raw data. useful when dealing with incomplete raw
         data set or only using part of raw data set to reconstruct
        flag: -b0 %s
n_directions: (an integer)
        Number of directions
        flag: %s, position: 2
n_output_directions: (an integer)
        Number of output directions
        flag: %s, position: 3
terminal_output: (&#39;stream&#39; or &#39;allatonce&#39; or &#39;file&#39; or &#39;none&#39;)
        Control terminal output: `stream` - displays to terminal
        immediately, `allatonce` - waits till command is finished to display
        output, `file` - writes output to file, `none` - output is ignored

[Optional]
args: (a string)
        Additional parameters to the command
        flag: %s
dsi: (a boolean)
        indicates that the data is dsi
        flag: -dsi
environ: (a dictionary with keys which are a value of type &#39;str&#39; and
         with values which are a value of type &#39;str&#39;, nipype default value:
         {})
        Environment variables
filter: (a boolean)
        apply a filter (e.g. high pass) to the raw image
        flag: -f
ignore_exception: (a boolean, nipype default value: False)
        Print an error message instead of throwing an exception in case the
        interface fails to run
image_orientation_vectors: (a list of from 6 to 6 items which are a
         float)
        specify image orientation vectors. if just one argument given,
         will treat it as filename and read the orientation vectors from
         the file. if 6 arguments are given, will treat them as 6 float
         numbers and construct the 1st and 2nd vector and calculate the 3rd
         one automatically.
         this information will be used to determine image orientation,
         as well as to adjust gradient vectors with oblique angle when
        flag: -iop %f
oblique_correction: (a boolean)
        when oblique angle(s) applied, some SIEMENS dti protocols do not
         adjust gradient accordingly, thus it requires adjustment for
        correct
         diffusion tensor calculation
        flag: -oc
out_prefix: (a string, nipype default value: odf)
        Output file prefix
        flag: %s, position: 4
output_entropy: (a boolean)
        output entropy map
        flag: -oe
output_type: (&#39;nii&#39; or &#39;analyze&#39; or &#39;ni1&#39; or &#39;nii.gz&#39;, nipype default
         value: nii)
        output file type
        flag: -ot %s
sharpness: (a float)
        smooth or sharpen the raw data. factor &gt; 0 is smoothing.
         factor &lt; 0 is sharpening. default value is 0
         NOTE: this option applies to DSI study only
        flag: -s %f
subtract_background: (a boolean)
        subtract the background value before reconstruction
        flag: -bg
</pre></div>
</div>
<p>Outputs:</p>
<div class="highlight-python"><div class="highlight"><pre>B0: (an existing file name)
DWI: (an existing file name)
ODF: (an existing file name)
entropy: (a file name)
max: (an existing file name)
</pre></div>
</div>
<span class="target" id="nipype-interfaces-diffusion-toolkit-odf-odftracker"></span></div>
<div class="section" id="odftracker">
<span id="index-2"></span><h2>ODFTracker<a class="headerlink" href="#odftracker" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://github.com/nipy/nipype/tree/e63e055194d62d2bdc4665688261c03a42fd0025/nipype/interfaces/diffusion_toolkit/odf.py#L205">Link to code</a></p>
<p>Wraps command <strong>odf_tracker</strong></p>
<p>Use odf_tracker to generate track file</p>
<p>Inputs:</p>
<div class="highlight-python"><div class="highlight"><pre>[Mandatory]
ODF: (an existing file name)
mask1_file: (a file name)
        first mask image
        flag: -m %s, position: 2
max: (an existing file name)
terminal_output: (&#39;stream&#39; or &#39;allatonce&#39; or &#39;file&#39; or &#39;none&#39;)
        Control terminal output: `stream` - displays to terminal
        immediately, `allatonce` - waits till command is finished to display
        output, `file` - writes output to file, `none` - output is ignored

[Optional]
angle_threshold: (a float)
        set angle threshold. default value is 35 degree for
         default tracking method and 25 for rk2
        flag: -at %f
args: (a string)
        Additional parameters to the command
        flag: %s
disc: (a boolean)
        use disc tracking
        flag: -disc
dsi: (a boolean)
         specify the input odf data is dsi. because dsi recon uses fixed
         pre-calculated matrix, some special orientation patch needs to
         be applied to keep dti/dsi/q-ball consistent.
        flag: -dsi
environ: (a dictionary with keys which are a value of type &#39;str&#39; and
         with values which are a value of type &#39;str&#39;, nipype default value:
         {})
        Environment variables
ignore_exception: (a boolean, nipype default value: False)
        Print an error message instead of throwing an exception in case the
        interface fails to run
image_orientation_vectors: (a list of from 6 to 6 items which are a
         float)
        specify image orientation vectors. if just one argument given,
         will treat it as filename and read the orientation vectors from
         the file. if 6 arguments are given, will treat them as 6 float
         numbers and construct the 1st and 2nd vector and calculate the 3rd
         one automatically.
         this information will be used to determine image orientation,
         as well as to adjust gradient vectors with oblique angle when
        flag: -iop %f
input_data_prefix: (a string, nipype default value: odf)
        recon data prefix
        flag: %s, position: 0
input_output_type: (&#39;nii&#39; or &#39;analyze&#39; or &#39;ni1&#39; or &#39;nii.gz&#39;, nipype
         default value: nii)
        input and output file type
        flag: -it %s
invert_x: (a boolean)
        invert x component of the vector
        flag: -ix
invert_y: (a boolean)
        invert y component of the vector
        flag: -iy
invert_z: (a boolean)
        invert z component of the vector
        flag: -iz
limit: (an integer)
        in some special case, such as heart data, some track may go into
         infinite circle and take long time to stop. this option allows
         setting a limit for the longest tracking steps (voxels)
        flag: -limit %d
mask1_threshold: (a float)
        threshold value for the first mask image, if not given, the program
        will try automatically find the threshold
mask2_file: (a file name)
        second mask image
        flag: -m2 %s, position: 4
mask2_threshold: (a float)
        threshold value for the second mask image, if not given, the program
        will try automatically find the threshold
out_file: (a file name, nipype default value: tracks.trk)
        output track file
        flag: %s, position: 1
random_seed: (an integer)
        use random location in a voxel instead of the center of the voxel
         to seed. can also define number of seed per voxel. default is 1
        flag: -rseed %s
runge_kutta2: (a boolean)
        use 2nd order runge-kutta method for tracking.
         default tracking method is non-interpolate streamline
        flag: -rk2
slice_order: (an integer)
        set the slice order. 1 means normal, -1 means reversed. default
        value is 1
        flag: -sorder %d
step_length: (a float)
        set step length, in the unit of minimum voxel size.
         default value is 0.1.
        flag: -l %f
swap_xy: (a boolean)
        swap x and y vectors while tracking
        flag: -sxy
swap_yz: (a boolean)
        swap y and z vectors while tracking
        flag: -syz
swap_zx: (a boolean)
        swap x and z vectors while tracking
        flag: -szx
voxel_order: (&#39;RAS&#39; or &#39;RPS&#39; or &#39;RAI&#39; or &#39;RPI&#39; or &#39;LAI&#39; or &#39;LAS&#39; or
         &#39;LPS&#39; or &#39;LPI&#39;)
        specify the voxel order in RL/AP/IS (human brain) reference. must be
         3 letters with no space in between.
         for example, RAS means the voxel row is from L-&gt;R, the column
         is from P-&gt;A and the slice order is from I-&gt;S.
         by default voxel order is determined by the image orientation
         (but NOT guaranteed to be correct because of various standards).
         for example, siemens axial image is LPS, coronal image is LIP and
         sagittal image is PIL.
         this information also is NOT needed for tracking but will be saved
         in the track file and is essential for track display to map onto
         the right coordinates
        flag: -vorder %s
</pre></div>
</div>
<p>Outputs:</p>
<div class="highlight-python"><div class="highlight"><pre>track_file: (an existing file name)
        output track file
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
        &copy; Copyright 2009-14, Neuroimaging in Python team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
</div>

  </body>
</html>