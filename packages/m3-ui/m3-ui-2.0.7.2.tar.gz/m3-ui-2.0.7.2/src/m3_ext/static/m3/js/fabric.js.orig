/**
 * "Класс" для построения UI
 *
 * @param config
 * @constructor
 */

function loadJavaScriptSync(filePath) {
    var req = new XMLHttpRequest();
    req.open("GET", filePath, false); // 'false': synchronous.
    req.send(null);

    var headElement = document.getElementsByTagName("head")[0];
    var newScriptElement = document.createElement("script");
    newScriptElement.type = "text/javascript";
    newScriptElement.text = req.responseText;
    headElement.appendChild(newScriptElement);
}

UI = function (config) {

    this.confStorage = config['confStorage']; // хранилище базовых конфигураций окон
    this.uiFabric = config['uiFabric'];       // собственно, формирователь UI


    Ext.create = function (cfg, defaultType) {
        var xtype = cfg.xtype || defaultType,
            Class = Ext.ComponentMgr.types[xtype];

        if (cfg.render) {
            return cfg;
        }

        debugger;
        if (xtype && !(Class)) {
            loadJavaScriptSync(config['staticPrefix'] + '/m3/js/ext-extensions/' + xtype + '.js');
            debugger;
            if (!Ext.ComponentMgr.types[xtype]){
                debugger;
            }
            return new Ext.ComponentMgr.types[xtype](cfg);
        } else {
            return new Class(cfg);
        }

    };


    UI.create = function (data) {         // словарь параметров должен содержать
        var initialData = data['data'],    // - словарь данных для инициализации
            key = data['ui'];              // - key, однозначно идентифицирующий окно в хранилище

        // грузим конфиг и данные из хранилища...
        return this.confStorage(key)
            .then(function (result) {
                // ..., данные затем патчим инициализирующими данными,...
                var data = Ext.apply(result.data || {}, initialData || {});
                return [result.config, data];
            }).then(function (cfg) {
                var module = cfg[0]['xtype'],
                    result = Q.defer();

                // Не загружаем модули для списка исключений
                if (config['requireExclude'].indexOf(module) >= 0) {
                    result.resolve(cfg);
                } else {

                    require([config['staticPrefix'] + module + '.js'], function () {
                        if (config['debug']) {
                            require.undef(config['staticPrefix'] + module + '.js');
                        }
                        result.resolve(cfg);
                    });
                }
                return result.promise;
            }).then(function (cfgAndData) {
                // формируем UI widget
                var win = this.uiFabric(cfgAndData[0]),
                    data = cfgAndData[1];
                if (win.bind) {
                    win.initialData = data;
                    win.bind(data);
                }
                return win;
            }.bind(this));
    }.bind(this);
};

/**
 * Загружает JSON AJAX-запросом и кладёт в promise
 * @param cfg
 * @returns {promise|Q.promise}
 */
UI.ajax = function (cfg) {
    var result = Q.defer();

    cfg = Ext.applyIf(cfg, {
        method: 'GET'
    });

    var obj = Ext.applyIf({
        success: function () {
            result.resolve.apply(this, arguments);
        },
        failure: function (response) {
            result.reject(response);
        }
    }, cfg);
    Ext.Ajax.request(obj);
    return result.promise;
};

/**
 *
 * @param cfg
 * @returns {promise|Q.promise}
 */
UI.msgBox = function (cfg) {
    var result = Q.defer();
    Ext.Msg.show(Ext.apply(cfg, {fn: result.resolve}));
    return result.promise;
};

/**
 *
 * @param response
 * @returns {*}
 */
UI.evalResult = function (response) {
    var obj = Ext.decode(response.responseText);
    if (!obj) {
        return null;
    }

    return new Q(
    ).then(function () {
            if (obj.message) {
                return msgBox({
                    title: 'Внимание',
                    msg: obj.message,
                    buttons: Ext.Msg.OK,
                    icon: (
                        obj.success != undefined && !obj.success
                        ) ? Ext.Msg.WARNING : Ext.Msg.Info
                });
            }
            return null;
        }).then(function () {
            if (obj.code) {
                if (obj.code.ui) {

                    return UI.create(obj.code)
                        .then(function (win) {

                            AppDesktop.getDesktop()
                                .createWindow(win)
                                .show();

                            return win;
                        })

                } else {
                    return obj.code;
                }
            } else {
                return obj;
            }
        }.bind(this));
};

/**
 *
 * @param cfg Конфигурация для отправки запроса и получения ui-данных
 *
 * Например:
 *
 *         callAction({
 *            scope: this,
 *            beforeRequest: 'beforenewrequest',
 *            afterRequest: 'afternewrequest',
 *            request: {
 *                url: this.actionNewUrl,
 *                params: params,
 *                success: this.onNewRecordWindowOpenHandler.createDelegate(this),
 *                failure: uiAjaxFailMessage
 *            },
 *            mask: this.loadMask
 *         });
 *
 * @returns {*} q-object
 */
UI.callAction = function (cfg) {

    var scope = cfg['scope'],
        success = cfg['success'] || cfg['request']['success'],
        failure = cfg['failure'] || cfg['request']['failure'] || uiAjaxFailMessage,
        beforeRequest = cfg['beforeRequest'],
        afterRequest = cfg['afterRequest'],
        request = cfg['request'],
        mask = cfg['mask'];


    if (beforeRequest && !scope.fireEvent(beforeRequest, scope, request)) {
        // Событие до запроса обработано
        return null;
    }

    if (mask) {
        mask.show();
    }

    var ui = UI.ajax(request);

    if (afterRequest) {
        ui = ui.then(function (res, opt) {
            if (!scope.fireEvent(afterRequest, scope, res, opt)) {
                return Q.reject({'eventProcessed': true});
            }
            return arguments;
        });
        ui = ui.spread(this.evalResult.bind(this));
    } else {
        ui = ui.then(this.evalResult.bind(this));
    }

    if (success) {
        ui = ui.then(success)
    }

    ui = ui.catch(function (e) {
        // Если событие после запроса не обработано
        if (!e['eventProcessed'] && failure) {
            failure(e);
            e.eventProcessed = true;
            throw e;
        }
    });

    if (mask) {
        ui = ui.finally(function () {
            mask.hide()
        })
    }
    return ui;
};
