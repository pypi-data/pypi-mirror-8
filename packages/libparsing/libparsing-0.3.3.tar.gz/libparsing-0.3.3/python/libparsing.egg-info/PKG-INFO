Metadata-Version: 1.1
Name: libparsing
Version: 0.3.3
Summary: Python wrapper for libparsing, a PEG-based parsing library written in C
Home-page: https://github.com/sebastien/libparsing
Author: SÃ©bastien Pierre
Author-email: UNKNOWN
License: BSD
Description: 
        <p><code>libparsing</code> is a parsing element grammar (PEG) library written in C with Python bindings. It offers decent performance while allowing for a lot of flexibility. It is mainly intended to be used to create programming languages and software engineering tools.</p><p>As opposed to more traditional parsing techniques, the grammar is not compiled but constructed using an API that allows dynamic update of the grammar.</p><p>The parser does not do any tokeninzation, the instead input stream is consumed and parsing elements are dynamically asked to match the next element of it. Once parsing elements match, the resulting matched input is processed and an action is triggered.</p><p><code>libparsing</code> supports the following features:</p><ul><li><span class='term'>backtracking</span>, ie. going back in the input stream if a match is not found </li><li><span class='term'>cherry-picking</span>, ie. skipping unrecognized input </li><li><span class='term'>contextual rules</span>, ie. a rule that will match or not depending on external variables</li></ul><p>Parsing elements are usually slower than compiled or FSM-based parsers as they trade performance for flexibility. It's probably not a great idea to use <code>libparsing</code> if the parsing has to happen as fast as possible (ie. a protocol implementation), but it is a great use for programming languages, as it opens up the door to dynamic syntax plug-ins and multiple language embedding.</p><p>If you're interested in PEG, you can start reading Brian Ford's original article. Projects such as PEG/LEG by Ian Piumarta <a href="http://piumarta.com/software/peg/" target="_blank">http://piumarta.com/software/peg/</a> ,OMeta by Alessandro Warth <a href="http://www.tinlizzie.org/ometa/" target="_blank">http://www.tinlizzie.org/ometa/</a> or Haskell's Parsec library <a href="https://www.haskell.org/haskellwiki/Parsec" target="_blank">https://www.haskell.org/haskellwiki/Parsec</a> are of particular interest in the field.</p><p>Here is a short example of what creating a simple grammar looks like in Python:</p><pre><code>g = Grammar()
        s = g.symbols
        g.token("WS",       "\s+")
        g.token("NUMBER",   "\d+(\.\d+)?")
        g.token("VARIABLE", "\w+")
        g.token("OPERATOR", "[\/\+\-\*]")
        g.group("Value",     s.NUMBER, s.VARIABLE)
        g.rule("Suffix",     s.OPERATOR._as("operator"), s.Value._as("value"))
        g.rule("Expression", s.Value, s.Suffix.zeroOrMore())
        g.axiom(s.Expression)
        g.skip(s.WS)
        match = g.parseString("10 + 20 / 5")</code></pre><p>and the equivalent code in C</p><pre><code>Grammar* g = Grammar_new()
        SYMBOL(WS,         TOKEN("\\s+"))
        SYMBOL(NUMBER,     TOKEN("\\d+(\\.\\d+)?"))
        SYMBOL(VARIABLE,   TOKEN("\\w+"))
        SYMBOL(OPERATOR,   GROUP("[\\/\\+\\-\\*]"))
        SYMBOL(Value,      GOUP(_S(NUMBER), _S(VARIABLE)))
        SYMBOL(Suffix,     RULE(_AS(_S(OPERATOR), "operator"), _AS(_S(Value), "value")))
        SYMBOL(Expression, RULE(_S(Value), _MO(Suffix))
        g-&gt;axiom = s_Expression;
        g-&gt;skip(s_WS);
        Grammar_prepare(g);
        Match* match = Grammar_parseString(g, "10 + 20 / 5")</code></pre>
        
        
Keywords: parsing PEG grammar libparsing
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Topic :: Software Development :: Build Tools
Classifier: License :: OSI Approved :: BSD License
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.6
Classifier: Programming Language :: Python :: 2.7
