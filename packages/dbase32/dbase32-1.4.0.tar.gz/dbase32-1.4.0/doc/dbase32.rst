:mod:`dbase32` API
==================

.. py:module:: dbase32
    :synopsis: base32-encoding with a sorted-order alphabet (for databases)


The :mod:`dbase32` API consists of just six functions:

    * For encoding and decoding, there is :func:`db32enc()` and :func:`db32dec()`

    * For validation, there is :func:`isdb32()` and :func:`check_db32()`

    * :func:`random_id()` generates Dbase32 encoded random IDs

    * :func:`time_id()` generates random IDs that will sort by timestamp



Tutorial
--------

Encode a ``bytes`` instance with :func:`db32enc()`:

>>> from dbase32 import db32enc
>>> db32enc(b'binary foo')
'FCNPVRELI7J9FUUI'

Decode the resulting ``str`` instance with :func:`db32dec()`:

>>> from dbase32 import db32dec
>>> db32dec('FCNPVRELI7J9FUUI')
b'binary foo'

:func:`db32dec()` can also directly decode UTF-8 encoded ``bytes``:

>>> db32dec(b'FCNPVRELI7J9FUUI')
b'binary foo'

Use :func:`isdb32()` to test whether you have a valid Dbase32 encoded ID.  It
will return ``True`` if the ID is valid:

>>> from dbase32 import isdb32
>>> isdb32('FCNPVRELI7J9FUUI')
True

And will return ``False`` if the ID contains invalid characters:

>>> isdb32('FCNPVRELI7J9FUUZ')
False

Or will also return ``False`` if the ID is the wrong length:

>>> isdb32('FCNPVRELI7J9FUU')
False

You can likewise use :func:`check_db32()` to validate an ID.  It will return
``None`` if the ID is valid:

>>> from dbase32 import check_db32
>>> check_db32('FCNPVRELI7J9FUUI')

And will raise a ``ValueError`` if the ID contains invalid characters:

>>> check_db32('FCNPVRELI7J9FUUZ')  # doctest: -IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
  ...
ValueError: invalid Dbase32: 'FCNPVRELI7J9FUUZ'

Or will also raise a ``ValueError`` if the ID is the wrong length:

>>> check_db32('FCNPVRELI7J9FUU')  # doctest: -IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
  ...
ValueError: len(text) is 15, need len(text) % 8 == 0

When you don't need the decoded ID, it's faster to validate with
:func:`isdb32()` or :func:`check_db32()` than to validate with :func:`db32dec()`
and throw away the needlessly decoded value.

Use :func:`random_id()` to generate a Dbase32 encoded random ID.  By default it
returns a 120-bit (15-byte) ID, which will be 24 characters in length when
Dbase32 encoded:

>>> from dbase32 import random_id
>>> random_id()  # doctest: +SKIP
'UGT6U75VTJL8IRBBPRFONKOQ'

The *numbytes* keyword argument defaults to ``15``, but you can override this
to get an ID of a different length.  For example, you might want to create a
well-formed 240-bit (30-byte) `Dmedia`_ file ID for unit testing, which will be
48 characters in length when Dbase32 encoded:

>>> random_id(30)  # doctest: +SKIP
'AU8HC68B9IC6AY6B3NHWOGCI9VK4MTOUSFLWRD7TLQBC56MN'

:func:`random_id()` gets its random data from ``os.urandom()``.  This:

>>> _id = random_id(15)

Is equivalent to this:

>>> import os
>>> _id = db32enc(os.urandom(15))

Although note that the C implementation of :func:`random_id()` is faster than
the above because it does everything internally with no back-and-forth between
Python and C.

Lastly, use :func:`time_id()` to generate random IDs that will sort according to
their Unix timestamp with a one second granularity.

Similar to :func:`random_id()`, :func:`time_id()` returns a 120-bit (15-byte)
ID, which will be 24 characters in length when Dbase32 encoded.  The difference
is the first 4 bytes contain the Unix timestamp (32-bit unsigned big endian),
and the remaining 11 bytes are from ``os.urandom()``.

If you don't provide the *timestamp* argument, it will be automatically
generated by calling ``time.time()``:

>>> time_id()  # doctest: +SKIP
'DBFL77QDNXTGB7GB3JB9YCCK'

Or you can provide your own timestamp, for example to use a timestamp already
generated for another purpose:

>>> time_id(1234567890)  # doctest: +SKIP
'C9E38NQ89VDDM5DAI8NGWGN5'



Well-formed IDs
---------------

Dbase32 is not designed to encode arbitrary data.  Instead, it's designed only
to encode well-formed IDs like those used in `Dmedia`_ and `Novacut`_.

Unlike standard `RFC-3548 Base32`_ encoding, Dbase32 does *not* support
padding.  The binary data must always be a multiple of 40 bits (5 bytes) in
length.

Well-formed *data* to be encoded must meet the following condition::

    5 <= len(data) <= 60 and len(data) % 5 == 0

If this condition isn't met, :func:`db32enc()` will raise a ``ValueError``.

In addition to only containing letters in :data:`DB32ALPHABET`, well-formed
*text* to be decoded must meet the following condition::

    8 <= len(text) <= 96 and len(text) % 8 == 0

If this condition isn't met, both :func:`db32dec()` and :func:`check_db32()`
will raise a ``ValueError``.  Likewise, if this condition isn't met,
:func:`isdb32()` will return ``False``.



Functions
---------

.. function:: db32enc(data)

    Encode *data* as Dbase32 text.

    A ``str`` instance is returned:

    >>> db32enc(b'Bytes')
    'BCVQBSEM'

    *data* must be a ``bytes`` instance that meets the following condition::

        5 <= len(data) <= 60 and len(data) % 5 == 0

    If the above condition is not met, a ``ValueError`` is raised.


.. function:: db32dec(text)

    Decode Dbase32 *text*.

    A ``bytes`` instance is returned:

    >>> db32dec('BCVQBSEM')
    b'Bytes'

    *text* must be a ``str`` or ``bytes`` instance that meets the following
    condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    If the above condition is not met, or if *text* contains any letters not
    in :data:`DB32ALPHABET`, a ``ValueError`` is raised.


.. function:: isdb32(text)

    Return ``True`` if *text* contains a valid Dbase32 encoded ID.

    >>> isdb32('39AYA9AY')
    True
    >>> isdb32('27AZ27AZ')
    False

    This function will only return ``True`` if *text* contains only letters
    in :data:`DB32ALPHABET`, and if *text* meets following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    Otherwise, ``False`` is returned.


.. function:: check_db32(text)

    Raise a ``ValueError`` if *text* is not a valid Dbase32 encoded ID.

    This function will raise a ``ValueError`` if *text* contains any letters
    that are not in :data:`DB32ALPHABET`.  For example:

    >>> check_db32('39AYA9AY')
    >>> check_db32('39AY27AZ')  # doctest: -IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
      ...
    ValueError: invalid Dbase32: '39AY27AZ'

    This function will likewise raise a ``ValueError`` if *text* doesn't meet
    the following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    If *text* is a valid Dbase32 ID, this function returns ``None``.


.. function:: random_id(numbytes=15)

    Return a Dbase32 encoded random ID.

    By default, a 120-bit (15-byte) ID is returned, which will be 24
    characters in length when Dbase32 encoded:

    >>> random_id()  # doctest: +SKIP
    'XM4OINLIPO6VVF549TWYNK89'

    If provided, *numbytes* must be an ``int`` such that::

        5 <= numbytes <= 60 and numbytes % 5 == 0

    The random data is from ``os.urandom()``.


.. function:: time_id(timestamp=-1)

    Return a Dbase32 encoded random ID that will sort according to timestamp.

    These IDs will sort in ascending order according to the Unix timestamp, with
    a one second granularity.

    Similar to :func:`random_id()`, this function returns a 120-bit (15-byte)
    ID, which will be 24 characters in length when Dbase32 encoded.

    The difference is the first 4 bytes of this ID are the time since the Unix
    Epoch in seconds, truncated a 32-bit unsigned integer (which wont overflow
    till the year 2106).  The remaining 11 bytes are from ``os.urandom()``.

    This function is aimed at event logging and similar scenarios where it's
    handy for the IDs to sort chronologically.

    If you provide the optional *timestamp* kwarg, that timestamp will be used.
    Otherwise the timestamp is built by calling ``time.time()``.



Constants
---------

The :mod:`dbase32` module defines several handy constants:

.. data:: using_c_extension

    A flag indicating whether the Dbase32 `C implementation`_ is being used.

    >>> import dbase32
    >>> dbase32.using_c_extension
    True

    This will be ``True`` when the ``dbase32._dbase32`` C extension is being
    used, or ``False`` when the ``dbase32._dbase32py`` pure-Python fallback is
    being used.

    For both security and performance reasons, only the `C implementation`_ is
    recommended for production use.  As such, 3rd party software might want to
    use this attribute in their unit tests and/or runtime initialization to
    verify that the Dbase32 C extension is in fact being used.

    Please see :doc:`security` for more details.

    .. versionadded:: 1.4


.. data:: DB32ALPHABET

    A ``str`` containing the Dbase32 alphabet.

    >>> import dbase32
    >>> dbase32.DB32ALPHABET
    '3456789ABCDEFGHIJKLMNOPQRSTUVWXY'

    Note that the Dbase32 alphabet (encoding table) is in ASCII/UTF-8 sorted
    order:

    >>> dbase32.DB32ALPHABET == ''.join(sorted(set(dbase32.DB32ALPHABET)))
    True 


.. data:: MAX_BIN_LEN

    Max length of data (in bytes) accepted for encoding.

    >>> import dbase32
    >>> dbase32.MAX_BIN_LEN
    60
    >>> dbase32.MAX_BIN_LEN * 8  # 480 bits
    480

    This constraint is used by :func:`db32enc()`, :func:`random_id()`, and
    :func:`time_id()`.


.. data:: MAX_TXT_LEN

    Max length of text (in characters) accepted for decoding or validation.

    >>> import dbase32
    >>> dbase32.MAX_TXT_LEN
    96
    >>> dbase32.MAX_TXT_LEN * 5 // 8 == dbase32.MAX_BIN_LEN
    True

    This constraint is used by :func:`db32dec()`, :func:`isdb32()`, and
    :func:`check_db32()`.


.. data:: RANDOM_BITS

    Default size (in bits) of the *decoded* ID generated by :func:`random_id()`.

    >>> import dbase32
    >>> dbase32.RANDOM_BITS
    120


.. data:: RANDOM_BYTES

    Default size (in bytes) of the *decoded* ID generated by :func:`random_id()`.

    >>> import dbase32
    >>> dbase32.RANDOM_BYTES
    15
    >>> dbase32.RANDOM_BYTES * 8 == dbase32.RANDOM_BITS
    True


.. data:: RANDOM_B32LEN

    Default size (in characters) of the ID generated by :func:`random_id()`.

    >>> import dbase32
    >>> dbase32.RANDOM_B32LEN
    24
    >>> dbase32.RANDOM_B32LEN * 5 // 8 == dbase32.RANDOM_BYTES
    True



.. _`Dbase32`: https://launchpad.net/dbase32
.. _`RFC-3548 Base32`: https://tools.ietf.org/html/rfc4648
.. _`Novacut`: https://launchpad.net/novacut
.. _`Dmedia`: https://launchpad.net/dmedia

.. _`C implementation`: http://bazaar.launchpad.net/~dmedia/dbase32/trunk/view/head:/dbase32/_dbase32.c

