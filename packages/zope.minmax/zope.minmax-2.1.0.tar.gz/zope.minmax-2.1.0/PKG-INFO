Metadata-Version: 1.1
Name: zope.minmax
Version: 2.1.0
Summary: Homogeneous values favoring maximum or minimum for ZODB conflict resolution
Home-page: http://pypi.python.org/pypi/zope.minmax/
Author: Zope Foundation and Contributors
Author-email: zope-dev@zope.org
License: ZPL 2.1
Description: ``zope.minmax``
        ===============
        
        This package provides support for homogeneous values favoring maximum
        or minimum for ZODB conflict resolution.  See
        ``src/zope/minmax/minmax.txt`` for a detailed description.
        
        
        Detailed Documentation
        ----------------------
        
        Conflict Resolution using Maximum or Minimum Values
        ===================================================
        
        The `zope.minmax.AbstractValue` class provides a super class which can
        be subclassed to store arbitrary *homogeneous* values in a persistent
        storage and apply different conflict resolution policies.
        
        The subclasses defined here are resolving the conflicts using always
        either the maximum or the minimum of the conflicting values.
        
        Maximum
        -------
        
        The `zope.minmax.Maximum` class always resolves conflicts favoring the
        maximum value.  Let's instantiate one object and verify that it
        satisfies the interface.
        
            >>> import zope.minmax
            >>> import zope.interface.verify
            >>> max_favored = zope.minmax.Maximum()
            >>> zope.interface.verify.verifyObject(
            ...     zope.minmax.interfaces.IAbstractValue, max_favored)
            True
        
        We can confirm that the initial value is zero.
        
            >>> bool(max_favored)
            False
            >>> print(max_favored.value)
            None
        
        Now, we can store a new value in the object.
        
            >>> max_favored.value = 11
            >>> print(max_favored.value)
            11
            >>> bool(max_favored)
            True
        
        Or we can use the methods.
        
            >>> max_favored.__setstate__(4532)
            >>> max_favored.__getstate__()
            4532
            >>> print(max_favored.value)
            4532
            >>> bool(max_favored)
            True
        
        Do notice that using a direct assignment to the value attribute is a
        more natural use.
        
        Minimum
        -------
        
        The `zope.minmax.Minimum` class always resolves conflicts favoring the
        minimum value.  Again, we instantiate an object and verify that it
        satisfies the interface.
        
            >>> min_favored = zope.minmax.Minimum()
            >>> zope.interface.verify.verifyObject(
            ...     zope.minmax.interfaces.IAbstractValue, min_favored)
            True
        
        We need a confirmation that the initial value is zero.
        
            >>> bool(min_favored)
            False
            >>> print(min_favored.value)
            None
        
        Let's populate this one too.
        
            >>> min_favored.value = 22
            >>> print(min_favored.value)
            22
            >>> bool(min_favored)
            True
        
        Or we can use the methods, again.
        
            >>> min_favored.__setstate__(8796)
            >>> min_favored.__getstate__()
            8796
            >>> print(min_favored.value)
            8796
            >>> bool(min_favored)
            True
        
        Please, notice, again, that using a direct assignment to the value
        attribute is a more natural use.
        
        Conflict Resolution
        -------------------
        
        Now, we need to exercise the conflict resolution interface.
        First for the `zope.minmax.Maximum`:
        
        Let's try differing values larger than the old value.
        
            >>> max_favored._p_resolveConflict(max_favored.value, 4536, 4535)
            4536
            >>> max_favored._p_resolveConflict(max_favored.value, 4573, 4574)
            4574
        
        What happens when all the values are equal, including the old.
        
            >>> max_favored._p_resolveConflict(max_favored.value, 4532, 4532)
            4532
        
        Notice that when the old value is larger than both the committed and
        new, it is still disregarded.
        
            >>> max_favored._p_resolveConflict(max_favored.value, 4531, 4530)
            4531
        
        Now, the `zope.minmax.Minimum`:
        
        Let's try differing values smaller than the old value.
        
            >>> min_favored._p_resolveConflict(min_favored.value, 8792, 8791)
            8791
            >>> min_favored._p_resolveConflict(min_favored.value, 8785, 8786)
            8785
        
        What happens when all the values are equal, including the old.
        
            >>> min_favored._p_resolveConflict(min_favored.value, 8796, 8796)
            8796
        
        Notice that when the old value is smaller than both the committed and
        new, it is still disregarded.
        
            >>> min_favored._p_resolveConflict(min_favored.value, 8798, 8799)
            8798
        
        How about an example that is not numerical?
        
            >>> max_word = zope.minmax.Maximum('joy')
            >>> print(max_word.value)
            joy
            >>> bool(max_word)
            True
            >>> max_word._p_resolveConflict(max_word.value, 'happiness', 'exuberance')
            'happiness'
            >>> max_word._p_resolveConflict(max_word.value, 'exuberance', 'happiness')
            'happiness'
            >>> min_word = zope.minmax.Minimum(max_word.value)
            >>> print(min_word.value)
            joy
            >>> bool(min_word)
            True
            >>> min_word._p_resolveConflict(min_word.value, 'happiness', 'exuberance')
            'exuberance'
            >>> min_word._p_resolveConflict(min_word.value, 'exuberance', 'happiness')
            'exuberance'
        
        As indicated, we don't need to have numbers, just *homegeneous* items.
        The homogeneous values are not really inherently required.  However, it
        makes no sense to apply min() or max() on, say, one number and one
        string.  Simply, the ordering relations do not work at all on
        heterogeneous values.
        
        
        Changes
        =======
        
        2.1.0 (2014-12-27)
        ------------------
        
        - Add support for PyPy3.
        
        - Add support Python 3.4.
        
        
        2.0.0 (2013-02-19)
        ------------------
        
        - Add support for Python 3.3 and PyPy.
        
        - Replace deprecated ``zope.interface.implements`` usage with equivalent
          ``zope.interface.implementer`` decorator.
        
        - Drop support for Python 2.4 and 2.5.
        
        
        1.1.2 (2009-09-24)
        ------------------
        
        - Use the standard Python doctest module instead of the deprecated
          zope.testing.doctest.
        
        
        1.1.1 (2009-09-09)
        ------------------
        
        - Fix homepage link and mailing list address.
        
        
        1.1 (2007-10-02)
        ----------------
        
        - Refactor package setup.
        
        
        1.0 (2007-09-28)
        ----------------
        
        - No further changes since 1.0b2
        
        
        1.0b2 (2007-07-09)
        ------------------
        
        - Remove ``_p_independent`` method from ``AbstractValue`` class.
        
        
        1.0b1 (2007-07-03)
        ------------------
        
        - Initial release.
        
Keywords: zope3 zope zodb minimum maximum conflict resolution
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Environment :: Web Environment
Classifier: Framework :: Zope3
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Zope Public License
Classifier: Natural Language :: English
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.6
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Programming Language :: Python :: Implementation :: PyPy
Classifier: Topic :: Internet :: WWW/HTTP
Classifier: Topic :: Software Development :: Libraries :: Python Modules
