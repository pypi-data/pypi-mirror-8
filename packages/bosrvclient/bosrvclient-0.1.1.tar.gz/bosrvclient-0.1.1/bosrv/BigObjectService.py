#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def ping(self):
    """
    @brief   Method to examine state of service
    """
    pass

  def star_apply(self, token, srvname, cmd_stmt, autocommit):
    """
    Parameters:
     - token
     - srvname
     - cmd_stmt
     - autocommit
    """
    pass

  def sql_begin(self, token):
    """
    @brief   Method to mark the begin of an transaction

    Parameters:
     - token
    """
    pass

  def sql_commit(self, token, resource):
    """
    @brief   Method to mark the end of an transaction

    Parameters:
     - token
     - resource
    """
    pass

  def sql_execute_many(self, token, resource, sql_stmt):
    """
    @brief   Method to take a constructed sql statement and run
             This is to compliment sql_begin returned resource
    @return  Created resource when applicable

    Parameters:
     - token
     - resource
     - sql_stmt
    """
    pass

  def sql_execute(self, token, sql_stmt, autocommit):
    """
    @brief   Method to take a constructed sql statement and run
    @return  Created resource when applicable

    Parameters:
     - token
     - sql_stmt
     - autocommit
    """
    pass

  def aux_execute(self, token, stmt, autocommit):
    """
    Parameters:
     - token
     - stmt
     - autocommit
    """
    pass

  def assoc_execute(self, token, stmt, autocommit):
    """
    Parameters:
     - token
     - stmt
     - autocommit
    """
    pass

  def cursor_fetch(self, token, resource, rng):
    """
    @brief   Method to fetch data defined in the range of RangeSpec
    @return  JSON object of rows of tuples defined by the target resource
             [
                 [...],
                 [...],
                 ...
                 -1 // Indicator for EOL in the table
             ]

    Parameters:
     - token
     - resource
     - rng
    """
    pass

  def cursor_dup(self, token, resource, count):
    """
    @brief   Method to duplicate the cursor (increase reference count to the
             result table
    @return  A new set of handles resovled to the same result table pointed
             by "resource".  This is represented by a JSON object
             [
                 cursor_1,
                 cursor_2,
                 ...
             ]
             As many as there are defined by count.  Cursors will be evenly
             spaced (determined by the server)

             On return, the base handle from which we copied from will be
             closed and invalid.  Operate on the new resource ONLY!!

    Parameters:
     - token
     - resource
     - count
    """
    pass

  def cursor_close(self, token, resource):
    """
    @brief   Method to close the resource under this cursor.

             Call to this method may not necessarily result in resource
             recycled.  Only the last reference to this resource (created by
             cursor_dup) closed will the resource really be recycled

    Parameters:
     - token
     - resource
    """
    pass

  def get_table_list(self, token, path):
    """
    @brief   Method to retreive list of created resources at location

    Parameters:
     - token
     - path
    """
    pass

  def get_table_schema(self, token, table_name, path):
    """
    @brief   Method to retreive metadata regarding resource at location

    Parameters:
     - token
     - table_name
     - path
    """
    pass

  def get_table_relation(self, token, table_name, path):
    """
    @brief   Method to retreive relation of table to its dimensions (?)

    Parameters:
     - token
     - table_name
     - path
    """
    pass

  def get_table_create_stmt(self, token, resource, inmemory):
    """
    @brief   Method to retreive resource's original create statement

    Parameters:
     - token
     - resource
     - inmemory
    """
    pass

  def get_qbo_list(self, token, path):
    """
    @brief   Method to retreive list of created resources at location

    Parameters:
     - token
     - path
    """
    pass

  def get_qbo_info(self, token, table_name, path):
    """
    @brief   Method to retreive metadata regarding resource at location

    Parameters:
     - token
     - table_name
     - path
    """
    pass

  def get_mbt_list(self, token, path):
    """
    @brief   Method to retreive list of created resources at location

    Parameters:
     - token
     - path
    """
    pass

  def get_mbt_info(self, token, table_name, path):
    """
    @brief   Method to retreive metadata regarding resource at location

    Parameters:
     - token
     - table_name
     - path
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def ping(self):
    """
    @brief   Method to examine state of service
    """
    self.send_ping()
    return self.recv_ping()

  def send_ping(self):
    self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
    args = ping_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ping(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ping_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ping failed: unknown result");

  def star_apply(self, token, srvname, cmd_stmt, autocommit):
    """
    Parameters:
     - token
     - srvname
     - cmd_stmt
     - autocommit
    """
    self.send_star_apply(token, srvname, cmd_stmt, autocommit)
    return self.recv_star_apply()

  def send_star_apply(self, token, srvname, cmd_stmt, autocommit):
    self._oprot.writeMessageBegin('star_apply', TMessageType.CALL, self._seqid)
    args = star_apply_args()
    args.token = token
    args.srvname = srvname
    args.cmd_stmt = cmd_stmt
    args.autocommit = autocommit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_star_apply(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = star_apply_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "star_apply failed: unknown result");

  def sql_begin(self, token):
    """
    @brief   Method to mark the begin of an transaction

    Parameters:
     - token
    """
    self.send_sql_begin(token)
    return self.recv_sql_begin()

  def send_sql_begin(self, token):
    self._oprot.writeMessageBegin('sql_begin', TMessageType.CALL, self._seqid)
    args = sql_begin_args()
    args.token = token
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sql_begin(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sql_begin_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sql_begin failed: unknown result");

  def sql_commit(self, token, resource):
    """
    @brief   Method to mark the end of an transaction

    Parameters:
     - token
     - resource
    """
    self.send_sql_commit(token, resource)
    return self.recv_sql_commit()

  def send_sql_commit(self, token, resource):
    self._oprot.writeMessageBegin('sql_commit', TMessageType.CALL, self._seqid)
    args = sql_commit_args()
    args.token = token
    args.resource = resource
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sql_commit(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sql_commit_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.sqlerr is not None:
      raise result.sqlerr
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sql_commit failed: unknown result");

  def sql_execute_many(self, token, resource, sql_stmt):
    """
    @brief   Method to take a constructed sql statement and run
             This is to compliment sql_begin returned resource
    @return  Created resource when applicable

    Parameters:
     - token
     - resource
     - sql_stmt
    """
    self.send_sql_execute_many(token, resource, sql_stmt)
    return self.recv_sql_execute_many()

  def send_sql_execute_many(self, token, resource, sql_stmt):
    self._oprot.writeMessageBegin('sql_execute_many', TMessageType.CALL, self._seqid)
    args = sql_execute_many_args()
    args.token = token
    args.resource = resource
    args.sql_stmt = sql_stmt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sql_execute_many(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sql_execute_many_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.sqlerr is not None:
      raise result.sqlerr
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sql_execute_many failed: unknown result");

  def sql_execute(self, token, sql_stmt, autocommit):
    """
    @brief   Method to take a constructed sql statement and run
    @return  Created resource when applicable

    Parameters:
     - token
     - sql_stmt
     - autocommit
    """
    self.send_sql_execute(token, sql_stmt, autocommit)
    return self.recv_sql_execute()

  def send_sql_execute(self, token, sql_stmt, autocommit):
    self._oprot.writeMessageBegin('sql_execute', TMessageType.CALL, self._seqid)
    args = sql_execute_args()
    args.token = token
    args.sql_stmt = sql_stmt
    args.autocommit = autocommit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sql_execute(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sql_execute_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.sqlerr is not None:
      raise result.sqlerr
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sql_execute failed: unknown result");

  def aux_execute(self, token, stmt, autocommit):
    """
    Parameters:
     - token
     - stmt
     - autocommit
    """
    self.send_aux_execute(token, stmt, autocommit)
    return self.recv_aux_execute()

  def send_aux_execute(self, token, stmt, autocommit):
    self._oprot.writeMessageBegin('aux_execute', TMessageType.CALL, self._seqid)
    args = aux_execute_args()
    args.token = token
    args.stmt = stmt
    args.autocommit = autocommit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_aux_execute(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = aux_execute_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "aux_execute failed: unknown result");

  def assoc_execute(self, token, stmt, autocommit):
    """
    Parameters:
     - token
     - stmt
     - autocommit
    """
    self.send_assoc_execute(token, stmt, autocommit)
    return self.recv_assoc_execute()

  def send_assoc_execute(self, token, stmt, autocommit):
    self._oprot.writeMessageBegin('assoc_execute', TMessageType.CALL, self._seqid)
    args = assoc_execute_args()
    args.token = token
    args.stmt = stmt
    args.autocommit = autocommit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_assoc_execute(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = assoc_execute_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "assoc_execute failed: unknown result");

  def cursor_fetch(self, token, resource, rng):
    """
    @brief   Method to fetch data defined in the range of RangeSpec
    @return  JSON object of rows of tuples defined by the target resource
             [
                 [...],
                 [...],
                 ...
                 -1 // Indicator for EOL in the table
             ]

    Parameters:
     - token
     - resource
     - rng
    """
    self.send_cursor_fetch(token, resource, rng)
    return self.recv_cursor_fetch()

  def send_cursor_fetch(self, token, resource, rng):
    self._oprot.writeMessageBegin('cursor_fetch', TMessageType.CALL, self._seqid)
    args = cursor_fetch_args()
    args.token = token
    args.resource = resource
    args.rng = rng
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cursor_fetch(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cursor_fetch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cursor_fetch failed: unknown result");

  def cursor_dup(self, token, resource, count):
    """
    @brief   Method to duplicate the cursor (increase reference count to the
             result table
    @return  A new set of handles resovled to the same result table pointed
             by "resource".  This is represented by a JSON object
             [
                 cursor_1,
                 cursor_2,
                 ...
             ]
             As many as there are defined by count.  Cursors will be evenly
             spaced (determined by the server)

             On return, the base handle from which we copied from will be
             closed and invalid.  Operate on the new resource ONLY!!

    Parameters:
     - token
     - resource
     - count
    """
    self.send_cursor_dup(token, resource, count)
    return self.recv_cursor_dup()

  def send_cursor_dup(self, token, resource, count):
    self._oprot.writeMessageBegin('cursor_dup', TMessageType.CALL, self._seqid)
    args = cursor_dup_args()
    args.token = token
    args.resource = resource
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cursor_dup(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cursor_dup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cursor_dup failed: unknown result");

  def cursor_close(self, token, resource):
    """
    @brief   Method to close the resource under this cursor.

             Call to this method may not necessarily result in resource
             recycled.  Only the last reference to this resource (created by
             cursor_dup) closed will the resource really be recycled

    Parameters:
     - token
     - resource
    """
    self.send_cursor_close(token, resource)
    self.recv_cursor_close()

  def send_cursor_close(self, token, resource):
    self._oprot.writeMessageBegin('cursor_close', TMessageType.CALL, self._seqid)
    args = cursor_close_args()
    args.token = token
    args.resource = resource
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cursor_close(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cursor_close_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def get_table_list(self, token, path):
    """
    @brief   Method to retreive list of created resources at location

    Parameters:
     - token
     - path
    """
    self.send_get_table_list(token, path)
    return self.recv_get_table_list()

  def send_get_table_list(self, token, path):
    self._oprot.writeMessageBegin('get_table_list', TMessageType.CALL, self._seqid)
    args = get_table_list_args()
    args.token = token
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_list(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_list_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_list failed: unknown result");

  def get_table_schema(self, token, table_name, path):
    """
    @brief   Method to retreive metadata regarding resource at location

    Parameters:
     - token
     - table_name
     - path
    """
    self.send_get_table_schema(token, table_name, path)
    return self.recv_get_table_schema()

  def send_get_table_schema(self, token, table_name, path):
    self._oprot.writeMessageBegin('get_table_schema', TMessageType.CALL, self._seqid)
    args = get_table_schema_args()
    args.token = token
    args.table_name = table_name
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_schema(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_schema_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_schema failed: unknown result");

  def get_table_relation(self, token, table_name, path):
    """
    @brief   Method to retreive relation of table to its dimensions (?)

    Parameters:
     - token
     - table_name
     - path
    """
    self.send_get_table_relation(token, table_name, path)
    return self.recv_get_table_relation()

  def send_get_table_relation(self, token, table_name, path):
    self._oprot.writeMessageBegin('get_table_relation', TMessageType.CALL, self._seqid)
    args = get_table_relation_args()
    args.token = token
    args.table_name = table_name
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_relation(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_relation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_relation failed: unknown result");

  def get_table_create_stmt(self, token, resource, inmemory):
    """
    @brief   Method to retreive resource's original create statement

    Parameters:
     - token
     - resource
     - inmemory
    """
    self.send_get_table_create_stmt(token, resource, inmemory)
    return self.recv_get_table_create_stmt()

  def send_get_table_create_stmt(self, token, resource, inmemory):
    self._oprot.writeMessageBegin('get_table_create_stmt', TMessageType.CALL, self._seqid)
    args = get_table_create_stmt_args()
    args.token = token
    args.resource = resource
    args.inmemory = inmemory
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_create_stmt(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_create_stmt_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_create_stmt failed: unknown result");

  def get_qbo_list(self, token, path):
    """
    @brief   Method to retreive list of created resources at location

    Parameters:
     - token
     - path
    """
    self.send_get_qbo_list(token, path)
    return self.recv_get_qbo_list()

  def send_get_qbo_list(self, token, path):
    self._oprot.writeMessageBegin('get_qbo_list', TMessageType.CALL, self._seqid)
    args = get_qbo_list_args()
    args.token = token
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_qbo_list(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_qbo_list_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_qbo_list failed: unknown result");

  def get_qbo_info(self, token, table_name, path):
    """
    @brief   Method to retreive metadata regarding resource at location

    Parameters:
     - token
     - table_name
     - path
    """
    self.send_get_qbo_info(token, table_name, path)
    return self.recv_get_qbo_info()

  def send_get_qbo_info(self, token, table_name, path):
    self._oprot.writeMessageBegin('get_qbo_info', TMessageType.CALL, self._seqid)
    args = get_qbo_info_args()
    args.token = token
    args.table_name = table_name
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_qbo_info(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_qbo_info_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_qbo_info failed: unknown result");

  def get_mbt_list(self, token, path):
    """
    @brief   Method to retreive list of created resources at location

    Parameters:
     - token
     - path
    """
    self.send_get_mbt_list(token, path)
    return self.recv_get_mbt_list()

  def send_get_mbt_list(self, token, path):
    self._oprot.writeMessageBegin('get_mbt_list', TMessageType.CALL, self._seqid)
    args = get_mbt_list_args()
    args.token = token
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_mbt_list(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_mbt_list_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_mbt_list failed: unknown result");

  def get_mbt_info(self, token, table_name, path):
    """
    @brief   Method to retreive metadata regarding resource at location

    Parameters:
     - token
     - table_name
     - path
    """
    self.send_get_mbt_info(token, table_name, path)
    return self.recv_get_mbt_info()

  def send_get_mbt_info(self, token, table_name, path):
    self._oprot.writeMessageBegin('get_mbt_info', TMessageType.CALL, self._seqid)
    args = get_mbt_info_args()
    args.token = token
    args.table_name = table_name
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_mbt_info(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_mbt_info_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err is not None:
      raise result.err
    if result.arr is not None:
      raise result.arr
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_mbt_info failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["ping"] = Processor.process_ping
    self._processMap["star_apply"] = Processor.process_star_apply
    self._processMap["sql_begin"] = Processor.process_sql_begin
    self._processMap["sql_commit"] = Processor.process_sql_commit
    self._processMap["sql_execute_many"] = Processor.process_sql_execute_many
    self._processMap["sql_execute"] = Processor.process_sql_execute
    self._processMap["aux_execute"] = Processor.process_aux_execute
    self._processMap["assoc_execute"] = Processor.process_assoc_execute
    self._processMap["cursor_fetch"] = Processor.process_cursor_fetch
    self._processMap["cursor_dup"] = Processor.process_cursor_dup
    self._processMap["cursor_close"] = Processor.process_cursor_close
    self._processMap["get_table_list"] = Processor.process_get_table_list
    self._processMap["get_table_schema"] = Processor.process_get_table_schema
    self._processMap["get_table_relation"] = Processor.process_get_table_relation
    self._processMap["get_table_create_stmt"] = Processor.process_get_table_create_stmt
    self._processMap["get_qbo_list"] = Processor.process_get_qbo_list
    self._processMap["get_qbo_info"] = Processor.process_get_qbo_info
    self._processMap["get_mbt_list"] = Processor.process_get_mbt_list
    self._processMap["get_mbt_info"] = Processor.process_get_mbt_info

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_ping(self, seqid, iprot, oprot):
    args = ping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ping_result()
    result.success = self._handler.ping()
    oprot.writeMessageBegin("ping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_star_apply(self, seqid, iprot, oprot):
    args = star_apply_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = star_apply_result()
    try:
      result.success = self._handler.star_apply(args.token, args.srvname, args.cmd_stmt, args.autocommit)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("star_apply", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sql_begin(self, seqid, iprot, oprot):
    args = sql_begin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sql_begin_result()
    try:
      result.success = self._handler.sql_begin(args.token)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("sql_begin", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sql_commit(self, seqid, iprot, oprot):
    args = sql_commit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sql_commit_result()
    try:
      result.success = self._handler.sql_commit(args.token, args.resource)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.SQLError, sqlerr:
      result.sqlerr = sqlerr
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("sql_commit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sql_execute_many(self, seqid, iprot, oprot):
    args = sql_execute_many_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sql_execute_many_result()
    try:
      result.success = self._handler.sql_execute_many(args.token, args.resource, args.sql_stmt)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.SQLError, sqlerr:
      result.sqlerr = sqlerr
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("sql_execute_many", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sql_execute(self, seqid, iprot, oprot):
    args = sql_execute_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sql_execute_result()
    try:
      result.success = self._handler.sql_execute(args.token, args.sql_stmt, args.autocommit)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.SQLError, sqlerr:
      result.sqlerr = sqlerr
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("sql_execute", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_aux_execute(self, seqid, iprot, oprot):
    args = aux_execute_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = aux_execute_result()
    try:
      result.success = self._handler.aux_execute(args.token, args.stmt, args.autocommit)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("aux_execute", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_assoc_execute(self, seqid, iprot, oprot):
    args = assoc_execute_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = assoc_execute_result()
    try:
      result.success = self._handler.assoc_execute(args.token, args.stmt, args.autocommit)
    except exc.ttypes.ASSOCError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("assoc_execute", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cursor_fetch(self, seqid, iprot, oprot):
    args = cursor_fetch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cursor_fetch_result()
    try:
      result.success = self._handler.cursor_fetch(args.token, args.resource, args.rng)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("cursor_fetch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cursor_dup(self, seqid, iprot, oprot):
    args = cursor_dup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cursor_dup_result()
    try:
      result.success = self._handler.cursor_dup(args.token, args.resource, args.count)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("cursor_dup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cursor_close(self, seqid, iprot, oprot):
    args = cursor_close_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cursor_close_result()
    self._handler.cursor_close(args.token, args.resource)
    oprot.writeMessageBegin("cursor_close", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_list(self, seqid, iprot, oprot):
    args = get_table_list_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_list_result()
    try:
      result.success = self._handler.get_table_list(args.token, args.path)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_table_list", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_schema(self, seqid, iprot, oprot):
    args = get_table_schema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_schema_result()
    try:
      result.success = self._handler.get_table_schema(args.token, args.table_name, args.path)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_table_schema", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_relation(self, seqid, iprot, oprot):
    args = get_table_relation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_relation_result()
    try:
      result.success = self._handler.get_table_relation(args.token, args.table_name, args.path)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_table_relation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_create_stmt(self, seqid, iprot, oprot):
    args = get_table_create_stmt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_create_stmt_result()
    try:
      result.success = self._handler.get_table_create_stmt(args.token, args.resource, args.inmemory)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_table_create_stmt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_qbo_list(self, seqid, iprot, oprot):
    args = get_qbo_list_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_qbo_list_result()
    try:
      result.success = self._handler.get_qbo_list(args.token, args.path)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_qbo_list", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_qbo_info(self, seqid, iprot, oprot):
    args = get_qbo_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_qbo_info_result()
    try:
      result.success = self._handler.get_qbo_info(args.token, args.table_name, args.path)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_qbo_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mbt_list(self, seqid, iprot, oprot):
    args = get_mbt_list_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mbt_list_result()
    try:
      result.success = self._handler.get_mbt_list(args.token, args.path)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_mbt_list", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mbt_info(self, seqid, iprot, oprot):
    args = get_mbt_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mbt_info_result()
    try:
      result.success = self._handler.get_mbt_info(args.token, args.table_name, args.path)
    except exc.ttypes.ServiceError, err:
      result.err = err
    except exc.ttypes.AuthError, arr:
      result.arr = arr
    oprot.writeMessageBegin("get_mbt_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class ping_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class star_apply_args:
  """
  Attributes:
   - token
   - srvname
   - cmd_stmt
   - autocommit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'srvname', None, None, ), # 2
    (3, TType.STRING, 'cmd_stmt', None, None, ), # 3
    (4, TType.BOOL, 'autocommit', None, None, ), # 4
  )

  def __init__(self, token=None, srvname=None, cmd_stmt=None, autocommit=None,):
    self.token = token
    self.srvname = srvname
    self.cmd_stmt = cmd_stmt
    self.autocommit = autocommit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.srvname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cmd_stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.autocommit = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('star_apply_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.srvname is not None:
      oprot.writeFieldBegin('srvname', TType.STRING, 2)
      oprot.writeString(self.srvname)
      oprot.writeFieldEnd()
    if self.cmd_stmt is not None:
      oprot.writeFieldBegin('cmd_stmt', TType.STRING, 3)
      oprot.writeString(self.cmd_stmt)
      oprot.writeFieldEnd()
    if self.autocommit is not None:
      oprot.writeFieldBegin('autocommit', TType.BOOL, 4)
      oprot.writeBool(self.autocommit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class star_apply_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('star_apply_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sql_begin_args:
  """
  Attributes:
   - token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
  )

  def __init__(self, token=None,):
    self.token = token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sql_begin_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sql_begin_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sql_begin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sql_commit_args:
  """
  Attributes:
   - token
   - resource
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'resource', None, None, ), # 2
  )

  def __init__(self, token=None, resource=None,):
    self.token = token
    self.resource = resource

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.resource = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sql_commit_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRING, 2)
      oprot.writeString(self.resource)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sql_commit_result:
  """
  Attributes:
   - success
   - err
   - sqlerr
   - arr
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'sqlerr', (exc.ttypes.SQLError, exc.ttypes.SQLError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, err=None, sqlerr=None, arr=None,):
    self.success = success
    self.err = err
    self.sqlerr = sqlerr
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sqlerr = exc.ttypes.SQLError()
          self.sqlerr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sql_commit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.sqlerr is not None:
      oprot.writeFieldBegin('sqlerr', TType.STRUCT, 2)
      self.sqlerr.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 3)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sql_execute_many_args:
  """
  Attributes:
   - token
   - resource
   - sql_stmt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'resource', None, None, ), # 2
    (3, TType.STRING, 'sql_stmt', None, None, ), # 3
  )

  def __init__(self, token=None, resource=None, sql_stmt=None,):
    self.token = token
    self.resource = resource
    self.sql_stmt = sql_stmt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.resource = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sql_stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sql_execute_many_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRING, 2)
      oprot.writeString(self.resource)
      oprot.writeFieldEnd()
    if self.sql_stmt is not None:
      oprot.writeFieldBegin('sql_stmt', TType.STRING, 3)
      oprot.writeString(self.sql_stmt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sql_execute_many_result:
  """
  Attributes:
   - success
   - err
   - sqlerr
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'sqlerr', (exc.ttypes.SQLError, exc.ttypes.SQLError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, err=None, sqlerr=None, arr=None,):
    self.success = success
    self.err = err
    self.sqlerr = sqlerr
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sqlerr = exc.ttypes.SQLError()
          self.sqlerr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sql_execute_many_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.sqlerr is not None:
      oprot.writeFieldBegin('sqlerr', TType.STRUCT, 2)
      self.sqlerr.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 3)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sql_execute_args:
  """
  Attributes:
   - token
   - sql_stmt
   - autocommit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'sql_stmt', None, None, ), # 2
    (3, TType.BOOL, 'autocommit', None, None, ), # 3
  )

  def __init__(self, token=None, sql_stmt=None, autocommit=None,):
    self.token = token
    self.sql_stmt = sql_stmt
    self.autocommit = autocommit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.sql_stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.autocommit = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sql_execute_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.sql_stmt is not None:
      oprot.writeFieldBegin('sql_stmt', TType.STRING, 2)
      oprot.writeString(self.sql_stmt)
      oprot.writeFieldEnd()
    if self.autocommit is not None:
      oprot.writeFieldBegin('autocommit', TType.BOOL, 3)
      oprot.writeBool(self.autocommit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sql_execute_result:
  """
  Attributes:
   - success
   - err
   - sqlerr
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'sqlerr', (exc.ttypes.SQLError, exc.ttypes.SQLError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, err=None, sqlerr=None, arr=None,):
    self.success = success
    self.err = err
    self.sqlerr = sqlerr
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sqlerr = exc.ttypes.SQLError()
          self.sqlerr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sql_execute_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.sqlerr is not None:
      oprot.writeFieldBegin('sqlerr', TType.STRUCT, 2)
      self.sqlerr.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 3)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class aux_execute_args:
  """
  Attributes:
   - token
   - stmt
   - autocommit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'stmt', None, None, ), # 2
    (3, TType.BOOL, 'autocommit', None, None, ), # 3
  )

  def __init__(self, token=None, stmt=None, autocommit=None,):
    self.token = token
    self.stmt = stmt
    self.autocommit = autocommit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.autocommit = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('aux_execute_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.stmt is not None:
      oprot.writeFieldBegin('stmt', TType.STRING, 2)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    if self.autocommit is not None:
      oprot.writeFieldBegin('autocommit', TType.BOOL, 3)
      oprot.writeBool(self.autocommit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class aux_execute_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('aux_execute_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class assoc_execute_args:
  """
  Attributes:
   - token
   - stmt
   - autocommit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'stmt', None, None, ), # 2
    (3, TType.BOOL, 'autocommit', None, None, ), # 3
  )

  def __init__(self, token=None, stmt=None, autocommit=None,):
    self.token = token
    self.stmt = stmt
    self.autocommit = autocommit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.autocommit = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('assoc_execute_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.stmt is not None:
      oprot.writeFieldBegin('stmt', TType.STRING, 2)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    if self.autocommit is not None:
      oprot.writeFieldBegin('autocommit', TType.BOOL, 3)
      oprot.writeBool(self.autocommit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class assoc_execute_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ASSOCError, exc.ttypes.ASSOCError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ASSOCError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('assoc_execute_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cursor_fetch_args:
  """
  Attributes:
   - token
   - resource
   - rng
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'resource', None, None, ), # 2
    (3, TType.STRUCT, 'rng', (RangeSpec, RangeSpec.thrift_spec), None, ), # 3
  )

  def __init__(self, token=None, resource=None, rng=None,):
    self.token = token
    self.resource = resource
    self.rng = rng

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.resource = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.rng = RangeSpec()
          self.rng.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cursor_fetch_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRING, 2)
      oprot.writeString(self.resource)
      oprot.writeFieldEnd()
    if self.rng is not None:
      oprot.writeFieldBegin('rng', TType.STRUCT, 3)
      self.rng.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cursor_fetch_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cursor_fetch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cursor_dup_args:
  """
  Attributes:
   - token
   - resource
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'resource', None, None, ), # 2
    (3, TType.I64, 'count', None, None, ), # 3
  )

  def __init__(self, token=None, resource=None, count=None,):
    self.token = token
    self.resource = resource
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.resource = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.count = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cursor_dup_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRING, 2)
      oprot.writeString(self.resource)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I64, 3)
      oprot.writeI64(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cursor_dup_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cursor_dup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cursor_close_args:
  """
  Attributes:
   - token
   - resource
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'resource', None, None, ), # 2
  )

  def __init__(self, token=None, resource=None,):
    self.token = token
    self.resource = resource

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.resource = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cursor_close_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRING, 2)
      oprot.writeString(self.resource)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cursor_close_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cursor_close_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_list_args:
  """
  Attributes:
   - token
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'path', None, None, ), # 2
  )

  def __init__(self, token=None, path=None,):
    self.token = token
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_list_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 2)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_list_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_list_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_schema_args:
  """
  Attributes:
   - token
   - table_name
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'path', None, None, ), # 3
  )

  def __init__(self, token=None, table_name=None, path=None,):
    self.token = token
    self.table_name = table_name
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_schema_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 3)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_schema_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_schema_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_relation_args:
  """
  Attributes:
   - token
   - table_name
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'path', None, None, ), # 3
  )

  def __init__(self, token=None, table_name=None, path=None,):
    self.token = token
    self.table_name = table_name
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_relation_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 3)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_relation_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_relation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_create_stmt_args:
  """
  Attributes:
   - token
   - resource
   - inmemory
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'resource', None, None, ), # 2
    (3, TType.BOOL, 'inmemory', None, None, ), # 3
  )

  def __init__(self, token=None, resource=None, inmemory=None,):
    self.token = token
    self.resource = resource
    self.inmemory = inmemory

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.resource = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.inmemory = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_create_stmt_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRING, 2)
      oprot.writeString(self.resource)
      oprot.writeFieldEnd()
    if self.inmemory is not None:
      oprot.writeFieldBegin('inmemory', TType.BOOL, 3)
      oprot.writeBool(self.inmemory)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_create_stmt_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_create_stmt_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_qbo_list_args:
  """
  Attributes:
   - token
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'path', None, None, ), # 2
  )

  def __init__(self, token=None, path=None,):
    self.token = token
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_qbo_list_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 2)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_qbo_list_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_qbo_list_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_qbo_info_args:
  """
  Attributes:
   - token
   - table_name
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'path', None, None, ), # 3
  )

  def __init__(self, token=None, table_name=None, path=None,):
    self.token = token
    self.table_name = table_name
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_qbo_info_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 3)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_qbo_info_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_qbo_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mbt_list_args:
  """
  Attributes:
   - token
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'path', None, None, ), # 2
  )

  def __init__(self, token=None, path=None,):
    self.token = token
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mbt_list_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 2)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mbt_list_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mbt_list_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mbt_info_args:
  """
  Attributes:
   - token
   - table_name
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.STRING, 'path', None, None, ), # 3
  )

  def __init__(self, token=None, table_name=None, path=None,):
    self.token = token
    self.table_name = table_name
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mbt_info_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 3)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mbt_info_result:
  """
  Attributes:
   - success
   - err
   - arr
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'err', (exc.ttypes.ServiceError, exc.ttypes.ServiceError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'arr', (exc.ttypes.AuthError, exc.ttypes.AuthError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err=None, arr=None,):
    self.success = success
    self.err = err
    self.arr = arr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err = exc.ttypes.ServiceError()
          self.err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.arr = exc.ttypes.AuthError()
          self.arr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mbt_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRUCT, 1)
      self.err.write(oprot)
      oprot.writeFieldEnd()
    if self.arr is not None:
      oprot.writeFieldBegin('arr', TType.STRUCT, 2)
      self.arr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
