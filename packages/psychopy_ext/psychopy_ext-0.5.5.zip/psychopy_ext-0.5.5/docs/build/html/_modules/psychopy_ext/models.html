<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>psychopy_ext.models &mdash; psychopy_ext 0.5.4 documentation</title>
    
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootswatch-3.1.0/cosmo/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootswatch-3.1.0/cosmo/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="psychopy_ext 0.5.4 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
  <link rel="shortcut icon" href="../../_static/favicon.ico">
  <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="description" content="A framework for a rapid reproducible design, analysis and plotting of experiments in neuroscience and psychology">
  <meta name="author" content="Jonas Kubilius">

  </head>
  <body>

  <!-- Navigation
  ========================================== -->
  
  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          psychopy_ext 0.5.4</a>
<!--
        <span class="navbar-text navbar-version pull-left"><b>0.5.4</b></span>
-->
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
            <li><a href="../../intro/index.html">Quick intro</a></li>
            <li><a href="../../library/index.html">Tutorial</a></li>
            <li><a href="../../api/index.html">API</a></li>
            <li><a href="https://github.com/qbilius/psychopy_ext">GitHub</a></li>
<!--
            
              <h3><a href="../../index.html">Table Of Contents</a></h3>

              
            
-->
<!--
            
            
            
            
-->
          </ul>

<!--
          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
-->
        </div>
    </div>
  </div>


  
    <div class="container">
      <div class="row">
        <!-- Sidebar1
        ========================================== -->
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary">
<form action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>

        <!-- Main content
        ========================================== -->
        <div class="col-md-9">
          
  <h1>Source code for psychopy_ext.models</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>

<span class="c"># Part of the psychopy_ext library</span>
<span class="c"># Copyright 2010-2013 Jonas Kubilius</span>
<span class="c"># The program is distributed under the terms of the GNU General Public License,</span>
<span class="c"># either version 3 of the License, or (at your option) any later version.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A library of simple models of vision</span>

<span class="sd">Simple usage::</span>

<span class="sd">    import glob</span>
<span class="sd">    from psychopy_ext import models</span>
<span class="sd">    ims = glob.glob(&#39;Example_set/*.jpg&#39;)  # get all jpg images</span>
<span class="sd">    hmax = models.HMAX()</span>
<span class="sd">    # if you want to see how similar your images are to each other</span>
<span class="sd">    hmax.compare(ims)</span>
<span class="sd">    # or to simply get the output and use it further</span>
<span class="sd">    out = hmax.run(ims)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">import</span> <span class="nn">scipy.misc</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span>


<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<div class="viewcode-block" id="Model.get_teststim"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Model.get_teststim.html#psychopy_ext.models.Model.get_teststim">[docs]</a>    <span class="k">def</span> <span class="nf">get_teststim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Opens Lena image and resizes it to the specified size ((256, 256) by</span>
<span class="sd">        default)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lena</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">lena</span><span class="p">()</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">imresize</span><span class="p">(</span><span class="n">lena</span><span class="p">,</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">im</span>
</div>
<div class="viewcode-block" id="Model.train"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Model.train.html#psychopy_ext.models.Model.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A placeholder for a function for training a model.</span>
<span class="sd">        If the model is not trainable, then it will default to this function</span>
<span class="sd">        here that does nothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="Model.test"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Model.test.html#psychopy_ext.models.Model.test">[docs]</a>    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A placeholder for a function for testing a model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="Model.dissimilarity"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Model.dissimilarity.html#psychopy_ext.models.Model.dissimilarity">[docs]</a>    <span class="k">def</span> <span class="nf">dissimilarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;simple&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;simple&#39;</span><span class="p">:</span>
            <span class="n">dis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dis_simple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;gaborjet&#39;</span><span class="p">:</span>
            <span class="n">dis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dis_gj_simple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;gaborjet-fast&#39;</span><span class="p">:</span>
            <span class="n">dis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dis_gj_fast</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;corr&#39;</span><span class="p">:</span>
            <span class="c">#self._dis_corr(outputs)</span>
            <span class="k">raise</span> <span class="bp">NotImplemented</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Dissimilarity of </span><span class="si">%s</span><span class="s"> not recognized&#39;</span> <span class="o">%</span> <span class="n">kind</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dis</span>
</div>
<div class="viewcode-block" id="Model._dis_simple"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Model._dis_simple.html#psychopy_ext.models.Model._dis_simple">[docs]</a>    <span class="k">def</span> <span class="nf">_dis_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="c"># used in Grill-Spector et al. (1999), Op de Beeck et al. (2001),</span>
        <span class="c"># Panis et al. (2011)</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="n">dis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">dis</span><span class="p">):</span>
            <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">outputs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dis</span>

</div>
<div class="viewcode-block" id="Model._dis_gj_simple"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Model._dis_gj_simple.html#psychopy_ext.models.Model._dis_gj_simple">[docs]</a>    <span class="k">def</span> <span class="nf">_dis_gj_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate similarity between magnitudes of gabor jet.</span>

<span class="sd">        It may look complex but this is just a linear algebra implementation of</span>
<span class="sd">        1 - np.dot(f,g) / (np.sqrt(np.dot(g,g)) * np.sqrt(np.dot(f,f)) )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outputs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;ERROR: 2 dimensions expected&#39;</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">outputs</span><span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>  <span class="c"># make a square matrix</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span><span class="n">outputs</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">length</span> <span class="o">*</span> <span class="n">length</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_dis_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate a correlation between magnitudes of gabor jet.</span>

<span class="sd">        DOESN&#39;T WORK YET</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="n">outputs</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">outputs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s">&#39;ERROR: 2 dimensions expected&#39;</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">outputs</span><span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>  <span class="c"># make a square matrix</span>
        <span class="k">return</span> <span class="o">.</span><span class="mi">5</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span><span class="n">outputs</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">length</span> <span class="o">*</span> <span class="n">length</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dis_corr2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate a correlation between magnitudes of gabor jet.</span>

<span class="sd">        DOESN&#39;T WORK YET</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span> <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
        <span class="n">outputs</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">outputs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s">&#39;ERROR: 2 dimensions expected&#39;</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">outputs</span><span class="o">*</span><span class="n">outputs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>  <span class="c"># make a square matrix</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span><span class="n">outputs</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">length</span> <span class="o">*</span> <span class="n">length</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

<div class="viewcode-block" id="Model._dis_fast"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Model._dis_fast.html#psychopy_ext.models.Model._dis_fast">[docs]</a>    <span class="k">def</span> <span class="nf">_dis_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outputs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s">&#39;ERROR: 2 dimensions expected&#39;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">sq</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="c"># difference between tuning and each C2 response</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">outputs</span> <span class="o">-</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">row</span><span class="p">,(</span><span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
            <span class="c"># import pdb; pdb.set_trace()</span>
            <span class="c"># this difference is then square-summed and then exponentiated :)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">sq</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">diff</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Model.input2array"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Model.input2array.html#psychopy_ext.models.Model.input2array">[docs]</a>    <span class="k">def</span> <span class="nf">input2array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_im</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="n">im</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_im</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
                    <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;input type not recognized&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">array</span>
</div>
<div class="viewcode-block" id="Model._prepare_im"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Model._prepare_im.html#psychopy_ext.models.Model._prepare_im">[docs]</a>    <span class="k">def</span> <span class="nf">_prepare_im</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">):</span>
        <span class="n">large</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">large</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">imresize</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="mf">256.</span><span class="o">/</span><span class="n">large</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">im</span>

</div>
<div class="viewcode-block" id="Model.compare"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Model.compare.html#psychopy_ext.models.Model.compare">[docs]</a>    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ims</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">ims</span>
        <span class="k">print</span> <span class="s">&#39;processing image&#39;</span><span class="p">,</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">ims</span><span class="p">,</span> <span class="n">oneval</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">dis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dissimilarity</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">print</span>
        <span class="k">print</span> <span class="s">&#39;Dissimilarity across stimuli&#39;</span>
        <span class="k">print</span> <span class="s">&#39;0: similar, 1: dissimilar&#39;</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Dissimilarity across stimuli</span><span class="se">\n</span><span class="s">&#39;</span>
                  <span class="s">&#39;(blue: similar, red: dissimilar)&#39;</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dis</span>

</div>
<span class="k">class</span> <span class="nc">Pixelwise</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<div class="viewcode-block" id="Pixelwise.run"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.Pixelwise.run.html#psychopy_ext.models.Pixelwise.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_ims</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input2array</span><span class="p">(</span><span class="n">test_ims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ims</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s">&#39;ERROR: Input images must be two-dimensional&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ims</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ims</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

</div>
<span class="k">class</span> <span class="nc">Zoccolan</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Based on 10.1073/pnas.0811583106</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># receptive field sizes in degrees</span>
        <span class="c">#self.rfs = np.array([.6,.8,1.])</span>
        <span class="c">#self.rfs = np.array([.2,.35,.5])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>  <span class="c"># deg visual angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oris</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phases</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>  <span class="c"># cycles per RF size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">winsize</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>  <span class="c"># size of each patch on the grid</span>
        <span class="c"># window size will be fixed in pixels and we&#39;ll adjust degrees accordingly</span>
        <span class="c"># self.win_size_px = 300</span>

    <span class="k">def</span> <span class="nf">get_gabors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rf</span><span class="p">):</span>
        <span class="n">lams</span> <span class="o">=</span>  <span class="nb">float</span><span class="p">(</span><span class="n">rf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sfs</span> <span class="c"># lambda = 1./sf  #1./np.array([.1,.25,.4])</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">rf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="c"># rf = [100,100]</span>
        <span class="n">gabors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span> <span class="nb">len</span><span class="p">(</span><span class="n">oris</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">lams</span><span class="p">),</span> <span class="n">rf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">))</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">rf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">rf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c">#print i</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">rf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">rf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ii</span><span class="p">,</span><span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">oris</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">ii</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">jj</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">ii</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">jj</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">phase</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phases</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">lam</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lams</span><span class="p">):</span>
                    <span class="n">fxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">lam</span> <span class="o">+</span> <span class="n">phase</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">fxx</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span>
                    <span class="n">fxx</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span>

                    <span class="c">#if p==0:</span>
                        <span class="c">#plt.subplot(len(oris),len(lams),count+1)</span>
                        <span class="c">#plt.imshow(fxx,cmap=mpl.cm.gray,interpolation=&#39;bicubic&#39;)</span>
                        <span class="c">#count+=1</span>

                    <span class="n">gabors</span><span class="p">[</span><span class="n">o</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">fxx</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">gabors</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ims</span><span class="p">):</span>
        <span class="n">ims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input2array</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">ims</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">):</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">num_tiles</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span><span class="c">#[field[0]/10.,field[0]/10.]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">num_tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">num_tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">V1</span> <span class="o">=</span> <span class="p">[]</span><span class="c">#np.zeros( gabors.shape + num_tiles )</span>

    <span class="c">#    tiled_im = im.reshape((num_tiles[0],size[0],num_tiles[1],size[1]))</span>
    <span class="c">#    tiled_im = np.rollaxis(tiled_im, 1, start=3)</span>
    <span class="c">#    flat_im = im.reshape((num_tiles[0],num_tiles[1],-1))</span>

        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">rf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rfs</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">apply_filter</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">this_filter</span><span class="p">):</span>
                <span class="n">this_resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">this_filter</span><span class="p">,</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">this_filter</span><span class="p">)</span>
    <span class="c">#            import pdb; pdb.set_trace()</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">this_resp</span><span class="p">))</span> <span class="c"># returns at least zero</span>

            <span class="k">def</span> <span class="nf">filter_bank</span><span class="p">(</span><span class="n">this_filter</span><span class="p">,</span><span class="n">rf</span><span class="p">):</span>
                <span class="c">#print &#39;done0&#39;</span>
                <span class="n">resp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">generic_filter</span><span class="p">(</span>
                                <span class="n">im</span><span class="p">,</span> <span class="n">apply_filter</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">rf</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s">&#39;nearest&#39;</span><span class="p">,</span>
                                <span class="n">extra_arguments</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_filter</span><span class="p">,))</span>
    <span class="c">#            import pdb; pdb.set_trace()</span>
                <span class="c">#print &#39;done1&#39;</span>
                <span class="n">ii</span><span class="p">,</span><span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
                <span class="n">selresp</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span><span class="n">ii</span><span class="p">]</span>

    <span class="c">#            maxresp = scipy.ndimage.filters.maximum_filter(</span>
    <span class="c">#                resp,</span>
    <span class="c">#                size = size,</span>
    <span class="c">#                mode = &#39;nearest&#39;</span>
    <span class="c">#            )</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">selresp</span><span class="p">)</span>

            <span class="n">gabors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gabors</span><span class="p">(</span><span class="n">rf</span><span class="p">)</span>
            <span class="c">#import pdb; pdb.set_trace()</span>
            <span class="n">gabors</span> <span class="o">=</span> <span class="n">gabors</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gabors</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
    <span class="c">#        gabors_norms = np.apply_along_axis(np.linalg.norm, -1, gabors)</span>
    <span class="c">#        import pdb; pdb.set_trace()</span>
    <span class="c">#        V1.append( np.apply_along_axis(filter_bank, -1, gabors,rf) )</span>
            <span class="n">V1resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">gabors</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">num_tiles</span><span class="p">)</span>
    <span class="c">#        import pdb; pdb.set_trace()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">wi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">rf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">wj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">rf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                    <span class="n">window</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">wi</span><span class="p">:</span><span class="n">wi</span><span class="o">+</span><span class="n">rf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">wj</span><span class="p">:</span><span class="n">wj</span><span class="o">+</span><span class="n">rf</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">gabors</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
                    <span class="n">resp</span><span class="p">[</span><span class="n">resp</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">V1resp</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">resp</span> <span class="c">#/gabors_norms</span>
    <span class="c">#                print &#39;done&#39;</span>
            <span class="n">V1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">V1resp</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">V1</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">GaborJet</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>

<div class="viewcode-block" id="GaborJet.__init__"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.GaborJet.__init__.html#psychopy_ext.models.GaborJet.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nScale</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nOrientation</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Python implementation of the Gabor-Jet model from Biederman lab.</span>

<span class="sd">        A given image is transformed with a</span>
<span class="sd">        Gabor wavelet and certain values on a grid are chosen for the output.</span>
<span class="sd">        Further details are in `Xu et al., 2009</span>
<span class="sd">        &lt;http://dx.doi.org/10.1016/j.visres.2009.08.021&gt;`_.</span>

<span class="sd">        Original implementation copyright 2004 &#39;Xiaomin Yue</span>
<span class="sd">        &lt;http://geon.usc.edu/GWTgrid_simple.m&gt;`_.</span>


<span class="sd">        :Kwargs:</span>
<span class="sd">            - nScale (int, default: 5)</span>
<span class="sd">                Spatial frequency scales</span>
<span class="sd">            - nOrientation (int, default: 8)</span>
<span class="sd">                Orientation spacing; angle = np.pi/nOrientations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nScale</span> <span class="o">=</span> <span class="n">nScale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nOrientation</span> <span class="o">=</span> <span class="n">nOrientation</span>
</div>
<div class="viewcode-block" id="GaborJet.run"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.GaborJet.run.html#psychopy_ext.models.GaborJet.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ims</span><span class="p">,</span> <span class="n">oneval</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run GaborJet model.</span>

<span class="sd">        :Args:</span>
<span class="sd">            ims: str or list of str</span>
<span class="sd">                Image(s) to process witht he model.</span>
<span class="sd">        :Kwargs:</span>
<span class="sd">            oneval: bool (default: False)</span>
<span class="sd">                Whether only magnitude should be returned. If True, then also</span>
<span class="sd">                phase and gird positions are returned.</span>

<span class="sd">        :Returns:</span>
<span class="sd">            Magnitude and, depending on &#39;oneval&#39;, phase and grid positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input2array</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span>
        <span class="n">JetsMagnitudes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">JetsPhases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">ims</span><span class="p">:</span>
            <span class="n">JetsMagnitude</span><span class="p">,</span> <span class="n">JetsPhase</span><span class="p">,</span> <span class="n">grid_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="n">JetsMagnitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">JetsMagnitude</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="n">JetsPhases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">JetsPhase</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">oneval</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">JetsMagnitudes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">JetsMagnitudes</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">JetsPhases</span><span class="p">),</span> <span class="n">grid_position</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GaborJet.test"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.GaborJet.test.html#psychopy_ext.models.GaborJet.test">[docs]</a>    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">im</span><span class="p">,</span>
            <span class="n">cell_type</span> <span class="o">=</span> <span class="s">&#39;complex&#39;</span><span class="p">,</span>
            <span class="n">grid_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply GaborJet to given images.</span>

<span class="sd">        :Args:</span>
<span class="sd">            im (numpy.array)</span>
<span class="sd">                input image; can be (128,128) or (256,256) px size</span>

<span class="sd">        :Kwargs:</span>
<span class="sd">            - cell_type (str, default: &#39;complex&#39;)</span>
<span class="sd">                Choose between &#39;complex&#39;(40 output values) and &#39;simple&#39;</span>
<span class="sd">                (80 values, NOT FULLY WORKING YET)</span>
<span class="sd">            - grid_size (int, default: 0)</span>
<span class="sd">                How many positions within an image to take</span>
<span class="sd">            - sigma (float, default: 2*np.pi)</span>
<span class="sd">                Control the size of gaussian envelope</span>

<span class="sd">        :Returns:</span>
<span class="sd">            (JetsMagnitude, JetsPhase, grid_position)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s">&#39;The image has to be square. Please try again&#39;</span><span class="p">)</span>

        <span class="c"># generate the grid</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">grid_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rangeXY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">110</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c"># 10x10</span>
            <span class="k">elif</span> <span class="n">grid_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">rangeXY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">120</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c"># 12x12</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rangeXY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">128</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># 128x128</span>
            <span class="n">rangeXY</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>  <span class="c"># if len(im)==256, scale up by two</span>
            <span class="n">rangeXY</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c"># shift from MatLab indexing to Python</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s">&#39;The image has to be 256*256 px or 128*128 px. Please try again&#39;</span><span class="p">)</span>

        <span class="p">[</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">rangeXY</span><span class="p">,</span><span class="n">rangeXY</span><span class="p">)</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">xx</span> <span class="o">+</span> <span class="mi">1j</span><span class="o">*</span><span class="n">yy</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c"># transpose just to match MatLab&#39;s grid(:) behavior</span>
        <span class="n">grid_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">grid</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">real</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c"># FFT of the image</span>
        <span class="n">im_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

        <span class="c"># setup the paramers</span>
        <span class="n">xHalfResL</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">yHalfResL</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">kxFactor</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kyFactor</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># setup space coordinate</span>
        <span class="p">[</span><span class="n">tx</span><span class="p">,</span><span class="n">ty</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">xHalfResL</span><span class="p">,</span><span class="n">xHalfResL</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">yHalfResL</span><span class="p">,</span><span class="n">yHalfResL</span><span class="p">))</span>
        <span class="n">tx</span> <span class="o">=</span> <span class="n">kxFactor</span><span class="o">*</span><span class="n">tx</span>
        <span class="n">ty</span> <span class="o">=</span> <span class="n">kyFactor</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">ty</span><span class="p">)</span>

        <span class="c"># initiallize useful variables</span>
        <span class="n">nvars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nScale</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nOrientation</span>
        <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s">&#39;complex&#39;</span><span class="p">:</span>
            <span class="n">JetsMagnitude</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="n">nvars</span><span class="p">))</span>
            <span class="n">JetsPhase</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="n">nvars</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">JetsMagnitude</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">nvars</span><span class="p">))</span>
            <span class="n">JetsPhase</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="n">nvars</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">LevelL</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nScale</span><span class="p">):</span>
            <span class="n">k0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="n">LevelL</span>
            <span class="k">for</span> <span class="n">DirecL</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nOrientation</span><span class="p">):</span>
                <span class="n">kA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">DirecL</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nOrientation</span>
                <span class="n">k0x</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">kA</span><span class="p">)</span>
                <span class="n">k0y</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">kA</span><span class="p">)</span>
                <span class="c"># generate a kernel specified scale and orientation, which has DC on the center</span>
                <span class="c"># this is a FFT of a Morlet wavelet (http://en.wikipedia.org/wiki/Morlet_wavelet)</span>
                <span class="n">freq_kernel</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="p">(</span><span class="n">sigma</span><span class="o">/</span><span class="n">k0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">k0x</span><span class="o">-</span><span class="n">tx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">k0y</span><span class="o">-</span><span class="n">ty</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="o">-</span>\
                    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="p">(</span><span class="n">sigma</span><span class="o">/</span><span class="n">k0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">k0</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">tx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">ty</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
                    <span class="p">)</span>
                <span class="c"># use fftshift to change DC to the corners</span>
                <span class="n">freq_kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">freq_kernel</span><span class="p">)</span>

                <span class="c"># convolve the image with a kernel of the specified scale and orientation</span>
                <span class="n">TmpFilterImage</span> <span class="o">=</span> <span class="n">im_freq</span><span class="o">*</span><span class="n">freq_kernel</span>
                <span class="c">#</span>
                <span class="c"># calculate magnitude and phase</span>
                <span class="n">iTmpFilterImage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">TmpFilterImage</span><span class="p">)</span>
                <span class="c">#</span>
                <span class="c">#eps = np.finfo(float).eps**(3./4)</span>
                <span class="c">#real = np.real(iTmpFilterImage)</span>
                <span class="c">#real[real&lt;eps] = 0</span>
                <span class="c">#imag = np.imag(iTmpFilterImage)</span>
                <span class="c">#imag[imag&lt;eps] = 0</span>
                <span class="c">#iTmpFilterImage = real + 1j*imag</span>

                <span class="n">TmpGWTPhase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">iTmpFilterImage</span><span class="p">)</span>
                <span class="n">tmpPhase</span> <span class="o">=</span> <span class="n">TmpGWTPhase</span><span class="p">[</span><span class="n">rangeXY</span><span class="p">,:][:,</span><span class="n">rangeXY</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">JetsPhase</span><span class="p">[:,</span><span class="n">LevelL</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nOrientation</span><span class="o">+</span><span class="n">DirecL</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpPhase</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="c">#import pdb; pdb.set_trace()</span>

                <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s">&#39;complex&#39;</span><span class="p">:</span>
                    <span class="n">TmpGWTMag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">iTmpFilterImage</span><span class="p">)</span>
                    <span class="c"># get magnitude and phase at specific positions</span>
                    <span class="n">tmpMag</span> <span class="o">=</span> <span class="n">TmpGWTMag</span><span class="p">[</span><span class="n">rangeXY</span><span class="p">,:][:,</span><span class="n">rangeXY</span><span class="p">]</span>
                    <span class="n">JetsMagnitude</span><span class="p">[:,</span><span class="n">LevelL</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nOrientation</span><span class="o">+</span><span class="n">DirecL</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpMag</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;simple cell type not implemented yet&#39;</span><span class="p">)</span>
                    <span class="c">#TmpGWTMag_real = np.real(iTmpFilterImage)</span>
                    <span class="c">#TmpGWTMag_imag = np.imag(iTmpFilterImage)</span>
                    <span class="c">## get magnitude and phase at specific positions</span>
                    <span class="c">#tmpMag_real = TmpGWTMag_real[rangeXY,:][:,rangeXY]</span>
                    <span class="c">#tmpMag_imag = TmpGWTMag_imag[rangeXY,:][:,rangeXY]</span>
                    <span class="c">#JetsMagnitude_real[:,LevelL*self.nOrientation+DirecL] = tmpMag_real.ravel()</span>
                    <span class="c">#JetsMagnitude_imag[:,LevelL*self.nOrientation+DirecL] =  tmpMag_imag.ravel()</span>

        <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s">&#39;simple&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;simple cell type not implemented yet&#39;</span><span class="p">)</span>
            <span class="c">#JetsMagnitude = np.vstack((JetsMagnitude_real, JetsMagnitude_imag))</span>
        <span class="c"># use magnitude for dissimilarity measures</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">JetsMagnitude</span><span class="p">,</span> <span class="n">JetsPhase</span><span class="p">,</span> <span class="n">grid_position</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GaborJet.dissimilarity"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.GaborJet.dissimilarity.html#psychopy_ext.models.GaborJet.dissimilarity">[docs]</a>    <span class="k">def</span> <span class="nf">dissimilarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;kind&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;kind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;gaborjet&#39;</span>  <span class="c"># we want this by default</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">GaborJet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">dissimilarity</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GaborJet.compare"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.GaborJet.compare.html#psychopy_ext.models.GaborJet.compare">[docs]</a>    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ims</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">print</span> <span class="s">&#39;processing image&#39;</span><span class="p">,</span>
        <span class="k">for</span> <span class="n">imno</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span>
            <span class="k">print</span> <span class="n">imno</span><span class="p">,</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c"># use JetsMagnitude</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">dis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dissimilarity</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">print</span>
        <span class="k">print</span> <span class="s">&#39;Dissimilarity across stimuli&#39;</span>
        <span class="k">print</span> <span class="s">&#39;0: similar, 1: dissimilar&#39;</span>
        <span class="k">print</span> <span class="n">dis</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Dissimilarity across stimuli</span><span class="se">\n</span><span class="s">&#39;</span>
                  <span class="s">&#39;(blue: similar, red: dissimilar)&#39;</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

</div>
<span class="k">class</span> <span class="nc">HMAX</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    HMAX for Python</span>

<span class="sd">    Based on the original HMAX (`Riesenhuber &amp; Poggio, 1999</span>
<span class="sd">    &lt;http://dx.doi.org/10.1038/14819&gt;`_)</span>
<span class="sd">    Code rewritten using a Pure MatLab implementation by Minjoon Kouh at the</span>
<span class="sd">    MIT Center for Biological and Computational Learning. Most of the</span>
<span class="sd">    structure, variable names and some of the comments come from this</span>
<span class="sd">    implementation. More comments have been added and code was optimized as</span>
<span class="sd">    much as possible while trying to maintain its structure close to the</span>
<span class="sd">    original. View-tuned units have been added by Hans Op de Beeck.</span>

<span class="sd">    Code&#39;s output is tested against the Pure MatLab output which can be tested</span>
<span class="sd">    against the Standard C/MatLab code featured at `Riesenhuber&#39;s lab</span>
<span class="sd">    &lt;http://riesenhuberlab.neuro.georgetown.edu/hmax/index.html#code&gt;`_.</span>
<span class="sd">    You can compare the outputs to the standard Lena image between the present</span>
<span class="sd">    and C/MatLab implementation using function :mod:test_models</span>

<span class="sd">    Note that this implementation is not the most current HMAX</span>
<span class="sd">    implementation that doesn&#39;t rely on hardcoding features anymore (e.g.,</span>
<span class="sd">    Serre et al., 2007).</span>

<span class="sd">    Copyright 2011-2012 Jonas Kubilius</span>

<span class="sd">    Original VTU implementation copyright 2007 Hans P. Op de Beeck</span>

<span class="sd">    Original MatLab implementation copyright 2004 Minjoon Kouh</span>

<span class="sd">    Since the original code did not specify a license type, I assume GNU GPL v3</span>
<span class="sd">    since it is used in `Jim Mutch&#39;s latest implementation of HMAX</span>
<span class="sd">    &lt;http://cbcl.mit.edu/jmutch/cns/&gt;`_</span>

<span class="sd">    :Kwargs:</span>

<span class="sd">        - matlab (boolean, default: False)</span>
<span class="sd">            If *True*, Gaussian filters will be implemented using the</span>
<span class="sd">            original models implementation which mimicks MatLab&#39;s behavior.</span>
<span class="sd">            Otherwise, a more efficient numerical method is used.</span>
<span class="sd">        - filt_type ({&#39;gaussian&#39;, &#39;gabor&#39;}, default: &#39;gaussian&#39;)</span>
<span class="sd">            Type of V1 filter. We default to gaussian as it was used originally</span>
<span class="sd">            in HMAX&#39;99. However, many people prefer using Gabor filters as</span>
<span class="sd">            they presumambly model V1 better.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="HMAX.__init__"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.__init__.html#psychopy_ext.models.HMAX.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matlab</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">filt_type</span><span class="o">=</span><span class="s">&#39;gaussian&#39;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_ori</span> <span class="o">=</span> <span class="mi">4</span> <span class="c"># number of orientations</span>
        <span class="c"># S1 filter sizes for scale band 1, 2, 3, and 4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_sizes_all</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">21</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mi">23</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">29</span><span class="p">]]</span>
        <span class="c"># specify (per scale band) how many S1 units will be used to pool over</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C1_pooling_all</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>  <span class="c"># how many C1 outputs to put into one &quot;window&quot; in S2 in each direction</span>

        <span class="k">if</span> <span class="n">filt_type</span> <span class="o">==</span> <span class="s">&#39;gaussian&#39;</span><span class="p">:</span>  <span class="c"># &quot;typically&quot; used</span>
            <span class="k">if</span> <span class="n">matlab</span><span class="p">:</span>  <span class="c"># exact replica of the MatLab implementation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gaussians_matlab</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_sizes_all</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">n_ori</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c"># a faster and more elegant implementation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gaussians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_sizes_all</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">n_ori</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask_name</span> <span class="o">=</span> <span class="s">&#39;square&#39;</span>
        <span class="k">elif</span> <span class="n">filt_type</span> <span class="o">==</span> <span class="s">&#39;gabor&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gabors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_sizes_all</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ori</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask_name</span> <span class="o">=</span> <span class="s">&#39;circle&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;filter type not recognized&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">istrained</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># initially VTUs are not set up</span>
</div>
<div class="viewcode-block" id="HMAX.run"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.run.html#psychopy_ext.models.HMAX.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_ims</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">train_ims</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">oneval</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the main function to run the model.</span>
<span class="sd">        First, it trains the model, i.e., sets up prototypes for VTU.</span>
<span class="sd">        Next, it runs the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">train_ims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">train_ims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test_ims</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">test_ims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_teststim</span><span class="p">()]</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">test_ims</span><span class="p">,</span> <span class="n">oneval</span><span class="o">=</span><span class="n">oneval</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">oneval</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[</span><span class="s">&#39;C2&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>
</div>
<div class="viewcode-block" id="HMAX.train"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.train.html#psychopy_ext.models.HMAX.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_ims</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train the model, i.e., supply VTUs with C2 responses to &#39;prototype&#39;</span>
<span class="sd">        images to which these units will be maximally tuned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tuning</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">train_ims</span><span class="p">,</span><span class="s">&#39;rb&#39;</span><span class="p">))</span>
            <span class="k">print</span> <span class="s">&#39;done&#39;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">train_ims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input2array</span><span class="p">(</span><span class="n">train_ims</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tuning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="n">train_ims</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s">&#39;training&#39;</span><span class="p">)[</span><span class="s">&#39;C2&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">istrained</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="HMAX.test"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.test.html#psychopy_ext.models.HMAX.test">[docs]</a>    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ims</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s">&#39;testing&#39;</span><span class="p">,</span> <span class="n">oneval</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test the model on the given image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input2array</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span>
        <span class="c"># Get number of filter sizes</span>
        <span class="n">size_S1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span> <span class="k">for</span> <span class="n">fs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_sizes_all</span><span class="p">])</span>
        <span class="c"># outputs from each layer are stored if you want to inspect them closer</span>
        <span class="c"># but note that S1 is *massive*</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># S1 will not be in the output because it&#39;s too large:</span>
        <span class="c"># with default parameters S1 takes 256*256*12*4*64bits = 24Mb per image</span>
        <span class="n">S1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ims</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ims</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">size_S1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ori</span><span class="p">))</span>
        <span class="n">output</span><span class="p">[</span><span class="s">&#39;C1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ims</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_ori</span><span class="p">,</span>
                                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_sizes_all</span><span class="p">)))</span>
        <span class="c"># S2 has an irregular shape which depends on the spatial frequency band</span>
        <span class="c"># so we&#39;ll omit it as well</span>
        <span class="n">S2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">C2_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n_ori</span><span class="p">,</span>
                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_sizes_all</span><span class="p">)))</span>
        <span class="n">output</span><span class="p">[</span><span class="s">&#39;C2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">),</span><span class="n">C2_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">imNo</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">Running HMAX... </span><span class="si">%s</span><span class="s">: </span><span class="si">%d%%</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">imNo</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="c"># Go through each scale band</span>
            <span class="n">S1_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">which_band</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_sizes_all</span><span class="p">)):</span>
                <span class="c"># calculate S1 responses</span>
                <span class="n">S1_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_S1</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">which_band</span><span class="p">)</span>
                <span class="n">num_filter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_sizes_all</span><span class="p">[</span><span class="n">which_band</span><span class="p">])</span>
                <span class="c"># store S1 responses for each scale band</span>
                <span class="n">S1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">S1_idx</span><span class="p">:</span><span class="n">S1_idx</span> <span class="o">+</span> <span class="n">num_filter</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">S1_tmp</span>
                <span class="n">S1_idx</span> <span class="o">+=</span> <span class="n">num_filter</span>
                <span class="c"># calculate other layers</span>
                <span class="n">C1_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C1</span><span class="p">(</span><span class="n">S1_tmp</span><span class="p">,</span> <span class="n">which_band</span><span class="p">)</span>
                <span class="n">output</span><span class="p">[</span><span class="s">&#39;C1&#39;</span><span class="p">][</span><span class="n">imNo</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">which_band</span><span class="p">]</span> <span class="o">=</span> <span class="n">C1_tmp</span>
                <span class="n">S2_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_S2</span><span class="p">(</span><span class="n">C1_tmp</span><span class="p">,</span> <span class="n">which_band</span><span class="p">)</span>
                <span class="n">S2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S2_tmp</span><span class="p">)</span>
                <span class="n">C2_tmp</span><span class="p">[:,</span> <span class="n">which_band</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C2</span><span class="p">(</span><span class="n">S2_tmp</span><span class="p">,</span> <span class="n">which_band</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s">&#39;C2&#39;</span><span class="p">][</span><span class="n">imNo</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">C2_tmp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c"># max over all scale bands</span>
        <span class="n">output</span><span class="p">[</span><span class="s">&#39;S2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S2</span>
        <span class="c"># calculate VTU if trained</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">istrained</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s">&#39;VTU&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_VTU</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s">&#39;C2&#39;</span><span class="p">])</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">Running HMAX... </span><span class="si">%s</span><span class="s">: done</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span><span class="n">op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>
</div>
<div class="viewcode-block" id="HMAX.get_gaussians"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.get_gaussians.html#psychopy_ext.models.HMAX.get_gaussians">[docs]</a>    <span class="k">def</span> <span class="nf">get_gaussians</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filter_sizes_all</span><span class="p">,</span>
        <span class="n">n_ori</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">sigDivisor</span> <span class="o">=</span> <span class="mf">4.</span>
        <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates 2D difference of Gaussians (DoG) filters.</span>
<span class="sd">        This function is a faster, more accurate and more elegant version of</span>
<span class="sd">        the original gaussian_filters_matlab but will not produce identical</span>
<span class="sd">        filters as the original (but very close). For practical purposes, this</span>
<span class="sd">        one is prefered. In case you want to mimic the identical behavior of</span>
<span class="sd">        the original HMAX, use gaussian_filters_matlab.</span>

<span class="sd">        **Parameters**</span>
<span class="sd">            filter_sizes_all: list (depth 2))</span>
<span class="sd">                A nested list (grouped by filter bands) of integer filter sizes</span>
<span class="sd">            n_ori: int</span>
<span class="sd">                A number of filter orientations (default: 4)</span>
<span class="sd">                Orientations are spaced by np.pi/n_ori</span>
<span class="sd">            sigDivisor: float</span>
<span class="sd">                A parameter to adjust DoG filter frequency (default: 4.)</span>

<span class="sd">        **Returns**</span>
<span class="sd">            gaussians: list (depth 2)</span>
<span class="sd">                A nested list of filters of all orientations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gaussians</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># loop over filter bands</span>
        <span class="k">for</span> <span class="n">fNo</span><span class="p">,</span> <span class="n">filter_sizes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filter_sizes_all</span><span class="p">):</span>
            <span class="n">gaussians</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

            <span class="c"># loop over filter sizes within a filter band</span>
            <span class="k">for</span> <span class="n">filter_size</span> <span class="ow">in</span> <span class="n">filter_sizes</span><span class="p">:</span>
                <span class="n">fxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">filter_size</span><span class="p">,</span><span class="n">filter_size</span><span class="p">,</span><span class="n">n_ori</span><span class="p">))</span>
                <span class="n">sigmaq</span> <span class="o">=</span> <span class="p">(</span><span class="n">filter_size</span><span class="o">/</span><span class="n">sigDivisor</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">filter_size</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">filter_size</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ii</span><span class="p">,</span><span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ori</span><span class="p">):</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">n_ori</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">ii</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">jj</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">ii</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">jj</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                    <span class="c"># generate a 2D DoG of a particular orientation</span>
                    <span class="n">gaussian</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">sigmaq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigmaq</span> <span class="o">*</span> \
                                <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigmaq</span><span class="p">))</span>
                    <span class="c"># normalize the filter to zero mean and unit variance</span>
                    <span class="n">gaussian</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">gaussian</span><span class="p">)</span>
                    <span class="n">gaussian</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gaussian</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">fxx</span><span class="p">[:,:,</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaussian</span>

                <span class="n">gaussians</span><span class="p">[</span><span class="n">fNo</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gaussians</span>

</div>
<div class="viewcode-block" id="HMAX.get_gaussians_matlab"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.get_gaussians_matlab.html#psychopy_ext.models.HMAX.get_gaussians_matlab">[docs]</a>    <span class="k">def</span> <span class="nf">get_gaussians_matlab</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filter_sizes_all</span><span class="p">,</span>
        <span class="n">n_ori</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">sigDivisor</span> <span class="o">=</span> <span class="mf">4.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates 2D difference of Gaussians (DoG) filters.</span>
<span class="sd">        This is the original version of DoG filters used in HMAX. It was</span>
<span class="sd">        written in a very cumbersome way and thus I replaced it by the</span>
<span class="sd">        gaussian_filters function. If you want to produce identical</span>
<span class="sd">        numerical values of the filters, you should use this function.</span>
<span class="sd">        Otherwise, gaussian_filters does the job just as well, but much nicer.</span>

<span class="sd">        **Parameters**</span>
<span class="sd">            filter_sizes_all: list (depth 2))</span>
<span class="sd">                A nested list (grouped by filter bands) of integer filter sizes</span>
<span class="sd">            n_ori: int</span>
<span class="sd">                A number of filter orientations (default: 4)</span>
<span class="sd">                Orientations are spaced by np.pi/n_ori</span>
<span class="sd">            sigDivisor: float</span>
<span class="sd">                A parameter to adjust DoG filter frequency (default: 4.)</span>

<span class="sd">        **Returns**</span>
<span class="sd">            gaussians: list (depth 2)</span>
<span class="sd">                A nested list of filters of all orientations</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gaussians</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># loop over filter bands</span>
        <span class="k">for</span> <span class="n">fNo</span><span class="p">,</span> <span class="n">filter_sizes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filter_sizes_all</span><span class="p">):</span>
            <span class="n">gaussians</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

            <span class="c"># loop over filter sizes within a filter band</span>
            <span class="k">for</span> <span class="n">filter_size</span> <span class="ow">in</span> <span class="n">filter_sizes</span><span class="p">:</span>
                <span class="n">fx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">filter_size</span><span class="p">,</span><span class="n">filter_size</span><span class="p">,</span><span class="n">n_ori</span><span class="p">))</span>

                <span class="c"># we gonna use a trick here:</span>
                <span class="c"># make filters sqrt(2) times bigger so that we can rotate them</span>
                <span class="c"># without getting zeros around the edges</span>
                <span class="n">fieldSize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">filter_size</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
                <span class="n">fieldSize</span> <span class="o">=</span> <span class="n">fieldSize</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fieldSize</span><span class="o">%</span><span class="mi">2</span> <span class="c"># make odd</span>
                <span class="n">filtSizeH</span> <span class="o">=</span> <span class="n">fieldSize</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">cropOff</span> <span class="o">=</span> <span class="p">(</span><span class="n">fieldSize</span><span class="o">-</span><span class="n">filter_size</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">cropRange</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cropOff</span><span class="p">,</span> <span class="n">cropOff</span><span class="o">+</span><span class="n">filter_size</span><span class="p">)</span>
                <span class="n">sigmaq</span> <span class="o">=</span> <span class="p">(</span><span class="n">filter_size</span><span class="o">/</span><span class="n">sigDivisor</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

                <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">fieldSize</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">fieldSize</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ii</span><span class="p">,</span><span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

                <span class="n">theta</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">ii</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">jj</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">ii</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">jj</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="c"># generate a 2D DoG of 0 deg orientation</span>
                <span class="n">fxx</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">sigmaq</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">sigmaq</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigmaq</span><span class="p">))</span>

                <span class="c"># now loop over the orientations, rotate and trim the filter</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ori</span><span class="p">):</span>
                    <span class="n">fxx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addZeros</span><span class="p">(</span><span class="n">fxx</span><span class="p">,</span><span class="n">cropOff</span><span class="p">)</span>
                    <span class="n">fxx</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">fxx</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="n">reshape</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">fxx</span> <span class="o">=</span> <span class="n">fxx</span><span class="p">[</span><span class="n">cropOff</span><span class="p">:</span><span class="n">fieldSize</span><span class="o">+</span><span class="n">cropOff</span><span class="p">,</span><span class="n">cropOff</span><span class="p">:</span><span class="n">fieldSize</span><span class="o">+</span><span class="n">cropOff</span><span class="p">]</span>
                    <span class="c"># we generate first rotated versions of a filter</span>
                    <span class="c"># and end up with the one having 0 deg, but now having</span>
                    <span class="c"># undergonne all interpolations and rotations</span>
                    <span class="c"># to make things equall</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n_ori</span>
                    <span class="c"># crop the edges</span>
                    <span class="c"># note that you should assign this cropped version to sth</span>
                    <span class="c"># like fx1[:,:,count], and not a variable on its own</span>
                    <span class="c"># as otherwise you only pass a reference to fxx</span>
                    <span class="c"># so you&#39;d modify fxx as well when normalizing</span>
                    <span class="c"># and you really don&#39;t want that</span>
                    <span class="n">fx1</span><span class="p">[:,:,</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">fxx</span><span class="p">[</span><span class="n">cropRange</span><span class="p">,</span> <span class="n">cropRange</span><span class="p">]</span>
                    <span class="c"># normalize the filter to zero mean and unit variance</span>
                    <span class="n">fx1</span><span class="p">[:,:,</span><span class="n">count</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fx1</span><span class="p">[:,:,</span><span class="n">count</span><span class="p">])</span>
                    <span class="n">fx1</span><span class="p">[:,:,</span><span class="n">count</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fx1</span><span class="p">[:,:,</span><span class="n">count</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">gaussians</span><span class="p">[</span><span class="n">fNo</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fx1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gaussians</span>
</div>
<div class="viewcode-block" id="HMAX.get_gabors"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.get_gabors.html#psychopy_ext.models.HMAX.get_gabors">[docs]</a>    <span class="k">def</span> <span class="nf">get_gabors</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filter_sizes_all</span><span class="p">,</span>
        <span class="n">n_ori</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mf">2.1</span><span class="p">,</span>
        <span class="n">sx</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="mf">1.8</span><span class="p">,</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># S1 Gabor function phase (0 for cosine and pi/2 for sine)</span>

        <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates 2D Gabor filters.</span>
<span class="sd">        This is the original version of Gabor filters used in HMAX.</span>

<span class="sd">        **Parameters**</span>
<span class="sd">            filter_sizes_all: list (depth 2))</span>
<span class="sd">                A nested list (grouped by filter bands) of integer filter sizes</span>
<span class="sd">            n_ori: int</span>
<span class="sd">                A number of filter orientations (default: 4)</span>
<span class="sd">                Orientations are spaced by np.pi/n_ori</span>
<span class="sd">            k: float</span>
<span class="sd">                Gabor wave number (default: 2.1)</span>
<span class="sd">            sx: float</span>
<span class="sd">                Gabor sigma in x-dir (default: 2*np.pi * 1/3.)</span>
<span class="sd">            sy: float</span>
<span class="sd">                Gabor sigma in y-dir (default: 2*np.pi * 1/1.8)</span>
<span class="sd">            phase: int</span>
<span class="sd">                Gabor function phase (0 (default) for cosine (even),</span>
<span class="sd">                                      np.pi/2 for sine (odd))</span>

<span class="sd">        **Returns**</span>
<span class="sd">            gabors: list (depth 2)</span>
<span class="sd">                A nested list of filters of all orientations</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gabors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># loop over filter bands</span>
        <span class="k">for</span> <span class="n">fNo</span><span class="p">,</span> <span class="n">filter_sizes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filter_sizes_all</span><span class="p">):</span>
            <span class="n">gabors</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c"># loop over filter sizes within a filter band</span>
            <span class="k">for</span> <span class="n">filter_size</span> <span class="ow">in</span> <span class="n">filter_sizes</span><span class="p">:</span>
                <span class="n">fxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">filter_size</span><span class="p">,</span> <span class="n">filter_size</span><span class="p">,</span> <span class="n">n_ori</span><span class="p">))</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">filter_size</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">inc</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">inc</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
                <span class="n">ii</span><span class="p">,</span><span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

                <span class="n">circle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circle</span><span class="p">(</span><span class="n">filter_size</span><span class="p">)</span>
                <span class="n">circle_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ori</span><span class="p">):</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">n_ori</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">ii</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">jj</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">ii</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">jj</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                    <span class="c"># generate a 2D DoG of a particular orientation</span>
                    <span class="n">gabor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">phase</span><span class="p">)</span> <span class="o">*</span> \
                            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">sx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">sy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="c"># apply circle mask</span>
                    <span class="n">gabor</span> <span class="o">*=</span> <span class="n">circle</span>
                    <span class="c"># normalize the filter to zero mean and unit variance</span>
                    <span class="n">gabor</span> <span class="o">-=</span> <span class="n">circle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gabor</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>
                    <span class="n">gabor</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gabor</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">fxx</span><span class="p">[:,:,</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">gabor</span>
                <span class="n">gabors</span><span class="p">[</span><span class="n">fNo</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gabors</span>
</div>
<div class="viewcode-block" id="HMAX.get_circle"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.get_circle.html#psychopy_ext.models.HMAX.get_circle">[docs]</a>    <span class="k">def</span> <span class="nf">get_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_size</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
            <span class="n">inc</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">/</span><span class="n">filter_size</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">inc</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">inc</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span>

</div>
<div class="viewcode-block" id="HMAX.addZeros"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.addZeros.html#psychopy_ext.models.HMAX.addZeros">[docs]</a>    <span class="k">def</span> <span class="nf">addZeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">numZeros</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pads matrix with zeros</span>

<span class="sd">        **Parameters**</span>
<span class="sd">            matrix: numpy.array</span>
<span class="sd">                A 2D numpy array to be padded</span>
<span class="sd">            numZeros: int</span>
<span class="sd">                Number of rows and colums of zeros to pad</span>

<span class="sd">        **Returns**</span>
<span class="sd">            matrix_new: numpy.array</span>
<span class="sd">                A zero-padded 2D numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">numZeros</span><span class="p">,</span>
            <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">numZeros</span><span class="p">))</span>
        <span class="n">matrix_new</span><span class="p">[</span><span class="n">numZeros</span><span class="p">:</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">numZeros</span><span class="p">,</span>
            <span class="n">numZeros</span><span class="p">:</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">numZeros</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span>

        <span class="k">return</span> <span class="n">matrix_new</span>

</div>
<div class="viewcode-block" id="HMAX.get_S1"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.get_S1.html#psychopy_ext.models.HMAX.get_S1">[docs]</a>    <span class="k">def</span> <span class="nf">get_S1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">whichBand</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns S1 responses,</span>
<span class="sd">        using the difference of the Gaussians or Gabors as S1 filters.</span>
<span class="sd">        Filters are based on the original HMAX model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filter_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_sizes_all</span><span class="p">[</span><span class="n">whichBand</span><span class="p">]</span>
        <span class="n">num_filter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filter_sizes</span><span class="p">)</span>
        <span class="c"># make S1 same size as stimulus</span>
        <span class="n">S1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_filter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ori</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_filter</span><span class="p">):</span>
            <span class="n">S1_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filts</span><span class="p">[</span><span class="n">whichBand</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">filter_sizes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_name</span> <span class="o">==</span> <span class="s">&#39;circle&#39;</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circle</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">fs</span><span class="p">,</span><span class="n">fs</span><span class="p">))</span>
            <span class="c"># import pdb; pdb.set_trace()</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">im</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;constant&#39;</span><span class="p">)</span> <span class="o">+</span> \
                                          <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">epsilon</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_ori</span><span class="p">):</span>
                <span class="n">S1_buf</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">S1_filter</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span>
                                                <span class="n">mode</span><span class="o">=</span><span class="s">&#39;constant&#39;</span><span class="p">)</span>
                <span class="n">S1</span><span class="p">[:,:,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1_buf</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S1</span>

</div>
<div class="viewcode-block" id="HMAX.get_C1"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.get_C1.html#psychopy_ext.models.HMAX.get_C1">[docs]</a>    <span class="k">def</span> <span class="nf">get_C1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span> <span class="n">which_band</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes C1 responses given S1 as a max over a a couple of filter</span>
<span class="sd">        (as defined by C1_pooling)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C1_pooling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C1_pooling_all</span><span class="p">[</span><span class="n">which_band</span><span class="p">]</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">maximum_filter</span><span class="p">(</span>
            <span class="n">S1</span><span class="p">,</span>
            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">C1_pooling</span><span class="p">,</span><span class="n">C1_pooling</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s">&#39;constant&#39;</span><span class="p">,</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">C1_pooling</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c"># Max over scales;</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">C1</span>

</div>
<div class="viewcode-block" id="HMAX.get_S2"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.get_S2.html#psychopy_ext.models.HMAX.get_S2">[docs]</a>    <span class="k">def</span> <span class="nf">get_S2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">which_band</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates S2 responses given C1.</span>

<span class="sd">        First it pools over C1 activities over various combinations of 4</span>
<span class="sd">        filters.</span>
<span class="sd">        Then computes a distance to /target/ using /sigma/ as its tuning</span>
<span class="sd">        sharpness.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># half overlaped S2 sampling</span>
        <span class="n">S2_shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C1_pooling_all</span><span class="p">[</span><span class="n">which_band</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span>
        <span class="c"># C1 afferents are adjacent for each S2</span>
        <span class="n">C1_shift</span> <span class="o">=</span> <span class="n">S2_shift</span> <span class="o">*</span> <span class="mi">2</span> <span class="c"># distance/shift between C1 afferents</span>
        <span class="n">S2_buf</span> <span class="o">=</span> <span class="p">[</span><span class="n">C1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">C1_shift</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">C1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">C1_shift</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c"># produce a sequence of all possible orientation combinations</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_ori</span><span class="p">),</span>
            <span class="n">repeat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c"># we have to keep the same order as in the original model</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">])</span>

        <span class="n">S2_permute</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span>
            <span class="p">(</span><span class="n">S2_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">S2_shift</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">(</span><span class="n">S2_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">S2_shift</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S2_config</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">c2</span> <span class="o">+</span> <span class="n">c1</span>
                <span class="n">r1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">C1_shift</span><span class="o">*</span><span class="n">c1</span><span class="p">,</span> <span class="n">S2_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">C1_shift</span><span class="o">*</span><span class="n">c1</span><span class="p">,</span> <span class="n">S2_shift</span><span class="p">)</span>
                <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">C1_shift</span><span class="o">*</span><span class="n">c2</span><span class="p">,</span> <span class="n">S2_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">C1_shift</span><span class="o">*</span><span class="n">c2</span><span class="p">,</span> <span class="n">S2_shift</span><span class="p">)</span>
                <span class="n">ii</span><span class="p">,</span><span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
                <span class="n">S2_permute</span><span class="p">[:,:,:,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">C1</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span><span class="n">ii</span><span class="p">],</span> <span class="n">seq</span><span class="p">[:,</span><span class="n">c</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="c"># for si, s in enumerate(seq):</span>
                <span class="c">#     S2_permute[:,:,si,c] = C1[jj,ii,s[c]] # the window is</span>
                                                         <span class="c"># sliding in the x-dir</span>
        <span class="n">S2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">S2_permute</span><span class="o">-</span><span class="n">target</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">S2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">S2</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">S2</span>
</div>
<div class="viewcode-block" id="HMAX.get_C2"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.get_C2.html#psychopy_ext.models.HMAX.get_C2">[docs]</a>    <span class="k">def</span> <span class="nf">get_C2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S2</span><span class="p">,</span> <span class="n">which_band</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;C2 is a max over space per an S2 filter quadruplet&quot;&quot;&quot;</span>
        <span class="k">return</span>  <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">S2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="HMAX.get_VTU"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.get_VTU.html#psychopy_ext.models.HMAX.get_VTU">[docs]</a>    <span class="k">def</span> <span class="nf">get_VTU</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C2resp</span><span class="p">,</span> <span class="n">tuningWidth</span> <span class="o">=</span> <span class="o">.</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate response of view-tuned units</span>

<span class="sd">        **Parameters**</span>
<span class="sd">            c2RespSpec: numpy.array</span>
<span class="sd">                C2 responses to the stimuli</span>
<span class="sd">            tuningWidth: float</span>
<span class="sd">                How sharply VTUs should be tuned; lower values are shaper</span>
<span class="sd">                tuning (default: .1)</span>
<span class="sd">        **Returns**</span>
<span class="sd">            output: np.array</span>
<span class="sd">                An array where each column represents view-tuned units</span>
<span class="sd">                responses to a particular image (stimulus)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">sq</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="c"># difference between tuning and each C2 response</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tuning</span> <span class="o">-</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">row</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">tuning</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
            <span class="c"># this difference is then square-summed and then exponentiated :)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">sq</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">diff</span><span class="p">)</span> <span class="o">/</span> <span class="n">tuningWidth</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">istrained</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;You must first train VTUs by providing prototype &quot;</span>
                            <span class="s">&quot;images to them using the train() function&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">C2resp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tuning</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;The size of exemplar matrix does not match &quot;</span>
                            <span class="s">&quot;that of the prototype matrix&quot;</span><span class="p">)</span>
        <span class="c"># apply func on each row</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">C2resp</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="HMAX.compare"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.HMAX.compare.html#psychopy_ext.models.HMAX.compare">[docs]</a>    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ims</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">ims</span>
        <span class="k">print</span> <span class="s">&#39;processing image&#39;</span><span class="p">,</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">ims</span><span class="p">)[</span><span class="s">&#39;C2&#39;</span><span class="p">]</span>
        <span class="n">dis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dissimilarity</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">print</span>
        <span class="k">print</span> <span class="s">&#39;Dissimilarity across stimuli&#39;</span>
        <span class="k">print</span> <span class="s">&#39;0: similar, 1: dissimilar&#39;</span>
        <span class="k">print</span> <span class="n">dis</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Dissimilarity across stimuli</span><span class="se">\n</span><span class="s">&#39;</span>
                  <span class="s">&#39;(blue: similar, red: dissimilar)&#39;</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

</div>
<span class="n">KNOWN_MODELS</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;px&#39;</span><span class="p">:</span> <span class="n">Pixelwise</span><span class="p">,</span> <span class="s">&#39;gaborjet&#39;</span><span class="p">:</span> <span class="n">GaborJet</span><span class="p">,</span> <span class="s">&#39;hmax&#39;</span><span class="p">:</span> <span class="n">HMAX</span><span class="p">}</span>
<span class="c">#[&#39;px&#39;: Pixelwise, GaborJet, HMAX]</span>

<div class="viewcode-block" id="get_model"><a class="viewcode-back" href="../../api/generated/psychopy_ext.models.get_model.html#psychopy_ext.models.get_model">[docs]</a><span class="k">def</span> <span class="nf">get_model</span><span class="p">(</span><span class="n">model_name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">KNOWN_MODELS</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">KNOWN_MODELS</span><span class="p">[</span><span class="n">model_name</span><span class="p">]()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Model </span><span class="si">%s</span><span class="s"> not recognized&#39;</span> <span class="o">%</span><span class="n">model_name</span><span class="p">)</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">models</span> <span class="o">=</span> <span class="n">KNOWN_MODELS</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">HMAX</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">model_name</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span> <span class="n">m</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="n">model_name</span><span class="p">]()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c"># give image file names using glob syntax</span>
        <span class="n">ims</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ims</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">get_teststim</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">get_teststim</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span>
</pre></div>

        </div>

        <!-- Sidebar2
        ========================================== -->
          
      </div>
    </div>
  
  <footer>
  <div class="row">
    <div class="container">
      <div class="col-md-5">
        <img class="featurette-image img-rounded" src="../../_static/gpl.png" alt="Generic placeholder image">
      </div>
      <div class="col-md-7">
        <h2 class="featurette-heading">Free and Open Source.</h2>
        <p class="lead">psychopy_ext is licensed under GNU General Public License 3+.</p>
        <p class="author">Part of PsychoPy Standalone distribution.</p>
        <p class="author">Please cite it as: Kubilius, J. (2014). A framework for streamlining research workflow in neuroscience and psychology. <em>Frontiers in Neuroinformatics</em>, <em>7</em>, 52. doi: <a href="http://www.frontiersin.org/Neuroinformatics/10.3389/fninf.2013.00052/abstract">10.3389/fninf.2013.00052</a></p>
        <p class="author">Brought to you by Jonas Kubilius / <a href="http://klab.lt">klab.lt</a>, 2010-2014, using a <a href="https://github.com/ryan-roemer/sphinx-bootstrap-theme">themed</a> trio of <a href="http://sphinx-doc.org/">sphinx</a>, <a href="http://getbootstrap.com/">bootstrap</a> & <a href="http://bootswatch.com/">bootswatch</a></p>
      </div>
    </div>
  </div>
</footer>
  </body>
</html>