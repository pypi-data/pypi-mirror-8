<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>SpectralToolbox.HeterogeneousSparseGrids &mdash; DABISpectralToolbox 0.1a documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="DABISpectralToolbox 0.1a documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">DABISpectralToolbox 0.1a documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for SpectralToolbox.HeterogeneousSparseGrids</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>

<span class="c">#</span>
<span class="c"># This file is part of SpectralToolbox.</span>
<span class="c">#</span>
<span class="c"># SpectralToolbox is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the LGNU Lesser General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># SpectralToolbox is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># LGNU Lesser General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the LGNU Lesser General Public License</span>
<span class="c"># along with SpectralToolbox.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c">#</span>
<span class="c"># DTU UQ Library</span>
<span class="c"># Copyright (C) 2014 The Technical University of Denmark</span>
<span class="c"># Scientific Computing Section</span>
<span class="c"># Department of Applied Mathematics and Computer Science</span>
<span class="c">#</span>
<span class="c"># Author: Daniele Bigoni</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> Heterogeneous Sparse Grids</span>
<span class="sd">=========================================</span>

<span class="sd">Created on Wed Feb 27</span>

<span class="sd">@author: Daniele Bigoni (dabi@dtu.dk)</span>

<span class="sd">Description</span>
<span class="sd">-----------</span>

<span class="sd">This module is used to construct Heterogeneous Sparse Grids. These are integration rules based on Smolyak&#39;s Sparse Grids [6]_ built up in order to provide flexibility for both:</span>
<span class="sd">    #. the types of polynomials to be used per direction</span>
<span class="sd">    #. the accuracy to be used per direction</span>

<span class="sd">The types of polynomials available are all the ones included in the module :py:mod:`Spectral1D`. The rules don&#39;t need to be symmetric and the accuracy per each direction can vary.</span>

<span class="sd">For rules with Heterogeneous accuracy, two sparse grids will be construced: one partial sparse grid and one full sparse grid (up to the maximum accuracy). The values computed for the partial sparse grid can then be used to interpolate on the points of the full sparse grid. This latter rule can then be used to compute the integral.</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">.. [6] S. A. Smolyak, &quot;Quadrature and interpolation formulas for tensor products of certain classes of functions&quot;. Soviet Math. Dokl., 4:240â€“243, 1963</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>
<span class="sd">Let&#39;s consider the following space :math:`\Omega = [-\infty,\infty]\times[0,1]` with the associated measures :math:`\mu_1(x)=\\frac{1}{\\sqrt{2\pi}} e^{-\\frac{x^2}{2}}` and  :math:`\mu_2(x)=1` for each dimension. The product measure is given by :math:`\mu(\\bar{x})=\prod_{i=1}^n \mu_i(x_i)`. We will consider the function</span>

<span class="sd">.. math:: f(\\bar{x}) = x_1^{p_1} \\cdot x_2^{p_2}</span>

<span class="sd">&gt;&gt;&gt; f_mult = lambda x,y,xp,yp: x**xp * y**yp</span>

<span class="sd">with exact value of the integral given by</span>

<span class="sd">.. math:: \\int_\Omega f(\\bar{x}) \mu(\\bar{x}) = \\frac{2^{-1+p_2} \\left( 1+(-1)^{p_2} \\right) \\Gamma\\left( \\frac{1+p_2}{2} \\right)}{(1+p_1)\\sqrt{\pi}}</span>

<span class="sd">&gt;&gt;&gt; def I_mult(q,p):</span>
<span class="sd">&gt;&gt;&gt;     return 2.**(-.5+.5*(-1.+q)) * (1.+(-1.)**q) * scipy.special.gamma((1.+q)/2.) / ((1.+p)*np.sqrt(np.pi))</span>

<span class="sd">Let :math:`p_1=2` and :math:`p_2=4`. We can obtain a sparse grid composed using Hermite basis (:py:const:`Spectral1D.HERMITEP_PROB`) and Legendre basis (:py:const:`Spectral1D.JACOBI`) with orders 2 and 4 respectively.</span>

<span class="sd">&gt;&gt;&gt; from SpectralToolbox import HeterogeneousSparseGrids as HSG</span>
<span class="sd">&gt;&gt;&gt; pH = Spectral1D.Poly1D(Spectral1D.HERMITEP_PROB,None)</span>
<span class="sd">&gt;&gt;&gt; pL = Spectral1D.Poly1D(Spectral1D.JACOBI,[0.0,0.0])</span>
<span class="sd">&gt;&gt;&gt; polys = [pH,pL]</span>
<span class="sd">&gt;&gt;&gt; Ns = [2,4]</span>
<span class="sd">&gt;&gt;&gt; sg = HSG.HSparseGrid(polys,Ns)</span>
<span class="sd">&gt;&gt;&gt; (XF,W,X) = sg.sparseGrid()</span>
<span class="sd">[SG] Sparse Grid Generation [============================================] 100%</span>
<span class="sd">[SG] Sparse Grid Generation: 0.01s</span>
<span class="sd">&gt;&gt;&gt; XF[:,1] = (XF[:,1]+1.)/2.</span>
<span class="sd">&gt;&gt;&gt; X[:,1] = (X[:,1]+1.)/2.</span>
<span class="sd">&gt;&gt;&gt; plt.figure()</span>
<span class="sd">&gt;&gt;&gt; plt.plot(XF[:,0],XF[:,1],&#39;o&#39;)</span>
<span class="sd">&gt;&gt;&gt; plt.plot(X[:,0],X[:,1],&#39;or&#39;)</span>

<span class="sd">The resulting partial and full sparse grids are shown in the following figure.</span>

<span class="sd">.. _GridExample:</span>

<span class="sd">.. figure:: _static/Figures/HeterSparseGrids-GridExample.png</span>
<span class="sd">    </span>
<span class="sd">    Partial (red) and full (blue) sparse grid. The full sparse grid is overlapping over the partial sparse grid.</span>

<span class="sd">The values on the partial grid can be computed and then the interpolation is taken over the full sparse grid.</span>

<span class="sd">&gt;&gt;&gt; fX = f_mult(X[:,0],X[:,1],Q,P)</span>
<span class="sd">&gt;&gt;&gt; fXF = sg.sparseGridInterp(X,fX,XF)</span>
<span class="sd">[SG] Sparse Grid Interpolation [=========================================] 100%</span>
<span class="sd">[SG] Sparse Grid Interpolation: 0.00s</span>

<span class="sd">Finally the error of the quadrature rule is</span>

<span class="sd">&gt;&gt;&gt; IErr = np.abs(0.5*np.dot(fXF,W)-I_mult(Q,P))</span>
<span class="sd">&gt;&gt;&gt; print IErr</span>
<span class="sd">3.33066907388e-16</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__revision__</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">isdigit</span><span class="p">,</span> <span class="s">&quot;$Revision: 101 $&quot;</span><span class="p">)</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;Daniele Bigoni&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;Copyright 2012, Daniele Bigoni&quot;&quot;&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Daniele Bigoni&quot;</span><span class="p">]</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s">&quot;Daniele Bigoni&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s">&quot;dabi@dtu.dk&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s">&quot;Production&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">progressbar</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">scipy.special</span>

<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">from</span> <span class="nn">SpectralToolbox</span> <span class="kn">import</span> <span class="n">Misc</span>

<div class="viewcode-block" id="HSparseGrid"><a class="viewcode-back" href="../../index.html#SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid">[docs]</a><span class="k">class</span> <span class="nc">HSparseGrid</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Heterogeneous Sparse Grid class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Ns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sdout</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sdout</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor of Heterogeneous Sparse Grid object (this does not allocate the sparse grid)</span>
<span class="sd">        </span>
<span class="sd">        :param polys: orthogonal polynomials to be used as basis functions</span>
<span class="sd">        :type polys: list of :py:class:`Spectral1D.Poly1D`</span>
<span class="sd">        :param Ns: accuracy for each dimension. It can be a list of accuracies or a single accuracy, in which case uniform accuracy is assumed</span>
<span class="sd">        :type Ns: list of integers</span>
<span class="sd">        :param float tol: tolerance to be used when comparing points of the grid (optional, default=:py:func:`Misc.machineEpsilon()`)</span>
<span class="sd">        :param stream sdout: default output stream for the class (optional,default=``sys.stderr``)</span>
<span class="sd">        </span>
<span class="sd">        .. note:: one of the following must hold: len(polys)==len(Ns) or len(Ns)==1, in which case the same order is used for all the directions.</span>
<span class="sd">        </span>
<span class="sd">        **Example**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from SpectralToolbox import HeterogeneousSparseGrids as HSG</span>
<span class="sd">        &gt;&gt;&gt; pH = Spectral1D.Poly1D(Spectral1D.HERMITEP_PROB,None)</span>
<span class="sd">        &gt;&gt;&gt; pL = Spectral1D.Poly1D(Spectral1D.JACOBI,[0.0,0.0])</span>
<span class="sd">        &gt;&gt;&gt; polys = [pH,pL]</span>
<span class="sd">        &gt;&gt;&gt; Ns = [2,4]</span>
<span class="sd">        &gt;&gt;&gt; sg = HSG.HSparseGrid(polys,Ns)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sdout</span> <span class="o">=</span> <span class="n">sdout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span> <span class="ow">or</span> <span class="n">Misc</span><span class="o">.</span><span class="n">machineEpsilon</span><span class="p">()</span>
        
        <span class="c"># Check consistency of arguments</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Ns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ns</span><span class="p">):</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdout</span><span class="p">,</span> <span class="s">&quot;Size of parameters not consistent: either type(Ns)==int or len(polys) == len(Ns)&quot;</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&quot;Input Error.&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">polys</span> <span class="o">=</span> <span class="n">polys</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Ns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="n">Ns</span>
    
<div class="viewcode-block" id="HSparseGrid.sparseGrid"><a class="viewcode-back" href="../../index.html#SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid.sparseGrid">[docs]</a>    <span class="k">def</span> <span class="nf">sparseGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">heter</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generates the full and partial sparse grids</span>
<span class="sd">        </span>
<span class="sd">        :param bool heter: if :py:data:`Ns` is homogeneous, this parameter will force the output of the partial sparse grid as well</span>
<span class="sd">        </span>
<span class="sd">        :return: tuple :py:data:`(XF,WF,X)` containing:</span>
<span class="sd">            </span>
<span class="sd">            * :py:data:`XF`: full grid points</span>
<span class="sd">            * :py:data:`WF`: full grid weights</span>
<span class="sd">            * :py:data:`X`: partial grid points</span>
<span class="sd">        </span>
<span class="sd">        **Example**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; (XF,W,X) = sg.sparseGrid()</span>
<span class="sd">        [SG] Sparse Grid Generation [============================================] 100%</span>
<span class="sd">        [SG] Sparse Grid Generation: 0.01s</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">)</span>
        
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">)</span>
        
        <span class="n">heterogeneous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="o">&lt;</span><span class="n">k</span><span class="p">)</span> <span class="ow">or</span> <span class="n">heter</span>
        
        <span class="c"># Compute the number of multi-index elements</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        
        <span class="c"># Initialize the progress bar</span>
        <span class="n">bar</span> <span class="o">=</span> <span class="n">progressbar</span><span class="o">.</span><span class="n">ProgressBar</span><span class="p">(</span><span class="n">maxval</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">),</span> 
                                      <span class="n">widgets</span><span class="o">=</span><span class="p">[</span><span class="n">progressbar</span><span class="o">.</span><span class="n">Bar</span><span class="p">(</span>
                                      <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="s">&#39;[SG] Sparse Grid Generation [&#39;</span><span class="p">,</span> <span class="s">&#39;]&#39;</span><span class="p">),</span> <span class="s">&#39; &#39;</span><span class="p">,</span> <span class="n">progressbar</span><span class="o">.</span><span class="n">Percentage</span><span class="p">()])</span>
        <span class="n">bar</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        
        <span class="c"># Generate list of nodes and weights for univariate formulas</span>
        <span class="n">quadLists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i_d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">qList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j_N</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">qList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">i_d</span><span class="p">]</span><span class="o">.</span><span class="n">GaussQuadrature</span><span class="p">(</span><span class="n">j_N</span><span class="p">))</span>
            <span class="n">quadLists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qList</span><span class="p">)</span>
        
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Preallocation of memory for points and weights.</span>
<span class="sd">        The allocated memory is doubled all the times the allocated memory if filled.</span>
<span class="sd">        A counter is used to keep track of the last data position.</span>
<span class="sd">        Starting size is set to 10.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">X_full_exp</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">ExpandingArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)),</span><span class="n">maxIncrement</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="n">d</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">5</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">heterogeneous</span><span class="p">:</span>
            <span class="n">X_part_exp</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">ExpandingArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">)),</span><span class="n">maxIncrement</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="n">d</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">5</span><span class="p">))</span>
        
        <span class="n">W_exp</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">ExpandingArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">maxIncrement</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="n">d</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">5</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="n">counter</span><span class="p">,</span><span class="n">idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idxs</span><span class="p">):</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
            
            <span class="n">bq</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">wKron</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">for</span> <span class="n">idx_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="n">quadLists</span><span class="p">[</span><span class="n">idx_i</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">idx_i</span><span class="p">]]</span>
                <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">wKron</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">wKron</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
            
            <span class="n">xKron</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xs</span><span class="p">)))</span>
            <span class="n">lenX_full</span> <span class="o">=</span> <span class="n">X_full_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">X_full_exp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">xKron</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">heterogeneous</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">idx</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">):</span>
                <span class="n">lenX_part</span> <span class="o">=</span> <span class="n">X_part_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">X_part_exp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">xKron</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">W_exp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">bq</span> <span class="o">*</span> <span class="n">wKron</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c"># Sort</span>
            <span class="n">perm_full</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">argsort_insertion</span><span class="p">(</span><span class="n">X_full_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span><span class="n">start_idx</span><span class="o">=</span><span class="n">lenX_full</span><span class="p">,</span><span class="n">end_idx</span><span class="o">=</span><span class="n">X_full_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">X_full_exp</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">X_full_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">perm_full</span><span class="p">,:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">heterogeneous</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">idx</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">):</span>
                <span class="n">perm_part</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">argsort_insertion</span><span class="p">(</span><span class="n">X_part_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span><span class="n">start_idx</span><span class="o">=</span><span class="n">lenX_part</span><span class="p">,</span><span class="n">end_idx</span><span class="o">=</span><span class="n">X_part_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">X_part_exp</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">X_part_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">perm_part</span><span class="p">,]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">W_exp</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">W_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">perm_full</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="c"># Remove repetitions and add weights</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lastkeep</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">X_full_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">Misc</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">X_full_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">i</span><span class="p">,],</span><span class="n">X_full_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,],</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">W_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">lastkeep</span><span class="p">]</span> <span class="o">+=</span> <span class="n">W_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lastkeep</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            
            <span class="n">X_full_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[:</span><span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">),]</span> <span class="o">=</span> <span class="n">X_full_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">keep</span><span class="p">,]</span>
            <span class="n">X_full_exp</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">X_full_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">W_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[:</span><span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)]</span> <span class="o">=</span> <span class="n">W_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">keep</span><span class="p">]</span>
            <span class="n">W_exp</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">W_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">heterogeneous</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">idx</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">):</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">lastkeep</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">X_part_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">Misc</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">X_part_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">i</span><span class="p">,],</span><span class="n">X_part_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,],</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">lastkeep</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                
                <span class="n">X_part_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[:</span><span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">),]</span> <span class="o">=</span> <span class="n">X_part_exp</span><span class="o">.</span><span class="n">getAllocArray</span><span class="p">()[</span><span class="n">keep</span><span class="p">,]</span>
                <span class="n">X_part_exp</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">X_part_exp</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">bar</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdout</span><span class="p">,</span> <span class="s">&quot;[SG] Sparse Grid Generation: </span><span class="si">%.2f</span><span class="s">s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">last_update_time</span><span class="o">-</span><span class="n">bar</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">heterogeneous</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">X_full_exp</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">(),</span> <span class="n">W_exp</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">(),</span> <span class="n">X_part_exp</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">X_full_exp</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">(),</span> <span class="n">W_exp</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">(),</span> <span class="n">X_full_exp</span><span class="o">.</span><span class="n">getDataArray</span><span class="p">())</span>
    
    </div>
<div class="viewcode-block" id="HSparseGrid.sparseGridInterp"><a class="viewcode-back" href="../../index.html#SpectralToolbox.HeterogeneousSparseGrids.HSparseGrid.sparseGridInterp">[docs]</a>    <span class="k">def</span> <span class="nf">sparseGridInterp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">fX</span><span class="p">,</span><span class="n">XF</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Interpolate values of the Sparse Grid using 1D Polynomial interpolation along cuts.</span>
<span class="sd">        </span>
<span class="sd">        :param X: partial grid on which a function has been evaluated</span>
<span class="sd">        :type X: 2d-array of floats</span>
<span class="sd">        :param fX: values for the points in the partial grid</span>
<span class="sd">        :type fX: 1d-array of floats</span>
<span class="sd">        :param XF: full grid on which to interpolate</span>
<span class="sd">        :type XF: 2d-array of floats</span>
<span class="sd">        :return: :py:data:`fXF` the interpolated values on the full grid</span>
<span class="sd">        :rtype: 1d-array of floats</span>
<span class="sd">        </span>
<span class="sd">        ..note:: The partial and full grid must be overlapping</span>
<span class="sd">        </span>
<span class="sd">        **Example**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; fXF = sg.sparseGridInterp(X,fX,XF)</span>
<span class="sd">        [SG] Sparse Grid Interpolation [=========================================] 100%</span>
<span class="sd">        [SG] Sparse Grid Interpolation: 0.00s</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">Misc</span><span class="o">.</span><span class="n">machineEpsilon</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">XF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdout</span><span class="p">,</span> <span class="s">&quot;[SG] Sparse Grid Interpolation: Error! Dimensions of full and partial grid are not consistent</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdout</span><span class="p">,</span> <span class="s">&quot;[SG] Sparse Grid Interpolation: Error! Dimensions of partial nodes and value are not consistent</span><span class="se">\n</span><span class="s">&quot;</span>
        
        <span class="n">d</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        
        <span class="c"># Points on the full grid and on the actual interpolated grid, projected on d-1 dimensions</span>
        <span class="n">XF_mD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">XF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">XF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">fXF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">XF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="sd">&#39;&#39;&#39; Find not overlapping points (rules are ordered) &#39;&#39;&#39;</span>
        <span class="n">bool_idxs_over</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">findOverlapping</span><span class="p">(</span><span class="n">XF</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">tol</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bool_idxs_over</span><span class="p">)</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdout</span><span class="p">,</span> <span class="s">&quot;[SG] Sparse Grid Interpolation: Error! The selected grids are not overlapping. Functionality not implemented yet</span><span class="se">\n</span><span class="s">&quot;</span>
        
        <span class="sd">&#39;&#39;&#39; insert values of partial grid in correct position in the full grid &#39;&#39;&#39;</span>
        <span class="n">fXF</span><span class="p">[</span><span class="n">bool_idxs_over</span><span class="p">]</span> <span class="o">=</span> <span class="n">fX</span>
        
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>       <span class="c"># Counts the number of interpolated values</span>
        <span class="n">N_not_over</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bool_idxs_over</span><span class="p">))</span>
        <span class="n">bar</span> <span class="o">=</span> <span class="n">progressbar</span><span class="o">.</span><span class="n">ProgressBar</span><span class="p">(</span><span class="n">maxval</span><span class="o">=</span><span class="n">N_not_over</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> 
                                      <span class="n">widgets</span><span class="o">=</span><span class="p">[</span><span class="n">progressbar</span><span class="o">.</span><span class="n">Bar</span><span class="p">(</span>
                                      <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="s">&#39;[SG] Sparse Grid Interpolation [&#39;</span><span class="p">,</span> <span class="s">&#39;]&#39;</span><span class="p">),</span> <span class="s">&#39; &#39;</span><span class="p">,</span> <span class="n">progressbar</span><span class="o">.</span><span class="n">Percentage</span><span class="p">()])</span>
        <span class="n">bar</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">N_not_over</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i_d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">XF_mD</span><span class="p">[:,:</span><span class="n">i_d</span><span class="p">]</span> <span class="o">=</span> <span class="n">XF</span><span class="p">[:,:</span><span class="n">i_d</span><span class="p">]</span>
                <span class="n">XF_mD</span><span class="p">[:,</span><span class="n">i_d</span><span class="p">:]</span> <span class="o">=</span> <span class="n">XF</span><span class="p">[:,</span><span class="n">i_d</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                <span class="sd">&#39;&#39;&#39; find the unique coordinates of cuts &#39;&#39;&#39;</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">unique_cuts</span><span class="p">(</span><span class="n">XF_mD</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bool_idxs_over</span><span class="p">)])</span>
                <span class="sd">&#39;&#39;&#39; check for each value if the quadrature is up to the maximum accuracy &#39;&#39;&#39;</span>
                <span class="k">for</span> <span class="n">i_val</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                    
                    <span class="n">bool_idxs_not_over_cut</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">almostEqualList</span><span class="p">(</span><span class="n">XF_mD</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bool_idxs_over</span><span class="p">),],</span><span class="n">val</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
                    <span class="n">bool_idxs_over_cut</span> <span class="o">=</span> <span class="n">Misc</span><span class="o">.</span><span class="n">almostEqualList</span><span class="p">(</span><span class="n">XF_mD</span><span class="p">[</span><span class="n">bool_idxs_over</span><span class="p">,],</span><span class="n">val</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bool_idxs_not_over_cut</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bool_idxs_over_cut</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">[</span><span class="n">i_d</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                        <span class="sd">&#39;&#39;&#39; The quadrature is not up to the maximum accuracy for this cut &#39;&#39;&#39;</span>
                        <span class="sd">&#39;&#39;&#39; Apply 1D interpolation &#39;&#39;&#39;</span>
                        <span class="n">X_base</span> <span class="o">=</span> <span class="n">XF</span><span class="p">[</span><span class="n">bool_idxs_over</span><span class="p">,</span><span class="n">i_d</span><span class="p">][</span><span class="n">bool_idxs_over_cut</span><span class="p">]</span>
                        <span class="n">fXF_base</span> <span class="o">=</span> <span class="n">fXF</span><span class="p">[</span><span class="n">bool_idxs_over</span><span class="p">][</span><span class="n">bool_idxs_over_cut</span><span class="p">]</span>
                        <span class="n">XF_interp</span> <span class="o">=</span> <span class="n">XF</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bool_idxs_over</span><span class="p">),</span><span class="n">i_d</span><span class="p">][</span><span class="n">bool_idxs_not_over_cut</span><span class="p">]</span>
                        
                        <span class="n">fXF_interp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">i_d</span><span class="p">]</span><span class="o">.</span><span class="n">PolyInterp</span><span class="p">(</span><span class="n">X_base</span><span class="p">,</span><span class="n">fXF_base</span><span class="p">,</span><span class="n">XF_interp</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">[</span><span class="n">i_d</span><span class="p">])</span>
                        
                        <span class="n">fXF</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bool_idxs_over</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="n">bool_idxs_not_over_cut</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fXF_interp</span>
    
                        <span class="sd">&#39;&#39;&#39; Add new data for following interpolations &#39;&#39;&#39;</span>
                        <span class="n">bool_idxs_over</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">bool_idxs_over</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="n">bool_idxs_not_over_cut</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">True</span>
    
                        <span class="sd">&#39;&#39;&#39; Update the counter &#39;&#39;&#39;</span>
                        <span class="n">counter</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bool_idxs_not_over_cut</span><span class="p">)</span>
    
                        <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
        
        <span class="n">bar</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>
        <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdout</span><span class="p">,</span> <span class="s">&quot;[SG] Sparse Grid Interpolation: </span><span class="si">%.2f</span><span class="s">s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">last_update_time</span><span class="o">-</span><span class="n">bar</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">counter</span> <span class="o">!=</span> <span class="n">N_not_over</span><span class="p">:</span>
            <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdout</span><span class="p">,</span> <span class="s">&quot;Error: incomplete interpolation. The target function has not been computed for some non overlapping points</span><span class="se">\n</span><span class="s">&quot;</span>
        
        <span class="k">return</span> <span class="n">fXF</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">DABISpectralToolbox 0.1a documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Daniele Bigoni.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>